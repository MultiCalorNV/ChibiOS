
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c0 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 80001c0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80001c4:	b085      	sub	sp, #20
	/* Enable TRACE debug -----------------------------------------------*/
  Debug_ITMDebugEnable();
 80001c6:	f002 f873 	bl	80022b0 <Debug_ITMDebugEnable>
}

//****************************************************************************

void Debug_ITMDebugOutputString(char *Buffer){
	if (Debug_ITMDebug)
 80001ca:	4ba2      	ldr	r3, [pc, #648]	; (8000454 <__fini_array_end+0x294>)
 80001cc:	681b      	ldr	r3, [r3, #0]
 80001ce:	2b00      	cmp	r3, #0
 80001d0:	f040 81d5 	bne.w	800057e <__fini_array_end+0x3be>
int main(void) {
	/* Enable TRACE debug -----------------------------------------------*/
  Debug_ITMDebugEnable();
  Debug_ITMDebugOutputString("SWV Enabled\n");
  
  itmObjectInit(&itm_port);
 80001d4:	48a0      	ldr	r0, [pc, #640]	; (8000458 <__fini_array_end+0x298>)
 80001d6:	4fa1      	ldr	r7, [pc, #644]	; (800045c <__fini_array_end+0x29c>)
 80001d8:	4ea1      	ldr	r6, [pc, #644]	; (8000460 <__fini_array_end+0x2a0>)
 80001da:	4da2      	ldr	r5, [pc, #648]	; (8000464 <__fini_array_end+0x2a4>)
 80001dc:	f001 ff50 	bl	8002080 <itmObjectInit>
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 80001e0:	f001 f8ae 	bl	8001340 <halInit>
  chSysInit();
 80001e4:	f000 fae4 	bl	80007b0 <chSysInit>

  
  chprintf((BaseSequentialStream *)&itm_port, "%s", "ChibiOS V3.0\n");
 80001e8:	4a9f      	ldr	r2, [pc, #636]	; (8000468 <__fini_array_end+0x2a8>)
 80001ea:	49a0      	ldr	r1, [pc, #640]	; (800046c <__fini_array_end+0x2ac>)
 80001ec:	489a      	ldr	r0, [pc, #616]	; (8000458 <__fini_array_end+0x298>)
 80001ee:	f002 f847 	bl	8002280 <chprintf.constprop.4>

  /*
   * Prepares the Serial driver 6 and GPT drivers 2 and 3.
   */
  sdStart(&SD6, NULL);          /* Default is 38400-8-N-1.*/
 80001f2:	489f      	ldr	r0, [pc, #636]	; (8000470 <__fini_array_end+0x2b0>)
 80001f4:	2100      	movs	r1, #0
 80001f6:	f001 f973 	bl	80014e0 <sdStart>
  //palSetPadMode(GPIOA, 2, PAL_MODE_ALTERNATE(7));
  //palSetPadMode(GPIOA, 3, PAL_MODE_ALTERNATE(7));
  gptStart(&GPTD4, &gpt4cfg);
 80001fa:	489e      	ldr	r0, [pc, #632]	; (8000474 <__fini_array_end+0x2b4>)
 80001fc:	499e      	ldr	r1, [pc, #632]	; (8000478 <__fini_array_end+0x2b8>)
 80001fe:	f001 f8d7 	bl	80013b0 <gptStart>
  gptStart(&GPTD3, &gpt3cfg);
 8000202:	489e      	ldr	r0, [pc, #632]	; (800047c <__fini_array_end+0x2bc>)
 8000204:	499e      	ldr	r1, [pc, #632]	; (8000480 <__fini_array_end+0x2c0>)
 8000206:	f001 f8d3 	bl	80013b0 <gptStart>

  /*
   * Initializes the mailboxes and creates the worker threads.
   */
  for (i = 0; i < NUM_THREADS; i++) {
 800020a:	2400      	movs	r4, #0
    chMBObjectInit(&mb[i], b[i], MAILBOX_SIZE);
 800020c:	4638      	mov	r0, r7
 800020e:	4631      	mov	r1, r6
 8000210:	2204      	movs	r2, #4
 8000212:	f000 fe65 	bl	8000ee0 <chMBObjectInit>
    chThdCreateStatic(waWorkerThread[i], sizeof waWorkerThread[i],
 8000216:	9400      	str	r4, [sp, #0]
 8000218:	4628      	mov	r0, r5
 800021a:	f44f 71a4 	mov.w	r1, #328	; 0x148
  gptStart(&GPTD3, &gpt3cfg);

  /*
   * Initializes the mailboxes and creates the worker threads.
   */
  for (i = 0; i < NUM_THREADS; i++) {
 800021e:	3401      	adds	r4, #1
    chMBObjectInit(&mb[i], b[i], MAILBOX_SIZE);
    chThdCreateStatic(waWorkerThread[i], sizeof waWorkerThread[i],
 8000220:	222c      	movs	r2, #44	; 0x2c
 8000222:	4b98      	ldr	r3, [pc, #608]	; (8000484 <__fini_array_end+0x2c4>)
 8000224:	440d      	add	r5, r1
 8000226:	f000 fd4b 	bl	8000cc0 <chThdCreateStatic>
  gptStart(&GPTD3, &gpt3cfg);

  /*
   * Initializes the mailboxes and creates the worker threads.
   */
  for (i = 0; i < NUM_THREADS; i++) {
 800022a:	2c04      	cmp	r4, #4
 800022c:	f107 0728 	add.w	r7, r7, #40	; 0x28
 8000230:	f106 0610 	add.w	r6, r6, #16
 8000234:	d1ea      	bne.n	800020c <main+0x4c>
  }

  /*
   * Test procedure.
   */
  println("");
 8000236:	4894      	ldr	r0, [pc, #592]	; (8000488 <__fini_array_end+0x2c8>)
  println("*** ChibiOS/RT IRQ-STORM long duration test");
  println("***");
 8000238:	4c94      	ldr	r4, [pc, #592]	; (800048c <__fini_array_end+0x2cc>)
 800023a:	4d8d      	ldr	r5, [pc, #564]	; (8000470 <__fini_array_end+0x2b0>)
  }

  /*
   * Test procedure.
   */
  println("");
 800023c:	f001 ff28 	bl	8002090 <println>
  println("*** ChibiOS/RT IRQ-STORM long duration test");
 8000240:	4893      	ldr	r0, [pc, #588]	; (8000490 <__fini_array_end+0x2d0>)
 8000242:	f001 ff25 	bl	8002090 <println>
  println("***");
 8000246:	4893      	ldr	r0, [pc, #588]	; (8000494 <__fini_array_end+0x2d4>)
 8000248:	f001 ff22 	bl	8002090 <println>
 800024c:	212a      	movs	r1, #42	; 0x2a
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
 800024e:	682b      	ldr	r3, [r5, #0]
 8000250:	4887      	ldr	r0, [pc, #540]	; (8000470 <__fini_array_end+0x2b0>)
 8000252:	689b      	ldr	r3, [r3, #8]
 8000254:	4798      	blx	r3
/* Generic demo code.                                                        */
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
 8000256:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 800025a:	2900      	cmp	r1, #0
 800025c:	d1f7      	bne.n	800024e <main+0x8e>
   */
  println("");
  println("*** ChibiOS/RT IRQ-STORM long duration test");
  println("***");
  print("*** Kernel:       ");
  println(CH_KERNEL_VERSION);
 800025e:	488e      	ldr	r0, [pc, #568]	; (8000498 <__fini_array_end+0x2d8>)
 8000260:	4c8e      	ldr	r4, [pc, #568]	; (800049c <__fini_array_end+0x2dc>)
 8000262:	f001 ff15 	bl	8002090 <println>
 8000266:	212a      	movs	r1, #42	; 0x2a
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
 8000268:	682b      	ldr	r3, [r5, #0]
 800026a:	4881      	ldr	r0, [pc, #516]	; (8000470 <__fini_array_end+0x2b0>)
 800026c:	689b      	ldr	r3, [r3, #8]
 800026e:	4798      	blx	r3
/* Generic demo code.                                                        */
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
 8000270:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8000274:	2900      	cmp	r1, #0
 8000276:	d1f7      	bne.n	8000268 <main+0xa8>
  println("*** ChibiOS/RT IRQ-STORM long duration test");
  println("***");
  print("*** Kernel:       ");
  println(CH_KERNEL_VERSION);
  print("*** Compiled:     ");
  println(__DATE__ " - " __TIME__);
 8000278:	4889      	ldr	r0, [pc, #548]	; (80004a0 <__fini_array_end+0x2e0>)
 800027a:	4c8a      	ldr	r4, [pc, #552]	; (80004a4 <__fini_array_end+0x2e4>)
 800027c:	f001 ff08 	bl	8002090 <println>
 8000280:	212a      	movs	r1, #42	; 0x2a
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
 8000282:	682b      	ldr	r3, [r5, #0]
 8000284:	487a      	ldr	r0, [pc, #488]	; (8000470 <__fini_array_end+0x2b0>)
 8000286:	689b      	ldr	r3, [r3, #8]
 8000288:	4798      	blx	r3
/* Generic demo code.                                                        */
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
 800028a:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 800028e:	2900      	cmp	r1, #0
 8000290:	d1f7      	bne.n	8000282 <main+0xc2>
  println(CH_KERNEL_VERSION);
  print("*** Compiled:     ");
  println(__DATE__ " - " __TIME__);
#ifdef PORT_COMPILER_NAME
  print("*** Compiler:     ");
  println(PORT_COMPILER_NAME);
 8000292:	4885      	ldr	r0, [pc, #532]	; (80004a8 <__fini_array_end+0x2e8>)
 8000294:	4c85      	ldr	r4, [pc, #532]	; (80004ac <__fini_array_end+0x2ec>)
 8000296:	f001 fefb 	bl	8002090 <println>
 800029a:	212a      	movs	r1, #42	; 0x2a
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
 800029c:	682b      	ldr	r3, [r5, #0]
 800029e:	4874      	ldr	r0, [pc, #464]	; (8000470 <__fini_array_end+0x2b0>)
 80002a0:	689b      	ldr	r3, [r3, #8]
 80002a2:	4798      	blx	r3
/* Generic demo code.                                                        */
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
 80002a4:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 80002a8:	2900      	cmp	r1, #0
 80002aa:	d1f7      	bne.n	800029c <main+0xdc>
#ifdef PORT_COMPILER_NAME
  print("*** Compiler:     ");
  println(PORT_COMPILER_NAME);
#endif
  print("*** Architecture: ");
  println(PORT_ARCHITECTURE_NAME);
 80002ac:	4880      	ldr	r0, [pc, #512]	; (80004b0 <__fini_array_end+0x2f0>)
 80002ae:	4c81      	ldr	r4, [pc, #516]	; (80004b4 <__fini_array_end+0x2f4>)
 80002b0:	f001 feee 	bl	8002090 <println>
 80002b4:	212a      	movs	r1, #42	; 0x2a
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
 80002b6:	682b      	ldr	r3, [r5, #0]
 80002b8:	486d      	ldr	r0, [pc, #436]	; (8000470 <__fini_array_end+0x2b0>)
 80002ba:	689b      	ldr	r3, [r3, #8]
 80002bc:	4798      	blx	r3
/* Generic demo code.                                                        */
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
 80002be:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 80002c2:	2900      	cmp	r1, #0
 80002c4:	d1f7      	bne.n	80002b6 <main+0xf6>
#endif
  print("*** Architecture: ");
  println(PORT_ARCHITECTURE_NAME);
#ifdef PORT_CORE_VARIANT_NAME
  print("*** Core Variant: ");
  println(PORT_CORE_VARIANT_NAME);
 80002c6:	487c      	ldr	r0, [pc, #496]	; (80004b8 <__fini_array_end+0x2f8>)
 80002c8:	4c7c      	ldr	r4, [pc, #496]	; (80004bc <__fini_array_end+0x2fc>)
 80002ca:	f001 fee1 	bl	8002090 <println>
 80002ce:	212a      	movs	r1, #42	; 0x2a
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
 80002d0:	682b      	ldr	r3, [r5, #0]
 80002d2:	4867      	ldr	r0, [pc, #412]	; (8000470 <__fini_array_end+0x2b0>)
 80002d4:	689b      	ldr	r3, [r3, #8]
 80002d6:	4798      	blx	r3
/* Generic demo code.                                                        */
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
 80002d8:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 80002dc:	2900      	cmp	r1, #0
 80002de:	d1f7      	bne.n	80002d0 <main+0x110>
  print("*** Core Variant: ");
  println(PORT_CORE_VARIANT_NAME);
#endif
#ifdef PORT_INFO
  print("*** Port Info:    ");
  println(PORT_INFO);
 80002e0:	4877      	ldr	r0, [pc, #476]	; (80004c0 <__fini_array_end+0x300>)
 80002e2:	4c78      	ldr	r4, [pc, #480]	; (80004c4 <__fini_array_end+0x304>)
 80002e4:	f001 fed4 	bl	8002090 <println>
 80002e8:	212a      	movs	r1, #42	; 0x2a
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
 80002ea:	682b      	ldr	r3, [r5, #0]
 80002ec:	4860      	ldr	r0, [pc, #384]	; (8000470 <__fini_array_end+0x2b0>)
 80002ee:	689b      	ldr	r3, [r3, #8]
 80002f0:	4798      	blx	r3
/* Generic demo code.                                                        */
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
 80002f2:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 80002f6:	2900      	cmp	r1, #0
 80002f8:	d1f7      	bne.n	80002ea <main+0x12a>
  print("*** Port Info:    ");
  println(PORT_INFO);
#endif
#ifdef PLATFORM_NAME
  print("*** Platform:     ");
  println(PLATFORM_NAME);
 80002fa:	4873      	ldr	r0, [pc, #460]	; (80004c8 <__fini_array_end+0x308>)
 80002fc:	4c73      	ldr	r4, [pc, #460]	; (80004cc <__fini_array_end+0x30c>)
 80002fe:	f001 fec7 	bl	8002090 <println>
 8000302:	212a      	movs	r1, #42	; 0x2a
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
 8000304:	682b      	ldr	r3, [r5, #0]
 8000306:	485a      	ldr	r0, [pc, #360]	; (8000470 <__fini_array_end+0x2b0>)
 8000308:	689b      	ldr	r3, [r3, #8]
 800030a:	4798      	blx	r3
/* Generic demo code.                                                        */
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
 800030c:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8000310:	2900      	cmp	r1, #0
 8000312:	d1f7      	bne.n	8000304 <main+0x144>
  print("*** Platform:     ");
  println(PLATFORM_NAME);
#endif
#ifdef BOARD_NAME
  print("*** Test Board:   ");
  println(BOARD_NAME);
 8000314:	486e      	ldr	r0, [pc, #440]	; (80004d0 <__fini_array_end+0x310>)
#endif
  println("***");
 8000316:	4c6f      	ldr	r4, [pc, #444]	; (80004d4 <__fini_array_end+0x314>)
  print("*** Platform:     ");
  println(PLATFORM_NAME);
#endif
#ifdef BOARD_NAME
  print("*** Test Board:   ");
  println(BOARD_NAME);
 8000318:	f001 feba 	bl	8002090 <println>
#endif
  println("***");
 800031c:	485d      	ldr	r0, [pc, #372]	; (8000494 <__fini_array_end+0x2d4>)
 800031e:	f001 feb7 	bl	8002090 <println>
 8000322:	212a      	movs	r1, #42	; 0x2a
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
 8000324:	682b      	ldr	r3, [r5, #0]
 8000326:	4852      	ldr	r0, [pc, #328]	; (8000470 <__fini_array_end+0x2b0>)
 8000328:	689b      	ldr	r3, [r3, #8]
 800032a:	4798      	blx	r3
/* Generic demo code.                                                        */
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
 800032c:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8000330:	2900      	cmp	r1, #0
 8000332:	d1f7      	bne.n	8000324 <main+0x164>
  print("*** Test Board:   ");
  println(BOARD_NAME);
#endif
  println("***");
  print("*** System Clock: ");
  printn(STM32_SYSCLK);
 8000334:	4868      	ldr	r0, [pc, #416]	; (80004d8 <__fini_array_end+0x318>)
  println("");
 8000336:	4c69      	ldr	r4, [pc, #420]	; (80004dc <__fini_array_end+0x31c>)
  print("*** Test Board:   ");
  println(BOARD_NAME);
#endif
  println("***");
  print("*** System Clock: ");
  printn(STM32_SYSCLK);
 8000338:	f001 ff72 	bl	8002220 <printn>
  println("");
 800033c:	4852      	ldr	r0, [pc, #328]	; (8000488 <__fini_array_end+0x2c8>)
 800033e:	f001 fea7 	bl	8002090 <println>
 8000342:	212a      	movs	r1, #42	; 0x2a
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
 8000344:	682b      	ldr	r3, [r5, #0]
 8000346:	484a      	ldr	r0, [pc, #296]	; (8000470 <__fini_array_end+0x2b0>)
 8000348:	689b      	ldr	r3, [r3, #8]
 800034a:	4798      	blx	r3
/* Generic demo code.                                                        */
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
 800034c:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8000350:	2900      	cmp	r1, #0
 8000352:	d1f7      	bne.n	8000344 <main+0x184>
  println("***");
  print("*** System Clock: ");
  printn(STM32_SYSCLK);
  println("");
  print("*** Iterations:   ");
  printn(ITERATIONS);
 8000354:	2064      	movs	r0, #100	; 0x64
 8000356:	f001 ff63 	bl	8002220 <printn>
  println("");
 800035a:	4c61      	ldr	r4, [pc, #388]	; (80004e0 <__fini_array_end+0x320>)
 800035c:	484a      	ldr	r0, [pc, #296]	; (8000488 <__fini_array_end+0x2c8>)
 800035e:	f001 fe97 	bl	8002090 <println>
 8000362:	212a      	movs	r1, #42	; 0x2a
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
 8000364:	682b      	ldr	r3, [r5, #0]
 8000366:	4842      	ldr	r0, [pc, #264]	; (8000470 <__fini_array_end+0x2b0>)
 8000368:	689b      	ldr	r3, [r3, #8]
 800036a:	4798      	blx	r3
/* Generic demo code.                                                        */
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
 800036c:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8000370:	2900      	cmp	r1, #0
 8000372:	d1f7      	bne.n	8000364 <main+0x1a4>
 8000374:	f001 ff4c 	bl	8002210 <printn.part.0>
  print("*** Iterations:   ");
  printn(ITERATIONS);
  println("");
  print("*** Randomize:    ");
  printn(RANDOMIZE);
  println("");
 8000378:	4c5a      	ldr	r4, [pc, #360]	; (80004e4 <__fini_array_end+0x324>)
 800037a:	4843      	ldr	r0, [pc, #268]	; (8000488 <__fini_array_end+0x2c8>)
 800037c:	f001 fe88 	bl	8002090 <println>
 8000380:	212a      	movs	r1, #42	; 0x2a
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
 8000382:	682b      	ldr	r3, [r5, #0]
 8000384:	483a      	ldr	r0, [pc, #232]	; (8000470 <__fini_array_end+0x2b0>)
 8000386:	689b      	ldr	r3, [r3, #8]
 8000388:	4798      	blx	r3
/* Generic demo code.                                                        */
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
 800038a:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 800038e:	2900      	cmp	r1, #0
 8000390:	d1f7      	bne.n	8000382 <main+0x1c2>
  println("");
  print("*** Randomize:    ");
  printn(RANDOMIZE);
  println("");
  print("*** Threads:      ");
  printn(NUM_THREADS);
 8000392:	2004      	movs	r0, #4
 8000394:	f001 ff44 	bl	8002220 <printn>
  println("");
 8000398:	483b      	ldr	r0, [pc, #236]	; (8000488 <__fini_array_end+0x2c8>)
 800039a:	4e53      	ldr	r6, [pc, #332]	; (80004e8 <__fini_array_end+0x328>)
 800039c:	f001 fe78 	bl	8002090 <println>
 80003a0:	242a      	movs	r4, #42	; 0x2a
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
 80003a2:	682b      	ldr	r3, [r5, #0]
 80003a4:	4832      	ldr	r0, [pc, #200]	; (8000470 <__fini_array_end+0x2b0>)
 80003a6:	689b      	ldr	r3, [r3, #8]
 80003a8:	4621      	mov	r1, r4
 80003aa:	4798      	blx	r3
/* Generic demo code.                                                        */
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
 80003ac:	f816 4f01 	ldrb.w	r4, [r6, #1]!
 80003b0:	2c00      	cmp	r4, #0
 80003b2:	d1f6      	bne.n	80003a2 <main+0x1e2>
  println("");
  print("*** Threads:      ");
  printn(NUM_THREADS);
  println("");
  print("*** Mailbox size: ");
  printn(MAILBOX_SIZE);
 80003b4:	2004      	movs	r0, #4
 80003b6:	f001 ff33 	bl	8002220 <printn>
  println("");
 80003ba:	4833      	ldr	r0, [pc, #204]	; (8000488 <__fini_array_end+0x2c8>)
 80003bc:	4f4b      	ldr	r7, [pc, #300]	; (80004ec <__fini_array_end+0x32c>)
 80003be:	f001 fe67 	bl	8002090 <println>

  println("");
 80003c2:	4831      	ldr	r0, [pc, #196]	; (8000488 <__fini_array_end+0x2c8>)
 80003c4:	f001 fe64 	bl	8002090 <println>
  worst = 0;
 80003c8:	46a1      	mov	r9, r4
  for (i = 1; i <= ITERATIONS; i++){
 80003ca:	f04f 0801 	mov.w	r8, #1
  print("*** Randomize:    ");
  printn(RANDOMIZE);
  println("");
  print("*** Threads:      ");
  printn(NUM_THREADS);
  println("");
 80003ce:	4c48      	ldr	r4, [pc, #288]	; (80004f0 <__fini_array_end+0x330>)
 80003d0:	2149      	movs	r1, #73	; 0x49
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
 80003d2:	682b      	ldr	r3, [r5, #0]
 80003d4:	4826      	ldr	r0, [pc, #152]	; (8000470 <__fini_array_end+0x2b0>)
 80003d6:	689b      	ldr	r3, [r3, #8]
 80003d8:	4798      	blx	r3
/* Generic demo code.                                                        */
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
 80003da:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 80003de:	2900      	cmp	r1, #0
 80003e0:	d1f7      	bne.n	80003d2 <main+0x212>

  println("");
  worst = 0;
  for (i = 1; i <= ITERATIONS; i++){
    print("Iteration ");
    printn(i);
 80003e2:	4640      	mov	r0, r8
 80003e4:	9103      	str	r1, [sp, #12]
 80003e6:	f001 ff1b 	bl	8002220 <printn>
    println("");
 80003ea:	4827      	ldr	r0, [pc, #156]	; (8000488 <__fini_array_end+0x2c8>)
 80003ec:	f001 fe50 	bl	8002090 <println>
    saturated = FALSE;
    threshold = 0;
 80003f0:	9903      	ldr	r1, [sp, #12]
  worst = 0;
  for (i = 1; i <= ITERATIONS; i++){
    print("Iteration ");
    printn(i);
    println("");
    saturated = FALSE;
 80003f2:	7039      	strb	r1, [r7, #0]
    threshold = 0;
 80003f4:	460c      	mov	r4, r1
    for (interval = 2000;
 80003f6:	f44f 66fa 	mov.w	r6, #2000	; 0x7d0
 80003fa:	e00b      	b.n	8000414 <main+0x254>
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
 80003fc:	682b      	ldr	r3, [r5, #0]
 80003fe:	689b      	ldr	r3, [r3, #8]
 8000400:	4798      	blx	r3
    println("");
    saturated = FALSE;
    threshold = 0;
    for (interval = 2000;
        interval >= 2;
        interval -= (interval + 9) / 10) {
 8000402:	4a3c      	ldr	r2, [pc, #240]	; (80004f4 <__fini_array_end+0x334>)
 8000404:	f106 0309 	add.w	r3, r6, #9
 8000408:	fba2 2303 	umull	r2, r3, r2, r3
 800040c:	eba6 06d3 	sub.w	r6, r6, r3, lsr #3
    print("Iteration ");
    printn(i);
    println("");
    saturated = FALSE;
    threshold = 0;
    for (interval = 2000;
 8000410:	2e01      	cmp	r6, #1
 8000412:	d971      	bls.n	80004f8 <__fini_array_end+0x338>
        interval >= 2;
        interval -= (interval + 9) / 10) {
      gptStartContinuous(&GPTD4, interval - 1); /* Slightly out of phase.*/
 8000414:	4817      	ldr	r0, [pc, #92]	; (8000474 <__fini_array_end+0x2b4>)
 8000416:	1e71      	subs	r1, r6, #1
 8000418:	f000 ffda 	bl	80013d0 <gptStartContinuous>
      gptStartContinuous(&GPTD3, interval + 1); /* Slightly out of phase.*/
 800041c:	1c71      	adds	r1, r6, #1
 800041e:	4817      	ldr	r0, [pc, #92]	; (800047c <__fini_array_end+0x2bc>)
 8000420:	f000 ffd6 	bl	80013d0 <gptStartContinuous>
      chThdSleepMilliseconds(1000);
 8000424:	f242 7010 	movw	r0, #10000	; 0x2710
 8000428:	f000 fc8a 	bl	8000d40 <chThdSleep>
      gptStopTimer(&GPTD4);
 800042c:	4811      	ldr	r0, [pc, #68]	; (8000474 <__fini_array_end+0x2b4>)
 800042e:	f000 ffdf 	bl	80013f0 <gptStopTimer>
      gptStopTimer(&GPTD3);
 8000432:	4812      	ldr	r0, [pc, #72]	; (800047c <__fini_array_end+0x2bc>)
 8000434:	f000 ffdc 	bl	80013f0 <gptStopTimer>
      if (!saturated)
 8000438:	783b      	ldrb	r3, [r7, #0]
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
 800043a:	480d      	ldr	r0, [pc, #52]	; (8000470 <__fini_array_end+0x2b0>)
 800043c:	212e      	movs	r1, #46	; 0x2e
      gptStartContinuous(&GPTD4, interval - 1); /* Slightly out of phase.*/
      gptStartContinuous(&GPTD3, interval + 1); /* Slightly out of phase.*/
      chThdSleepMilliseconds(1000);
      gptStopTimer(&GPTD4);
      gptStopTimer(&GPTD3);
      if (!saturated)
 800043e:	2b00      	cmp	r3, #0
 8000440:	d0dc      	beq.n	80003fc <main+0x23c>
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
 8000442:	682b      	ldr	r3, [r5, #0]
 8000444:	480a      	ldr	r0, [pc, #40]	; (8000470 <__fini_array_end+0x2b0>)
 8000446:	689b      	ldr	r3, [r3, #8]
 8000448:	2123      	movs	r1, #35	; 0x23
 800044a:	4798      	blx	r3
      gptStopTimer(&GPTD3);
      if (!saturated)
        print(".");
      else {
        print("#");
        if (threshold == 0)
 800044c:	2c00      	cmp	r4, #0
 800044e:	bf08      	it	eq
 8000450:	4634      	moveq	r4, r6
 8000452:	e7d6      	b.n	8000402 <main+0x242>
 8000454:	20000f34 	.word	0x20000f34
 8000458:	20000f38 	.word	0x20000f38
 800045c:	20000f44 	.word	0x20000f44
 8000460:	20000fe4 	.word	0x20000fe4
 8000464:	20000a10 	.word	0x20000a10
 8000468:	08002630 	.word	0x08002630
 800046c:	080024ec 	.word	0x080024ec
 8000470:	20000998 	.word	0x20000998
 8000474:	20000988 	.word	0x20000988
 8000478:	080024d0 	.word	0x080024d0
 800047c:	20000978 	.word	0x20000978
 8000480:	080024c0 	.word	0x080024c0
 8000484:	080020d1 	.word	0x080020d1
 8000488:	080024fc 	.word	0x080024fc
 800048c:	08002500 	.word	0x08002500
 8000490:	08002640 	.word	0x08002640
 8000494:	0800266c 	.word	0x0800266c
 8000498:	08002684 	.word	0x08002684
 800049c:	08002514 	.word	0x08002514
 80004a0:	08002690 	.word	0x08002690
 80004a4:	08002528 	.word	0x08002528
 80004a8:	080026a8 	.word	0x080026a8
 80004ac:	0800253c 	.word	0x0800253c
 80004b0:	080026f0 	.word	0x080026f0
 80004b4:	08002550 	.word	0x08002550
 80004b8:	080026fc 	.word	0x080026fc
 80004bc:	08002564 	.word	0x08002564
 80004c0:	08002708 	.word	0x08002708
 80004c4:	08002578 	.word	0x08002578
 80004c8:	08002720 	.word	0x08002720
 80004cc:	0800258c 	.word	0x0800258c
 80004d0:	0800274c 	.word	0x0800274c
 80004d4:	080025a0 	.word	0x080025a0
 80004d8:	08f0d180 	.word	0x08f0d180
 80004dc:	080025b4 	.word	0x080025b4
 80004e0:	080025c8 	.word	0x080025c8
 80004e4:	080025dc 	.word	0x080025dc
 80004e8:	080025f0 	.word	0x080025f0
 80004ec:	20000f30 	.word	0x20000f30
 80004f0:	08002604 	.word	0x08002604
 80004f4:	cccccccd 	.word	0xcccccccd
          threshold = interval;
      }
    }
    /* Gives the worker threads a chance to empty the mailboxes before next
       cycle.*/
    chThdSleepMilliseconds(20);
 80004f8:	20c8      	movs	r0, #200	; 0xc8
 80004fa:	f000 fc21 	bl	8000d40 <chThdSleep>
    println("");
 80004fe:	4e24      	ldr	r6, [pc, #144]	; (8000590 <__fini_array_end+0x3d0>)
 8000500:	4824      	ldr	r0, [pc, #144]	; (8000594 <__fini_array_end+0x3d4>)
 8000502:	f001 fdc5 	bl	8002090 <println>
 8000506:	2153      	movs	r1, #83	; 0x53
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
 8000508:	682b      	ldr	r3, [r5, #0]
 800050a:	4823      	ldr	r0, [pc, #140]	; (8000598 <__fini_array_end+0x3d8>)
 800050c:	689b      	ldr	r3, [r3, #8]
 800050e:	4798      	blx	r3
/* Generic demo code.                                                        */
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
 8000510:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8000514:	2900      	cmp	r1, #0
 8000516:	d1f7      	bne.n	8000508 <__fini_array_end+0x348>
    /* Gives the worker threads a chance to empty the mailboxes before next
       cycle.*/
    chThdSleepMilliseconds(20);
    println("");
    print("Saturated at ");
    printn(threshold);
 8000518:	4620      	mov	r0, r4
 800051a:	f001 fe81 	bl	8002220 <printn>
    println(" uS");
 800051e:	481f      	ldr	r0, [pc, #124]	; (800059c <__fini_array_end+0x3dc>)
 8000520:	f001 fdb6 	bl	8002090 <println>
  printn(MAILBOX_SIZE);
  println("");

  println("");
  worst = 0;
  for (i = 1; i <= ITERATIONS; i++){
 8000524:	f108 0801 	add.w	r8, r8, #1
 8000528:	45a1      	cmp	r9, r4
    chThdSleepMilliseconds(20);
    println("");
    print("Saturated at ");
    printn(threshold);
    println(" uS");
    println("");
 800052a:	481a      	ldr	r0, [pc, #104]	; (8000594 <__fini_array_end+0x3d4>)
 800052c:	bf38      	it	cc
 800052e:	46a1      	movcc	r9, r4
 8000530:	f001 fdae 	bl	8002090 <println>
  printn(MAILBOX_SIZE);
  println("");

  println("");
  worst = 0;
  for (i = 1; i <= ITERATIONS; i++){
 8000534:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 8000538:	f47f af49 	bne.w	80003ce <main+0x20e>
    println(" uS");
    println("");
    if (threshold > worst)
      worst = threshold;
  }
  gptStopTimer(&GPTD4);
 800053c:	4818      	ldr	r0, [pc, #96]	; (80005a0 <__fini_array_end+0x3e0>)
  gptStopTimer(&GPTD3);
 800053e:	4c19      	ldr	r4, [pc, #100]	; (80005a4 <__fini_array_end+0x3e4>)
    println(" uS");
    println("");
    if (threshold > worst)
      worst = threshold;
  }
  gptStopTimer(&GPTD4);
 8000540:	f000 ff56 	bl	80013f0 <gptStopTimer>
  gptStopTimer(&GPTD3);
 8000544:	4818      	ldr	r0, [pc, #96]	; (80005a8 <__fini_array_end+0x3e8>)
 8000546:	f000 ff53 	bl	80013f0 <gptStopTimer>
 800054a:	2157      	movs	r1, #87	; 0x57
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
 800054c:	682b      	ldr	r3, [r5, #0]
 800054e:	4812      	ldr	r0, [pc, #72]	; (8000598 <__fini_array_end+0x3d8>)
 8000550:	689b      	ldr	r3, [r3, #8]
 8000552:	4798      	blx	r3
/* Generic demo code.                                                        */
/*===========================================================================*/

static void print(char *p) {

  while (*p) {
 8000554:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8000558:	2900      	cmp	r1, #0
 800055a:	d1f7      	bne.n	800054c <__fini_array_end+0x38c>
  }
  gptStopTimer(&GPTD4);
  gptStopTimer(&GPTD3);

  print("Worst case at ");
  printn(worst);
 800055c:	4648      	mov	r0, r9
 800055e:	f001 fe5f 	bl	8002220 <printn>
  println(" uS");
 8000562:	480e      	ldr	r0, [pc, #56]	; (800059c <__fini_array_end+0x3dc>)
 8000564:	f001 fd94 	bl	8002090 <println>
  println("");
 8000568:	480a      	ldr	r0, [pc, #40]	; (8000594 <__fini_array_end+0x3d4>)
 800056a:	f001 fd91 	bl	8002090 <println>
  println("Test Complete");
 800056e:	480f      	ldr	r0, [pc, #60]	; (80005ac <__fini_array_end+0x3ec>)
 8000570:	f001 fd8e 	bl	8002090 <println>

  /*
   * Normal main() thread activity, nothing in this test.
   */
  while (TRUE) {
    chThdSleepMilliseconds(5000);
 8000574:	f24c 3050 	movw	r0, #50000	; 0xc350
 8000578:	f000 fbe2 	bl	8000d40 <chThdSleep>
  }
 800057c:	e7fa      	b.n	8000574 <__fini_array_end+0x3b4>
}

//****************************************************************************

void Debug_ITMDebugOutputString(char *Buffer){
	if (Debug_ITMDebug)
 800057e:	4c0c      	ldr	r4, [pc, #48]	; (80005b0 <__fini_array_end+0x3f0>)
 8000580:	2053      	movs	r0, #83	; 0x53
		while(*Buffer)
			Debug_ITMDebugOutputChar(*Buffer++);
 8000582:	f001 feb5 	bl	80022f0 <Debug_ITMDebugOutputChar>

//****************************************************************************

void Debug_ITMDebugOutputString(char *Buffer){
	if (Debug_ITMDebug)
		while(*Buffer)
 8000586:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 800058a:	2800      	cmp	r0, #0
 800058c:	d1f9      	bne.n	8000582 <__fini_array_end+0x3c2>
 800058e:	e621      	b.n	80001d4 <main+0x14>
 8000590:	08002610 	.word	0x08002610
 8000594:	080024fc 	.word	0x080024fc
 8000598:	20000998 	.word	0x20000998
 800059c:	08002670 	.word	0x08002670
 80005a0:	20000988 	.word	0x20000988
 80005a4:	08002620 	.word	0x08002620
 80005a8:	20000978 	.word	0x20000978
 80005ac:	08002674 	.word	0x08002674
 80005b0:	080024f0 	.word	0x080024f0
 80005b4:	f3af 8000 	nop.w
 80005b8:	f3af 8000 	nop.w
 80005bc:	f3af 8000 	nop.w

080005c0 <_port_switch>:
 80005c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80005c4:	f8c1 d00c 	str.w	sp, [r1, #12]
 80005c8:	f8d0 d00c 	ldr.w	sp, [r0, #12]
 80005cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080005d0 <_port_thread_start>:
 80005d0:	2300      	movs	r3, #0
 80005d2:	f383 8811 	msr	BASEPRI, r3
 80005d6:	4628      	mov	r0, r5
 80005d8:	47a0      	blx	r4
 80005da:	f000 fbe1 	bl	8000da0 <chThdExit>

080005de <_port_switch_from_isr>:
 80005de:	f000 fad7 	bl	8000b90 <chSchDoReschedule>

080005e2 <_port_exit_from_isr>:
 80005e2:	df00      	svc	0
 80005e4:	e7fe      	b.n	80005e4 <_port_exit_from_isr+0x2>
	...

080005f0 <__late_init>:
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void __late_init(void) {}
 80005f0:	4770      	bx	lr
 80005f2:	bf00      	nop
 80005f4:	f3af 8000 	nop.w
 80005f8:	f3af 8000 	nop.w
 80005fc:	f3af 8000 	nop.w

08000600 <_default_exit>:
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
void _default_exit(void) {
  while (1)
    ;
 8000600:	e7fe      	b.n	8000600 <_default_exit>
 8000602:	bf00      	nop
 8000604:	f3af 8000 	nop.w
 8000608:	f3af 8000 	nop.w
 800060c:	f3af 8000 	nop.w

08000610 <Reset_Handler>:
  uint32_t psp, reg;

  /* Process Stack initialization, it is allocated starting from the
     symbol __process_stack_end__ and its lower limit is the symbol
     __process_stack_base__.*/
  asm volatile ("cpsid   i");
 8000610:	b672      	cpsid	i
  psp = SYMVAL(__process_stack_end__);
 8000612:	4c31      	ldr	r4, [pc, #196]	; (80006d8 <Reset_Handler+0xc8>)
  asm volatile ("msr     PSP, %0" : : "r" (psp));
 8000614:	f384 8809 	msr	PSP, r4
  reg = CRT0_CONTROL_INIT | 4;
#else
  /* CPU mode initialization.*/
  reg = CRT0_CONTROL_INIT;
#endif
  asm volatile ("msr     CONTROL, %0" : : "r" (reg));
 8000618:	2302      	movs	r3, #2
 800061a:	f383 8814 	msr	CONTROL, r3
  asm volatile ("isb");
 800061e:	f3bf 8f6f 	isb	sy

  /* Early initialization hook invocation.*/
  __early_init();
 8000622:	f001 fb45 	bl	8001cb0 <__early_init>

#if CRT0_INIT_STACKS
  /* Main and Process stacks initialization.*/
  fill32(&__main_stack_base__,
 8000626:	4b2d      	ldr	r3, [pc, #180]	; (80006dc <Reset_Handler+0xcc>)
 8000628:	4a2d      	ldr	r2, [pc, #180]	; (80006e0 <Reset_Handler+0xd0>)
 800062a:	4293      	cmp	r3, r2
 800062c:	d20b      	bcs.n	8000646 <Reset_Handler+0x36>
 800062e:	43d9      	mvns	r1, r3
 8000630:	440a      	add	r2, r1
 8000632:	f022 0203 	bic.w	r2, r2, #3
 8000636:	3204      	adds	r2, #4
 8000638:	441a      	add	r2, r3
 800063a:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 800063e:	f843 1b04 	str.w	r1, [r3], #4
 8000642:	4293      	cmp	r3, r2
 8000644:	d1fb      	bne.n	800063e <Reset_Handler+0x2e>
         &__main_stack_end__,
         CRT0_STACKS_FILL_PATTERN);
  fill32(&__process_stack_base__,
 8000646:	4b27      	ldr	r3, [pc, #156]	; (80006e4 <Reset_Handler+0xd4>)
 8000648:	42a3      	cmp	r3, r4
 800064a:	d20c      	bcs.n	8000666 <Reset_Handler+0x56>
 800064c:	4a26      	ldr	r2, [pc, #152]	; (80006e8 <Reset_Handler+0xd8>)
 800064e:	1d19      	adds	r1, r3, #4
 8000650:	1a52      	subs	r2, r2, r1
 8000652:	f022 0203 	bic.w	r2, r2, #3
 8000656:	3204      	adds	r2, #4
 8000658:	441a      	add	r2, r3
 800065a:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 800065e:	f843 1b04 	str.w	r1, [r3], #4
 8000662:	4293      	cmp	r3, r2
 8000664:	d1fb      	bne.n	800065e <Reset_Handler+0x4e>
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 8000666:	4a21      	ldr	r2, [pc, #132]	; (80006ec <Reset_Handler+0xdc>)
 8000668:	4b21      	ldr	r3, [pc, #132]	; (80006f0 <Reset_Handler+0xe0>)
 800066a:	429a      	cmp	r2, r3
 800066c:	d20c      	bcs.n	8000688 <Reset_Handler+0x78>
 800066e:	43d0      	mvns	r0, r2
 8000670:	4418      	add	r0, r3
 8000672:	f020 0003 	bic.w	r0, r0, #3
 8000676:	4b1f      	ldr	r3, [pc, #124]	; (80006f4 <Reset_Handler+0xe4>)
 8000678:	3004      	adds	r0, #4
 800067a:	4418      	add	r0, r3
      *dp++ = *tp++;
 800067c:	f853 1b04 	ldr.w	r1, [r3], #4
 8000680:	f842 1b04 	str.w	r1, [r2], #4
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 8000684:	4283      	cmp	r3, r0
 8000686:	d1f9      	bne.n	800067c <Reset_Handler+0x6c>
  }
#endif

#if CRT0_INIT_BSS
  /* BSS segment initialization.*/
  fill32(&_bss_start, &_bss_end, 0);
 8000688:	4b1b      	ldr	r3, [pc, #108]	; (80006f8 <Reset_Handler+0xe8>)
 800068a:	4a1c      	ldr	r2, [pc, #112]	; (80006fc <Reset_Handler+0xec>)
 800068c:	4293      	cmp	r3, r2
 800068e:	d20a      	bcs.n	80006a6 <Reset_Handler+0x96>
 8000690:	43d9      	mvns	r1, r3
 8000692:	440a      	add	r2, r1
 8000694:	f022 0203 	bic.w	r2, r2, #3
 8000698:	3204      	adds	r2, #4
 800069a:	441a      	add	r2, r3
 800069c:	2100      	movs	r1, #0
 800069e:	f843 1b04 	str.w	r1, [r3], #4
 80006a2:	4293      	cmp	r3, r2
 80006a4:	d1fb      	bne.n	800069e <Reset_Handler+0x8e>

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
    while (fpp < &__init_array_end) {
 80006a6:	4d16      	ldr	r5, [pc, #88]	; (8000700 <Reset_Handler+0xf0>)
 80006a8:	4c16      	ldr	r4, [pc, #88]	; (8000704 <Reset_Handler+0xf4>)
  /* BSS segment initialization.*/
  fill32(&_bss_start, &_bss_end, 0);
#endif

  /* Late initialization hook invocation.*/
  __late_init();
 80006aa:	f7ff ffa1 	bl	80005f0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
    while (fpp < &__init_array_end) {
 80006ae:	42ac      	cmp	r4, r5
 80006b0:	d204      	bcs.n	80006bc <Reset_Handler+0xac>
      (*fpp)();
 80006b2:	f854 3b04 	ldr.w	r3, [r4], #4
 80006b6:	4798      	blx	r3

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
    while (fpp < &__init_array_end) {
 80006b8:	42ac      	cmp	r4, r5
 80006ba:	d3fa      	bcc.n	80006b2 <Reset_Handler+0xa2>

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
    while (fpp < &__fini_array_end) {
 80006bc:	4d12      	ldr	r5, [pc, #72]	; (8000708 <Reset_Handler+0xf8>)
 80006be:	4c13      	ldr	r4, [pc, #76]	; (800070c <Reset_Handler+0xfc>)
    }
  }
#endif

  /* Invoking application main() function.*/
  main();
 80006c0:	f7ff fd7e 	bl	80001c0 <main>

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
    while (fpp < &__fini_array_end) {
 80006c4:	42ac      	cmp	r4, r5
 80006c6:	d204      	bcs.n	80006d2 <Reset_Handler+0xc2>
      (*fpp)();
 80006c8:	f854 3b04 	ldr.w	r3, [r4], #4
 80006cc:	4798      	blx	r3

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
    while (fpp < &__fini_array_end) {
 80006ce:	42ac      	cmp	r4, r5
 80006d0:	d3fa      	bcc.n	80006c8 <Reset_Handler+0xb8>
    }
  }
#endif

  /* Invoking the exit handler.*/
  _default_exit();
 80006d2:	f7ff ff95 	bl	8000600 <_default_exit>
 80006d6:	bf00      	nop
 80006d8:	20000800 	.word	0x20000800
 80006dc:	20000000 	.word	0x20000000
 80006e0:	20000400 	.word	0x20000400
 80006e4:	20000400 	.word	0x20000400
 80006e8:	20000803 	.word	0x20000803
 80006ec:	20000800 	.word	0x20000800
 80006f0:	20000800 	.word	0x20000800
 80006f4:	08002778 	.word	0x08002778
 80006f8:	20000800 	.word	0x20000800
 80006fc:	20001024 	.word	0x20001024
 8000700:	080001c0 	.word	0x080001c0
 8000704:	080001c0 	.word	0x080001c0
 8000708:	080001c0 	.word	0x080001c0
 800070c:	080001c0 	.word	0x080001c0

08000710 <_unhandled_exception>:
 * @notapi
 */
void _unhandled_exception(void) {

  while (true)
    ;
 8000710:	e7fe      	b.n	8000710 <_unhandled_exception>
 8000712:	bf00      	nop
 8000714:	f3af 8000 	nop.w
 8000718:	f3af 8000 	nop.w
 800071c:	f3af 8000 	nop.w

08000720 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000720:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000724:	3320      	adds	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000726:	f383 8809 	msr	PSP, r3

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800072a:	2300      	movs	r3, #0
 800072c:	f383 8811 	msr	BASEPRI, r3
 8000730:	4770      	bx	lr
 8000732:	bf00      	nop
 8000734:	f3af 8000 	nop.w
 8000738:	f3af 8000 	nop.w
 800073c:	f3af 8000 	nop.w

08000740 <_port_irq_epilogue>:
 8000740:	2320      	movs	r3, #32
 8000742:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0) {
 8000746:	4b0f      	ldr	r3, [pc, #60]	; (8000784 <_port_irq_epilogue+0x44>)
 8000748:	685b      	ldr	r3, [r3, #4]
 800074a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800074e:	d102      	bne.n	8000756 <_port_irq_epilogue+0x16>
 8000750:	f383 8811 	msr	BASEPRI, r3
 8000754:	4770      	bx	lr
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8000756:	b510      	push	{r4, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000758:	f3ef 8409 	mrs	r4, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800075c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8000760:	f844 3c04 	str.w	r3, [r4, #-4]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8000764:	f1a4 0320 	sub.w	r3, r4, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000768:	f383 8809 	msr	PSP, r3
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800076c:	f000 f9d0 	bl	8000b10 <chSchIsPreemptionRequired>
 8000770:	b118      	cbz	r0, 800077a <_port_irq_epilogue+0x3a>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8000772:	4b05      	ldr	r3, [pc, #20]	; (8000788 <_port_irq_epilogue+0x48>)
 8000774:	f844 3c08 	str.w	r3, [r4, #-8]
 8000778:	bd10      	pop	{r4, pc}
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 800077a:	4b04      	ldr	r3, [pc, #16]	; (800078c <_port_irq_epilogue+0x4c>)
 800077c:	f844 3c08 	str.w	r3, [r4, #-8]
 8000780:	bd10      	pop	{r4, pc}
 8000782:	bf00      	nop
 8000784:	e000ed00 	.word	0xe000ed00
 8000788:	080005df 	.word	0x080005df
 800078c:	080005e2 	.word	0x080005e2

08000790 <_idle_thread>:
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {

  (void)p;
  chRegSetThreadName("idle");
 8000790:	4b02      	ldr	r3, [pc, #8]	; (800079c <_idle_thread+0xc>)
 8000792:	4a03      	ldr	r2, [pc, #12]	; (80007a0 <_idle_thread+0x10>)
 8000794:	699b      	ldr	r3, [r3, #24]
 8000796:	619a      	str	r2, [r3, #24]
 8000798:	e7fe      	b.n	8000798 <_idle_thread+0x8>
 800079a:	bf00      	nop
 800079c:	20000800 	.word	0x20000800
 80007a0:	08002320 	.word	0x08002320
 80007a4:	f3af 8000 	nop.w
 80007a8:	f3af 8000 	nop.w
 80007ac:	f3af 8000 	nop.w

080007b0 <chSysInit>:
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 80007b0:	4b1e      	ldr	r3, [pc, #120]	; (800082c <chSysInit+0x7c>)
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
 80007b2:	4a1f      	ldr	r2, [pc, #124]	; (8000830 <chSysInit+0x80>)
  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80007b4:	481f      	ldr	r0, [pc, #124]	; (8000834 <chSysInit+0x84>)
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80007b6:	b5f0      	push	{r4, r5, r6, r7, lr}
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 80007b8:	2400      	movs	r4, #0
 80007ba:	609c      	str	r4, [r3, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80007bc:	68df      	ldr	r7, [r3, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80007be:	4e1e      	ldr	r6, [pc, #120]	; (8000838 <chSysInit+0x88>)
  _dbg_trace_init();
#endif

#if !CH_CFG_NO_IDLE_THREAD
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80007c0:	4d1e      	ldr	r5, [pc, #120]	; (800083c <chSysInit+0x8c>)
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 80007c2:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 80007c6:	4039      	ands	r1, r7
  reg_value  =  (reg_value                                 |
 80007c8:	430a      	orrs	r2, r1
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80007ca:	60da      	str	r2, [r3, #12]
 80007cc:	68f2      	ldr	r2, [r6, #12]
 80007ce:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80007d2:	60f2      	str	r2, [r6, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80007d4:	6802      	ldr	r2, [r0, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 80007d6:	2120      	movs	r1, #32
 80007d8:	f042 0201 	orr.w	r2, r2, #1
 80007dc:	2610      	movs	r6, #16
 80007de:	6002      	str	r2, [r0, #0]
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80007e0:	b083      	sub	sp, #12
 80007e2:	77de      	strb	r6, [r3, #31]
 80007e4:	f883 1022 	strb.w	r1, [r3, #34]	; 0x22
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
  _scheduler_init();
 80007e8:	f000 f8fa 	bl	80009e0 <_scheduler_init>
  _vt_init();
 80007ec:	f000 f9d8 	bl	8000ba0 <_vt_init>
#if CH_CFG_USE_TM
  _tm_init();
 80007f0:	f000 f89e 	bl	8000930 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE
  _core_init();
 80007f4:	f000 fd44 	bl	8001280 <_core_init>
#endif
#if CH_CFG_USE_HEAP
  _heap_init();
 80007f8:	f000 fd7a 	bl	80012f0 <_heap_init>
  _dbg_trace_init();
#endif

#if !CH_CFG_NO_IDLE_THREAD
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80007fc:	4628      	mov	r0, r5
 80007fe:	2140      	movs	r1, #64	; 0x40
 8000800:	f000 fa3e 	bl	8000c80 <_thread_init>
 8000804:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8000808:	2201      	movs	r2, #1
  _dbg_trace_init();
#endif

#if !CH_CFG_NO_IDLE_THREAD
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 800080a:	6198      	str	r0, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 800080c:	7702      	strb	r2, [r0, #28]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800080e:	f384 8811 	msr	BASEPRI, r4
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000812:	b662      	cpsie	i
#endif
  chSysEnable();

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 8000814:	699b      	ldr	r3, [r3, #24]
 8000816:	490a      	ldr	r1, [pc, #40]	; (8000840 <chSysInit+0x90>)
 8000818:	6199      	str	r1, [r3, #24]

#if !CH_CFG_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(ch.idle_thread_wa, sizeof(ch.idle_thread_wa), IDLEPRIO,
 800081a:	f105 0048 	add.w	r0, r5, #72	; 0x48
 800081e:	9400      	str	r4, [sp, #0]
 8000820:	21d8      	movs	r1, #216	; 0xd8
 8000822:	4b08      	ldr	r3, [pc, #32]	; (8000844 <chSysInit+0x94>)
 8000824:	f000 fa4c 	bl	8000cc0 <chThdCreateStatic>
                    (tfunc_t)_idle_thread, NULL);
#endif
}
 8000828:	b003      	add	sp, #12
 800082a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800082c:	e000ed00 	.word	0xe000ed00
 8000830:	05fa0300 	.word	0x05fa0300
 8000834:	e0001000 	.word	0xe0001000
 8000838:	e000edf0 	.word	0xe000edf0
 800083c:	20000830 	.word	0x20000830
 8000840:	08002330 	.word	0x08002330
 8000844:	08000791 	.word	0x08000791
 8000848:	f3af 8000 	nop.w
 800084c:	f3af 8000 	nop.w

08000850 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8000850:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8000854:	4c1b      	ldr	r4, [pc, #108]	; (80008c4 <chSysTimerHandlerI+0x74>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000856:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 800085a:	69e3      	ldr	r3, [r4, #28]
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 800085c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800085e:	6a69      	ldr	r1, [r5, #36]	; 0x24

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8000860:	6898      	ldr	r0, [r3, #8]
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8000862:	1a8e      	subs	r6, r1, r2

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8000864:	4286      	cmp	r6, r0
 8000866:	f104 061c 	add.w	r6, r4, #28
 800086a:	d319      	bcc.n	80008a0 <chSysTimerHandlerI+0x50>

    /* The timer is removed from the list and marked as non-armed.*/
    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = (vtfunc_t)NULL;
 800086c:	f04f 0800 	mov.w	r8, #0

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000870:	2720      	movs	r7, #32
    /* The "last time" becomes this timer's expiration time.*/
    delta -= vtp->vt_delta;
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    /* The timer is removed from the list and marked as non-armed.*/
    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000872:	6819      	ldr	r1, [r3, #0]
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 8000874:	f8d3 c00c 	ldr.w	ip, [r3, #12]
      break;
    }

    /* The "last time" becomes this timer's expiration time.*/
    delta -= vtp->vt_delta;
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8000878:	4402      	add	r2, r0
 800087a:	62a2      	str	r2, [r4, #40]	; 0x28

    /* The timer is removed from the list and marked as non-armed.*/
    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800087c:	604e      	str	r6, [r1, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 800087e:	61e1      	str	r1, [r4, #28]
    fn = vtp->vt_func;
    vtp->vt_func = (vtfunc_t)NULL;
 8000880:	f8c3 800c 	str.w	r8, [r3, #12]
 8000884:	f388 8811 	msr	BASEPRI, r8

    /* The callback is invoked outside the kernel critical zone.*/
    chSysUnlockFromISR();
    fn(vtp->vt_par);
 8000888:	6918      	ldr	r0, [r3, #16]
 800088a:	47e0      	blx	ip
 800088c:	f387 8811 	msr	BASEPRI, r7
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8000890:	69e3      	ldr	r3, [r4, #28]
 8000892:	6a69      	ldr	r1, [r5, #36]	; 0x24
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8000894:	6aa2      	ldr	r2, [r4, #40]	; 0x28

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8000896:	6898      	ldr	r0, [r3, #8]
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8000898:	ebc2 0e01 	rsb	lr, r2, r1

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 800089c:	4586      	cmp	lr, r0
 800089e:	d2e8      	bcs.n	8000872 <chSysTimerHandlerI+0x22>
    /* The callback is invoked outside the kernel critical zone.*/
    chSysUnlockFromISR();
    fn(vtp->vt_par);
    chSysLockFromISR();
  }
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80008a0:	42b3      	cmp	r3, r6
 80008a2:	d00b      	beq.n	80008bc <chSysTimerHandlerI+0x6c>
    port_timer_stop_alarm();
  }
  else {
    /* Updating the alarm to the next deadline, deadline that must not be
       closer in time than the minimum time delta.*/
    if (vtp->vt_delta >= CH_CFG_ST_TIMEDELTA) {
 80008a4:	2801      	cmp	r0, #1
 80008a6:	d004      	beq.n	80008b2 <chSysTimerHandlerI+0x62>
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 80008a8:	4408      	add	r0, r1
#endif
  chVTDoTickI();
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 80008aa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80008ae:	f000 be5f 	b.w	8001570 <stSetAlarm>
 80008b2:	1c88      	adds	r0, r1, #2
 80008b4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80008b8:	f000 be5a 	b.w	8001570 <stSetAlarm>
 80008bc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 80008c0:	f000 be4e 	b.w	8001560 <stStopAlarm>
 80008c4:	20000800 	.word	0x20000800
 80008c8:	f3af 8000 	nop.w
 80008cc:	f3af 8000 	nop.w

080008d0 <chTMStartMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80008d0:	4b01      	ldr	r3, [pc, #4]	; (80008d8 <chTMStartMeasurementX+0x8>)
 80008d2:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 80008d4:	6083      	str	r3, [r0, #8]
 80008d6:	4770      	bx	lr
 80008d8:	e0001000 	.word	0xe0001000
 80008dc:	f3af 8000 	nop.w

080008e0 <chTMStopMeasurementX>:
 80008e0:	4b0f      	ldr	r3, [pc, #60]	; (8000920 <chTMStopMeasurementX+0x40>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80008e2:	4910      	ldr	r1, [pc, #64]	; (8000924 <chTMStopMeasurementX+0x44>)
 80008e4:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = now - tmp->last - offset;
 80008e6:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80008e8:	b4f0      	push	{r4, r5, r6, r7}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80008ea:	6f4f      	ldr	r7, [r1, #116]	; 0x74

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 80008ec:	68c6      	ldr	r6, [r0, #12]
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 80008ee:	6841      	ldr	r1, [r0, #4]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 80008f0:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = now - tmp->last - offset;
 80008f4:	1ad3      	subs	r3, r2, r3
 80008f6:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
 80008f8:	18e4      	adds	r4, r4, r3
 80008fa:	f145 0500 	adc.w	r5, r5, #0

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 80008fe:	3601      	adds	r6, #1
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 8000900:	428b      	cmp	r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8000902:	60c6      	str	r6, [r0, #12]
  tmp->last = now - tmp->last - offset;
 8000904:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8000906:	e9c0 4504 	strd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
 800090a:	d805      	bhi.n	8000918 <chTMStopMeasurementX+0x38>
    tmp->worst = tmp->last;
  }
  else if (tmp->last < tmp->best) {
 800090c:	6802      	ldr	r2, [r0, #0]
 800090e:	4293      	cmp	r3, r2
    tmp->best = tmp->last;
 8000910:	bf38      	it	cc
 8000912:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8000914:	bcf0      	pop	{r4, r5, r6, r7}
 8000916:	4770      	bx	lr

  tmp->n++;
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 8000918:	6043      	str	r3, [r0, #4]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 800091a:	bcf0      	pop	{r4, r5, r6, r7}
 800091c:	4770      	bx	lr
 800091e:	bf00      	nop
 8000920:	e0001000 	.word	0xe0001000
 8000924:	20000800 	.word	0x20000800
 8000928:	f3af 8000 	nop.w
 800092c:	f3af 8000 	nop.w

08000930 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8000930:	b5d0      	push	{r4, r6, r7, lr}
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
 8000932:	4c0c      	ldr	r4, [pc, #48]	; (8000964 <_tm_init+0x34>)
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8000934:	b086      	sub	sp, #24
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
 8000936:	2300      	movs	r3, #0
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8000938:	f04f 32ff 	mov.w	r2, #4294967295
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 800093c:	4668      	mov	r0, sp

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 800093e:	2600      	movs	r6, #0
 8000940:	2700      	movs	r7, #0
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
 8000942:	6763      	str	r3, [r4, #116]	; 0x74
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 8000944:	9301      	str	r3, [sp, #4]
  tmp->last       = (rtcnt_t)0;
 8000946:	9302      	str	r3, [sp, #8]
  tmp->n          = (ucnt_t)0;
 8000948:	9303      	str	r3, [sp, #12]
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 800094a:	9200      	str	r2, [sp, #0]
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 800094c:	e9cd 6704 	strd	r6, r7, [sp, #16]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8000950:	f7ff ffbe 	bl	80008d0 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 8000954:	4668      	mov	r0, sp
 8000956:	f7ff ffc3 	bl	80008e0 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 800095a:	9b02      	ldr	r3, [sp, #8]
 800095c:	6763      	str	r3, [r4, #116]	; 0x74
}
 800095e:	b006      	add	sp, #24
 8000960:	bdd0      	pop	{r4, r6, r7, pc}
 8000962:	bf00      	nop
 8000964:	20000800 	.word	0x20000800
 8000968:	f3af 8000 	nop.w
 800096c:	f3af 8000 	nop.w

08000970 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000970:	b410      	push	{r4}
 8000972:	2320      	movs	r3, #32
 8000974:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 8000978:	7f03      	ldrb	r3, [r0, #28]
 800097a:	2b07      	cmp	r3, #7
 800097c:	d80e      	bhi.n	800099c <wakeup+0x2c>
 800097e:	e8df f003 	tbb	[pc, r3]
 8000982:	0d27      	.short	0x0d27
 8000984:	0408230d 	.word	0x0408230d
 8000988:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *(thread_reference_t *)tp->p_u.wtobjp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES
  case CH_STATE_WTSEM:
    chSemFastSignalI((semaphore_t *)tp->p_u.wtobjp);
 800098a:	6a02      	ldr	r2, [r0, #32]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 800098c:	6893      	ldr	r3, [r2, #8]
 800098e:	3301      	adds	r3, #1
 8000990:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000992:	e890 000c 	ldmia.w	r0, {r2, r3}
 8000996:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000998:	6802      	ldr	r2, [r0, #0]
 800099a:	6053      	str	r3, [r2, #4]
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    queue_dequeue(tp);
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 800099c:	f04f 34ff 	mov.w	r4, #4294967295
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80009a0:	2200      	movs	r2, #0
 80009a2:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 80009a4:	4b0d      	ldr	r3, [pc, #52]	; (80009dc <wakeup+0x6c>)
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    queue_dequeue(tp);
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 80009a6:	6204      	str	r4, [r0, #32]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80009a8:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 80009aa:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80009ac:	689a      	ldr	r2, [r3, #8]
 80009ae:	428a      	cmp	r2, r1
 80009b0:	d2fb      	bcs.n	80009aa <wakeup+0x3a>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80009b2:	685a      	ldr	r2, [r3, #4]
 80009b4:	6042      	str	r2, [r0, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80009b6:	6003      	str	r3, [r0, #0]
 80009b8:	2100      	movs	r1, #0
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 80009ba:	6058      	str	r0, [r3, #4]
 80009bc:	6010      	str	r0, [r2, #0]
 80009be:	f381 8811 	msr	BASEPRI, r1
    queue_dequeue(tp);
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  chSchReadyI(tp);
  chSysUnlockFromISR();
}
 80009c2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80009c6:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *(thread_reference_t *)tp->p_u.wtobjp = NULL;
 80009c8:	6a03      	ldr	r3, [r0, #32]
 80009ca:	2200      	movs	r2, #0
 80009cc:	601a      	str	r2, [r3, #0]
    break;
 80009ce:	e7e5      	b.n	800099c <wakeup+0x2c>
 80009d0:	2300      	movs	r3, #0
 80009d2:	f383 8811 	msr	BASEPRI, r3
    queue_dequeue(tp);
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  chSchReadyI(tp);
  chSysUnlockFromISR();
}
 80009d6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80009da:	4770      	bx	lr
 80009dc:	20000800 	.word	0x20000800

080009e0 <_scheduler_init>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 80009e0:	4b03      	ldr	r3, [pc, #12]	; (80009f0 <_scheduler_init+0x10>)
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 80009e2:	2200      	movs	r2, #0
 80009e4:	605b      	str	r3, [r3, #4]
 80009e6:	601b      	str	r3, [r3, #0]
#if CH_CFG_USE_REGISTRY
  ch.rlist.r_newer = ch.rlist.r_older = (thread_t *)&ch.rlist;
 80009e8:	615b      	str	r3, [r3, #20]
 80009ea:	611b      	str	r3, [r3, #16]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 80009ec:	609a      	str	r2, [r3, #8]
 80009ee:	4770      	bx	lr
 80009f0:	20000800 	.word	0x20000800
 80009f4:	f3af 8000 	nop.w
 80009f8:	f3af 8000 	nop.w
 80009fc:	f3af 8000 	nop.w

08000a00 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000a00:	2200      	movs	r2, #0
 8000a02:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000a04:	4b08      	ldr	r3, [pc, #32]	; (8000a28 <chSchReadyI+0x28>)
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8000a06:	b410      	push	{r4}
 8000a08:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000a0a:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 8000a0c:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8000a0e:	689a      	ldr	r2, [r3, #8]
 8000a10:	428a      	cmp	r2, r1
 8000a12:	d2fb      	bcs.n	8000a0c <chSchReadyI+0xc>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000a14:	685a      	ldr	r2, [r3, #4]
 8000a16:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000a18:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;

  return tp;
}
 8000a1a:	4620      	mov	r0, r4
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 8000a1c:	605c      	str	r4, [r3, #4]
 8000a1e:	6014      	str	r4, [r2, #0]

  return tp;
}
 8000a20:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000a24:	4770      	bx	lr
 8000a26:	bf00      	nop
 8000a28:	20000800 	.word	0x20000800
 8000a2c:	f3af 8000 	nop.w

08000a30 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 8000a30:	4b07      	ldr	r3, [pc, #28]	; (8000a50 <chSchGoSleepS+0x20>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000a32:	b430      	push	{r4, r5}
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8000a34:	681a      	ldr	r2, [r3, #0]
  thread_t *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 8000a36:	6999      	ldr	r1, [r3, #24]

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8000a38:	6814      	ldr	r4, [r2, #0]
 8000a3a:	7708      	strb	r0, [r1, #28]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000a3c:	2501      	movs	r5, #1
 8000a3e:	6063      	str	r3, [r4, #4]
 8000a40:	7715      	strb	r5, [r2, #28]
 8000a42:	601c      	str	r4, [r3, #0]
  chSysSwitch(currp, otp);
 8000a44:	4610      	mov	r0, r2
}
 8000a46:	bc30      	pop	{r4, r5}
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000a48:	619a      	str	r2, [r3, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 8000a4a:	f7ff bdb9 	b.w	80005c0 <_port_switch>
 8000a4e:	bf00      	nop
 8000a50:	20000800 	.word	0x20000800
 8000a54:	f3af 8000 	nop.w
 8000a58:	f3af 8000 	nop.w
 8000a5c:	f3af 8000 	nop.w

08000a60 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000a60:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000a62:	1c4b      	adds	r3, r1, #1
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000a64:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000a66:	d012      	beq.n	8000a8e <chSchGoSleepTimeoutS+0x2e>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8000a68:	4c0c      	ldr	r4, [pc, #48]	; (8000a9c <chSchGoSleepTimeoutS+0x3c>)
 8000a6a:	4a0d      	ldr	r2, [pc, #52]	; (8000aa0 <chSchGoSleepTimeoutS+0x40>)
 8000a6c:	69a3      	ldr	r3, [r4, #24]
 8000a6e:	4605      	mov	r5, r0
 8000a70:	a801      	add	r0, sp, #4
 8000a72:	f000 f8a5 	bl	8000bc0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8000a76:	4628      	mov	r0, r5
 8000a78:	f7ff ffda 	bl	8000a30 <chSchGoSleepS>
    if (chVTIsArmedI(&vt))
 8000a7c:	9b04      	ldr	r3, [sp, #16]
 8000a7e:	b113      	cbz	r3, 8000a86 <chSchGoSleepTimeoutS+0x26>
      chVTDoResetI(&vt);
 8000a80:	a801      	add	r0, sp, #4
 8000a82:	f000 f8d5 	bl	8000c30 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 8000a86:	69a3      	ldr	r3, [r4, #24]
}
 8000a88:	6a18      	ldr	r0, [r3, #32]
 8000a8a:	b007      	add	sp, #28
 8000a8c:	bd30      	pop	{r4, r5, pc}
 8000a8e:	4c03      	ldr	r4, [pc, #12]	; (8000a9c <chSchGoSleepTimeoutS+0x3c>)
    chSchGoSleepS(newstate);
    if (chVTIsArmedI(&vt))
      chVTDoResetI(&vt);
  }
  else {
    chSchGoSleepS(newstate);
 8000a90:	f7ff ffce 	bl	8000a30 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8000a94:	69a3      	ldr	r3, [r4, #24]
}
 8000a96:	6a18      	ldr	r0, [r3, #32]
 8000a98:	b007      	add	sp, #28
 8000a9a:	bd30      	pop	{r4, r5, pc}
 8000a9c:	20000800 	.word	0x20000800
 8000aa0:	08000971 	.word	0x08000971
 8000aa4:	f3af 8000 	nop.w
 8000aa8:	f3af 8000 	nop.w
 8000aac:	f3af 8000 	nop.w

08000ab0 <chSchWakeupS>:

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000ab0:	4b14      	ldr	r3, [pc, #80]	; (8000b04 <chSchWakeupS+0x54>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000ab2:	b4f0      	push	{r4, r5, r6, r7}

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000ab4:	699e      	ldr	r6, [r3, #24]
 8000ab6:	6884      	ldr	r4, [r0, #8]
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000ab8:	4605      	mov	r5, r0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000aba:	68b0      	ldr	r0, [r6, #8]

  chDbgCheckClassS();

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8000abc:	6229      	str	r1, [r5, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000abe:	4284      	cmp	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000ac0:	f04f 0200 	mov.w	r2, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000ac4:	d80b      	bhi.n	8000ade <chSchWakeupS+0x2e>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000ac6:	772a      	strb	r2, [r5, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 8000ac8:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8000aca:	689a      	ldr	r2, [r3, #8]
 8000acc:	4294      	cmp	r4, r2
 8000ace:	d9fb      	bls.n	8000ac8 <chSchWakeupS+0x18>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000ad0:	685a      	ldr	r2, [r3, #4]
 8000ad2:	606a      	str	r2, [r5, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000ad4:	602b      	str	r3, [r5, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 8000ad6:	605d      	str	r5, [r3, #4]
 8000ad8:	6015      	str	r5, [r2, #0]
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 8000ada:	bcf0      	pop	{r4, r5, r6, r7}
 8000adc:	4770      	bx	lr
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000ade:	7732      	strb	r2, [r6, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000ae0:	461a      	mov	r2, r3
  do {
    cp = cp->p_next;
 8000ae2:	6812      	ldr	r2, [r2, #0]
  } while (cp->p_prio >= tp->p_prio);
 8000ae4:	6891      	ldr	r1, [r2, #8]
 8000ae6:	4288      	cmp	r0, r1
 8000ae8:	d9fb      	bls.n	8000ae2 <chSchWakeupS+0x32>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000aea:	6854      	ldr	r4, [r2, #4]
 8000aec:	6074      	str	r4, [r6, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8000aee:	2701      	movs	r7, #1
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000af0:	6032      	str	r2, [r6, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 8000af2:	6056      	str	r6, [r2, #4]
 8000af4:	6026      	str	r6, [r4, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8000af6:	772f      	strb	r7, [r5, #28]
    chSysSwitch(ntp, otp);
 8000af8:	4631      	mov	r1, r6
 8000afa:	4628      	mov	r0, r5
  if (ntp->p_prio <= currp->p_prio) {
    chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 8000afc:	619d      	str	r5, [r3, #24]
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 8000afe:	bcf0      	pop	{r4, r5, r6, r7}
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8000b00:	f7ff bd5e 	b.w	80005c0 <_port_switch>
 8000b04:	20000800 	.word	0x20000800
 8000b08:	f3af 8000 	nop.w
 8000b0c:	f3af 8000 	nop.w

08000b10 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8000b10:	4b04      	ldr	r3, [pc, #16]	; (8000b24 <chSchIsPreemptionRequired+0x14>)
 8000b12:	681a      	ldr	r2, [r3, #0]
  tprio_t p2 = currp->p_prio;
 8000b14:	699b      	ldr	r3, [r3, #24]
     if the first thread on the ready queue has equal or higher priority.*/
  return currp->p_preempt ? p1 > p2 : p1 >= p2;
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8000b16:	6890      	ldr	r0, [r2, #8]
 8000b18:	689b      	ldr	r3, [r3, #8]
#endif
}
 8000b1a:	4298      	cmp	r0, r3
 8000b1c:	bf94      	ite	ls
 8000b1e:	2000      	movls	r0, #0
 8000b20:	2001      	movhi	r0, #1
 8000b22:	4770      	bx	lr
 8000b24:	20000800 	.word	0x20000800
 8000b28:	f3af 8000 	nop.w
 8000b2c:	f3af 8000 	nop.w

08000b30 <chSchDoRescheduleAhead>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 8000b30:	4a0d      	ldr	r2, [pc, #52]	; (8000b68 <chSchDoRescheduleAhead+0x38>)
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8000b32:	6810      	ldr	r0, [r2, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8000b34:	b470      	push	{r4, r5, r6}

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8000b36:	6803      	ldr	r3, [r0, #0]
  thread_t *otp, *cp;

  otp = currp;
 8000b38:	6994      	ldr	r4, [r2, #24]
 8000b3a:	6013      	str	r3, [r2, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000b3c:	2601      	movs	r6, #1

  otp->p_state = CH_STATE_READY;
 8000b3e:	2500      	movs	r5, #0
 8000b40:	68a1      	ldr	r1, [r4, #8]
 8000b42:	605a      	str	r2, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000b44:	7706      	strb	r6, [r0, #28]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000b46:	6190      	str	r0, [r2, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 8000b48:	7725      	strb	r5, [r4, #28]
 8000b4a:	e000      	b.n	8000b4e <chSchDoRescheduleAhead+0x1e>
 8000b4c:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 8000b4e:	689a      	ldr	r2, [r3, #8]
 8000b50:	428a      	cmp	r2, r1
 8000b52:	d8fb      	bhi.n	8000b4c <chSchDoRescheduleAhead+0x1c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8000b54:	685a      	ldr	r2, [r3, #4]
 8000b56:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8000b58:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
 8000b5a:	4621      	mov	r1, r4
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;
 8000b5c:	605c      	str	r4, [r3, #4]
 8000b5e:	6014      	str	r4, [r2, #0]

  chSysSwitch(currp, otp);
}
 8000b60:	bc70      	pop	{r4, r5, r6}
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
 8000b62:	f7ff bd2d 	b.w	80005c0 <_port_switch>
 8000b66:	bf00      	nop
 8000b68:	20000800 	.word	0x20000800
 8000b6c:	f3af 8000 	nop.w

08000b70 <chSchRescheduleS>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 8000b70:	4b04      	ldr	r3, [pc, #16]	; (8000b84 <chSchRescheduleS+0x14>)
 8000b72:	681a      	ldr	r2, [r3, #0]
 8000b74:	699b      	ldr	r3, [r3, #24]
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8000b76:	6892      	ldr	r2, [r2, #8]
 8000b78:	689b      	ldr	r3, [r3, #8]
 8000b7a:	429a      	cmp	r2, r3
 8000b7c:	d800      	bhi.n	8000b80 <chSchRescheduleS+0x10>
 8000b7e:	4770      	bx	lr
    chSchDoRescheduleAhead();
 8000b80:	f7ff bfd6 	b.w	8000b30 <chSchDoRescheduleAhead>
 8000b84:	20000800 	.word	0x20000800
 8000b88:	f3af 8000 	nop.w
 8000b8c:	f3af 8000 	nop.w

08000b90 <chSchDoReschedule>:
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8000b90:	f7ff bfce 	b.w	8000b30 <chSchDoRescheduleAhead>
 8000b94:	f3af 8000 	nop.w
 8000b98:	f3af 8000 	nop.w
 8000b9c:	f3af 8000 	nop.w

08000ba0 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
 8000ba0:	4b05      	ldr	r3, [pc, #20]	; (8000bb8 <_vt_init+0x18>)
  ch.vtlist.vt_delta = (systime_t)-1;
 8000ba2:	f04f 30ff 	mov.w	r0, #4294967295
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
 8000ba6:	f103 021c 	add.w	r2, r3, #28
  ch.vtlist.vt_delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = 0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = 0;
 8000baa:	2100      	movs	r1, #0
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 8000bac:	6258      	str	r0, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = 0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = 0;
 8000bae:	6299      	str	r1, [r3, #40]	; 0x28
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
 8000bb0:	621a      	str	r2, [r3, #32]
 8000bb2:	61da      	str	r2, [r3, #28]
 8000bb4:	4770      	bx	lr
 8000bb6:	bf00      	nop
 8000bb8:	20000800 	.word	0x20000800
 8000bbc:	f3af 8000 	nop.w

08000bc0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8000bc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = ch.vtlist.vt_next;
 8000bc2:	4f1a      	ldr	r7, [pc, #104]	; (8000c2c <chVTDoSetI+0x6c>)
 8000bc4:	46be      	mov	lr, r7
    systime_t now = port_timer_get_time();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < CH_CFG_ST_TIMEDELTA) {
      delay = CH_CFG_ST_TIMEDELTA;
 8000bc6:	2901      	cmp	r1, #1
 8000bc8:	bf8c      	ite	hi
 8000bca:	460d      	movhi	r5, r1
 8000bcc:	2502      	movls	r5, #2
  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = ch.vtlist.vt_next;
 8000bce:	f85e 4f1c 	ldr.w	r4, [lr, #28]!
  virtual_timer_t *p;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8000bd2:	6103      	str	r3, [r0, #16]
 8000bd4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
       is raised to the minimum safe value.*/
    if (delay < CH_CFG_ST_TIMEDELTA) {
      delay = CH_CFG_ST_TIMEDELTA;
    }

    if (&ch.vtlist == (virtual_timers_list_t *)p) {
 8000bd8:	4574      	cmp	r4, lr

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 8000bda:	60c2      	str	r2, [r0, #12]
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8000bdc:	4606      	mov	r6, r0
 8000bde:	6a5a      	ldr	r2, [r3, #36]	; 0x24
       is raised to the minimum safe value.*/
    if (delay < CH_CFG_ST_TIMEDELTA) {
      delay = CH_CFG_ST_TIMEDELTA;
    }

    if (&ch.vtlist == (virtual_timers_list_t *)p) {
 8000be0:	d01d      	beq.n	8000c1e <chVTDoSetI+0x5e>
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
    }
    else {
      /* Now the delay is calculated as delta from the last tick interrupt
         time.*/
      delay += now - ch.vtlist.vt_lasttime;
 8000be2:	6ab8      	ldr	r0, [r7, #40]	; 0x28

      /* If the specified delay is closer in time than the first element
         in the delta list then it becomes the next alarm event in time.*/
      if (delay < p->vt_delta) {
 8000be4:	68a3      	ldr	r3, [r4, #8]
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
    }
    else {
      /* Now the delay is calculated as delta from the last tick interrupt
         time.*/
      delay += now - ch.vtlist.vt_lasttime;
 8000be6:	1a12      	subs	r2, r2, r0
 8000be8:	4415      	add	r5, r2

      /* If the specified delay is closer in time than the first element
         in the delta list then it becomes the next alarm event in time.*/
      if (delay < p->vt_delta) {
 8000bea:	429d      	cmp	r5, r3
 8000bec:	d203      	bcs.n	8000bf6 <chVTDoSetI+0x36>
 8000bee:	e011      	b.n	8000c14 <chVTDoSetI+0x54>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delay) {
    delay -= p->vt_delta;
    p = p->vt_next;
 8000bf0:	6824      	ldr	r4, [r4, #0]
#endif /* CH_CFG_ST_TIMEDELTA > 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delay) {
    delay -= p->vt_delta;
 8000bf2:	1aed      	subs	r5, r5, r3
  }
#endif /* CH_CFG_ST_TIMEDELTA > 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delay) {
 8000bf4:	68a3      	ldr	r3, [r4, #8]
 8000bf6:	42ab      	cmp	r3, r5
 8000bf8:	d3fa      	bcc.n	8000bf0 <chVTDoSetI+0x30>
    delay -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
 8000bfa:	6863      	ldr	r3, [r4, #4]
 8000bfc:	6073      	str	r3, [r6, #4]
 8000bfe:	6034      	str	r4, [r6, #0]
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
 8000c00:	6066      	str	r6, [r4, #4]
 8000c02:	601e      	str	r6, [r3, #0]
  vtp->vt_delta = delay
 8000c04:	60b5      	str	r5, [r6, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delay;
 8000c06:	68a1      	ldr	r1, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8000c08:	f04f 33ff 	mov.w	r3, #4294967295
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
  vtp->vt_delta = delay

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delay;
 8000c0c:	1b49      	subs	r1, r1, r5
 8000c0e:	60a1      	str	r1, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8000c10:	627b      	str	r3, [r7, #36]	; 0x24
 8000c12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8000c14:	4428      	add	r0, r5
 8000c16:	f000 fcab 	bl	8001570 <stSetAlarm>
 8000c1a:	68a3      	ldr	r3, [r4, #8]
 8000c1c:	e7eb      	b.n	8000bf6 <chVTDoSetI+0x36>
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {

  stStartAlarm(time);
 8000c1e:	18a8      	adds	r0, r5, r2
    }

    if (&ch.vtlist == (virtual_timers_list_t *)p) {
      /* The delta list is empty, the current time becomes the new
         delta list base time.*/
      ch.vtlist.vt_lasttime = now;
 8000c20:	62ba      	str	r2, [r7, #40]	; 0x28
 8000c22:	f000 fc95 	bl	8001550 <stStartAlarm>
 8000c26:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000c28:	e7e5      	b.n	8000bf6 <chVTDoSetI+0x36>
 8000c2a:	bf00      	nop
 8000c2c:	20000800 	.word	0x20000800

08000c30 <chVTDoResetI>:
  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8000c30:	6802      	ldr	r2, [r0, #0]
 8000c32:	6883      	ldr	r3, [r0, #8]
 8000c34:	6891      	ldr	r1, [r2, #8]
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8000c36:	b430      	push	{r4, r5}
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = (vtfunc_t)NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8000c38:	4c10      	ldr	r4, [pc, #64]	; (8000c7c <chVTDoResetI+0x4c>)
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
 8000c3a:	6845      	ldr	r5, [r0, #4]
  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8000c3c:	4419      	add	r1, r3
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000c3e:	4623      	mov	r3, r4
  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8000c40:	6091      	str	r1, [r2, #8]
  vtp->vt_prev->vt_next = vtp->vt_next;
 8000c42:	602a      	str	r2, [r5, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
 8000c44:	6801      	ldr	r1, [r0, #0]
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000c46:	f853 2f1c 	ldr.w	r2, [r3, #28]!
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
 8000c4a:	604d      	str	r5, [r1, #4]
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000c4c:	429a      	cmp	r2, r3

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = (vtfunc_t)NULL;
 8000c4e:	f04f 0500 	mov.w	r5, #0

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8000c52:	f04f 31ff 	mov.w	r1, #4294967295

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = (vtfunc_t)NULL;
 8000c56:	60c5      	str	r5, [r0, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8000c58:	6261      	str	r1, [r4, #36]	; 0x24

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000c5a:	d00b      	beq.n	8000c74 <chVTDoResetI+0x44>
      port_timer_stop_alarm();
    }
    else {
      /* Updating the alarm to the next deadline, deadline that must not be
         closer in time than the minimum time delta.*/
      if (ch.vtlist.vt_next->vt_delta >= CH_CFG_ST_TIMEDELTA) {
 8000c5c:	6893      	ldr	r3, [r2, #8]
        port_timer_set_alarm(ch.vtlist.vt_lasttime +
 8000c5e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
      port_timer_stop_alarm();
    }
    else {
      /* Updating the alarm to the next deadline, deadline that must not be
         closer in time than the minimum time delta.*/
      if (ch.vtlist.vt_next->vt_delta >= CH_CFG_ST_TIMEDELTA) {
 8000c60:	2b01      	cmp	r3, #1
 8000c62:	d903      	bls.n	8000c6c <chVTDoResetI+0x3c>
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8000c64:	4418      	add	r0, r3
                             CH_CFG_ST_TIMEDELTA);
      }
    }
  }
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000c66:	bc30      	pop	{r4, r5}
 8000c68:	f000 bc82 	b.w	8001570 <stSetAlarm>
 8000c6c:	3002      	adds	r0, #2
 8000c6e:	bc30      	pop	{r4, r5}
 8000c70:	f000 bc7e 	b.w	8001570 <stSetAlarm>
 8000c74:	bc30      	pop	{r4, r5}
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 8000c76:	f000 bc73 	b.w	8001560 <stStopAlarm>
 8000c7a:	bf00      	nop
 8000c7c:	20000800 	.word	0x20000800

08000c80 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8000c80:	b5f0      	push	{r4, r5, r6, r7, lr}
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000c82:	4c0e      	ldr	r4, [pc, #56]	; (8000cbc <_thread_init+0x3c>)
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
 8000c84:	63c1      	str	r1, [r0, #60]	; 0x3c
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000c86:	6966      	ldr	r6, [r4, #20]
 8000c88:	6146      	str	r6, [r0, #20]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8000c8a:	2200      	movs	r2, #0
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
 8000c8c:	f100 0528 	add.w	r5, r0, #40	; 0x28
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8000c90:	f04f 0c02 	mov.w	ip, #2
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 8000c94:	f04f 0e01 	mov.w	lr, #1
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
 8000c98:	f100 0724 	add.w	r7, r0, #36	; 0x24
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8000c9c:	6081      	str	r1, [r0, #8]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000c9e:	6104      	str	r4, [r0, #16]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8000ca0:	f880 c01c 	strb.w	ip, [r0, #28]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000ca4:	6160      	str	r0, [r4, #20]
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 8000ca6:	f880 e01e 	strb.w	lr, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8000caa:	7742      	strb	r2, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8000cac:	6382      	str	r2, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS
  tp->p_epending = 0;
 8000cae:	6342      	str	r2, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
 8000cb0:	6182      	str	r2, [r0, #24]
  REG_INSERT(tp);
 8000cb2:	6130      	str	r0, [r6, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8000cb4:	6247      	str	r7, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8000cb6:	62c5      	str	r5, [r0, #44]	; 0x2c
 8000cb8:	6285      	str	r5, [r0, #40]	; 0x28
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
}
 8000cba:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000cbc:	20000800 	.word	0x20000800

08000cc0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8000cc0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000cc4:	4699      	mov	r9, r3
 8000cc6:	4604      	mov	r4, r0
 8000cc8:	2320      	movs	r3, #32
 8000cca:	f383 8811 	msr	BASEPRI, r3
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000cce:	4e1a      	ldr	r6, [pc, #104]	; (8000d38 <chThdCreateStatic+0x78>)

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000cd0:	4b1a      	ldr	r3, [pc, #104]	; (8000d3c <chThdCreateStatic+0x7c>)
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000cd2:	6977      	ldr	r7, [r6, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000cd4:	3924      	subs	r1, #36	; 0x24
 8000cd6:	eb00 0a01 	add.w	sl, r0, r1
 8000cda:	f8c0 a00c 	str.w	sl, [r0, #12]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8000cde:	2500      	movs	r5, #0

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000ce0:	f840 9001 	str.w	r9, [r0, r1]
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 8000ce4:	f04f 0c01 	mov.w	ip, #1
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
 8000ce8:	f100 0928 	add.w	r9, r0, #40	; 0x28

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000cec:	9908      	ldr	r1, [sp, #32]
 8000cee:	f8ca 1004 	str.w	r1, [sl, #4]
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
 8000cf2:	f100 0e24 	add.w	lr, r0, #36	; 0x24
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8000cf6:	f04f 0802 	mov.w	r8, #2

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000cfa:	f8ca 3020 	str.w	r3, [sl, #32]
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), MSG_OK);
 8000cfe:	4629      	mov	r1, r5
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8000d00:	6082      	str	r2, [r0, #8]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000d02:	6106      	str	r6, [r0, #16]
 8000d04:	6147      	str	r7, [r0, #20]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
 8000d06:	63c2      	str	r2, [r0, #60]	; 0x3c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8000d08:	f880 801c 	strb.w	r8, [r0, #28]
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 8000d0c:	f880 c01e 	strb.w	ip, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8000d10:	7745      	strb	r5, [r0, #29]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000d12:	6170      	str	r0, [r6, #20]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8000d14:	6385      	str	r5, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS
  tp->p_epending = 0;
 8000d16:	6345      	str	r5, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
 8000d18:	6185      	str	r5, [r0, #24]
  REG_INSERT(tp);
 8000d1a:	6138      	str	r0, [r7, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8000d1c:	f8c0 e024 	str.w	lr, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8000d20:	f8c0 902c 	str.w	r9, [r0, #44]	; 0x2c
 8000d24:	f8c0 9028 	str.w	r9, [r0, #40]	; 0x28
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), MSG_OK);
 8000d28:	f7ff fec2 	bl	8000ab0 <chSchWakeupS>
 8000d2c:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
 8000d30:	4620      	mov	r0, r4
 8000d32:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000d36:	bf00      	nop
 8000d38:	20000800 	.word	0x20000800
 8000d3c:	080005d1 	.word	0x080005d1

08000d40 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8000d40:	b508      	push	{r3, lr}
 8000d42:	4601      	mov	r1, r0
 8000d44:	2320      	movs	r3, #32
 8000d46:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8000d4a:	2008      	movs	r0, #8
 8000d4c:	f7ff fe88 	bl	8000a60 <chSchGoSleepTimeoutS>
 8000d50:	2300      	movs	r3, #0
 8000d52:	f383 8811 	msr	BASEPRI, r3
 8000d56:	bd08      	pop	{r3, pc}
 8000d58:	f3af 8000 	nop.w
 8000d5c:	f3af 8000 	nop.w

08000d60 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8000d60:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
 8000d62:	4b0e      	ldr	r3, [pc, #56]	; (8000d9c <chThdExitS+0x3c>)
 8000d64:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8000d66:	6a63      	ldr	r3, [r4, #36]	; 0x24

  tp->p_u.exitcode = msg;
 8000d68:	6220      	str	r0, [r4, #32]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  while (list_notempty(&tp->p_waiting)) {
 8000d6a:	f104 0524 	add.w	r5, r4, #36	; 0x24
 8000d6e:	429d      	cmp	r5, r3
 8000d70:	d007      	beq.n	8000d82 <chThdExitS+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 8000d72:	681a      	ldr	r2, [r3, #0]
 8000d74:	6262      	str	r2, [r4, #36]	; 0x24
    chSchReadyI(list_remove(&tp->p_waiting));
 8000d76:	4618      	mov	r0, r3
 8000d78:	f7ff fe42 	bl	8000a00 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8000d7c:	6a63      	ldr	r3, [r4, #36]	; 0x24
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  while (list_notempty(&tp->p_waiting)) {
 8000d7e:	42ab      	cmp	r3, r5
 8000d80:	d1f7      	bne.n	8000d72 <chThdExitS+0x12>
  }
#endif
#if CH_CFG_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8000d82:	7f63      	ldrb	r3, [r4, #29]
 8000d84:	079b      	lsls	r3, r3, #30
 8000d86:	d104      	bne.n	8000d92 <chThdExitS+0x32>
    REG_REMOVE(tp);
 8000d88:	6963      	ldr	r3, [r4, #20]
 8000d8a:	6922      	ldr	r2, [r4, #16]
 8000d8c:	611a      	str	r2, [r3, #16]
 8000d8e:	6922      	ldr	r2, [r4, #16]
 8000d90:	6153      	str	r3, [r2, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8000d92:	200f      	movs	r0, #15

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 8000d94:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8000d98:	f7ff be4a 	b.w	8000a30 <chSchGoSleepS>
 8000d9c:	20000800 	.word	0x20000800

08000da0 <chThdExit>:
 8000da0:	2320      	movs	r3, #32
 8000da2:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
 8000da6:	f7ff bfdb 	b.w	8000d60 <chThdExitS>
 8000daa:	bf00      	nop
 8000dac:	f3af 8000 	nop.w

08000db0 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 8000db0:	b169      	cbz	r1, 8000dce <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000db2:	4b08      	ldr	r3, [pc, #32]	; (8000dd4 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8000db4:	b410      	push	{r4}
 8000db6:	4602      	mov	r2, r0
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8000db8:	6844      	ldr	r4, [r0, #4]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000dba:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000dbc:	2004      	movs	r0, #4
 8000dbe:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->p_prev->p_next = tqp->p_prev = tp;
 8000dc2:	6053      	str	r3, [r2, #4]
 8000dc4:	6023      	str	r3, [r4, #0]
}
 8000dc6:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000dca:	f7ff be49 	b.w	8000a60 <chSchGoSleepTimeoutS>
}
 8000dce:	f04f 30ff 	mov.w	r0, #4294967295
 8000dd2:	4770      	bx	lr
 8000dd4:	20000800 	.word	0x20000800
 8000dd8:	f3af 8000 	nop.w
 8000ddc:	f3af 8000 	nop.w

08000de0 <chThdDequeueNextI>:
 *
 * @notapi
 */
static inline bool queue_notempty(threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (thread_t *)tqp);
 8000de0:	6802      	ldr	r2, [r0, #0]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8000de2:	4290      	cmp	r0, r2
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8000de4:	4603      	mov	r3, r0

  if (queue_notempty(tqp)) {
 8000de6:	d009      	beq.n	8000dfc <chThdDequeueNextI+0x1c>
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8000de8:	b410      	push	{r4}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8000dea:	6814      	ldr	r4, [r2, #0]
 8000dec:	6004      	str	r4, [r0, #0]
 8000dee:	6063      	str	r3, [r4, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8000df0:	6211      	str	r1, [r2, #32]
  chSchReadyI(tp);
 8000df2:	4610      	mov	r0, r2

  if (queue_notempty(tqp)) {
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8000df4:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000df8:	f7ff be02 	b.w	8000a00 <chSchReadyI>
 8000dfc:	4770      	bx	lr
 8000dfe:	bf00      	nop

08000e00 <chSemObjectInit>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8000e00:	6040      	str	r0, [r0, #4]
 8000e02:	6000      	str	r0, [r0, #0]
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= 0));

  queue_init(&sp->s_queue);
  sp->s_cnt = n;
 8000e04:	6081      	str	r1, [r0, #8]
 8000e06:	4770      	bx	lr
 8000e08:	f3af 8000 	nop.w
 8000e0c:	f3af 8000 	nop.w

08000e10 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8000e10:	4603      	mov	r3, r0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= 0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
 8000e12:	6880      	ldr	r0, [r0, #8]
 8000e14:	1e42      	subs	r2, r0, #1
 8000e16:	2a00      	cmp	r2, #0
 8000e18:	609a      	str	r2, [r3, #8]
 8000e1a:	db01      	blt.n	8000e20 <chSemWaitTimeoutS+0x10>
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
 8000e1c:	2000      	movs	r0, #0
 8000e1e:	4770      	bx	lr
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8000e20:	b410      	push	{r4}
  chDbgAssert(((sp->s_cnt >= 0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
    if (TIME_IMMEDIATE == time) {
 8000e22:	b161      	cbz	r1, 8000e3e <chSemWaitTimeoutS+0x2e>
      sp->s_cnt++;

      return MSG_TIMEOUT;
    }
    currp->p_u.wtobjp = sp;
 8000e24:	4a09      	ldr	r2, [pc, #36]	; (8000e4c <chSemWaitTimeoutS+0x3c>)
 8000e26:	6992      	ldr	r2, [r2, #24]
 8000e28:	6213      	str	r3, [r2, #32]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8000e2a:	685c      	ldr	r4, [r3, #4]
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8000e2c:	2005      	movs	r0, #5
 8000e2e:	e882 0018 	stmia.w	r2, {r3, r4}
  tp->p_prev->p_next = tqp->p_prev = tp;
 8000e32:	605a      	str	r2, [r3, #4]
 8000e34:	6022      	str	r2, [r4, #0]
  }

  return MSG_OK;
}
 8000e36:	f85d 4b04 	ldr.w	r4, [sp], #4
      return MSG_TIMEOUT;
    }
    currp->p_u.wtobjp = sp;
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8000e3a:	f7ff be11 	b.w	8000a60 <chSchGoSleepTimeoutS>
              ((sp->s_cnt < 0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;
 8000e3e:	6098      	str	r0, [r3, #8]

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
}
 8000e40:	f85d 4b04 	ldr.w	r4, [sp], #4

  if (--sp->s_cnt < 0) {
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;

      return MSG_TIMEOUT;
 8000e44:	f04f 30ff 	mov.w	r0, #4294967295

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
}
 8000e48:	4770      	bx	lr
 8000e4a:	bf00      	nop
 8000e4c:	20000800 	.word	0x20000800

08000e50 <chSemSignalI>:
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= 0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= 0) {
 8000e50:	6883      	ldr	r3, [r0, #8]
 8000e52:	3301      	adds	r3, #1
 8000e54:	2b00      	cmp	r3, #0
 8000e56:	6083      	str	r3, [r0, #8]
 8000e58:	dd00      	ble.n	8000e5c <chSemSignalI+0xc>
 8000e5a:	4770      	bx	lr
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8000e5c:	6803      	ldr	r3, [r0, #0]

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8000e5e:	681a      	ldr	r2, [r3, #0]
 8000e60:	6002      	str	r2, [r0, #0]
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
 8000e62:	2100      	movs	r1, #0
 8000e64:	6050      	str	r0, [r2, #4]
    chSchReadyI(tp);
 8000e66:	4618      	mov	r0, r3

  if (++sp->s_cnt <= 0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
 8000e68:	6219      	str	r1, [r3, #32]
    chSchReadyI(tp);
 8000e6a:	f7ff bdc9 	b.w	8000a00 <chSchReadyI>
 8000e6e:	bf00      	nop

08000e70 <chMtxObjectInit>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 8000e70:	2300      	movs	r3, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8000e72:	6040      	str	r0, [r0, #4]
 8000e74:	6000      	str	r0, [r0, #0]
 8000e76:	6083      	str	r3, [r0, #8]
 8000e78:	4770      	bx	lr
 8000e7a:	bf00      	nop
 8000e7c:	f3af 8000 	nop.w

08000e80 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8000e80:	6b43      	ldr	r3, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000e82:	7f02      	ldrb	r2, [r0, #28]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8000e84:	4319      	orrs	r1, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000e86:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8000e88:	6341      	str	r1, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000e8a:	d00a      	beq.n	8000ea2 <chEvtSignalI+0x22>
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
 8000e8c:	2a0b      	cmp	r2, #11
 8000e8e:	d000      	beq.n	8000e92 <chEvtSignalI+0x12>
 8000e90:	4770      	bx	lr
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8000e92:	6a03      	ldr	r3, [r0, #32]
 8000e94:	4019      	ands	r1, r3

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8000e96:	428b      	cmp	r3, r1
 8000e98:	d1fa      	bne.n	8000e90 <chEvtSignalI+0x10>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8000e9a:	2300      	movs	r3, #0
 8000e9c:	6203      	str	r3, [r0, #32]
    chSchReadyI(tp);
 8000e9e:	f7ff bdaf 	b.w	8000a00 <chSchReadyI>
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
 8000ea2:	6a03      	ldr	r3, [r0, #32]
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000ea4:	4219      	tst	r1, r3
 8000ea6:	d1f8      	bne.n	8000e9a <chEvtSignalI+0x1a>
 8000ea8:	4770      	bx	lr
 8000eaa:	bf00      	nop
 8000eac:	f3af 8000 	nop.w

08000eb0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000eb0:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8000eb2:	6804      	ldr	r4, [r0, #0]
  while (elp != (event_listener_t *)esp) {
 8000eb4:	42a0      	cmp	r0, r4
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000eb6:	4606      	mov	r6, r0
 8000eb8:	460d      	mov	r5, r1

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  while (elp != (event_listener_t *)esp) {
 8000eba:	d00d      	beq.n	8000ed8 <chEvtBroadcastFlagsI+0x28>
    elp->el_flags |= flags;
 8000ebc:	68e3      	ldr	r3, [r4, #12]
 8000ebe:	432b      	orrs	r3, r5
 8000ec0:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == 0) || ((elp->el_flags & elp->el_wflags) != 0)) {
 8000ec2:	b115      	cbz	r5, 8000eca <chEvtBroadcastFlagsI+0x1a>
 8000ec4:	6922      	ldr	r2, [r4, #16]
 8000ec6:	4213      	tst	r3, r2
 8000ec8:	d003      	beq.n	8000ed2 <chEvtBroadcastFlagsI+0x22>
      chEvtSignalI(elp->el_listener, elp->el_events);
 8000eca:	6860      	ldr	r0, [r4, #4]
 8000ecc:	68a1      	ldr	r1, [r4, #8]
 8000ece:	f7ff ffd7 	bl	8000e80 <chEvtSignalI>
    }
    elp = elp->el_next;
 8000ed2:	6824      	ldr	r4, [r4, #0]

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  while (elp != (event_listener_t *)esp) {
 8000ed4:	42a6      	cmp	r6, r4
 8000ed6:	d1f1      	bne.n	8000ebc <chEvtBroadcastFlagsI+0xc>
 8000ed8:	bd70      	pop	{r4, r5, r6, pc}
 8000eda:	bf00      	nop
 8000edc:	f3af 8000 	nop.w

08000ee0 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
 8000ee0:	b510      	push	{r4, lr}
 8000ee2:	460b      	mov	r3, r1

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > 0));

  mbp->mb_buffer = mbp->mb_wrptr = mbp->mb_rdptr = buf;
  mbp->mb_top = &buf[n];
 8000ee4:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 8000ee8:	6041      	str	r1, [r0, #4]
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
 8000eea:	4604      	mov	r4, r0

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > 0));

  mbp->mb_buffer = mbp->mb_wrptr = mbp->mb_rdptr = buf;
 8000eec:	60c3      	str	r3, [r0, #12]
 8000eee:	6083      	str	r3, [r0, #8]
 8000ef0:	6003      	str	r3, [r0, #0]
  mbp->mb_top = &buf[n];
  chSemObjectInit(&mbp->mb_emptysem, n);
 8000ef2:	4611      	mov	r1, r2
 8000ef4:	301c      	adds	r0, #28
 8000ef6:	f7ff ff83 	bl	8000e00 <chSemObjectInit>
  chSemObjectInit(&mbp->mb_fullsem, 0);
 8000efa:	f104 0010 	add.w	r0, r4, #16
 8000efe:	2100      	movs	r1, #0
}
 8000f00:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > 0));

  mbp->mb_buffer = mbp->mb_wrptr = mbp->mb_rdptr = buf;
  mbp->mb_top = &buf[n];
  chSemObjectInit(&mbp->mb_emptysem, n);
  chSemObjectInit(&mbp->mb_fullsem, 0);
 8000f04:	f7ff bf7c 	b.w	8000e00 <chSemObjectInit>
 8000f08:	f3af 8000 	nop.w
 8000f0c:	f3af 8000 	nop.w

08000f10 <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t time) {
 8000f10:	b570      	push	{r4, r5, r6, lr}
 8000f12:	4604      	mov	r4, r0
 8000f14:	460e      	mov	r6, r1
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
 8000f16:	301c      	adds	r0, #28
 8000f18:	4611      	mov	r1, r2
 8000f1a:	f7ff ff79 	bl	8000e10 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 8000f1e:	4605      	mov	r5, r0
 8000f20:	b978      	cbnz	r0, 8000f42 <chMBPostS+0x32>
    *mbp->mb_wrptr++ = msg;
 8000f22:	68a2      	ldr	r2, [r4, #8]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 8000f24:	6861      	ldr	r1, [r4, #4]
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 8000f26:	1d13      	adds	r3, r2, #4
    if (mbp->mb_wrptr >= mbp->mb_top) {
 8000f28:	428b      	cmp	r3, r1
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 8000f2a:	60a3      	str	r3, [r4, #8]
    if (mbp->mb_wrptr >= mbp->mb_top) {
      mbp->mb_wrptr = mbp->mb_buffer;
 8000f2c:	bf28      	it	cs
 8000f2e:	6823      	ldrcs	r3, [r4, #0]
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 8000f30:	6016      	str	r6, [r2, #0]
    if (mbp->mb_wrptr >= mbp->mb_top) {
      mbp->mb_wrptr = mbp->mb_buffer;
    }
    chSemSignalI(&mbp->mb_fullsem);
 8000f32:	f104 0010 	add.w	r0, r4, #16

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
    if (mbp->mb_wrptr >= mbp->mb_top) {
      mbp->mb_wrptr = mbp->mb_buffer;
 8000f36:	bf28      	it	cs
 8000f38:	60a3      	strcs	r3, [r4, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
 8000f3a:	f7ff ff89 	bl	8000e50 <chSemSignalI>
    chSchRescheduleS();
 8000f3e:	f7ff fe17 	bl	8000b70 <chSchRescheduleS>
  }

  return rdymsg;
}
 8000f42:	4628      	mov	r0, r5
 8000f44:	bd70      	pop	{r4, r5, r6, pc}
 8000f46:	bf00      	nop
 8000f48:	f3af 8000 	nop.w
 8000f4c:	f3af 8000 	nop.w

08000f50 <chMBPost>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t time) {
 8000f50:	b508      	push	{r3, lr}
 8000f52:	2320      	movs	r3, #32
 8000f54:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chSysLock();
  rdymsg = chMBPostS(mbp, msg, time);
 8000f58:	f7ff ffda 	bl	8000f10 <chMBPostS>
 8000f5c:	2300      	movs	r3, #0
 8000f5e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return rdymsg;
}
 8000f62:	bd08      	pop	{r3, pc}
 8000f64:	f3af 8000 	nop.w
 8000f68:	f3af 8000 	nop.w
 8000f6c:	f3af 8000 	nop.w

08000f70 <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8000f70:	b538      	push	{r3, r4, r5, lr}
 8000f72:	6a43      	ldr	r3, [r0, #36]	; 0x24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0) {
 8000f74:	2b00      	cmp	r3, #0
 8000f76:	dd12      	ble.n	8000f9e <chMBPostI+0x2e>
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 8000f78:	6884      	ldr	r4, [r0, #8]
  if (mbp->mb_wrptr >= mbp->mb_top) {
 8000f7a:	6845      	ldr	r5, [r0, #4]
  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 8000f7c:	1d22      	adds	r2, r4, #4
 */
static inline void chSemFastWaitI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt--;
 8000f7e:	3b01      	subs	r3, #1
  if (mbp->mb_wrptr >= mbp->mb_top) {
 8000f80:	42aa      	cmp	r2, r5
 8000f82:	6243      	str	r3, [r0, #36]	; 0x24
    mbp->mb_wrptr = mbp->mb_buffer;
 8000f84:	bf28      	it	cs
 8000f86:	6803      	ldrcs	r3, [r0, #0]
  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 8000f88:	6082      	str	r2, [r0, #8]
 8000f8a:	6021      	str	r1, [r4, #0]
  if (mbp->mb_wrptr >= mbp->mb_top) {
    mbp->mb_wrptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_fullsem);
 8000f8c:	f100 0010 	add.w	r0, r0, #16
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
  if (mbp->mb_wrptr >= mbp->mb_top) {
    mbp->mb_wrptr = mbp->mb_buffer;
 8000f90:	bf28      	it	cs
 8000f92:	f840 3c08 	strcs.w	r3, [r0, #-8]
  }
  chSemSignalI(&mbp->mb_fullsem);
 8000f96:	f7ff ff5b 	bl	8000e50 <chSemSignalI>

  return MSG_OK;
 8000f9a:	2000      	movs	r0, #0
 8000f9c:	bd38      	pop	{r3, r4, r5, pc}

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0) {
    return MSG_TIMEOUT;
 8000f9e:	f04f 30ff 	mov.w	r0, #4294967295
    mbp->mb_wrptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_fullsem);

  return MSG_OK;
}
 8000fa2:	bd38      	pop	{r3, r4, r5, pc}
 8000fa4:	f3af 8000 	nop.w
 8000fa8:	f3af 8000 	nop.w
 8000fac:	f3af 8000 	nop.w

08000fb0 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t time) {
 8000fb0:	b570      	push	{r4, r5, r6, lr}
 8000fb2:	4604      	mov	r4, r0
 8000fb4:	460e      	mov	r6, r1
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, time);
 8000fb6:	3010      	adds	r0, #16
 8000fb8:	4611      	mov	r1, r2
 8000fba:	f7ff ff29 	bl	8000e10 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 8000fbe:	4605      	mov	r5, r0
 8000fc0:	b980      	cbnz	r0, 8000fe4 <chMBFetchS+0x34>
    *msgp = *mbp->mb_rdptr++;
 8000fc2:	68e3      	ldr	r3, [r4, #12]
    if (mbp->mb_rdptr >= mbp->mb_top) {
 8000fc4:	6862      	ldr	r2, [r4, #4]
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, time);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
 8000fc6:	6819      	ldr	r1, [r3, #0]
 8000fc8:	3304      	adds	r3, #4
    if (mbp->mb_rdptr >= mbp->mb_top) {
 8000fca:	4293      	cmp	r3, r2
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, time);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
 8000fcc:	60e3      	str	r3, [r4, #12]
    if (mbp->mb_rdptr >= mbp->mb_top) {
      mbp->mb_rdptr = mbp->mb_buffer;
 8000fce:	bf28      	it	cs
 8000fd0:	6823      	ldrcs	r3, [r4, #0]
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, time);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
 8000fd2:	6031      	str	r1, [r6, #0]
    if (mbp->mb_rdptr >= mbp->mb_top) {
      mbp->mb_rdptr = mbp->mb_buffer;
    }
    chSemSignalI(&mbp->mb_emptysem);
 8000fd4:	f104 001c 	add.w	r0, r4, #28

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, time);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
    if (mbp->mb_rdptr >= mbp->mb_top) {
      mbp->mb_rdptr = mbp->mb_buffer;
 8000fd8:	bf28      	it	cs
 8000fda:	60e3      	strcs	r3, [r4, #12]
    }
    chSemSignalI(&mbp->mb_emptysem);
 8000fdc:	f7ff ff38 	bl	8000e50 <chSemSignalI>
    chSchRescheduleS();
 8000fe0:	f7ff fdc6 	bl	8000b70 <chSchRescheduleS>
  }

  return rdymsg;
}
 8000fe4:	4628      	mov	r0, r5
 8000fe6:	bd70      	pop	{r4, r5, r6, pc}
 8000fe8:	f3af 8000 	nop.w
 8000fec:	f3af 8000 	nop.w

08000ff0 <chMBFetch>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t time) {
 8000ff0:	b508      	push	{r3, lr}
 8000ff2:	2320      	movs	r3, #32
 8000ff4:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chSysLock();
  rdymsg = chMBFetchS(mbp, msgp, time);
 8000ff8:	f7ff ffda 	bl	8000fb0 <chMBFetchS>
 8000ffc:	2300      	movs	r3, #0
 8000ffe:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return rdymsg;
}
 8001002:	bd08      	pop	{r3, pc}
 8001004:	f3af 8000 	nop.w
 8001008:	f3af 8000 	nop.w
 800100c:	f3af 8000 	nop.w

08001010 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 8001010:	b430      	push	{r4, r5}
 8001012:	9c02      	ldr	r4, [sp, #8]
  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
  iqp->q_top = bp + size;
  iqp->q_notify = infy;
  iqp->q_link = link;
 8001014:	6204      	str	r4, [r0, #32]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8001016:	2500      	movs	r5, #0
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
  iqp->q_top = bp + size;
 8001018:	440a      	add	r2, r1
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 800101a:	6085      	str	r5, [r0, #8]
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
  iqp->q_top = bp + size;
 800101c:	6102      	str	r2, [r0, #16]
 800101e:	6040      	str	r0, [r0, #4]
 8001020:	6000      	str	r0, [r0, #0]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
 8001022:	6141      	str	r1, [r0, #20]
 8001024:	6181      	str	r1, [r0, #24]
 8001026:	60c1      	str	r1, [r0, #12]
  iqp->q_top = bp + size;
  iqp->q_notify = infy;
 8001028:	61c3      	str	r3, [r0, #28]
  iqp->q_link = link;
}
 800102a:	bc30      	pop	{r4, r5}
 800102c:	4770      	bx	lr
 800102e:	bf00      	nop

08001030 <chIQPutI>:
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0));
 8001030:	6983      	ldr	r3, [r0, #24]
 8001032:	6942      	ldr	r2, [r0, #20]
 8001034:	429a      	cmp	r2, r3
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 8001036:	b510      	push	{r4, lr}
 8001038:	6883      	ldr	r3, [r0, #8]
 800103a:	d00f      	beq.n	800105c <chIQPutI+0x2c>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 800103c:	3301      	adds	r3, #1
  *iqp->q_wrptr++ = b;
 800103e:	1c54      	adds	r4, r2, #1

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8001040:	6083      	str	r3, [r0, #8]
  *iqp->q_wrptr++ = b;
 8001042:	6144      	str	r4, [r0, #20]
 8001044:	7011      	strb	r1, [r2, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8001046:	6942      	ldr	r2, [r0, #20]
 8001048:	6903      	ldr	r3, [r0, #16]
 800104a:	429a      	cmp	r2, r3
 800104c:	d301      	bcc.n	8001052 <chIQPutI+0x22>
    iqp->q_wrptr = iqp->q_buffer;
 800104e:	68c3      	ldr	r3, [r0, #12]
 8001050:	6143      	str	r3, [r0, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 8001052:	2100      	movs	r1, #0
 8001054:	f7ff fec4 	bl	8000de0 <chThdDequeueNextI>

  return Q_OK;
 8001058:	2000      	movs	r0, #0
 800105a:	bd10      	pop	{r4, pc}
 800105c:	2b00      	cmp	r3, #0
 800105e:	d0ed      	beq.n	800103c <chIQPutI+0xc>
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
 8001060:	f06f 0003 	mvn.w	r0, #3
 8001064:	bd10      	pop	{r4, pc}
 8001066:	bf00      	nop
 8001068:	f3af 8000 	nop.w
 800106c:	f3af 8000 	nop.w

08001070 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t time) {
 8001070:	b570      	push	{r4, r5, r6, lr}
 8001072:	2320      	movs	r3, #32
 8001074:	460e      	mov	r6, r1
 8001076:	4604      	mov	r4, r0
 8001078:	f383 8811 	msr	BASEPRI, r3
  uint8_t b;

  chSysLock();
  if (iqp->q_notify) {
 800107c:	69c3      	ldr	r3, [r0, #28]
 800107e:	b12b      	cbz	r3, 800108c <chIQGetTimeout+0x1c>
    iqp->q_notify(iqp);
 8001080:	4798      	blx	r3
 8001082:	e003      	b.n	800108c <chIQGetTimeout+0x1c>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg;
    if ((msg = chThdEnqueueTimeoutS(&iqp->q_waiting, time)) < Q_OK) {
 8001084:	f7ff fe94 	bl	8000db0 <chThdEnqueueTimeoutS>
 8001088:	2800      	cmp	r0, #0
 800108a:	db15      	blt.n	80010b8 <chIQGetTimeout+0x48>
 800108c:	68a5      	ldr	r5, [r4, #8]
 800108e:	4620      	mov	r0, r4
 8001090:	4631      	mov	r1, r6
  chSysLock();
  if (iqp->q_notify) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 8001092:	2d00      	cmp	r5, #0
 8001094:	d0f6      	beq.n	8001084 <chIQGetTimeout+0x14>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8001096:	69a2      	ldr	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
 8001098:	6921      	ldr	r1, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800109a:	1c53      	adds	r3, r2, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 800109c:	428b      	cmp	r3, r1
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 800109e:	f105 35ff 	add.w	r5, r5, #4294967295
  b = *iqp->q_rdptr++;
 80010a2:	61a3      	str	r3, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 80010a4:	60a5      	str	r5, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 80010a6:	bf28      	it	cs
 80010a8:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 80010aa:	7810      	ldrb	r0, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 80010ac:	bf28      	it	cs
 80010ae:	61a3      	strcs	r3, [r4, #24]
 80010b0:	2300      	movs	r3, #0
 80010b2:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return b;
}
 80010b6:	bd70      	pop	{r4, r5, r6, pc}
 80010b8:	f385 8811 	msr	BASEPRI, r5

  while (chIQIsEmptyI(iqp)) {
    msg_t msg;
    if ((msg = chThdEnqueueTimeoutS(&iqp->q_waiting, time)) < Q_OK) {
      chSysUnlock();
      return msg;
 80010bc:	bd70      	pop	{r4, r5, r6, pc}
 80010be:	bf00      	nop

080010c0 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t time) {
 80010c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80010c4:	4604      	mov	r4, r0
 80010c6:	b083      	sub	sp, #12
 80010c8:	4689      	mov	r9, r1
 80010ca:	4693      	mov	fp, r2
 80010cc:	461d      	mov	r5, r3
  qnotify_t nfy = iqp->q_notify;
 80010ce:	f8d0 801c 	ldr.w	r8, [r0, #28]
 80010d2:	2720      	movs	r7, #32
 80010d4:	f387 8811 	msr	BASEPRI, r7
  size_t r = 0;
 80010d8:	2600      	movs	r6, #0
 80010da:	9701      	str	r7, [sp, #4]
 80010dc:	46b2      	mov	sl, r6

  chDbgCheck(n > 0);

  chSysLock();
  while (true) {
    if (nfy) {
 80010de:	f1b8 0f00 	cmp.w	r8, #0
 80010e2:	d005      	beq.n	80010f0 <chIQReadTimeout+0x30>
      nfy(iqp);
 80010e4:	4620      	mov	r0, r4
 80010e6:	47c0      	blx	r8
 80010e8:	e002      	b.n	80010f0 <chIQReadTimeout+0x30>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, time) != Q_OK) {
 80010ea:	f7ff fe61 	bl	8000db0 <chThdEnqueueTimeoutS>
 80010ee:	b9d8      	cbnz	r0, 8001128 <chIQReadTimeout+0x68>
 80010f0:	68a7      	ldr	r7, [r4, #8]
 80010f2:	4620      	mov	r0, r4
 80010f4:	4629      	mov	r1, r5
  while (true) {
    if (nfy) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 80010f6:	2f00      	cmp	r7, #0
 80010f8:	d0f7      	beq.n	80010ea <chIQReadTimeout+0x2a>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 80010fa:	69a2      	ldr	r2, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 80010fc:	1e7b      	subs	r3, r7, #1
    *bp++ = *iqp->q_rdptr++;
 80010fe:	1c51      	adds	r1, r2, #1
 8001100:	61a1      	str	r1, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8001102:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8001104:	7813      	ldrb	r3, [r2, #0]
 8001106:	f809 3b01 	strb.w	r3, [r9], #1
    if (iqp->q_rdptr >= iqp->q_top)
 800110a:	6923      	ldr	r3, [r4, #16]
 800110c:	69a2      	ldr	r2, [r4, #24]
 800110e:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 8001110:	bf24      	itt	cs
 8001112:	68e3      	ldrcs	r3, [r4, #12]
 8001114:	61a3      	strcs	r3, [r4, #24]
 8001116:	f38a 8811 	msr	BASEPRI, sl

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    r++;
 800111a:	3601      	adds	r6, #1
    if (--n == 0) {
 800111c:	45b3      	cmp	fp, r6
 800111e:	d005      	beq.n	800112c <chIQReadTimeout+0x6c>
 8001120:	9b01      	ldr	r3, [sp, #4]
 8001122:	f383 8811 	msr	BASEPRI, r3
 8001126:	e7da      	b.n	80010de <chIQReadTimeout+0x1e>
 8001128:	f387 8811 	msr	BASEPRI, r7
      return r;
    }

    chSysLock();
  }
}
 800112c:	4630      	mov	r0, r6
 800112e:	b003      	add	sp, #12
 8001130:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001134:	f3af 8000 	nop.w
 8001138:	f3af 8000 	nop.w
 800113c:	f3af 8000 	nop.w

08001140 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 8001140:	b430      	push	{r4, r5}
 8001142:	9c02      	ldr	r4, [sp, #8]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
  oqp->q_top = bp + size;
  oqp->q_notify = onfy;
  oqp->q_link = link;
 8001144:	6204      	str	r4, [r0, #32]
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
  oqp->q_top = bp + size;
 8001146:	188d      	adds	r5, r1, r2
 8001148:	6105      	str	r5, [r0, #16]
 800114a:	6040      	str	r0, [r0, #4]
 800114c:	6000      	str	r0, [r0, #0]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 800114e:	6082      	str	r2, [r0, #8]
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
 8001150:	6141      	str	r1, [r0, #20]
 8001152:	6181      	str	r1, [r0, #24]
 8001154:	60c1      	str	r1, [r0, #12]
  oqp->q_top = bp + size;
  oqp->q_notify = onfy;
 8001156:	61c3      	str	r3, [r0, #28]
  oqp->q_link = link;
}
 8001158:	bc30      	pop	{r4, r5}
 800115a:	4770      	bx	lr
 800115c:	f3af 8000 	nop.w

08001160 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t time) {
 8001160:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001162:	4604      	mov	r4, r0
 8001164:	460f      	mov	r7, r1
 8001166:	4616      	mov	r6, r2
 8001168:	2320      	movs	r3, #32
 800116a:	f383 8811 	msr	BASEPRI, r3
 800116e:	e003      	b.n	8001178 <chOQPutTimeout+0x18>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg;

    if ((msg = chThdEnqueueTimeoutS(&oqp->q_waiting, time)) < Q_OK) {
 8001170:	f7ff fe1e 	bl	8000db0 <chThdEnqueueTimeoutS>
 8001174:	2800      	cmp	r0, #0
 8001176:	db18      	blt.n	80011aa <chOQPutTimeout+0x4a>
 8001178:	68a5      	ldr	r5, [r4, #8]
 800117a:	4620      	mov	r0, r4
 800117c:	4631      	mov	r1, r6
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t time) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 800117e:	2d00      	cmp	r5, #0
 8001180:	d0f6      	beq.n	8001170 <chOQPutTimeout+0x10>
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8001182:	6963      	ldr	r3, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8001184:	3d01      	subs	r5, #1
  *oqp->q_wrptr++ = b;
 8001186:	1c5a      	adds	r2, r3, #1
 8001188:	6162      	str	r2, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 800118a:	60a5      	str	r5, [r4, #8]
  *oqp->q_wrptr++ = b;
 800118c:	701f      	strb	r7, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 800118e:	6923      	ldr	r3, [r4, #16]
 8001190:	6962      	ldr	r2, [r4, #20]
 8001192:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8001194:	bf24      	itt	cs
 8001196:	68e3      	ldrcs	r3, [r4, #12]
 8001198:	6163      	strcs	r3, [r4, #20]
  }

  if (oqp->q_notify) {
 800119a:	69e3      	ldr	r3, [r4, #28]
 800119c:	b10b      	cbz	r3, 80011a2 <chOQPutTimeout+0x42>
    oqp->q_notify(oqp);
 800119e:	4620      	mov	r0, r4
 80011a0:	4798      	blx	r3
 80011a2:	2000      	movs	r0, #0
 80011a4:	f380 8811 	msr	BASEPRI, r0
  }
  chSysUnlock();

  return Q_OK;
}
 80011a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80011aa:	f385 8811 	msr	BASEPRI, r5
  while (chOQIsFullI(oqp)) {
    msg_t msg;

    if ((msg = chThdEnqueueTimeoutS(&oqp->q_waiting, time)) < Q_OK) {
      chSysUnlock();
      return msg;
 80011ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080011b0 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 80011b0:	b538      	push	{r3, r4, r5, lr}
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0));
 80011b2:	6982      	ldr	r2, [r0, #24]
 80011b4:	6943      	ldr	r3, [r0, #20]
 80011b6:	4293      	cmp	r3, r2
 80011b8:	6883      	ldr	r3, [r0, #8]
 80011ba:	d00e      	beq.n	80011da <chOQGetI+0x2a>
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 80011bc:	6905      	ldr	r5, [r0, #16]
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 80011be:	1c51      	adds	r1, r2, #1

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 80011c0:	3301      	adds	r3, #1
 80011c2:	6083      	str	r3, [r0, #8]
  b = *oqp->q_rdptr++;
 80011c4:	6181      	str	r1, [r0, #24]
  if (oqp->q_rdptr >= oqp->q_top) {
 80011c6:	42a9      	cmp	r1, r5
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 80011c8:	7814      	ldrb	r4, [r2, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 80011ca:	d301      	bcc.n	80011d0 <chOQGetI+0x20>
    oqp->q_rdptr = oqp->q_buffer;
 80011cc:	68c3      	ldr	r3, [r0, #12]
 80011ce:	6183      	str	r3, [r0, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 80011d0:	2100      	movs	r1, #0
 80011d2:	f7ff fe05 	bl	8000de0 <chThdDequeueNextI>

  return b;
 80011d6:	4620      	mov	r0, r4
 80011d8:	bd38      	pop	{r3, r4, r5, pc}
 80011da:	2b00      	cmp	r3, #0
 80011dc:	d0ee      	beq.n	80011bc <chOQGetI+0xc>
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
 80011de:	f06f 0002 	mvn.w	r0, #2
 80011e2:	bd38      	pop	{r3, r4, r5, pc}
 80011e4:	f3af 8000 	nop.w
 80011e8:	f3af 8000 	nop.w
 80011ec:	f3af 8000 	nop.w

080011f0 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t time) {
 80011f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80011f4:	b083      	sub	sp, #12
 80011f6:	4604      	mov	r4, r0
 80011f8:	468b      	mov	fp, r1
 80011fa:	4616      	mov	r6, r2
 80011fc:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 80011fe:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8001202:	f04f 0920 	mov.w	r9, #32
 8001206:	f389 8811 	msr	BASEPRI, r9
  size_t w = 0;
 800120a:	2700      	movs	r7, #0
 800120c:	f8cd 9000 	str.w	r9, [sp]
 8001210:	46ba      	mov	sl, r7
 8001212:	68a5      	ldr	r5, [r4, #8]
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8001214:	f10b 0901 	add.w	r9, fp, #1
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 8001218:	1e6a      	subs	r2, r5, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy) {
      nfy(oqp);
 800121a:	4620      	mov	r0, r4

  chDbgCheck(n > 0);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 800121c:	b30d      	cbz	r5, 8001262 <chOQWriteTimeout+0x72>
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 800121e:	6963      	ldr	r3, [r4, #20]
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 8001220:	60a2      	str	r2, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8001222:	1c5a      	adds	r2, r3, #1
 8001224:	6162      	str	r2, [r4, #20]
 8001226:	f89b 2000 	ldrb.w	r2, [fp]
 800122a:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 800122c:	6923      	ldr	r3, [r4, #16]
 800122e:	6962      	ldr	r2, [r4, #20]
 8001230:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 8001232:	bf24      	itt	cs
 8001234:	68e3      	ldrcs	r3, [r4, #12]
 8001236:	6163      	strcs	r3, [r4, #20]
    }

    if (nfy) {
 8001238:	f1b8 0f00 	cmp.w	r8, #0
 800123c:	d000      	beq.n	8001240 <chOQWriteTimeout+0x50>
      nfy(oqp);
 800123e:	47c0      	blx	r8
 8001240:	f38a 8811 	msr	BASEPRI, sl
    }

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    w++;
    if (--n == 0) {
 8001244:	3e01      	subs	r6, #1
    if (nfy) {
      nfy(oqp);
    }

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    w++;
 8001246:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0) {
 800124a:	d012      	beq.n	8001272 <chOQWriteTimeout+0x82>
 800124c:	9b00      	ldr	r3, [sp, #0]
 800124e:	f383 8811 	msr	BASEPRI, r3
 8001252:	68a5      	ldr	r5, [r4, #8]
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8001254:	46cb      	mov	fp, r9
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 8001256:	1e6a      	subs	r2, r5, #1
    *oqp->q_wrptr++ = *bp++;
 8001258:	f10b 0901 	add.w	r9, fp, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy) {
      nfy(oqp);
 800125c:	4620      	mov	r0, r4

  chDbgCheck(n > 0);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 800125e:	2d00      	cmp	r5, #0
 8001260:	d1dd      	bne.n	800121e <chOQWriteTimeout+0x2e>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
 8001262:	4620      	mov	r0, r4
 8001264:	9901      	ldr	r1, [sp, #4]
 8001266:	f7ff fda3 	bl	8000db0 <chThdEnqueueTimeoutS>
 800126a:	2800      	cmp	r0, #0
 800126c:	d0d1      	beq.n	8001212 <chOQWriteTimeout+0x22>
 800126e:	f385 8811 	msr	BASEPRI, r5
    if (--n == 0) {
      return w;
    }
    chSysLock();
  }
}
 8001272:	4638      	mov	r0, r7
 8001274:	b003      	add	sp, #12
 8001276:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800127a:	bf00      	nop
 800127c:	f3af 8000 	nop.w

08001280 <_core_init>:
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001280:	4a05      	ldr	r2, [pc, #20]	; (8001298 <_core_init+0x18>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001282:	4b06      	ldr	r3, [pc, #24]	; (800129c <_core_init+0x1c>)
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001284:	4806      	ldr	r0, [pc, #24]	; (80012a0 <_core_init+0x20>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001286:	4907      	ldr	r1, [pc, #28]	; (80012a4 <_core_init+0x24>)
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001288:	f022 0207 	bic.w	r2, r2, #7
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800128c:	f023 0307 	bic.w	r3, r3, #7
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001290:	6002      	str	r2, [r0, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001292:	600b      	str	r3, [r1, #0]
 8001294:	4770      	bx	lr
 8001296:	bf00      	nop
 8001298:	2000102b 	.word	0x2000102b
 800129c:	2001c000 	.word	0x2001c000
 80012a0:	20000954 	.word	0x20000954
 80012a4:	20000950 	.word	0x20000950
 80012a8:	f3af 8000 	nop.w
 80012ac:	f3af 8000 	nop.w

080012b0 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 80012b0:	b410      	push	{r4}
 80012b2:	2320      	movs	r3, #32
 80012b4:	f383 8811 	msr	BASEPRI, r3
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  if ((size_t)(endmem - nextmem) < size) {
 80012b8:	4c09      	ldr	r4, [pc, #36]	; (80012e0 <chCoreAlloc+0x30>)
 80012ba:	4b0a      	ldr	r3, [pc, #40]	; (80012e4 <chCoreAlloc+0x34>)
 80012bc:	6822      	ldr	r2, [r4, #0]
 80012be:	6819      	ldr	r1, [r3, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 80012c0:	1dc3      	adds	r3, r0, #7
 80012c2:	f023 0307 	bic.w	r3, r3, #7
  if ((size_t)(endmem - nextmem) < size) {
 80012c6:	1a89      	subs	r1, r1, r2
 80012c8:	428b      	cmp	r3, r1
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 80012ca:	bf9d      	ittte	ls
 80012cc:	189b      	addls	r3, r3, r2
 80012ce:	6023      	strls	r3, [r4, #0]

  return p;
 80012d0:	4610      	movls	r0, r2

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  if ((size_t)(endmem - nextmem) < size) {
    return NULL;
 80012d2:	2000      	movhi	r0, #0
 80012d4:	2300      	movs	r3, #0
 80012d6:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 80012da:	f85d 4b04 	ldr.w	r4, [sp], #4
 80012de:	4770      	bx	lr
 80012e0:	20000954 	.word	0x20000954
 80012e4:	20000950 	.word	0x20000950
 80012e8:	f3af 8000 	nop.w
 80012ec:	f3af 8000 	nop.w

080012f0 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 80012f0:	4b04      	ldr	r3, [pc, #16]	; (8001304 <_heap_init+0x14>)
 80012f2:	4a05      	ldr	r2, [pc, #20]	; (8001308 <_heap_init+0x18>)
 80012f4:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = (union heap_header *)NULL;
  default_heap.h_free.h.size = 0;
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 80012f6:	f103 0010 	add.w	r0, r3, #16
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
  default_heap.h_free.h.u.next = (union heap_header *)NULL;
 80012fa:	2200      	movs	r2, #0
 80012fc:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 80012fe:	60da      	str	r2, [r3, #12]
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8001300:	f7ff bdb6 	b.w	8000e70 <chMtxObjectInit>
 8001304:	20000958 	.word	0x20000958
 8001308:	080012b1 	.word	0x080012b1
 800130c:	f3af 8000 	nop.w

08001310 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8001310:	b40e      	push	{r1, r2, r3}
 8001312:	b500      	push	{lr}
 8001314:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8001316:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 8001318:	461a      	mov	r2, r3
 800131a:	4905      	ldr	r1, [pc, #20]	; (8001330 <chprintf.constprop.0+0x20>)
 800131c:	4805      	ldr	r0, [pc, #20]	; (8001334 <chprintf.constprop.0+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800131e:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8001320:	f000 fcfe 	bl	8001d20 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8001324:	b002      	add	sp, #8
 8001326:	f85d eb04 	ldr.w	lr, [sp], #4
 800132a:	b003      	add	sp, #12
 800132c:	4770      	bx	lr
 800132e:	bf00      	nop
 8001330:	08002350 	.word	0x08002350
 8001334:	20000f38 	.word	0x20000f38
 8001338:	f3af 8000 	nop.w
 800133c:	f3af 8000 	nop.w

08001340 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8001340:	b538      	push	{r3, r4, r5, lr}
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
  
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "hal_lld_init");
 8001342:	4d0d      	ldr	r5, [pc, #52]	; (8001378 <halInit+0x38>)
 8001344:	4c0d      	ldr	r4, [pc, #52]	; (800137c <halInit+0x3c>)

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 8001346:	f000 f93b 	bl	80015c0 <hal_lld_init>
  
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "hal_lld_init");
 800134a:	4621      	mov	r1, r4
 800134c:	4a0c      	ldr	r2, [pc, #48]	; (8001380 <halInit+0x40>)
 800134e:	4628      	mov	r0, r5
 8001350:	f7ff ffde 	bl	8001310 <chprintf.constprop.0>

#if HAL_USE_PAL || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8001354:	480b      	ldr	r0, [pc, #44]	; (8001384 <halInit+0x44>)
 8001356:	f000 f9d3 	bl	8001700 <_pal_lld_init>
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "palInit");
 800135a:	4621      	mov	r1, r4
 800135c:	4a0a      	ldr	r2, [pc, #40]	; (8001388 <halInit+0x48>)
 800135e:	4628      	mov	r0, r5
 8001360:	f7ff ffd6 	bl	8001310 <chprintf.constprop.0>
#endif
#if HAL_USE_EXT || defined(__DOXYGEN__)
  extInit();
#endif
#if HAL_USE_GPT || defined(__DOXYGEN__)
  gptInit();
 8001364:	f000 f814 	bl	8001390 <gptInit>
#endif
#if HAL_USE_PWM || defined(__DOXYGEN__)
  pwmInit();
#endif
#if HAL_USE_SERIAL || defined(__DOXYGEN__)
  sdInit();
 8001368:	f000 f892 	bl	8001490 <sdInit>
#if HAL_USE_COMMUNITY || defined(__DOXYGEN__)
  halCommunityInit();
#endif

  /* Board specific initialization.*/
  boardInit();
 800136c:	f000 fca8 	bl	8001cc0 <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
 8001370:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8001374:	f000 b8e4 	b.w	8001540 <stInit>
 8001378:	20000f38 	.word	0x20000f38
 800137c:	08002350 	.word	0x08002350
 8001380:	08002354 	.word	0x08002354
 8001384:	080023a0 	.word	0x080023a0
 8001388:	08002364 	.word	0x08002364
 800138c:	f3af 8000 	nop.w

08001390 <gptInit>:
 *
 * @init
 */
void gptInit(void) {

  gpt_lld_init();
 8001390:	f000 bad6 	b.w	8001940 <gpt_lld_init>
 8001394:	f3af 8000 	nop.w
 8001398:	f3af 8000 	nop.w
 800139c:	f3af 8000 	nop.w

080013a0 <gptObjectInit>:
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {

  gptp->state  = GPT_STOP;
 80013a0:	2201      	movs	r2, #1
  gptp->config = NULL;
 80013a2:	2300      	movs	r3, #0
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {

  gptp->state  = GPT_STOP;
 80013a4:	7002      	strb	r2, [r0, #0]
  gptp->config = NULL;
 80013a6:	6043      	str	r3, [r0, #4]
 80013a8:	4770      	bx	lr
 80013aa:	bf00      	nop
 80013ac:	f3af 8000 	nop.w

080013b0 <gptStart>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] config    pointer to the @p GPTConfig object
 *
 * @api
 */
void gptStart(GPTDriver *gptp, const GPTConfig *config) {
 80013b0:	b510      	push	{r4, lr}
 80013b2:	2320      	movs	r3, #32
 80013b4:	4604      	mov	r4, r0
 80013b6:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck((gptp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
              "invalid state");
  gptp->config = config;
 80013ba:	6041      	str	r1, [r0, #4]
  gpt_lld_start(gptp);
 80013bc:	f000 fad8 	bl	8001970 <gpt_lld_start>
  gptp->state = GPT_READY;
 80013c0:	2302      	movs	r3, #2
 80013c2:	7023      	strb	r3, [r4, #0]
 80013c4:	2300      	movs	r3, #0
 80013c6:	f383 8811 	msr	BASEPRI, r3
 80013ca:	bd10      	pop	{r4, pc}
 80013cc:	f3af 8000 	nop.w

080013d0 <gptStartContinuous>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @api
 */
void gptStartContinuous(GPTDriver *gptp, gptcnt_t interval) {
 80013d0:	b508      	push	{r3, lr}
 80013d2:	2220      	movs	r2, #32
 80013d4:	f382 8811 	msr	BASEPRI, r2
  osalDbgCheckClassI();
  osalDbgCheck(gptp != NULL);
  osalDbgAssert(gptp->state == GPT_READY,
                "invalid state");

  gptp->state = GPT_CONTINUOUS;
 80013d8:	2203      	movs	r2, #3
 80013da:	7002      	strb	r2, [r0, #0]
  gpt_lld_start_timer(gptp, interval);
 80013dc:	f000 fb18 	bl	8001a10 <gpt_lld_start_timer>
 80013e0:	2300      	movs	r3, #0
 80013e2:	f383 8811 	msr	BASEPRI, r3
 80013e6:	bd08      	pop	{r3, pc}
 80013e8:	f3af 8000 	nop.w
 80013ec:	f3af 8000 	nop.w

080013f0 <gptStopTimer>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimer(GPTDriver *gptp) {
 80013f0:	b508      	push	{r3, lr}
 80013f2:	2220      	movs	r2, #32
 80013f4:	f382 8811 	msr	BASEPRI, r2
  osalDbgCheck(gptp != NULL);
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
                (gptp->state == GPT_ONESHOT),
                "invalid state");

  gptp->state = GPT_READY;
 80013f8:	2202      	movs	r2, #2
 80013fa:	7002      	strb	r2, [r0, #0]
  gpt_lld_stop_timer(gptp);
 80013fc:	f000 fb20 	bl	8001a40 <gpt_lld_stop_timer>
 8001400:	2300      	movs	r3, #0
 8001402:	f383 8811 	msr	BASEPRI, r3
 8001406:	bd08      	pop	{r3, pc}
 8001408:	f3af 8000 	nop.w
 800140c:	f3af 8000 	nop.w

08001410 <readt>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t time) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, time);
 8001410:	300c      	adds	r0, #12
 8001412:	f7ff be55 	b.w	80010c0 <chIQReadTimeout>
 8001416:	bf00      	nop
 8001418:	f3af 8000 	nop.w
 800141c:	f3af 8000 	nop.w

08001420 <read>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8001420:	300c      	adds	r0, #12
 8001422:	f04f 33ff 	mov.w	r3, #4294967295
 8001426:	f7ff be4b 	b.w	80010c0 <chIQReadTimeout>
 800142a:	bf00      	nop
 800142c:	f3af 8000 	nop.w

08001430 <writet>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t time) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
 8001430:	3030      	adds	r0, #48	; 0x30
 8001432:	f7ff bedd 	b.w	80011f0 <chOQWriteTimeout>
 8001436:	bf00      	nop
 8001438:	f3af 8000 	nop.w
 800143c:	f3af 8000 	nop.w

08001440 <write>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8001440:	3030      	adds	r0, #48	; 0x30
 8001442:	f04f 33ff 	mov.w	r3, #4294967295
 8001446:	f7ff bed3 	b.w	80011f0 <chOQWriteTimeout>
 800144a:	bf00      	nop
 800144c:	f3af 8000 	nop.w

08001450 <gett>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8001450:	300c      	adds	r0, #12
 8001452:	f7ff be0d 	b.w	8001070 <chIQGetTimeout>
 8001456:	bf00      	nop
 8001458:	f3af 8000 	nop.w
 800145c:	f3af 8000 	nop.w

08001460 <get>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8001460:	300c      	adds	r0, #12
 8001462:	f04f 31ff 	mov.w	r1, #4294967295
 8001466:	f7ff be03 	b.w	8001070 <chIQGetTimeout>
 800146a:	bf00      	nop
 800146c:	f3af 8000 	nop.w

08001470 <putt>:
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8001470:	3030      	adds	r0, #48	; 0x30
 8001472:	f7ff be75 	b.w	8001160 <chOQPutTimeout>
 8001476:	bf00      	nop
 8001478:	f3af 8000 	nop.w
 800147c:	f3af 8000 	nop.w

08001480 <put>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8001480:	3030      	adds	r0, #48	; 0x30
 8001482:	f04f 32ff 	mov.w	r2, #4294967295
 8001486:	f7ff be6b 	b.w	8001160 <chOQPutTimeout>
 800148a:	bf00      	nop
 800148c:	f3af 8000 	nop.w

08001490 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
 8001490:	f000 bbae 	b.w	8001bf0 <sd_lld_init>
 8001494:	f3af 8000 	nop.w
 8001498:	f3af 8000 	nop.w
 800149c:	f3af 8000 	nop.w

080014a0 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80014a0:	b570      	push	{r4, r5, r6, lr}

  sdp->vmt = &vmt;
 80014a2:	4b0e      	ldr	r3, [pc, #56]	; (80014dc <sdObjectInit+0x3c>)
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80014a4:	4604      	mov	r4, r0
 80014a6:	b082      	sub	sp, #8

  sdp->vmt = &vmt;
 80014a8:	f840 3b04 	str.w	r3, [r0], #4
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 80014ac:	2601      	movs	r6, #1
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80014ae:	9400      	str	r4, [sp, #0]
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80014b0:	460b      	mov	r3, r1
 80014b2:	4615      	mov	r5, r2
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)(void *)esp;
 80014b4:	6060      	str	r0, [r4, #4]

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80014b6:	f104 0154 	add.w	r1, r4, #84	; 0x54
 80014ba:	f104 000c 	add.w	r0, r4, #12
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 80014be:	7226      	strb	r6, [r4, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80014c0:	2210      	movs	r2, #16
 80014c2:	f7ff fda5 	bl	8001010 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 80014c6:	9400      	str	r4, [sp, #0]
 80014c8:	462b      	mov	r3, r5
 80014ca:	f104 0030 	add.w	r0, r4, #48	; 0x30
 80014ce:	f104 0164 	add.w	r1, r4, #100	; 0x64
 80014d2:	2210      	movs	r2, #16
 80014d4:	f7ff fe34 	bl	8001140 <chOQObjectInit>
}
 80014d8:	b002      	add	sp, #8
 80014da:	bd70      	pop	{r4, r5, r6, pc}
 80014dc:	08002370 	.word	0x08002370

080014e0 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 80014e0:	b510      	push	{r4, lr}
 80014e2:	2320      	movs	r3, #32
 80014e4:	4604      	mov	r4, r0
 80014e6:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 80014ea:	f000 fb91 	bl	8001c10 <sd_lld_start>
  sdp->state = SD_READY;
 80014ee:	2302      	movs	r3, #2
 80014f0:	7223      	strb	r3, [r4, #8]
 80014f2:	2300      	movs	r3, #0
 80014f4:	f383 8811 	msr	BASEPRI, r3
 80014f8:	bd10      	pop	{r4, pc}
 80014fa:	bf00      	nop
 80014fc:	f3af 8000 	nop.w

08001500 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8001500:	b538      	push	{r3, r4, r5, lr}

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8001502:	6943      	ldr	r3, [r0, #20]
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8001504:	4604      	mov	r4, r0
 8001506:	460d      	mov	r5, r1

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8001508:	b13b      	cbz	r3, 800151a <sdIncomingDataI+0x1a>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 800150a:	4629      	mov	r1, r5
 800150c:	f104 000c 	add.w	r0, r4, #12
 8001510:	f7ff fd8e 	bl	8001030 <chIQPutI>
 8001514:	2800      	cmp	r0, #0
 8001516:	db0b      	blt.n	8001530 <sdIncomingDataI+0x30>
 8001518:	bd38      	pop	{r3, r4, r5, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800151a:	3004      	adds	r0, #4
 800151c:	2104      	movs	r1, #4
 800151e:	f7ff fcc7 	bl	8000eb0 <chEvtBroadcastFlagsI>
 8001522:	4629      	mov	r1, r5
 8001524:	f104 000c 	add.w	r0, r4, #12
 8001528:	f7ff fd82 	bl	8001030 <chIQPutI>
 800152c:	2800      	cmp	r0, #0
 800152e:	daf3      	bge.n	8001518 <sdIncomingDataI+0x18>
 8001530:	1d20      	adds	r0, r4, #4
 8001532:	2180      	movs	r1, #128	; 0x80
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
}
 8001534:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8001538:	f7ff bcba 	b.w	8000eb0 <chEvtBroadcastFlagsI>
 800153c:	f3af 8000 	nop.w

08001540 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
 8001540:	f000 ba9e 	b.w	8001a80 <st_lld_init>
 8001544:	f3af 8000 	nop.w
 8001548:	f3af 8000 	nop.w
 800154c:	f3af 8000 	nop.w

08001550 <stStartAlarm>:
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001550:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->SR     = 0;
 8001554:	2100      	movs	r1, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8001556:	2202      	movs	r2, #2
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001558:	6358      	str	r0, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800155a:	6119      	str	r1, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800155c:	60da      	str	r2, [r3, #12]
 800155e:	4770      	bx	lr

08001560 <stStopAlarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8001560:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001564:	2200      	movs	r2, #0
 8001566:	60da      	str	r2, [r3, #12]
 8001568:	4770      	bx	lr
 800156a:	bf00      	nop
 800156c:	f3af 8000 	nop.w

08001570 <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001570:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001574:	6358      	str	r0, [r3, #52]	; 0x34
 8001576:	4770      	bx	lr
 8001578:	f3af 8000 	nop.w
 800157c:	f3af 8000 	nop.w

08001580 <nvicEnableVector>:
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8001580:	0943      	lsrs	r3, r0, #5
 8001582:	009b      	lsls	r3, r3, #2
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8001584:	b410      	push	{r4}
 8001586:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 800158a:	f100 4460 	add.w	r4, r0, #3758096384	; 0xe0000000
 800158e:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
 8001592:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 8001596:	0109      	lsls	r1, r1, #4
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8001598:	f000 001f 	and.w	r0, r0, #31
 800159c:	2201      	movs	r2, #1
 800159e:	4082      	lsls	r2, r0
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 80015a0:	b2c9      	uxtb	r1, r1
 80015a2:	f884 1300 	strb.w	r1, [r4, #768]	; 0x300
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 80015a6:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 80015aa:	601a      	str	r2, [r3, #0]
}
 80015ac:	f85d 4b04 	ldr.w	r4, [sp], #4
 80015b0:	4770      	bx	lr
 80015b2:	bf00      	nop
 80015b4:	f3af 8000 	nop.w
 80015b8:	f3af 8000 	nop.w
 80015bc:	f3af 8000 	nop.w

080015c0 <hal_lld_init>:
 */
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 80015c0:	4b16      	ldr	r3, [pc, #88]	; (800161c <hal_lld_init+0x5c>)
 80015c2:	f04f 31ff 	mov.w	r1, #4294967295
 80015c6:	691a      	ldr	r2, [r3, #16]
 80015c8:	2200      	movs	r2, #0
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80015ca:	b410      	push	{r4}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 80015cc:	6119      	str	r1, [r3, #16]
 80015ce:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 80015d0:	6958      	ldr	r0, [r3, #20]
 80015d2:	6159      	str	r1, [r3, #20]
 80015d4:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 80015d6:	6a18      	ldr	r0, [r3, #32]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80015d8:	4c11      	ldr	r4, [pc, #68]	; (8001620 <hal_lld_init+0x60>)

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
  rccResetAHB2(~0);
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 80015da:	f060 5080 	orn	r0, r0, #268435456	; 0x10000000
 80015de:	6218      	str	r0, [r3, #32]
 80015e0:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 80015e2:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80015e4:	6259      	str	r1, [r3, #36]	; 0x24
 80015e6:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80015e8:	6c19      	ldr	r1, [r3, #64]	; 0x40
 80015ea:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 80015ee:	6419      	str	r1, [r3, #64]	; 0x40
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80015f0:	6821      	ldr	r1, [r4, #0]
 80015f2:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 80015f6:	6021      	str	r1, [r4, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 80015f8:	6f19      	ldr	r1, [r3, #112]	; 0x70
 80015fa:	f401 7140 	and.w	r1, r1, #768	; 0x300
 80015fe:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8001602:	d003      	beq.n	800160c <hal_lld_init+0x4c>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8001604:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8001608:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 800160a:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 800160c:	4a04      	ldr	r2, [pc, #16]	; (8001620 <hal_lld_init+0x60>)

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800160e:	f85d 4b04 	ldr.w	r4, [sp], #4

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8001612:	6853      	ldr	r3, [r2, #4]
 8001614:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8001618:	6053      	str	r3, [r2, #4]

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800161a:	4770      	bx	lr
 800161c:	40023800 	.word	0x40023800
 8001620:	40007000 	.word	0x40007000
 8001624:	f3af 8000 	nop.w
 8001628:	f3af 8000 	nop.w
 800162c:	f3af 8000 	nop.w

08001630 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001630:	492c      	ldr	r1, [pc, #176]	; (80016e4 <stm32_clock_init+0xb4>)

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8001632:	4b2d      	ldr	r3, [pc, #180]	; (80016e8 <stm32_clock_init+0xb8>)
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001634:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8001638:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800163c:	6408      	str	r0, [r1, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 800163e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001640:	680b      	ldr	r3, [r1, #0]
 8001642:	f043 0301 	orr.w	r3, r3, #1
 8001646:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001648:	680a      	ldr	r2, [r1, #0]
 800164a:	4b26      	ldr	r3, [pc, #152]	; (80016e4 <stm32_clock_init+0xb4>)
 800164c:	0790      	lsls	r0, r2, #30
 800164e:	d5fb      	bpl.n	8001648 <stm32_clock_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8001650:	689a      	ldr	r2, [r3, #8]
 8001652:	f022 0203 	bic.w	r2, r2, #3
 8001656:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001658:	689a      	ldr	r2, [r3, #8]
 800165a:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800165c:	4619      	mov	r1, r3
 800165e:	688b      	ldr	r3, [r1, #8]
 8001660:	4a20      	ldr	r2, [pc, #128]	; (80016e4 <stm32_clock_init+0xb4>)
 8001662:	f013 030c 	ands.w	r3, r3, #12
 8001666:	d1fa      	bne.n	800165e <stm32_clock_init+0x2e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001668:	6811      	ldr	r1, [r2, #0]
 800166a:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 800166e:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001670:	6093      	str	r3, [r2, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 8001672:	6813      	ldr	r3, [r2, #0]
 8001674:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001678:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 800167a:	6811      	ldr	r1, [r2, #0]
 800167c:	4b19      	ldr	r3, [pc, #100]	; (80016e4 <stm32_clock_init+0xb4>)
 800167e:	0389      	lsls	r1, r1, #14
 8001680:	d5fb      	bpl.n	800167a <stm32_clock_init+0x4a>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001682:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8001684:	f042 0201 	orr.w	r2, r2, #1
 8001688:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800168a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800168c:	4915      	ldr	r1, [pc, #84]	; (80016e4 <stm32_clock_init+0xb4>)
 800168e:	0790      	lsls	r0, r2, #30
 8001690:	d5fb      	bpl.n	800168a <stm32_clock_init+0x5a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8001692:	4b16      	ldr	r3, [pc, #88]	; (80016ec <stm32_clock_init+0xbc>)
 8001694:	604b      	str	r3, [r1, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8001696:	680b      	ldr	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8001698:	4a13      	ldr	r2, [pc, #76]	; (80016e8 <stm32_clock_init+0xb8>)

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 800169a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800169e:	600b      	str	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 80016a0:	6853      	ldr	r3, [r2, #4]
 80016a2:	0459      	lsls	r1, r3, #17
 80016a4:	d5fc      	bpl.n	80016a0 <stm32_clock_init+0x70>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80016a6:	490f      	ldr	r1, [pc, #60]	; (80016e4 <stm32_clock_init+0xb4>)
 80016a8:	680a      	ldr	r2, [r1, #0]
 80016aa:	4b0e      	ldr	r3, [pc, #56]	; (80016e4 <stm32_clock_init+0xb4>)
 80016ac:	0192      	lsls	r2, r2, #6
 80016ae:	d5fb      	bpl.n	80016a8 <stm32_clock_init+0x78>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 80016b0:	4a0f      	ldr	r2, [pc, #60]	; (80016f0 <stm32_clock_init+0xc0>)
  while (!(RCC->CR & RCC_CR_PLLI2SRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 80016b2:	4910      	ldr	r1, [pc, #64]	; (80016f4 <stm32_clock_init+0xc4>)
 80016b4:	6099      	str	r1, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 80016b6:	f240 7104 	movw	r1, #1796	; 0x704
 80016ba:	6011      	str	r1, [r2, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 80016bc:	689a      	ldr	r2, [r3, #8]
 80016be:	f042 0202 	orr.w	r2, r2, #2
 80016c2:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80016c4:	461a      	mov	r2, r3
 80016c6:	6893      	ldr	r3, [r2, #8]
 80016c8:	4906      	ldr	r1, [pc, #24]	; (80016e4 <stm32_clock_init+0xb4>)
 80016ca:	f003 030c 	and.w	r3, r3, #12
 80016ce:	2b08      	cmp	r3, #8
 80016d0:	d1f9      	bne.n	80016c6 <stm32_clock_init+0x96>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80016d2:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 80016d4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80016d8:	644b      	str	r3, [r1, #68]	; 0x44
 80016da:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 80016dc:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80016e0:	664b      	str	r3, [r1, #100]	; 0x64
 80016e2:	4770      	bx	lr
 80016e4:	40023800 	.word	0x40023800
 80016e8:	40007000 	.word	0x40007000
 80016ec:	07404b19 	.word	0x07404b19
 80016f0:	40023c00 	.word	0x40023c00
 80016f4:	38089400 	.word	0x38089400
 80016f8:	f3af 8000 	nop.w
 80016fc:	f3af 8000 	nop.w

08001700 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8001700:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8001704:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 80018bc <_pal_lld_init+0x1bc>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001708:	f8df c1b4 	ldr.w	ip, [pc, #436]	; 80018c0 <_pal_lld_init+0x1c0>
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 800170c:	f8d8 a030 	ldr.w	sl, [r8, #48]	; 0x30
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001710:	f8df e1b0 	ldr.w	lr, [pc, #432]	; 80018c4 <_pal_lld_init+0x1c4>
 8001714:	4f63      	ldr	r7, [pc, #396]	; (80018a4 <_pal_lld_init+0x1a4>)
 8001716:	4e64      	ldr	r6, [pc, #400]	; (80018a8 <_pal_lld_init+0x1a8>)
 8001718:	4d64      	ldr	r5, [pc, #400]	; (80018ac <_pal_lld_init+0x1ac>)
 800171a:	4c65      	ldr	r4, [pc, #404]	; (80018b0 <_pal_lld_init+0x1b0>)
 800171c:	4965      	ldr	r1, [pc, #404]	; (80018b4 <_pal_lld_init+0x1b4>)
 800171e:	4a66      	ldr	r2, [pc, #408]	; (80018b8 <_pal_lld_init+0x1b8>)
 8001720:	f8df b1a4 	ldr.w	fp, [pc, #420]	; 80018c8 <_pal_lld_init+0x1c8>
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8001724:	f240 19ff 	movw	r9, #511	; 0x1ff
 8001728:	ea4a 0a09 	orr.w	sl, sl, r9
 800172c:	f8c8 a030 	str.w	sl, [r8, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 8001730:	f8d8 a050 	ldr.w	sl, [r8, #80]	; 0x50
 8001734:	ea4a 0909 	orr.w	r9, sl, r9
 8001738:	f8c8 9050 	str.w	r9, [r8, #80]	; 0x50
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800173c:	6843      	ldr	r3, [r0, #4]
 800173e:	f8cc 3004 	str.w	r3, [ip, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001742:	6883      	ldr	r3, [r0, #8]
 8001744:	f8cc 3008 	str.w	r3, [ip, #8]
  gpiop->PUPDR   = config->pupdr;
 8001748:	68c3      	ldr	r3, [r0, #12]
 800174a:	f8cc 300c 	str.w	r3, [ip, #12]
  gpiop->ODR     = config->odr;
 800174e:	6903      	ldr	r3, [r0, #16]
 8001750:	f8cc 3014 	str.w	r3, [ip, #20]
  gpiop->AFRL    = config->afrl;
 8001754:	6943      	ldr	r3, [r0, #20]
 8001756:	f8cc 3020 	str.w	r3, [ip, #32]
  gpiop->AFRH    = config->afrh;
 800175a:	6983      	ldr	r3, [r0, #24]
 800175c:	f8cc 3024 	str.w	r3, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001760:	6803      	ldr	r3, [r0, #0]
 8001762:	f8cc 3000 	str.w	r3, [ip]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001766:	6a03      	ldr	r3, [r0, #32]
 8001768:	f8ce 3004 	str.w	r3, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800176c:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800176e:	f8ce 3008 	str.w	r3, [lr, #8]
  gpiop->PUPDR   = config->pupdr;
 8001772:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001774:	f8ce 300c 	str.w	r3, [lr, #12]
  gpiop->ODR     = config->odr;
 8001778:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800177a:	f8ce 3014 	str.w	r3, [lr, #20]
  gpiop->AFRL    = config->afrl;
 800177e:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8001780:	f8ce 3020 	str.w	r3, [lr, #32]
  gpiop->AFRH    = config->afrh;
 8001784:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001786:	f8ce 3024 	str.w	r3, [lr, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800178a:	69c3      	ldr	r3, [r0, #28]
 800178c:	f8ce 3000 	str.w	r3, [lr]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001790:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8001792:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001794:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001796:	60bb      	str	r3, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 8001798:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800179a:	60fb      	str	r3, [r7, #12]
  gpiop->ODR     = config->odr;
 800179c:	6c83      	ldr	r3, [r0, #72]	; 0x48
 800179e:	617b      	str	r3, [r7, #20]
  gpiop->AFRL    = config->afrl;
 80017a0:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 80017a2:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 80017a4:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80017a6:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80017a8:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80017aa:	603b      	str	r3, [r7, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80017ac:	6d87      	ldr	r7, [r0, #88]	; 0x58
 80017ae:	6077      	str	r7, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80017b0:	6dc7      	ldr	r7, [r0, #92]	; 0x5c
 80017b2:	60b7      	str	r7, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 80017b4:	6e07      	ldr	r7, [r0, #96]	; 0x60
 80017b6:	60f7      	str	r7, [r6, #12]
  gpiop->ODR     = config->odr;
 80017b8:	6e47      	ldr	r7, [r0, #100]	; 0x64
 80017ba:	6177      	str	r7, [r6, #20]
  gpiop->AFRL    = config->afrl;
 80017bc:	6e87      	ldr	r7, [r0, #104]	; 0x68
 80017be:	6237      	str	r7, [r6, #32]
  gpiop->AFRH    = config->afrh;
 80017c0:	6ec7      	ldr	r7, [r0, #108]	; 0x6c
 80017c2:	6277      	str	r7, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80017c4:	6d47      	ldr	r7, [r0, #84]	; 0x54
 80017c6:	6037      	str	r7, [r6, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80017c8:	6f46      	ldr	r6, [r0, #116]	; 0x74
 80017ca:	606e      	str	r6, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80017cc:	6f86      	ldr	r6, [r0, #120]	; 0x78
 80017ce:	60ae      	str	r6, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 80017d0:	6fc6      	ldr	r6, [r0, #124]	; 0x7c
 80017d2:	60ee      	str	r6, [r5, #12]
  gpiop->ODR     = config->odr;
 80017d4:	f8d0 6080 	ldr.w	r6, [r0, #128]	; 0x80
 80017d8:	616e      	str	r6, [r5, #20]
  gpiop->AFRL    = config->afrl;
 80017da:	f8d0 6084 	ldr.w	r6, [r0, #132]	; 0x84
 80017de:	622e      	str	r6, [r5, #32]
  gpiop->AFRH    = config->afrh;
 80017e0:	f8d0 6088 	ldr.w	r6, [r0, #136]	; 0x88
 80017e4:	626e      	str	r6, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80017e6:	6f06      	ldr	r6, [r0, #112]	; 0x70
 80017e8:	602e      	str	r6, [r5, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80017ea:	f8d0 5090 	ldr.w	r5, [r0, #144]	; 0x90
 80017ee:	6065      	str	r5, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80017f0:	f8d0 5094 	ldr.w	r5, [r0, #148]	; 0x94
 80017f4:	60a5      	str	r5, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 80017f6:	f8d0 5098 	ldr.w	r5, [r0, #152]	; 0x98
 80017fa:	60e5      	str	r5, [r4, #12]
  gpiop->ODR     = config->odr;
 80017fc:	f8d0 509c 	ldr.w	r5, [r0, #156]	; 0x9c
 8001800:	6165      	str	r5, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8001802:	f8d0 50a0 	ldr.w	r5, [r0, #160]	; 0xa0
 8001806:	6225      	str	r5, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8001808:	f8d0 50a4 	ldr.w	r5, [r0, #164]	; 0xa4
 800180c:	6265      	str	r5, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800180e:	f8d0 508c 	ldr.w	r5, [r0, #140]	; 0x8c
 8001812:	6025      	str	r5, [r4, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001814:	f8d0 40ac 	ldr.w	r4, [r0, #172]	; 0xac
 8001818:	604c      	str	r4, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800181a:	f8d0 40b0 	ldr.w	r4, [r0, #176]	; 0xb0
 800181e:	608c      	str	r4, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8001820:	f8d0 40b4 	ldr.w	r4, [r0, #180]	; 0xb4
 8001824:	60cc      	str	r4, [r1, #12]
  gpiop->ODR     = config->odr;
 8001826:	f8d0 40b8 	ldr.w	r4, [r0, #184]	; 0xb8
 800182a:	614c      	str	r4, [r1, #20]
  gpiop->AFRL    = config->afrl;
 800182c:	f8d0 40bc 	ldr.w	r4, [r0, #188]	; 0xbc
 8001830:	620c      	str	r4, [r1, #32]
  gpiop->AFRH    = config->afrh;
 8001832:	f8d0 40c0 	ldr.w	r4, [r0, #192]	; 0xc0
 8001836:	624c      	str	r4, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001838:	f8d0 40a8 	ldr.w	r4, [r0, #168]	; 0xa8
 800183c:	600c      	str	r4, [r1, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800183e:	f8d0 10c8 	ldr.w	r1, [r0, #200]	; 0xc8
 8001842:	6051      	str	r1, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001844:	f8d0 10cc 	ldr.w	r1, [r0, #204]	; 0xcc
 8001848:	6091      	str	r1, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 800184a:	f8d0 10d0 	ldr.w	r1, [r0, #208]	; 0xd0
 800184e:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 8001850:	f8d0 10d4 	ldr.w	r1, [r0, #212]	; 0xd4
 8001854:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8001856:	f8d0 10d8 	ldr.w	r1, [r0, #216]	; 0xd8
 800185a:	6211      	str	r1, [r2, #32]
  gpiop->AFRH    = config->afrh;
 800185c:	f8d0 10dc 	ldr.w	r1, [r0, #220]	; 0xdc
 8001860:	6251      	str	r1, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001862:	f8d0 10c4 	ldr.w	r1, [r0, #196]	; 0xc4
 8001866:	6011      	str	r1, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001868:	f8d0 20e4 	ldr.w	r2, [r0, #228]	; 0xe4
 800186c:	f8cb 2004 	str.w	r2, [fp, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001870:	f8d0 20e8 	ldr.w	r2, [r0, #232]	; 0xe8
 8001874:	f8cb 2008 	str.w	r2, [fp, #8]
  gpiop->PUPDR   = config->pupdr;
 8001878:	f8d0 20ec 	ldr.w	r2, [r0, #236]	; 0xec
 800187c:	f8cb 200c 	str.w	r2, [fp, #12]
  gpiop->ODR     = config->odr;
 8001880:	f8d0 20f0 	ldr.w	r2, [r0, #240]	; 0xf0
 8001884:	f8cb 2014 	str.w	r2, [fp, #20]
  gpiop->AFRL    = config->afrl;
 8001888:	f8d0 20f4 	ldr.w	r2, [r0, #244]	; 0xf4
 800188c:	f8cb 2020 	str.w	r2, [fp, #32]
  gpiop->AFRH    = config->afrh;
 8001890:	f8d0 20f8 	ldr.w	r2, [r0, #248]	; 0xf8
 8001894:	f8cb 2024 	str.w	r2, [fp, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001898:	f8d0 20e0 	ldr.w	r2, [r0, #224]	; 0xe0
 800189c:	f8cb 2000 	str.w	r2, [fp]
 80018a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80018a4:	40020800 	.word	0x40020800
 80018a8:	40020c00 	.word	0x40020c00
 80018ac:	40021000 	.word	0x40021000
 80018b0:	40021400 	.word	0x40021400
 80018b4:	40021800 	.word	0x40021800
 80018b8:	40021c00 	.word	0x40021c00
 80018bc:	40023800 	.word	0x40023800
 80018c0:	40020000 	.word	0x40020000
 80018c4:	40020400 	.word	0x40020400
 80018c8:	40022000 	.word	0x40022000
 80018cc:	f3af 8000 	nop.w

080018d0 <gpt_lld_serve_interrupt>:
 * @param[in] gptp      pointer to a @p GPTDriver object
 */
static void gpt_lld_serve_interrupt(GPTDriver *gptp) {

  gptp->tim->SR = 0;
  if (gptp->state == GPT_ONESHOT) {
 80018d0:	7801      	ldrb	r1, [r0, #0]
 *
 * @param[in] gptp      pointer to a @p GPTDriver object
 */
static void gpt_lld_serve_interrupt(GPTDriver *gptp) {

  gptp->tim->SR = 0;
 80018d2:	68c3      	ldr	r3, [r0, #12]
 80018d4:	2200      	movs	r2, #0
  if (gptp->state == GPT_ONESHOT) {
 80018d6:	2904      	cmp	r1, #4
 *
 * @param[in] gptp      pointer to a @p GPTDriver object
 */
static void gpt_lld_serve_interrupt(GPTDriver *gptp) {

  gptp->tim->SR = 0;
 80018d8:	611a      	str	r2, [r3, #16]
  if (gptp->state == GPT_ONESHOT) {
 80018da:	d107      	bne.n	80018ec <gpt_lld_serve_interrupt+0x1c>
    gptp->state = GPT_READY;                /* Back in GPT_READY state.     */
 80018dc:	2102      	movs	r1, #2
 80018de:	7001      	strb	r1, [r0, #0]
 *
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {

  gptp->tim->CR1   = 0;                         /* Initially stopped.       */
 80018e0:	601a      	str	r2, [r3, #0]
  gptp->tim->SR    = 0;                         /* Clear pending IRQs.      */
 80018e2:	611a      	str	r2, [r3, #16]

  /* All interrupts disabled.*/
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 80018e4:	68da      	ldr	r2, [r3, #12]
 80018e6:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 80018ea:	60da      	str	r2, [r3, #12]
  gptp->tim->SR = 0;
  if (gptp->state == GPT_ONESHOT) {
    gptp->state = GPT_READY;                /* Back in GPT_READY state.     */
    gpt_lld_stop_timer(gptp);               /* Timer automatically stopped. */
  }
  gptp->config->callback(gptp);
 80018ec:	6843      	ldr	r3, [r0, #4]
 80018ee:	685b      	ldr	r3, [r3, #4]
 80018f0:	4718      	bx	r3
 80018f2:	bf00      	nop
 80018f4:	f3af 8000 	nop.w
 80018f8:	f3af 8000 	nop.w
 80018fc:	f3af 8000 	nop.w

08001900 <VectorB4>:
/**
 * @brief   TIM3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
 8001900:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  gpt_lld_serve_interrupt(&GPTD3);
 8001902:	4803      	ldr	r0, [pc, #12]	; (8001910 <VectorB4+0x10>)
 8001904:	f7ff ffe4 	bl	80018d0 <gpt_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8001908:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  gpt_lld_serve_interrupt(&GPTD3);

  OSAL_IRQ_EPILOGUE();
 800190c:	f7fe bf18 	b.w	8000740 <_port_irq_epilogue>
 8001910:	20000978 	.word	0x20000978
 8001914:	f3af 8000 	nop.w
 8001918:	f3af 8000 	nop.w
 800191c:	f3af 8000 	nop.w

08001920 <VectorB8>:
/**
 * @brief   TIM4 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM4_HANDLER) {
 8001920:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  gpt_lld_serve_interrupt(&GPTD4);
 8001922:	4803      	ldr	r0, [pc, #12]	; (8001930 <VectorB8+0x10>)
 8001924:	f7ff ffd4 	bl	80018d0 <gpt_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8001928:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  gpt_lld_serve_interrupt(&GPTD4);

  OSAL_IRQ_EPILOGUE();
 800192c:	f7fe bf08 	b.w	8000740 <_port_irq_epilogue>
 8001930:	20000988 	.word	0x20000988
 8001934:	f3af 8000 	nop.w
 8001938:	f3af 8000 	nop.w
 800193c:	f3af 8000 	nop.w

08001940 <gpt_lld_init>:
/**
 * @brief   Low level GPT driver initialization.
 *
 * @notapi
 */
void gpt_lld_init(void) {
 8001940:	b508      	push	{r3, lr}
  gptObjectInit(&GPTD2);
#endif

#if STM32_GPT_USE_TIM3
  /* Driver initialization.*/
  GPTD3.tim = STM32_TIM3;
 8001942:	4806      	ldr	r0, [pc, #24]	; (800195c <gpt_lld_init+0x1c>)
 8001944:	4b06      	ldr	r3, [pc, #24]	; (8001960 <gpt_lld_init+0x20>)
 8001946:	60c3      	str	r3, [r0, #12]
  gptObjectInit(&GPTD3);
 8001948:	f7ff fd2a 	bl	80013a0 <gptObjectInit>
#endif

#if STM32_GPT_USE_TIM4
  /* Driver initialization.*/
  GPTD4.tim = STM32_TIM4;
 800194c:	4805      	ldr	r0, [pc, #20]	; (8001964 <gpt_lld_init+0x24>)
 800194e:	4b06      	ldr	r3, [pc, #24]	; (8001968 <gpt_lld_init+0x28>)
 8001950:	60c3      	str	r3, [r0, #12]
#if STM32_GPT_USE_TIM14
  /* Driver initialization.*/
  GPTD14.tim = STM32_TIM14;
  gptObjectInit(&GPTD14);
#endif
}
 8001952:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
#endif

#if STM32_GPT_USE_TIM4
  /* Driver initialization.*/
  GPTD4.tim = STM32_TIM4;
  gptObjectInit(&GPTD4);
 8001956:	f7ff bd23 	b.w	80013a0 <gptObjectInit>
 800195a:	bf00      	nop
 800195c:	20000978 	.word	0x20000978
 8001960:	40000400 	.word	0x40000400
 8001964:	20000988 	.word	0x20000988
 8001968:	40000800 	.word	0x40000800
 800196c:	f3af 8000 	nop.w

08001970 <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
 8001970:	b538      	push	{r3, r4, r5, lr}
  uint16_t psc;

  if (gptp->state == GPT_STOP) {
 8001972:	7803      	ldrb	r3, [r0, #0]
 8001974:	2b01      	cmp	r3, #1
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
 8001976:	4604      	mov	r4, r0
  uint16_t psc;

  if (gptp->state == GPT_STOP) {
 8001978:	d012      	beq.n	80019a0 <gpt_lld_start+0x30>
    }
#endif
  }

  /* Prescaler value calculation.*/
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 800197a:	6860      	ldr	r0, [r4, #4]
 800197c:	68a3      	ldr	r3, [r4, #8]
  /* Timer configuration.*/
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
  gptp->tim->CR2  = gptp->config->cr2;
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
  gptp->tim->SR   = 0;                          /* Clear pending IRQs.      */
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
 800197e:	68c1      	ldr	r1, [r0, #12]
    }
#endif
  }

  /* Prescaler value calculation.*/
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 8001980:	6805      	ldr	r5, [r0, #0]
  osalDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
                "invalid frequency");

  /* Timer configuration.*/
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
 8001982:	68e2      	ldr	r2, [r4, #12]
    }
#endif
  }

  /* Prescaler value calculation.*/
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 8001984:	fbb3 f3f5 	udiv	r3, r3, r5
 8001988:	3b01      	subs	r3, #1
  osalDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
                "invalid frequency");

  /* Timer configuration.*/
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
  gptp->tim->CR2  = gptp->config->cr2;
 800198a:	6884      	ldr	r4, [r0, #8]
    }
#endif
  }

  /* Prescaler value calculation.*/
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 800198c:	b29b      	uxth	r3, r3
  osalDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
                "invalid frequency");

  /* Timer configuration.*/
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
 800198e:	2000      	movs	r0, #0
  gptp->tim->CR2  = gptp->config->cr2;
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
  gptp->tim->SR   = 0;                          /* Clear pending IRQs.      */
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
 8001990:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
  osalDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
                "invalid frequency");

  /* Timer configuration.*/
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
 8001994:	6010      	str	r0, [r2, #0]
  gptp->tim->CR2  = gptp->config->cr2;
 8001996:	6054      	str	r4, [r2, #4]
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
 8001998:	6293      	str	r3, [r2, #40]	; 0x28
  gptp->tim->SR   = 0;                          /* Clear pending IRQs.      */
 800199a:	6110      	str	r0, [r2, #16]
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
 800199c:	60d1      	str	r1, [r2, #12]
 800199e:	bd38      	pop	{r3, r4, r5, pc}
      nvicEnableVector(STM32_TIM2_NUMBER, STM32_GPT_TIM2_IRQ_PRIORITY);
      gptp->clock = STM32_TIMCLK1;
    }
#endif
#if STM32_GPT_USE_TIM3
    if (&GPTD3 == gptp) {
 80019a0:	4b14      	ldr	r3, [pc, #80]	; (80019f4 <gpt_lld_start+0x84>)
 80019a2:	4298      	cmp	r0, r3
 80019a4:	d014      	beq.n	80019d0 <gpt_lld_start+0x60>
      nvicEnableVector(STM32_TIM3_NUMBER, STM32_GPT_TIM3_IRQ_PRIORITY);
      gptp->clock = STM32_TIMCLK1;
    }
#endif
#if STM32_GPT_USE_TIM4
    if (&GPTD4 == gptp) {
 80019a6:	4b14      	ldr	r3, [pc, #80]	; (80019f8 <gpt_lld_start+0x88>)
 80019a8:	4298      	cmp	r0, r3
 80019aa:	d1e6      	bne.n	800197a <gpt_lld_start+0xa>
      rccEnableTIM4(FALSE);
 80019ac:	4b13      	ldr	r3, [pc, #76]	; (80019fc <gpt_lld_start+0x8c>)
 80019ae:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80019b0:	f042 0204 	orr.w	r2, r2, #4
 80019b4:	641a      	str	r2, [r3, #64]	; 0x40
      rccResetTIM4();
 80019b6:	6a1a      	ldr	r2, [r3, #32]
 80019b8:	2100      	movs	r1, #0
 80019ba:	f042 0204 	orr.w	r2, r2, #4
 80019be:	621a      	str	r2, [r3, #32]
      nvicEnableVector(STM32_TIM4_NUMBER, STM32_GPT_TIM4_IRQ_PRIORITY);
 80019c0:	201e      	movs	r0, #30
    }
#endif
#if STM32_GPT_USE_TIM4
    if (&GPTD4 == gptp) {
      rccEnableTIM4(FALSE);
      rccResetTIM4();
 80019c2:	6219      	str	r1, [r3, #32]
      nvicEnableVector(STM32_TIM4_NUMBER, STM32_GPT_TIM4_IRQ_PRIORITY);
 80019c4:	2106      	movs	r1, #6
 80019c6:	f7ff fddb 	bl	8001580 <nvicEnableVector>
      gptp->clock = STM32_TIMCLK1;
 80019ca:	4b0d      	ldr	r3, [pc, #52]	; (8001a00 <gpt_lld_start+0x90>)
 80019cc:	60a3      	str	r3, [r4, #8]
 80019ce:	e7d4      	b.n	800197a <gpt_lld_start+0xa>
      gptp->clock = STM32_TIMCLK1;
    }
#endif
#if STM32_GPT_USE_TIM3
    if (&GPTD3 == gptp) {
      rccEnableTIM3(FALSE);
 80019d0:	4b0a      	ldr	r3, [pc, #40]	; (80019fc <gpt_lld_start+0x8c>)
 80019d2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80019d4:	f042 0202 	orr.w	r2, r2, #2
 80019d8:	641a      	str	r2, [r3, #64]	; 0x40
      rccResetTIM3();
 80019da:	6a1a      	ldr	r2, [r3, #32]
 80019dc:	2100      	movs	r1, #0
 80019de:	f042 0202 	orr.w	r2, r2, #2
 80019e2:	621a      	str	r2, [r3, #32]
      nvicEnableVector(STM32_TIM3_NUMBER, STM32_GPT_TIM3_IRQ_PRIORITY);
 80019e4:	201d      	movs	r0, #29
    }
#endif
#if STM32_GPT_USE_TIM3
    if (&GPTD3 == gptp) {
      rccEnableTIM3(FALSE);
      rccResetTIM3();
 80019e6:	6219      	str	r1, [r3, #32]
      nvicEnableVector(STM32_TIM3_NUMBER, STM32_GPT_TIM3_IRQ_PRIORITY);
 80019e8:	210a      	movs	r1, #10
 80019ea:	f7ff fdc9 	bl	8001580 <nvicEnableVector>
      gptp->clock = STM32_TIMCLK1;
 80019ee:	4b04      	ldr	r3, [pc, #16]	; (8001a00 <gpt_lld_start+0x90>)
 80019f0:	60a3      	str	r3, [r4, #8]
 80019f2:	e7c2      	b.n	800197a <gpt_lld_start+0xa>
 80019f4:	20000978 	.word	0x20000978
 80019f8:	20000988 	.word	0x20000988
 80019fc:	40023800 	.word	0x40023800
 8001a00:	047868c0 	.word	0x047868c0
 8001a04:	f3af 8000 	nop.w
 8001a08:	f3af 8000 	nop.w
 8001a0c:	f3af 8000 	nop.w

08001a10 <gpt_lld_start_timer>:

  /* NOTE: After generating the UG event it takes several clock cycles before
     SR bit 0 goes to 1. This is because the clearing of CNT has been inserted
     before the clearing of SR, to give it some time.*/
  gptp->tim->SR    = 0;                         /* Clear pending IRQs.      */
  if (NULL != gptp->config->callback)
 8001a10:	6842      	ldr	r2, [r0, #4]
 *
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {

  gptp->tim->ARR   = (uint32_t)(interval - 1);  /* Time constant.           */
 8001a12:	68c3      	ldr	r3, [r0, #12]

  /* NOTE: After generating the UG event it takes several clock cycles before
     SR bit 0 goes to 1. This is because the clearing of CNT has been inserted
     before the clearing of SR, to give it some time.*/
  gptp->tim->SR    = 0;                         /* Clear pending IRQs.      */
  if (NULL != gptp->config->callback)
 8001a14:	6850      	ldr	r0, [r2, #4]
 *
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {

  gptp->tim->ARR   = (uint32_t)(interval - 1);  /* Time constant.           */
 8001a16:	3901      	subs	r1, #1
 8001a18:	62d9      	str	r1, [r3, #44]	; 0x2c
  gptp->tim->EGR   = STM32_TIM_EGR_UG;          /* Update event.            */
  gptp->tim->CNT   = 0;                         /* Reset counter.           */
 8001a1a:	2200      	movs	r2, #0
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {

  gptp->tim->ARR   = (uint32_t)(interval - 1);  /* Time constant.           */
  gptp->tim->EGR   = STM32_TIM_EGR_UG;          /* Update event.            */
 8001a1c:	2101      	movs	r1, #1
 8001a1e:	6159      	str	r1, [r3, #20]
  gptp->tim->CNT   = 0;                         /* Reset counter.           */
 8001a20:	625a      	str	r2, [r3, #36]	; 0x24

  /* NOTE: After generating the UG event it takes several clock cycles before
     SR bit 0 goes to 1. This is because the clearing of CNT has been inserted
     before the clearing of SR, to give it some time.*/
  gptp->tim->SR    = 0;                         /* Clear pending IRQs.      */
 8001a22:	611a      	str	r2, [r3, #16]
  if (NULL != gptp->config->callback)
 8001a24:	b110      	cbz	r0, 8001a2c <gpt_lld_start_timer+0x1c>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
 8001a26:	68da      	ldr	r2, [r3, #12]
 8001a28:	430a      	orrs	r2, r1
 8001a2a:	60da      	str	r2, [r3, #12]
  gptp->tim->CR1   = STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 8001a2c:	2205      	movs	r2, #5
 8001a2e:	601a      	str	r2, [r3, #0]
 8001a30:	4770      	bx	lr
 8001a32:	bf00      	nop
 8001a34:	f3af 8000 	nop.w
 8001a38:	f3af 8000 	nop.w
 8001a3c:	f3af 8000 	nop.w

08001a40 <gpt_lld_stop_timer>:
 *
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {

  gptp->tim->CR1   = 0;                         /* Initially stopped.       */
 8001a40:	68c3      	ldr	r3, [r0, #12]
 8001a42:	2200      	movs	r2, #0
 8001a44:	601a      	str	r2, [r3, #0]
  gptp->tim->SR    = 0;                         /* Clear pending IRQs.      */
 8001a46:	611a      	str	r2, [r3, #16]

  /* All interrupts disabled.*/
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 8001a48:	68da      	ldr	r2, [r3, #12]
 8001a4a:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 8001a4e:	60da      	str	r2, [r3, #12]
 8001a50:	4770      	bx	lr
 8001a52:	bf00      	nop
 8001a54:	f3af 8000 	nop.w
 8001a58:	f3af 8000 	nop.w
 8001a5c:	f3af 8000 	nop.w

08001a60 <VectorB0>:
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  STM32_ST_TIM->SR = 0;
 8001a60:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8001a64:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  STM32_ST_TIM->SR = 0;
 8001a66:	2400      	movs	r4, #0
 8001a68:	611c      	str	r4, [r3, #16]
 8001a6a:	2320      	movs	r3, #32
 8001a6c:	f383 8811 	msr	BASEPRI, r3
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
 8001a70:	f7fe feee 	bl	8000850 <chSysTimerHandlerI>
 8001a74:	f384 8811 	msr	BASEPRI, r4
  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
}
 8001a78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
 8001a7c:	f7fe be60 	b.w	8000740 <_port_irq_epilogue>

08001a80 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8001a80:	b470      	push	{r4, r5, r6}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001a82:	480d      	ldr	r0, [pc, #52]	; (8001ab8 <st_lld_init+0x38>)
 8001a84:	6c01      	ldr	r1, [r0, #64]	; 0x40

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001a86:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 8001a8a:	2200      	movs	r2, #0
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8001a8c:	2401      	movs	r4, #1

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001a8e:	f041 0101 	orr.w	r1, r1, #1

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001a92:	f641 564b 	movw	r6, #7499	; 0x1d4b
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001a96:	f04f 35ff 	mov.w	r5, #4294967295

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001a9a:	6401      	str	r1, [r0, #64]	; 0x40

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001a9c:	629e      	str	r6, [r3, #40]	; 0x28
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8001a9e:	201c      	movs	r0, #28
  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001aa0:	62dd      	str	r5, [r3, #44]	; 0x2c
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8001aa2:	2108      	movs	r1, #8
  ST_ENABLE_CLOCK();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 8001aa4:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8001aa6:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8001aa8:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8001aaa:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8001aac:	615c      	str	r4, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8001aae:	601c      	str	r4, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8001ab0:	bc70      	pop	{r4, r5, r6}
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8001ab2:	f7ff bd65 	b.w	8001580 <nvicEnableVector>
 8001ab6:	bf00      	nop
 8001ab8:	40023800 	.word	0x40023800
 8001abc:	f3af 8000 	nop.w

08001ac0 <notify6>:

#if STM32_SERIAL_USE_USART6 || defined(__DOXYGEN__)
static void notify6(io_queue_t *qp) {

  (void)qp;
  USART6->CR1 |= USART_CR1_TXEIE;
 8001ac0:	4a02      	ldr	r2, [pc, #8]	; (8001acc <notify6+0xc>)
 8001ac2:	68d3      	ldr	r3, [r2, #12]
 8001ac4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001ac8:	60d3      	str	r3, [r2, #12]
 8001aca:	4770      	bx	lr
 8001acc:	40011400 	.word	0x40011400

08001ad0 <Vector15C>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART6_HANDLER) {
 8001ad0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8001ad2:	4e43      	ldr	r6, [pc, #268]	; (8001be0 <Vector15C+0x110>)
 8001ad4:	6f75      	ldr	r5, [r6, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 8001ad6:	68ef      	ldr	r7, [r5, #12]
  uint16_t sr = u->SR;
 8001ad8:	682b      	ldr	r3, [r5, #0]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8001ada:	05da      	lsls	r2, r3, #23
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
  uint16_t sr = u->SR;
 8001adc:	b29c      	uxth	r4, r3

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8001ade:	d44f      	bmi.n	8001b80 <Vector15C+0xb0>
 8001ae0:	2320      	movs	r3, #32
 8001ae2:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8001ae6:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8001aea:	d108      	bne.n	8001afe <Vector15C+0x2e>
 8001aec:	e029      	b.n	8001b42 <Vector15C+0x72>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 8001aee:	06a0      	lsls	r0, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 8001af0:	6869      	ldr	r1, [r5, #4]
    if (sr & USART_SR_RXNE)
 8001af2:	d41d      	bmi.n	8001b30 <Vector15C+0x60>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 8001af4:	682c      	ldr	r4, [r5, #0]
 8001af6:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8001af8:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8001afc:	d021      	beq.n	8001b42 <Vector15C+0x72>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8001afe:	0723      	lsls	r3, r4, #28
 8001b00:	d0f5      	beq.n	8001aee <Vector15C+0x1e>
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
  eventflags_t sts = 0;

  if (sr & USART_SR_ORE)
    sts |= SD_OVERRUN_ERROR;
 8001b02:	f014 0f08 	tst.w	r4, #8
 8001b06:	bf0c      	ite	eq
 8001b08:	2100      	moveq	r1, #0
 8001b0a:	2180      	movne	r1, #128	; 0x80
  if (sr & USART_SR_PE)
 8001b0c:	07e0      	lsls	r0, r4, #31
    sts |= SD_PARITY_ERROR;
 8001b0e:	bf48      	it	mi
 8001b10:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 8001b14:	07a2      	lsls	r2, r4, #30
    sts |= SD_FRAMING_ERROR;
 8001b16:	bf48      	it	mi
 8001b18:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 8001b1c:	0763      	lsls	r3, r4, #29
    sts |= SD_NOISE_ERROR;
 8001b1e:	bf48      	it	mi
 8001b20:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8001b24:	482f      	ldr	r0, [pc, #188]	; (8001be4 <Vector15C+0x114>)
 8001b26:	f7ff f9c3 	bl	8000eb0 <chEvtBroadcastFlagsI>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 8001b2a:	06a0      	lsls	r0, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 8001b2c:	6869      	ldr	r1, [r5, #4]
    if (sr & USART_SR_RXNE)
 8001b2e:	d5e1      	bpl.n	8001af4 <Vector15C+0x24>
      sdIncomingDataI(sdp, b);
 8001b30:	b2c9      	uxtb	r1, r1
 8001b32:	482b      	ldr	r0, [pc, #172]	; (8001be0 <Vector15C+0x110>)
 8001b34:	f7ff fce4 	bl	8001500 <sdIncomingDataI>
    sr = u->SR;
 8001b38:	682c      	ldr	r4, [r5, #0]
 8001b3a:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8001b3c:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8001b40:	d1dd      	bne.n	8001afe <Vector15C+0x2e>
 8001b42:	2300      	movs	r3, #0
 8001b44:	f383 8811 	msr	BASEPRI, r3
    sr = u->SR;
  }
  osalSysUnlockFromISR();

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8001b48:	0639      	lsls	r1, r7, #24
 8001b4a:	d501      	bpl.n	8001b50 <Vector15C+0x80>
 8001b4c:	0622      	lsls	r2, r4, #24
 8001b4e:	d426      	bmi.n	8001b9e <Vector15C+0xce>
      u->DR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 8001b50:	0663      	lsls	r3, r4, #25
 8001b52:	d511      	bpl.n	8001b78 <Vector15C+0xa8>
 8001b54:	2320      	movs	r3, #32
 8001b56:	f383 8811 	msr	BASEPRI, r3
 8001b5a:	6c72      	ldr	r2, [r6, #68]	; 0x44
 8001b5c:	6cb3      	ldr	r3, [r6, #72]	; 0x48
 8001b5e:	4820      	ldr	r0, [pc, #128]	; (8001be0 <Vector15C+0x110>)
 8001b60:	429a      	cmp	r2, r3
 8001b62:	d029      	beq.n	8001bb8 <Vector15C+0xe8>
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8001b64:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 8001b68:	403b      	ands	r3, r7
    u->SR = ~USART_SR_TC;
 8001b6a:	f06f 0240 	mvn.w	r2, #64	; 0x40
  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8001b6e:	60eb      	str	r3, [r5, #12]
 8001b70:	2300      	movs	r3, #0
    u->SR = ~USART_SR_TC;
 8001b72:	602a      	str	r2, [r5, #0]
 8001b74:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD6);

  OSAL_IRQ_EPILOGUE();
}
 8001b78:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD6);

  OSAL_IRQ_EPILOGUE();
 8001b7c:	f7fe bde0 	b.w	8000740 <_port_irq_epilogue>
 8001b80:	2320      	movs	r3, #32
 8001b82:	f383 8811 	msr	BASEPRI, r3
 8001b86:	f44f 7100 	mov.w	r1, #512	; 0x200
 8001b8a:	1d30      	adds	r0, r6, #4
 8001b8c:	f7ff f990 	bl	8000eb0 <chEvtBroadcastFlagsI>

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    u->SR = ~USART_SR_LBD;
 8001b90:	f46f 7380 	mvn.w	r3, #256	; 0x100
 8001b94:	602b      	str	r3, [r5, #0]
 8001b96:	2300      	movs	r3, #0
 8001b98:	f383 8811 	msr	BASEPRI, r3
 8001b9c:	e7a0      	b.n	8001ae0 <Vector15C+0x10>
 8001b9e:	2320      	movs	r3, #32
 8001ba0:	f383 8811 	msr	BASEPRI, r3

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
 8001ba4:	4810      	ldr	r0, [pc, #64]	; (8001be8 <Vector15C+0x118>)
 8001ba6:	f7ff fb03 	bl	80011b0 <chOQGetI>
    if (b < Q_OK) {
 8001baa:	2800      	cmp	r0, #0
 8001bac:	db0c      	blt.n	8001bc8 <Vector15C+0xf8>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->DR = b;
 8001bae:	6068      	str	r0, [r5, #4]
 8001bb0:	2300      	movs	r3, #0
 8001bb2:	f383 8811 	msr	BASEPRI, r3
 8001bb6:	e7cb      	b.n	8001b50 <Vector15C+0x80>
 8001bb8:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8001bba:	2b00      	cmp	r3, #0
 8001bbc:	d0d2      	beq.n	8001b64 <Vector15C+0x94>
 8001bbe:	3004      	adds	r0, #4
 8001bc0:	2110      	movs	r1, #16
 8001bc2:	f7ff f975 	bl	8000eb0 <chEvtBroadcastFlagsI>
 8001bc6:	e7cd      	b.n	8001b64 <Vector15C+0x94>
 8001bc8:	4806      	ldr	r0, [pc, #24]	; (8001be4 <Vector15C+0x114>)
 8001bca:	2108      	movs	r1, #8
 8001bcc:	f7ff f970 	bl	8000eb0 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8001bd0:	f64f 733f 	movw	r3, #65343	; 0xff3f
 8001bd4:	403b      	ands	r3, r7
 8001bd6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001bda:	60eb      	str	r3, [r5, #12]
 8001bdc:	e7e8      	b.n	8001bb0 <Vector15C+0xe0>
 8001bde:	bf00      	nop
 8001be0:	20000998 	.word	0x20000998
 8001be4:	2000099c 	.word	0x2000099c
 8001be8:	200009c8 	.word	0x200009c8
 8001bec:	f3af 8000 	nop.w

08001bf0 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8001bf0:	b510      	push	{r4, lr}
  sdObjectInit(&SD5, NULL, notify5);
  SD5.usart = UART5;
#endif

#if STM32_SERIAL_USE_USART6
  sdObjectInit(&SD6, NULL, notify6);
 8001bf2:	4c04      	ldr	r4, [pc, #16]	; (8001c04 <sd_lld_init+0x14>)
 8001bf4:	4a04      	ldr	r2, [pc, #16]	; (8001c08 <sd_lld_init+0x18>)
 8001bf6:	4620      	mov	r0, r4
 8001bf8:	2100      	movs	r1, #0
 8001bfa:	f7ff fc51 	bl	80014a0 <sdObjectInit>
  SD6.usart = USART6;
 8001bfe:	4b03      	ldr	r3, [pc, #12]	; (8001c0c <sd_lld_init+0x1c>)
 8001c00:	6763      	str	r3, [r4, #116]	; 0x74
 8001c02:	bd10      	pop	{r4, pc}
 8001c04:	20000998 	.word	0x20000998
 8001c08:	08001ac1 	.word	0x08001ac1
 8001c0c:	40011400 	.word	0x40011400

08001c10 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8001c10:	b538      	push	{r3, r4, r5, lr}

  if (config == NULL)
    config = &default_config;
 8001c12:	4c1f      	ldr	r4, [pc, #124]	; (8001c90 <sd_lld_start+0x80>)

  if (sdp->state == SD_STOP) {
 8001c14:	7a03      	ldrb	r3, [r0, #8]
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
 8001c16:	2900      	cmp	r1, #0
 8001c18:	bf18      	it	ne
 8001c1a:	460c      	movne	r4, r1

  if (sdp->state == SD_STOP) {
 8001c1c:	2b01      	cmp	r3, #1
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8001c1e:	4605      	mov	r5, r0

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8001c20:	d022      	beq.n	8001c68 <sd_lld_start+0x58>
 8001c22:	6f6b      	ldr	r3, [r5, #116]	; 0x74
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 8001c24:	4a1b      	ldr	r2, [pc, #108]	; (8001c94 <sd_lld_start+0x84>)
 8001c26:	4293      	cmp	r3, r2
 8001c28:	d02b      	beq.n	8001c82 <sd_lld_start+0x72>
 8001c2a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001c2e:	4293      	cmp	r3, r2
 8001c30:	d027      	beq.n	8001c82 <sd_lld_start+0x72>
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;
 8001c32:	6821      	ldr	r1, [r4, #0]
 8001c34:	4a18      	ldr	r2, [pc, #96]	; (8001c98 <sd_lld_start+0x88>)
 8001c36:	fbb2 f2f1 	udiv	r2, r2, r1
 8001c3a:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8001c3c:	88a2      	ldrh	r2, [r4, #4]
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8001c3e:	88e0      	ldrh	r0, [r4, #6]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8001c40:	8921      	ldrh	r1, [r4, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8001c42:	f442 5204 	orr.w	r2, r2, #8448	; 0x2100
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8001c46:	f040 0040 	orr.w	r0, r0, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8001c4a:	f042 022c 	orr.w	r2, r2, #44	; 0x2c
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8001c4e:	f041 0101 	orr.w	r1, r1, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8001c52:	b292      	uxth	r2, r2
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8001c54:	b280      	uxth	r0, r0
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8001c56:	b289      	uxth	r1, r1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8001c58:	2400      	movs	r4, #0
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8001c5a:	6118      	str	r0, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8001c5c:	6159      	str	r1, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8001c5e:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8001c60:	601c      	str	r4, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8001c62:	681a      	ldr	r2, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8001c64:	685b      	ldr	r3, [r3, #4]
 8001c66:	bd38      	pop	{r3, r4, r5, pc}
      rccEnableUART5(FALSE);
      nvicEnableVector(STM32_UART5_NUMBER, STM32_SERIAL_UART5_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART6
    if (&SD6 == sdp) {
 8001c68:	4b0c      	ldr	r3, [pc, #48]	; (8001c9c <sd_lld_start+0x8c>)
 8001c6a:	4298      	cmp	r0, r3
 8001c6c:	d1d9      	bne.n	8001c22 <sd_lld_start+0x12>
      rccEnableUSART6(FALSE);
 8001c6e:	4a0c      	ldr	r2, [pc, #48]	; (8001ca0 <sd_lld_start+0x90>)
 8001c70:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8001c72:	f043 0320 	orr.w	r3, r3, #32
 8001c76:	6453      	str	r3, [r2, #68]	; 0x44
      nvicEnableVector(STM32_USART6_NUMBER, STM32_SERIAL_USART6_PRIORITY);
 8001c78:	2047      	movs	r0, #71	; 0x47
 8001c7a:	210c      	movs	r1, #12
 8001c7c:	f7ff fc80 	bl	8001580 <nvicEnableVector>
 8001c80:	e7cf      	b.n	8001c22 <sd_lld_start+0x12>
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8001c82:	6821      	ldr	r1, [r4, #0]
 8001c84:	4a07      	ldr	r2, [pc, #28]	; (8001ca4 <sd_lld_start+0x94>)
 8001c86:	fbb2 f2f1 	udiv	r2, r2, r1
 8001c8a:	609a      	str	r2, [r3, #8]
 8001c8c:	e7d6      	b.n	8001c3c <sd_lld_start+0x2c>
 8001c8e:	bf00      	nop
 8001c90:	08002390 	.word	0x08002390
 8001c94:	40011000 	.word	0x40011000
 8001c98:	023c3460 	.word	0x023c3460
 8001c9c:	20000998 	.word	0x20000998
 8001ca0:	40023800 	.word	0x40023800
 8001ca4:	047868c0 	.word	0x047868c0
 8001ca8:	f3af 8000 	nop.w
 8001cac:	f3af 8000 	nop.w

08001cb0 <__early_init>:
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
 8001cb0:	f7ff bcbe 	b.w	8001630 <stm32_clock_init>
 8001cb4:	f3af 8000 	nop.w
 8001cb8:	f3af 8000 	nop.w
 8001cbc:	f3af 8000 	nop.w

08001cc0 <boardInit>:

/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
 8001cc0:	4770      	bx	lr
 8001cc2:	bf00      	nop
 8001cc4:	f3af 8000 	nop.w
 8001cc8:	f3af 8000 	nop.w
 8001ccc:	f3af 8000 	nop.w

08001cd0 <long_to_string_with_divisor.constprop.0>:
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
 8001cd0:	b4f0      	push	{r4, r5, r6, r7}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8001cd2:	f100 070b 	add.w	r7, r0, #11
 8001cd6:	463c      	mov	r4, r7
 8001cd8:	460d      	mov	r5, r1
  do {
    i = (int)(l % radix);
 8001cda:	fbb1 f6f2 	udiv	r6, r1, r2
 8001cde:	fb02 1116 	mls	r1, r2, r6, r1
    i += '0';
 8001ce2:	f101 0330 	add.w	r3, r1, #48	; 0x30
    if (i > '9')
 8001ce6:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
 8001ce8:	bfc8      	it	gt
 8001cea:	f101 0337 	addgt.w	r3, r1, #55	; 0x37
    *--q = i;
 8001cee:	b2db      	uxtb	r3, r3
 8001cf0:	f804 3d01 	strb.w	r3, [r4, #-1]!
    l /= radix;
  } while ((ll /= radix) != 0);
 8001cf4:	fbb5 f5f2 	udiv	r5, r5, r2
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
 8001cf8:	4631      	mov	r1, r6
  } while ((ll /= radix) != 0);
 8001cfa:	2d00      	cmp	r5, #0
 8001cfc:	d1ed      	bne.n	8001cda <long_to_string_with_divisor.constprop.0+0xa>

  i = (int)(p + MAX_FILLER - q);
 8001cfe:	1b3a      	subs	r2, r7, r4
 8001d00:	4402      	add	r2, r0
 8001d02:	e001      	b.n	8001d08 <long_to_string_with_divisor.constprop.0+0x38>
 8001d04:	f814 3f01 	ldrb.w	r3, [r4, #1]!
  do
    *p++ = *q++;
 8001d08:	f800 3b01 	strb.w	r3, [r0], #1
  while (--i);
 8001d0c:	4290      	cmp	r0, r2
 8001d0e:	d1f9      	bne.n	8001d04 <long_to_string_with_divisor.constprop.0+0x34>

  return p;
}
 8001d10:	bcf0      	pop	{r4, r5, r6, r7}
 8001d12:	4770      	bx	lr
 8001d14:	f3af 8000 	nop.w
 8001d18:	f3af 8000 	nop.w
 8001d1c:	f3af 8000 	nop.w

08001d20 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8001d20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001d24:	b087      	sub	sp, #28
 8001d26:	4615      	mov	r5, r2
 8001d28:	f10d 030d 	add.w	r3, sp, #13
 8001d2c:	aa03      	add	r2, sp, #12
 8001d2e:	1a9b      	subs	r3, r3, r2
 8001d30:	4681      	mov	r9, r0
 8001d32:	468a      	mov	sl, r1
 8001d34:	9301      	str	r3, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8001d36:	f04f 0800 	mov.w	r8, #0
 8001d3a:	468b      	mov	fp, r1
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 8001d3c:	f89b 1000 	ldrb.w	r1, [fp]
 8001d40:	f10b 0301 	add.w	r3, fp, #1
    if (c == 0)
 8001d44:	b179      	cbz	r1, 8001d66 <chvprintf+0x46>
      return n;
    if (c != '%') {
 8001d46:	2925      	cmp	r1, #37	; 0x25
 8001d48:	d011      	beq.n	8001d6e <chvprintf+0x4e>
      chSequentialStreamPut(chp, (uint8_t)c);
 8001d4a:	f8d9 2000 	ldr.w	r2, [r9]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 8001d4e:	469b      	mov	fp, r3
    if (c == 0)
      return n;
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
 8001d50:	6892      	ldr	r2, [r2, #8]
 8001d52:	4648      	mov	r0, r9
 8001d54:	4790      	blx	r2
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 8001d56:	f89b 1000 	ldrb.w	r1, [fp]
    if (c == 0)
      return n;
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
 8001d5a:	f108 0801 	add.w	r8, r8, #1
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 8001d5e:	f10b 0301 	add.w	r3, fp, #1
    if (c == 0)
 8001d62:	2900      	cmp	r1, #0
 8001d64:	d1ef      	bne.n	8001d46 <chvprintf+0x26>
      chSequentialStreamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 8001d66:	4640      	mov	r0, r8
 8001d68:	b007      	add	sp, #28
 8001d6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 8001d6e:	f89b 2001 	ldrb.w	r2, [fp, #1]
 8001d72:	2a2d      	cmp	r2, #45	; 0x2d
 8001d74:	bf03      	ittte	eq
 8001d76:	f89b 2002 	ldrbeq.w	r2, [fp, #2]
      fmt++;
 8001d7a:	f10b 0302 	addeq.w	r3, fp, #2
      left_align = TRUE;
 8001d7e:	f04f 0a01 	moveq.w	sl, #1
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
 8001d82:	f04f 0a00 	movne.w	sl, #0
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
 8001d86:	2a30      	cmp	r2, #48	; 0x30
 8001d88:	bf03      	ittte	eq
 8001d8a:	785a      	ldrbeq	r2, [r3, #1]
      fmt++;
 8001d8c:	3301      	addeq	r3, #1
      filler = '0';
 8001d8e:	2730      	moveq	r7, #48	; 0x30
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
 8001d90:	2720      	movne	r7, #32
 8001d92:	1c59      	adds	r1, r3, #1
    if (*fmt == '0') {
      fmt++;
      filler = '0';
    }
    width = 0;
 8001d94:	2600      	movs	r6, #0
 8001d96:	e006      	b.n	8001da6 <chvprintf+0x86>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
 8001d98:	782b      	ldrb	r3, [r5, #0]
 8001d9a:	3504      	adds	r5, #4
 8001d9c:	f89b 2000 	ldrb.w	r2, [fp]
      else
        break;
      width = width * 10 + c;
 8001da0:	eb03 0640 	add.w	r6, r3, r0, lsl #1
 8001da4:	3101      	adds	r1, #1
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 8001da6:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8001daa:	b2db      	uxtb	r3, r3
 8001dac:	2b09      	cmp	r3, #9
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
 8001dae:	468b      	mov	fp, r1
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
 8001db0:	eb06 0086 	add.w	r0, r6, r6, lsl #2
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 8001db4:	d9f2      	bls.n	8001d9c <chvprintf+0x7c>
        c -= '0';
      else if (c == '*')
 8001db6:	2a2a      	cmp	r2, #42	; 0x2a
 8001db8:	d0ee      	beq.n	8001d98 <chvprintf+0x78>
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
 8001dba:	2a2e      	cmp	r2, #46	; 0x2e
 8001dbc:	f04f 0100 	mov.w	r1, #0
 8001dc0:	d043      	beq.n	8001e4a <chvprintf+0x12a>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8001dc2:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 8001dc6:	2b4c      	cmp	r3, #76	; 0x4c
 8001dc8:	d04e      	beq.n	8001e68 <chvprintf+0x148>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8001dca:	f1a2 0044 	sub.w	r0, r2, #68	; 0x44
 8001dce:	2834      	cmp	r0, #52	; 0x34
 8001dd0:	f200 80f7 	bhi.w	8001fc2 <chvprintf+0x2a2>
 8001dd4:	e8df f010 	tbh	[pc, r0, lsl #1]
 8001dd8:	00f500ea 	.word	0x00f500ea
 8001ddc:	00f500f5 	.word	0x00f500f5
 8001de0:	00ea00f5 	.word	0x00ea00f5
 8001de4:	00f500f5 	.word	0x00f500f5
 8001de8:	00f500f5 	.word	0x00f500f5
 8001dec:	00e800f5 	.word	0x00e800f5
 8001df0:	00f500f5 	.word	0x00f500f5
 8001df4:	00f500f5 	.word	0x00f500f5
 8001df8:	00dd00f5 	.word	0x00dd00f5
 8001dfc:	00f500f5 	.word	0x00f500f5
 8001e00:	00f500f2 	.word	0x00f500f2
 8001e04:	00f500f5 	.word	0x00f500f5
 8001e08:	00f500f5 	.word	0x00f500f5
 8001e0c:	00f500f5 	.word	0x00f500f5
 8001e10:	00f500f5 	.word	0x00f500f5
 8001e14:	00a100f5 	.word	0x00a100f5
 8001e18:	00f500ea 	.word	0x00f500ea
 8001e1c:	00f500f5 	.word	0x00f500f5
 8001e20:	00ea00f5 	.word	0x00ea00f5
 8001e24:	00f500f5 	.word	0x00f500f5
 8001e28:	00f500f5 	.word	0x00f500f5
 8001e2c:	00e800f5 	.word	0x00e800f5
 8001e30:	00f500f5 	.word	0x00f500f5
 8001e34:	007100f5 	.word	0x007100f5
 8001e38:	00dd00f5 	.word	0x00dd00f5
 8001e3c:	00f500f5 	.word	0x00f500f5
 8001e40:	00f2      	.short	0x00f2
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
 8001e42:	782b      	ldrb	r3, [r5, #0]
 8001e44:	3504      	adds	r5, #4
        else
          break;
        precision *= 10;
        precision += c;
 8001e46:	eb03 0140 	add.w	r1, r3, r0, lsl #1
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 8001e4a:	f81b 2b01 	ldrb.w	r2, [fp], #1
        if (c >= '0' && c <= '9')
 8001e4e:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8001e52:	b2db      	uxtb	r3, r3
 8001e54:	2b09      	cmp	r3, #9
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
        else
          break;
        precision *= 10;
 8001e56:	eb01 0081 	add.w	r0, r1, r1, lsl #2
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
 8001e5a:	d9f4      	bls.n	8001e46 <chvprintf+0x126>
          c -= '0';
        else if (c == '*')
 8001e5c:	2a2a      	cmp	r2, #42	; 0x2a
 8001e5e:	d0f0      	beq.n	8001e42 <chvprintf+0x122>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8001e60:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 8001e64:	2b4c      	cmp	r3, #76	; 0x4c
 8001e66:	d1b0      	bne.n	8001dca <chvprintf+0xaa>
      is_long = TRUE;
      if (*fmt)
 8001e68:	f89b 3000 	ldrb.w	r3, [fp]
 8001e6c:	2b00      	cmp	r3, #0
 8001e6e:	f000 80a8 	beq.w	8001fc2 <chvprintf+0x2a2>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8001e72:	f1a3 0244 	sub.w	r2, r3, #68	; 0x44
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 8001e76:	f10b 0b01 	add.w	fp, fp, #1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8001e7a:	2a34      	cmp	r2, #52	; 0x34
 8001e7c:	f200 80a0 	bhi.w	8001fc0 <chvprintf+0x2a0>
 8001e80:	e8df f002 	tbb	[pc, r2]
 8001e84:	9e9e9e94 	.word	0x9e9e9e94
 8001e88:	9e9e949e 	.word	0x9e9e949e
 8001e8c:	929e9e9e 	.word	0x929e9e9e
 8001e90:	9e9e9e9e 	.word	0x9e9e9e9e
 8001e94:	9e9e879e 	.word	0x9e9e879e
 8001e98:	9e9e9e9c 	.word	0x9e9e9e9c
 8001e9c:	9e9e9e9e 	.word	0x9e9e9e9e
 8001ea0:	4b9e9e9e 	.word	0x4b9e9e9e
 8001ea4:	9e9e9e94 	.word	0x9e9e9e94
 8001ea8:	9e9e949e 	.word	0x9e9e949e
 8001eac:	929e9e9e 	.word	0x929e9e9e
 8001eb0:	1b9e9e9e 	.word	0x1b9e9e9e
 8001eb4:	9e9e879e 	.word	0x9e9e879e
 8001eb8:	9c          	.byte	0x9c
 8001eb9:	00          	.byte	0x00
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8001eba:	682c      	ldr	r4, [r5, #0]
        s = "(null)";
 8001ebc:	4b5a      	ldr	r3, [pc, #360]	; (8002028 <chvprintf+0x308>)
 8001ebe:	2c00      	cmp	r4, #0
 8001ec0:	bf08      	it	eq
 8001ec2:	461c      	moveq	r4, r3
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8001ec4:	3504      	adds	r5, #4
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8001ec6:	7823      	ldrb	r3, [r4, #0]
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
 8001ec8:	2900      	cmp	r1, #0
 8001eca:	f000 8094 	beq.w	8001ff6 <chvprintf+0x2d6>
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8001ece:	2b00      	cmp	r3, #0
 8001ed0:	f000 8096 	beq.w	8002000 <chvprintf+0x2e0>
 8001ed4:	3901      	subs	r1, #1
 8001ed6:	4620      	mov	r0, r4
 8001ed8:	e001      	b.n	8001ede <chvprintf+0x1be>
 8001eda:	3901      	subs	r1, #1
 8001edc:	d403      	bmi.n	8001ee6 <chvprintf+0x1c6>
 8001ede:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8001ee2:	2b00      	cmp	r3, #0
 8001ee4:	d1f9      	bne.n	8001eda <chvprintf+0x1ba>
 8001ee6:	1b00      	subs	r0, r0, r4
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 8001ee8:	1a36      	subs	r6, r6, r0
 8001eea:	1e43      	subs	r3, r0, #1
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 8001eec:	2720      	movs	r7, #32
 8001eee:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8001ef2:	f1ba 0f00 	cmp.w	sl, #0
 8001ef6:	d01f      	beq.n	8001f38 <chvprintf+0x218>
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8001ef8:	2b00      	cmp	r3, #0
 8001efa:	9300      	str	r3, [sp, #0]
 8001efc:	da34      	bge.n	8001f68 <chvprintf+0x248>
      chSequentialStreamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8001efe:	2e00      	cmp	r6, #0
 8001f00:	f43f af1c 	beq.w	8001d3c <chvprintf+0x1c>
 8001f04:	4634      	mov	r4, r6
      chSequentialStreamPut(chp, (uint8_t)filler);
 8001f06:	f8d9 3000 	ldr.w	r3, [r9]
 8001f0a:	4648      	mov	r0, r9
 8001f0c:	689b      	ldr	r3, [r3, #8]
 8001f0e:	4639      	mov	r1, r7
 8001f10:	4798      	blx	r3
    while (--i >= 0) {
      chSequentialStreamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8001f12:	3c01      	subs	r4, #1
 8001f14:	d1f7      	bne.n	8001f06 <chvprintf+0x1e6>
 8001f16:	44b0      	add	r8, r6
 8001f18:	e710      	b.n	8001d3c <chvprintf+0x1c>

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 8001f1a:	682b      	ldr	r3, [r5, #0]
 8001f1c:	f88d 300c 	strb.w	r3, [sp, #12]
 8001f20:	9b01      	ldr	r3, [sp, #4]
 8001f22:	3504      	adds	r5, #4
 8001f24:	4618      	mov	r0, r3
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 8001f26:	2720      	movs	r7, #32
 8001f28:	3b01      	subs	r3, #1
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8001f2a:	ac03      	add	r4, sp, #12
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 8001f2c:	1a36      	subs	r6, r6, r0
 8001f2e:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      width = 0;
    if (left_align == FALSE)
 8001f32:	f1ba 0f00 	cmp.w	sl, #0
 8001f36:	d1df      	bne.n	8001ef8 <chvprintf+0x1d8>
 8001f38:	9300      	str	r3, [sp, #0]
      width = -width;
 8001f3a:	f1c6 0a00 	rsb	sl, r6, #0
    if (width < 0) {
 8001f3e:	f1ba 0f00 	cmp.w	sl, #0
 8001f42:	d045      	beq.n	8001fd0 <chvprintf+0x2b0>
      if (*s == '-' && filler == '0') {
 8001f44:	7821      	ldrb	r1, [r4, #0]
 8001f46:	292d      	cmp	r1, #45	; 0x2d
 8001f48:	d047      	beq.n	8001fda <chvprintf+0x2ba>
        chSequentialStreamPut(chp, (uint8_t)*s++);
        n++;
 8001f4a:	4656      	mov	r6, sl
        i--;
      }
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
 8001f4c:	f8d9 3000 	ldr.w	r3, [r9]
 8001f50:	4648      	mov	r0, r9
 8001f52:	689b      	ldr	r3, [r3, #8]
 8001f54:	4639      	mov	r1, r7
 8001f56:	4798      	blx	r3
        n++;
      } while (++width != 0);
 8001f58:	3601      	adds	r6, #1
 8001f5a:	d1f7      	bne.n	8001f4c <chvprintf+0x22c>
    }
    while (--i >= 0) {
 8001f5c:	9b00      	ldr	r3, [sp, #0]
 8001f5e:	2b00      	cmp	r3, #0
 8001f60:	ebca 0808 	rsb	r8, sl, r8
 8001f64:	f6ff aeea 	blt.w	8001d3c <chvprintf+0x1c>
 8001f68:	f8dd a000 	ldr.w	sl, [sp]
      chSequentialStreamPut(chp, (uint8_t)*s++);
 8001f6c:	f8d9 3000 	ldr.w	r3, [r9]
 8001f70:	f814 1b01 	ldrb.w	r1, [r4], #1
 8001f74:	689b      	ldr	r3, [r3, #8]
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8001f76:	f10a 3aff 	add.w	sl, sl, #4294967295
      chSequentialStreamPut(chp, (uint8_t)*s++);
 8001f7a:	4648      	mov	r0, r9
 8001f7c:	4798      	blx	r3
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8001f7e:	f1ba 3fff 	cmp.w	sl, #4294967295
 8001f82:	d1f3      	bne.n	8001f6c <chvprintf+0x24c>
 8001f84:	9b00      	ldr	r3, [sp, #0]
 8001f86:	f108 0801 	add.w	r8, r8, #1
 8001f8a:	2b00      	cmp	r3, #0
 8001f8c:	bfa8      	it	ge
 8001f8e:	4498      	addge	r8, r3
 8001f90:	e7b5      	b.n	8001efe <chvprintf+0x1de>
      c = 16;
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
      goto unsigned_common;
 8001f92:	220a      	movs	r2, #10
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 8001f94:	6829      	ldr	r1, [r5, #0]
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8001f96:	a803      	add	r0, sp, #12
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 8001f98:	3504      	adds	r5, #4
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8001f9a:	f7ff fe99 	bl	8001cd0 <long_to_string_with_divisor.constprop.0>
 8001f9e:	ab03      	add	r3, sp, #12
 8001fa0:	1ac0      	subs	r0, r0, r3
 8001fa2:	1e43      	subs	r3, r0, #1
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8001fa4:	ac03      	add	r4, sp, #12
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
 8001fa6:	e7c1      	b.n	8001f2c <chvprintf+0x20c>
 8001fa8:	2208      	movs	r2, #8
 8001faa:	e7f3      	b.n	8001f94 <chvprintf+0x274>
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 8001fac:	6829      	ldr	r1, [r5, #0]
      if (l < 0) {
 8001fae:	2900      	cmp	r1, #0
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 8001fb0:	f105 0504 	add.w	r5, r5, #4
      if (l < 0) {
 8001fb4:	db2e      	blt.n	8002014 <chvprintf+0x2f4>
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 8001fb6:	a803      	add	r0, sp, #12
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8001fb8:	220a      	movs	r2, #10
 8001fba:	e7ee      	b.n	8001f9a <chvprintf+0x27a>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8001fbc:	2210      	movs	r2, #16
 8001fbe:	e7e9      	b.n	8001f94 <chvprintf+0x274>
 8001fc0:	461a      	mov	r2, r3
 8001fc2:	9b01      	ldr	r3, [sp, #4]
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8001fc4:	f88d 200c 	strb.w	r2, [sp, #12]
 8001fc8:	4618      	mov	r0, r3
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8001fca:	ac03      	add	r4, sp, #12
 8001fcc:	3b01      	subs	r3, #1
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
      break;
 8001fce:	e7ad      	b.n	8001f2c <chvprintf+0x20c>
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8001fd0:	9b00      	ldr	r3, [sp, #0]
 8001fd2:	2b00      	cmp	r3, #0
 8001fd4:	4656      	mov	r6, sl
 8001fd6:	dac7      	bge.n	8001f68 <chvprintf+0x248>
 8001fd8:	e6b0      	b.n	8001d3c <chvprintf+0x1c>
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
 8001fda:	2f30      	cmp	r7, #48	; 0x30
 8001fdc:	d1b5      	bne.n	8001f4a <chvprintf+0x22a>
        chSequentialStreamPut(chp, (uint8_t)*s++);
 8001fde:	f8d9 3000 	ldr.w	r3, [r9]
 8001fe2:	4648      	mov	r0, r9
 8001fe4:	689b      	ldr	r3, [r3, #8]
 8001fe6:	4798      	blx	r3
 8001fe8:	9b00      	ldr	r3, [sp, #0]
 8001fea:	3b01      	subs	r3, #1
 8001fec:	3401      	adds	r4, #1
        n++;
 8001fee:	f108 0801 	add.w	r8, r8, #1
 8001ff2:	9300      	str	r3, [sp, #0]
 8001ff4:	e7a9      	b.n	8001f4a <chvprintf+0x22a>
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8001ff6:	f647 71fe 	movw	r1, #32766	; 0x7ffe
 8001ffa:	2b00      	cmp	r3, #0
 8001ffc:	f47f af6b 	bne.w	8001ed6 <chvprintf+0x1b6>
 8002000:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8002004:	f1ba 0f00 	cmp.w	sl, #0
 8002008:	d10b      	bne.n	8002022 <chvprintf+0x302>
 800200a:	f04f 33ff 	mov.w	r3, #4294967295
 800200e:	9300      	str	r3, [sp, #0]
 8002010:	2720      	movs	r7, #32
 8002012:	e792      	b.n	8001f3a <chvprintf+0x21a>
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8002014:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 8002016:	4249      	negs	r1, r1
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8002018:	f88d 300c 	strb.w	r3, [sp, #12]
 800201c:	f10d 000d 	add.w	r0, sp, #13
 8002020:	e7ca      	b.n	8001fb8 <chvprintf+0x298>
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8002022:	2720      	movs	r7, #32
 8002024:	e76b      	b.n	8001efe <chvprintf+0x1de>
 8002026:	bf00      	nop
 8002028:	080024a0 	.word	0x080024a0
 800202c:	f3af 8000 	nop.w

08002030 <get>:
static msg_t get(void *ip) {

  (void)ip;

  return 4;
}
 8002030:	2004      	movs	r0, #4
 8002032:	4770      	bx	lr
 8002034:	f3af 8000 	nop.w
 8002038:	f3af 8000 	nop.w
 800203c:	f3af 8000 	nop.w

08002040 <reads>:
  (void)ip;
  (void)bp;
  (void)n;

  return 0;
}
 8002040:	2000      	movs	r0, #0
 8002042:	4770      	bx	lr
 8002044:	f3af 8000 	nop.w
 8002048:	f3af 8000 	nop.w
 800204c:	f3af 8000 	nop.w

08002050 <put>:
extern void Debug_ITMDebugOutputChar(char ch);

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static msg_t put(void *ip, uint8_t b) {
 8002050:	b508      	push	{r3, lr}

  (void)ip;
  
  Debug_ITMDebugOutputChar(b);
 8002052:	4608      	mov	r0, r1
 8002054:	f000 f94c 	bl	80022f0 <Debug_ITMDebugOutputChar>

  return 1;
}
 8002058:	2001      	movs	r0, #1
 800205a:	bd08      	pop	{r3, pc}
 800205c:	f3af 8000 	nop.w

08002060 <writes>:
  (void)ip;

  return 4;
}

static size_t writes(void *ip, const uint8_t *bp, size_t n) {
 8002060:	b570      	push	{r4, r5, r6, lr}
  size_t cnt = n;

  while (cnt > 0) {
 8002062:	4616      	mov	r6, r2
 8002064:	b13a      	cbz	r2, 8002076 <writes+0x16>
 8002066:	460d      	mov	r5, r1
 8002068:	4614      	mov	r4, r2
/*===========================================================================*/
static msg_t put(void *ip, uint8_t b) {

  (void)ip;
  
  Debug_ITMDebugOutputChar(b);
 800206a:	f815 0b01 	ldrb.w	r0, [r5], #1
 800206e:	f000 f93f 	bl	80022f0 <Debug_ITMDebugOutputChar>
}

static size_t writes(void *ip, const uint8_t *bp, size_t n) {
  size_t cnt = n;

  while (cnt > 0) {
 8002072:	3c01      	subs	r4, #1
 8002074:	d1f9      	bne.n	800206a <writes+0xa>
    bp++;
    cnt--;
  }

  return n;
}
 8002076:	4630      	mov	r0, r6
 8002078:	bd70      	pop	{r4, r5, r6, pc}
 800207a:	bf00      	nop
 800207c:	f3af 8000 	nop.w

08002080 <itmObjectInit>:
 * @brief   ITM stream object initialization.
 *
 * @param[out] pitm      pointer to the @p ITMStream object to be initialized
 */
void itmObjectInit(ITMStream *pitm) {
   pitm->vmt = &vmt;
 8002080:	4b01      	ldr	r3, [pc, #4]	; (8002088 <itmObjectInit+0x8>)
 8002082:	6003      	str	r3, [r0, #0]
 8002084:	4770      	bx	lr
 8002086:	bf00      	nop
 8002088:	080024b0 	.word	0x080024b0
 800208c:	f3af 8000 	nop.w

08002090 <println>:
  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
  }
}

static void println(char *p) {
 8002090:	b570      	push	{r4, r5, r6, lr}

  while (*p) {
 8002092:	7801      	ldrb	r1, [r0, #0]
 8002094:	4d09      	ldr	r5, [pc, #36]	; (80020bc <println+0x2c>)
  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
  }
}

static void println(char *p) {
 8002096:	4604      	mov	r4, r0

  while (*p) {
 8002098:	b139      	cbz	r1, 80020aa <println+0x1a>
    chSequentialStreamPut(&SD6, *p++);
 800209a:	682b      	ldr	r3, [r5, #0]
 800209c:	4807      	ldr	r0, [pc, #28]	; (80020bc <println+0x2c>)
 800209e:	689b      	ldr	r3, [r3, #8]
 80020a0:	4798      	blx	r3
  }
}

static void println(char *p) {

  while (*p) {
 80020a2:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 80020a6:	2900      	cmp	r1, #0
 80020a8:	d1f7      	bne.n	800209a <println+0xa>
    chSequentialStreamPut(&SD6, *p++);
  }
  chSequentialStreamWrite(&SD6, (uint8_t *)"\r\n", 2);
 80020aa:	682b      	ldr	r3, [r5, #0]
 80020ac:	4803      	ldr	r0, [pc, #12]	; (80020bc <println+0x2c>)
 80020ae:	681b      	ldr	r3, [r3, #0]
 80020b0:	4903      	ldr	r1, [pc, #12]	; (80020c0 <println+0x30>)
 80020b2:	2202      	movs	r2, #2
}
 80020b4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
static void println(char *p) {

  while (*p) {
    chSequentialStreamPut(&SD6, *p++);
  }
  chSequentialStreamWrite(&SD6, (uint8_t *)"\r\n", 2);
 80020b8:	4718      	bx	r3
 80020ba:	bf00      	nop
 80020bc:	20000998 	.word	0x20000998
 80020c0:	080024e0 	.word	0x080024e0
 80020c4:	f3af 8000 	nop.w
 80020c8:	f3af 8000 	nop.w
 80020cc:	f3af 8000 	nop.w

080020d0 <WorkerThread>:
  unsigned me = (unsigned)arg;
  unsigned target;
  unsigned r;
  msg_t msg;

  chRegSetThreadName("worker");
 80020d0:	4b27      	ldr	r3, [pc, #156]	; (8002170 <WorkerThread+0xa0>)
 80020d2:	4a28      	ldr	r2, [pc, #160]	; (8002174 <WorkerThread+0xa4>)
 80020d4:	699b      	ldr	r3, [r3, #24]

/*
 * Test worker threads.
 */
static THD_WORKING_AREA(waWorkerThread[NUM_THREADS], 128);
static msg_t WorkerThread(void *arg) {
 80020d6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80020da:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 8002184 <WorkerThread+0xb4>
  unsigned me = (unsigned)arg;
  unsigned target;
  unsigned r;
  msg_t msg;

  chRegSetThreadName("worker");
 80020de:	619a      	str	r2, [r3, #24]
 80020e0:	4b25      	ldr	r3, [pc, #148]	; (8002178 <WorkerThread+0xa8>)
 80020e2:	f8df b0a4 	ldr.w	fp, [pc, #164]	; 8002188 <WorkerThread+0xb8>
 80020e6:	eb00 0580 	add.w	r5, r0, r0, lsl #2
 80020ea:	0906      	lsrs	r6, r0, #4

/*
 * Test worker threads.
 */
static THD_WORKING_AREA(waWorkerThread[NUM_THREADS], 128);
static msg_t WorkerThread(void *arg) {
 80020ec:	b083      	sub	sp, #12
 80020ee:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
 80020f2:	f106 38ff 	add.w	r8, r6, #4294967295
 80020f6:	1e47      	subs	r7, r0, #1
 80020f8:	1c44      	adds	r4, r0, #1
      if (msg != MSG_OK)
        saturated = TRUE;
    }
    else {
      /* Provides a visual feedback about the system.*/
      if (++cnt >= 500) {
 80020fa:	46d1      	mov	r9, sl
  chRegSetThreadName("worker");

  /* Work loop.*/
  while (TRUE) {
    /* Waiting for a message.*/
   chMBFetch(&mb[me], &msg, TIME_INFINITE);
 80020fc:	f04f 32ff 	mov.w	r2, #4294967295
 8002100:	4628      	mov	r0, r5
 8002102:	a901      	add	r1, sp, #4
 8002104:	f7fe ff74 	bl	8000ff0 <chMBFetch>
   }
#else
   /* Fixed delay.*/
   {
     r = me >> 4;
     while (r--)
 8002108:	4642      	mov	r2, r8
 800210a:	b13e      	cbz	r6, 800211c <WorkerThread+0x4c>
       x++;
 800210c:	f8db 3000 	ldr.w	r3, [fp]
   }
#else
   /* Fixed delay.*/
   {
     r = me >> 4;
     while (r--)
 8002110:	3a01      	subs	r2, #1
       x++;
 8002112:	3301      	adds	r3, #1
 8002114:	f8cb 3000 	str.w	r3, [fp]
   }
#else
   /* Fixed delay.*/
   {
     r = me >> 4;
     while (r--)
 8002118:	1c53      	adds	r3, r2, #1
 800211a:	d1f7      	bne.n	800210c <WorkerThread+0x3c>
       x++;
   }
#endif

    /* Deciding in which direction to re-send the message.*/
    if (msg == MSG_SEND_LEFT)
 800211c:	9901      	ldr	r1, [sp, #4]
      target = me - 1;
    else
      target = me + 1;
 800211e:	2900      	cmp	r1, #0
 8002120:	bf0c      	ite	eq
 8002122:	4638      	moveq	r0, r7
 8002124:	4620      	movne	r0, r4

    if (target < NUM_THREADS) {
 8002126:	2803      	cmp	r0, #3
 8002128:	d912      	bls.n	8002150 <WorkerThread+0x80>
      if (msg != MSG_OK)
        saturated = TRUE;
    }
    else {
      /* Provides a visual feedback about the system.*/
      if (++cnt >= 500) {
 800212a:	f8da 3000 	ldr.w	r3, [sl]
 800212e:	3301      	adds	r3, #1
 8002130:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8002134:	d202      	bcs.n	800213c <WorkerThread+0x6c>
 8002136:	f8c9 3000 	str.w	r3, [r9]
 800213a:	e7df      	b.n	80020fc <WorkerThread+0x2c>
        cnt = 0;
 800213c:	2300      	movs	r3, #0
 800213e:	f8c9 3000 	str.w	r3, [r9]
        palTogglePad(GPIOG, GPIOG_PIN6);
 8002142:	4b0e      	ldr	r3, [pc, #56]	; (800217c <WorkerThread+0xac>)
 8002144:	4a0d      	ldr	r2, [pc, #52]	; (800217c <WorkerThread+0xac>)
 8002146:	695b      	ldr	r3, [r3, #20]
 8002148:	f083 0340 	eor.w	r3, r3, #64	; 0x40
 800214c:	6153      	str	r3, [r2, #20]
 800214e:	e7d5      	b.n	80020fc <WorkerThread+0x2c>
      target = me + 1;

    if (target < NUM_THREADS) {
      /* If this thread is not at the end of a chain re-sending the message,
         note this check works because the variable target is unsigned.*/
      msg = chMBPost(&mb[target], msg, TIME_IMMEDIATE);
 8002150:	4b09      	ldr	r3, [pc, #36]	; (8002178 <WorkerThread+0xa8>)
 8002152:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002156:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800215a:	2200      	movs	r2, #0
 800215c:	f7fe fef8 	bl	8000f50 <chMBPost>
 8002160:	9001      	str	r0, [sp, #4]
      if (msg != MSG_OK)
 8002162:	2800      	cmp	r0, #0
 8002164:	d0ca      	beq.n	80020fc <WorkerThread+0x2c>
        saturated = TRUE;
 8002166:	4a06      	ldr	r2, [pc, #24]	; (8002180 <WorkerThread+0xb0>)
 8002168:	2301      	movs	r3, #1
 800216a:	7013      	strb	r3, [r2, #0]
 800216c:	e7c6      	b.n	80020fc <WorkerThread+0x2c>
 800216e:	bf00      	nop
 8002170:	20000800 	.word	0x20000800
 8002174:	080024e4 	.word	0x080024e4
 8002178:	20000f44 	.word	0x20000f44
 800217c:	40021800 	.word	0x40021800
 8002180:	20000f30 	.word	0x20000f30
 8002184:	20000f40 	.word	0x20000f40
 8002188:	20000f3c 	.word	0x20000f3c
 800218c:	f3af 8000 	nop.w

08002190 <gpt3cb>:
 * GPT3 callback.
 */
static void gpt3cb(GPTDriver *gptp) {
  msg_t msg;
  
  palTogglePad(GPIOD, GPIOD_PIN_15_BLUELED);
 8002190:	4a0a      	ldr	r2, [pc, #40]	; (80021bc <gpt3cb+0x2c>)
}

/*
 * GPT3 callback.
 */
static void gpt3cb(GPTDriver *gptp) {
 8002192:	b508      	push	{r3, lr}
  msg_t msg;
  
  palTogglePad(GPIOD, GPIOD_PIN_15_BLUELED);
 8002194:	6953      	ldr	r3, [r2, #20]
 8002196:	f483 4300 	eor.w	r3, r3, #32768	; 0x8000
 800219a:	6153      	str	r3, [r2, #20]
 800219c:	2320      	movs	r3, #32
 800219e:	f383 8811 	msr	BASEPRI, r3

  (void)gptp;
  chSysLockFromISR();
  msg = chMBPostI(&mb[NUM_THREADS - 1], MSG_SEND_LEFT);
 80021a2:	4807      	ldr	r0, [pc, #28]	; (80021c0 <gpt3cb+0x30>)
 80021a4:	2100      	movs	r1, #0
 80021a6:	f7fe fee3 	bl	8000f70 <chMBPostI>
  if (msg != MSG_OK)
 80021aa:	b110      	cbz	r0, 80021b2 <gpt3cb+0x22>
    saturated = TRUE;
 80021ac:	4b05      	ldr	r3, [pc, #20]	; (80021c4 <gpt3cb+0x34>)
 80021ae:	2201      	movs	r2, #1
 80021b0:	701a      	strb	r2, [r3, #0]
 80021b2:	2300      	movs	r3, #0
 80021b4:	f383 8811 	msr	BASEPRI, r3
 80021b8:	bd08      	pop	{r3, pc}
 80021ba:	bf00      	nop
 80021bc:	40020c00 	.word	0x40020c00
 80021c0:	20000fbc 	.word	0x20000fbc
 80021c4:	20000f30 	.word	0x20000f30
 80021c8:	f3af 8000 	nop.w
 80021cc:	f3af 8000 	nop.w

080021d0 <gpt4cb>:
 * GPT2 callback.
 */
static void gpt4cb(GPTDriver *gptp) {
  msg_t msg;
  
  palTogglePad(GPIOI, GPIOI_PIN9);
 80021d0:	4a0a      	ldr	r2, [pc, #40]	; (80021fc <gpt4cb+0x2c>)
}

/*
 * GPT2 callback.
 */
static void gpt4cb(GPTDriver *gptp) {
 80021d2:	b508      	push	{r3, lr}
  msg_t msg;
  
  palTogglePad(GPIOI, GPIOI_PIN9);
 80021d4:	6953      	ldr	r3, [r2, #20]
 80021d6:	f483 7300 	eor.w	r3, r3, #512	; 0x200
 80021da:	6153      	str	r3, [r2, #20]
 80021dc:	2320      	movs	r3, #32
 80021de:	f383 8811 	msr	BASEPRI, r3

  (void)gptp;
  chSysLockFromISR();
  msg = chMBPostI(&mb[0], MSG_SEND_RIGHT);
 80021e2:	4807      	ldr	r0, [pc, #28]	; (8002200 <gpt4cb+0x30>)
 80021e4:	2101      	movs	r1, #1
 80021e6:	f7fe fec3 	bl	8000f70 <chMBPostI>
  if (msg != MSG_OK)
 80021ea:	b110      	cbz	r0, 80021f2 <gpt4cb+0x22>
    saturated = TRUE;
 80021ec:	4b05      	ldr	r3, [pc, #20]	; (8002204 <gpt4cb+0x34>)
 80021ee:	2201      	movs	r2, #1
 80021f0:	701a      	strb	r2, [r3, #0]
 80021f2:	2300      	movs	r3, #0
 80021f4:	f383 8811 	msr	BASEPRI, r3
 80021f8:	bd08      	pop	{r3, pc}
 80021fa:	bf00      	nop
 80021fc:	40022000 	.word	0x40022000
 8002200:	20000f44 	.word	0x20000f44
 8002204:	20000f30 	.word	0x20000f30
 8002208:	f3af 8000 	nop.w
 800220c:	f3af 8000 	nop.w

08002210 <printn.part.0>:

static void printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
    chSequentialStreamPut(&SD6, '0');
 8002210:	4802      	ldr	r0, [pc, #8]	; (800221c <printn.part.0+0xc>)
 8002212:	6803      	ldr	r3, [r0, #0]
 8002214:	2130      	movs	r1, #48	; 0x30
 8002216:	689b      	ldr	r3, [r3, #8]
 8002218:	4718      	bx	r3
 800221a:	bf00      	nop
 800221c:	20000998 	.word	0x20000998

08002220 <printn>:
}

static void printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
 8002220:	b310      	cbz	r0, 8002268 <printn+0x48>
    chSequentialStreamPut(&SD6, *p++);
  }
  chSequentialStreamWrite(&SD6, (uint8_t *)"\r\n", 2);
}

static void printn(uint32_t n) {
 8002222:	b570      	push	{r4, r5, r6, lr}
  if (!n)
    chSequentialStreamPut(&SD6, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 8002224:	4a11      	ldr	r2, [pc, #68]	; (800226c <printn+0x4c>)
    chSequentialStreamPut(&SD6, *p++);
  }
  chSequentialStreamWrite(&SD6, (uint8_t *)"\r\n", 2);
}

static void printn(uint32_t n) {
 8002226:	b084      	sub	sp, #16
  char buf[16], *p;

  if (!n)
 8002228:	466d      	mov	r5, sp
 800222a:	466c      	mov	r4, sp
    chSequentialStreamPut(&SD6, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 800222c:	fba2 1300 	umull	r1, r3, r2, r0
 8002230:	08db      	lsrs	r3, r3, #3
 8002232:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8002236:	eba0 0041 	sub.w	r0, r0, r1, lsl #1
 800223a:	f100 0130 	add.w	r1, r0, #48	; 0x30
 800223e:	b2c9      	uxtb	r1, r1
 8002240:	f804 1b01 	strb.w	r1, [r4], #1

  if (!n)
    chSequentialStreamPut(&SD6, '0');
  else {
    p = buf;
    while (n)
 8002244:	4618      	mov	r0, r3
 8002246:	2b00      	cmp	r3, #0
 8002248:	d1f0      	bne.n	800222c <printn+0xc>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 800224a:	42ac      	cmp	r4, r5
 800224c:	d90a      	bls.n	8002264 <printn+0x44>
 800224e:	4e08      	ldr	r6, [pc, #32]	; (8002270 <printn+0x50>)
 8002250:	3c01      	subs	r4, #1
 8002252:	e001      	b.n	8002258 <printn+0x38>
 8002254:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
      chSequentialStreamPut(&SD6, *--p);
 8002258:	6833      	ldr	r3, [r6, #0]
 800225a:	4805      	ldr	r0, [pc, #20]	; (8002270 <printn+0x50>)
 800225c:	689b      	ldr	r3, [r3, #8]
 800225e:	4798      	blx	r3
    chSequentialStreamPut(&SD6, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8002260:	42ac      	cmp	r4, r5
 8002262:	d1f7      	bne.n	8002254 <printn+0x34>
      chSequentialStreamPut(&SD6, *--p);
  }
}
 8002264:	b004      	add	sp, #16
 8002266:	bd70      	pop	{r4, r5, r6, pc}
 8002268:	f7ff bfd2 	b.w	8002210 <printn.part.0>
 800226c:	cccccccd 	.word	0xcccccccd
 8002270:	20000998 	.word	0x20000998
 8002274:	f3af 8000 	nop.w
 8002278:	f3af 8000 	nop.w
 800227c:	f3af 8000 	nop.w

08002280 <chprintf.constprop.4>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8002280:	b40e      	push	{r1, r2, r3}
 8002282:	b500      	push	{lr}
 8002284:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8002286:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 8002288:	461a      	mov	r2, r3
 800228a:	4905      	ldr	r1, [pc, #20]	; (80022a0 <chprintf.constprop.4+0x20>)
 800228c:	4805      	ldr	r0, [pc, #20]	; (80022a4 <chprintf.constprop.4+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800228e:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8002290:	f7ff fd46 	bl	8001d20 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8002294:	b002      	add	sp, #8
 8002296:	f85d eb04 	ldr.w	lr, [sp], #4
 800229a:	b003      	add	sp, #12
 800229c:	4770      	bx	lr
 800229e:	bf00      	nop
 80022a0:	080024ec 	.word	0x080024ec
 80022a4:	20000f38 	.word	0x20000f38
 80022a8:	f3af 8000 	nop.w
 80022ac:	f3af 8000 	nop.w

080022b0 <Debug_ITMDebugEnable>:
void Debug_ITMDebugEnable(void){
	volatile unsigned int *ITM_TER      = (volatile unsigned int *)0xE0000E00;
	volatile unsigned int *SCB_DHCSR 		= (volatile unsigned int *)0xE000EDF0;
	volatile unsigned int *DBGMCU_CR 		= (volatile unsigned int *)0xE0042004;

	*DBGMCU_CR |= 0x27; // DBGMCU_CR
 80022b0:	4a08      	ldr	r2, [pc, #32]	; (80022d4 <Debug_ITMDebugEnable+0x24>)

if ((*SCB_DHCSR & 1) && (*ITM_TER & 1)) // Enabled?
 80022b2:	4909      	ldr	r1, [pc, #36]	; (80022d8 <Debug_ITMDebugEnable+0x28>)
void Debug_ITMDebugEnable(void){
	volatile unsigned int *ITM_TER      = (volatile unsigned int *)0xE0000E00;
	volatile unsigned int *SCB_DHCSR 		= (volatile unsigned int *)0xE000EDF0;
	volatile unsigned int *DBGMCU_CR 		= (volatile unsigned int *)0xE0042004;

	*DBGMCU_CR |= 0x27; // DBGMCU_CR
 80022b4:	6813      	ldr	r3, [r2, #0]
 80022b6:	f043 0327 	orr.w	r3, r3, #39	; 0x27
 80022ba:	6013      	str	r3, [r2, #0]

if ((*SCB_DHCSR & 1) && (*ITM_TER & 1)) // Enabled?
 80022bc:	680b      	ldr	r3, [r1, #0]
 80022be:	07da      	lsls	r2, r3, #31
 80022c0:	d506      	bpl.n	80022d0 <Debug_ITMDebugEnable+0x20>
 80022c2:	4b06      	ldr	r3, [pc, #24]	; (80022dc <Debug_ITMDebugEnable+0x2c>)
 80022c4:	681b      	ldr	r3, [r3, #0]
 80022c6:	07db      	lsls	r3, r3, #31
 80022c8:	d502      	bpl.n	80022d0 <Debug_ITMDebugEnable+0x20>
    Debug_ITMDebug = 1;
 80022ca:	4b05      	ldr	r3, [pc, #20]	; (80022e0 <Debug_ITMDebugEnable+0x30>)
 80022cc:	2201      	movs	r2, #1
 80022ce:	601a      	str	r2, [r3, #0]
 80022d0:	4770      	bx	lr
 80022d2:	bf00      	nop
 80022d4:	e0042004 	.word	0xe0042004
 80022d8:	e000edf0 	.word	0xe000edf0
 80022dc:	e0000e00 	.word	0xe0000e00
 80022e0:	20000f34 	.word	0x20000f34
 80022e4:	f3af 8000 	nop.w
 80022e8:	f3af 8000 	nop.w
 80022ec:	f3af 8000 	nop.w

080022f0 <Debug_ITMDebugOutputChar>:

void Debug_ITMDebugOutputChar(char ch){
	static volatile unsigned int *ITM_STIM0 = (volatile unsigned int *)0xE0000000; // ITM Port 0
	static volatile unsigned int *SCB_DEMCR = (volatile unsigned int *)0xE000EDFC;

	if (Debug_ITMDebug && (*SCB_DEMCR & 0x01000000))
 80022f0:	4b07      	ldr	r3, [pc, #28]	; (8002310 <Debug_ITMDebugOutputChar+0x20>)
 80022f2:	681b      	ldr	r3, [r3, #0]
 80022f4:	b15b      	cbz	r3, 800230e <Debug_ITMDebugOutputChar+0x1e>
 80022f6:	4b07      	ldr	r3, [pc, #28]	; (8002314 <Debug_ITMDebugOutputChar+0x24>)
 80022f8:	681b      	ldr	r3, [r3, #0]
 80022fa:	01db      	lsls	r3, r3, #7
 80022fc:	d507      	bpl.n	800230e <Debug_ITMDebugOutputChar+0x1e>
	{
		while(*ITM_STIM0 == 0);
 80022fe:	f04f 4160 	mov.w	r1, #3758096384	; 0xe0000000
 8002302:	680b      	ldr	r3, [r1, #0]
 8002304:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 8002308:	2b00      	cmp	r3, #0
 800230a:	d0fa      	beq.n	8002302 <Debug_ITMDebugOutputChar+0x12>
  	*((volatile char *)ITM_STIM0) = ch;
 800230c:	7010      	strb	r0, [r2, #0]
 800230e:	4770      	bx	lr
 8002310:	20000f34 	.word	0x20000f34
 8002314:	e000edfc 	.word	0xe000edfc
 8002318:	f3af 8000 	nop.w
 800231c:	f3af 8000 	nop.w
 8002320:	656c6469 	.word	0x656c6469
	...

08002330 <ch_debug>:
 8002330:	6e69616d 18001600 08440404 1814100c     main......D.....
 8002340:	1e1d1c00 00000000 00000000 00000000     ................
 8002350:	000a7325 5f6c6168 5f646c6c 74696e69     %s..hal_lld_init
 8002360:	00000000 496c6170 0074696e 00000000     ....palInit.....

08002370 <vmt>:
 8002370:	08001441 08001421 08001481 08001461     A...!.......a...
 8002380:	08001471 08001451 08001431 08001411     q...Q...1.......

08002390 <default_config>:
 8002390:	00009600 40000000 00000000 00000000     .......@........

080023a0 <pal_default_config>:
 80023a0:	2a82aa28 00280028 ffffffff 40000054     (..*(.(.....T..@
 80023b0:	0000ffff b5560bb0 00000000 00082080     ......V...... ..
 80023c0:	00000240 ffffffff 55514515 0000ffff     @........EQU....
 80023d0:	04000000 00000040 00a5aa09 00000000     ....@...........
 80023e0:	ffffffff 54000050 0000fcff 88bb00b0     ....P..T........
 80023f0:	00067700 55000100 00000000 ffffffff     .w.....U........
 8002400:	00155055 00000fff 00000000 00000000     UP..............
 8002410:	00000040 00000000 ffffffff 00000000     @...............
 8002420:	0000ffff 00000000 00000000 00000000     ................
 8002430:	00000000 ffffffff 00000000 0000ffff     ................
	...
 8002448:	28811000 00000000 ffffffff 14400000     ...(..........@.
 8002458:	0000febf 00000000 0bb0b000 00000000     ................
 8002468:	00000000 ffffffff 00000000 0000ffff     ................
	...
 8002480:	00040000 00000000 ffffffff 00000000     ................
 8002490:	0000fdff 00000000 00000000 00000000     ................
 80024a0:	6c756e28 0000296c 00000000 00000000     (null)..........

080024b0 <vmt>:
 80024b0:	08002061 08002041 08002051 08002031     a ..A ..Q ..1 ..

080024c0 <gpt3cfg>:
 80024c0:	000f4240 08002191 00000000 00000000     @B...!..........

080024d0 <gpt4cfg>:
 80024d0:	000f4240 080021d1 00000000 00000000     @B...!..........
 80024e0:	00000a0d 6b726f77 00007265 00007325     ....worker..%s..
 80024f0:	20565753 62616e45 0a64656c 00000000     SWV Enabled.....
 8002500:	202a2a2a 6e72654b 203a6c65 20202020     *** Kernel:     
 8002510:	00002020 202a2a2a 706d6f43 64656c69       ..*** Compiled
 8002520:	2020203a 00002020 202a2a2a 706d6f43     :     ..*** Comp
 8002530:	72656c69 2020203a 00002020 202a2a2a     iler:     ..*** 
 8002540:	68637241 63657469 65727574 0000203a     Architecture: ..
 8002550:	202a2a2a 65726f43 72615620 746e6169     *** Core Variant
 8002560:	0000203a 202a2a2a 74726f50 666e4920     : ..*** Port Inf
 8002570:	20203a6f 00002020 202a2a2a 74616c50     o:    ..*** Plat
 8002580:	6d726f66 2020203a 00002020 202a2a2a     form:     ..*** 
 8002590:	74736554 616f4220 203a6472 00002020     Test Board:   ..
 80025a0:	202a2a2a 74737953 43206d65 6b636f6c     *** System Clock
 80025b0:	0000203a 202a2a2a 72657449 6f697461     : ..*** Iteratio
 80025c0:	203a736e 00002020 202a2a2a 646e6152     ns:   ..*** Rand
 80025d0:	7a696d6f 20203a65 00002020 202a2a2a     omize:    ..*** 
 80025e0:	65726854 3a736461 20202020 00002020     Threads:      ..
 80025f0:	202a2a2a 6c69614d 20786f62 657a6973     *** Mailbox size
 8002600:	0000203a 72657449 6f697461 0000206e     : ..Iteration ..
 8002610:	75746153 65746172 74612064 00000020     Saturated at ...
 8002620:	73726f57 61632074 61206573 00002074     Worst case at ..
 8002630:	62696843 20534f69 302e3356 0000000a     ChibiOS V3.0....
 8002640:	202a2a2a 62696843 2f534f69 49205452     *** ChibiOS/RT I
 8002650:	532d5152 4d524f54 6e6f6c20 75642067     RQ-STORM long du
 8002660:	69746172 74206e6f 00747365 002a2a2a     ration test.***.
 8002670:	00537520 74736554 6d6f4320 74656c70      uS.Test Complet
 8002680:	00000065 2e302e33 76656430 00000000     e...3.0.0dev....
 8002690:	2079614d 32203820 20353130 3630202d     May  8 2015 - 06
 80026a0:	3a35343a 00003432 20434347 2e392e34     :45:24..GCC 4.9.
 80026b0:	30322033 31313431 28203931 656c6572     3 20141119 (rele
 80026c0:	29657361 52415b20 6d652f4d 64646562     ase) [ARM/embedd
 80026d0:	342d6465 622d395f 636e6172 65722068     ed-4_9-branch re
 80026e0:	69736976 32206e6f 37323831 00005d38     vision 218278]..
 80026f0:	764d5241 454d2d37 00000000 74726f43     ARMv7-ME....Cort
 8002700:	4d2d7865 00000034 61766441 6465636e     ex-M4...Advanced
 8002710:	72656b20 206c656e 65646f6d 00000000      kernel mode....
 8002720:	334d5453 30344632 69482037 50206867     STM32F407 High P
 8002730:	6f667265 6e616d72 77206563 20687469     erformance with 
 8002740:	20505344 20646e61 00555046 694d5453     DSP and FPU.STMi
 8002750:	656f7263 7463656c 696e6f72 53207363     croelectronics S
 8002760:	32334d54 442d3446 6f637369 79726576     TM32F4-Discovery
 8002770:	00000000                                ....

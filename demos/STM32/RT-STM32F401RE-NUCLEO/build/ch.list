
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c0 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 80001c0:	b510      	push	{r4, lr}
 80001c2:	b086      	sub	sp, #24
  /* Enable TRACE debug -----------------------------------------------*/
  Debug_ITMDebugEnable();
 80001c4:	f001 fe5c 	bl	8001e80 <Debug_ITMDebugEnable>
}

//****************************************************************************

void Debug_ITMDebugOutputString(char *Buffer){
	if (Debug_ITMDebug)
 80001c8:	4b20      	ldr	r3, [pc, #128]	; (800024c <__fini_array_end+0x8c>)
 80001ca:	681b      	ldr	r3, [r3, #0]
 80001cc:	2b00      	cmp	r3, #0
 80001ce:	d133      	bne.n	8000238 <main+0x78>
int main(void) {
  /* Enable TRACE debug -----------------------------------------------*/
  Debug_ITMDebugEnable();
  Debug_ITMDebugOutputString("SWV Enabled\n");
  
  itmObjectInit(&itm_port);
 80001d0:	481f      	ldr	r0, [pc, #124]	; (8000250 <__fini_array_end+0x90>)
 80001d2:	f001 fced 	bl	8001bb0 <itmObjectInit>

  chprintf((BaseSequentialStream *)&itm_port, "%s", "ChibiOS V3.0\n");
 80001d6:	4a1f      	ldr	r2, [pc, #124]	; (8000254 <__fini_array_end+0x94>)
 80001d8:	491f      	ldr	r1, [pc, #124]	; (8000258 <__fini_array_end+0x98>)
 80001da:	481d      	ldr	r0, [pc, #116]	; (8000250 <__fini_array_end+0x90>)
 80001dc:	f001 fe38 	bl	8001e50 <chprintf.constprop.3>
  
  /*End****************************************************************/
  
  DeviceList list_RTC;
  init(&list_RTC);
 80001e0:	a802      	add	r0, sp, #8
 80001e2:	f001 fd65 	bl	8001cb0 <init>
  add(&list_RTC, (Element){10});
 80001e6:	210a      	movs	r1, #10
 80001e8:	a802      	add	r0, sp, #8
 80001ea:	f001 fd69 	bl	8001cc0 <add>
  add(&list_RTC, (Element){50});
 80001ee:	2132      	movs	r1, #50	; 0x32
 80001f0:	a802      	add	r0, sp, #8
 80001f2:	f001 fd65 	bl	8001cc0 <add>
  add(&list_RTC, (Element){100});
 80001f6:	2164      	movs	r1, #100	; 0x64
 80001f8:	a802      	add	r0, sp, #8
 80001fa:	f001 fd61 	bl	8001cc0 <add>
  print(&list_RTC);
 80001fe:	a802      	add	r0, sp, #8
 8000200:	f001 fdce 	bl	8001da0 <print>
  
  insert(&list_RTC, (Element){20}, 1);
 8000204:	2114      	movs	r1, #20
 8000206:	2201      	movs	r2, #1
 8000208:	a802      	add	r0, sp, #8
 800020a:	f001 fda1 	bl	8001d50 <insert>
  print(&list_RTC);
 800020e:	a802      	add	r0, sp, #8
 8000210:	f001 fdc6 	bl	8001da0 <print>
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 8000214:	f000 ffec 	bl	80011f0 <halInit>
  chSysInit();
 8000218:	f000 f9c2 	bl	80005a0 <chSysInit>
  //sdStart(&SD2, NULL);

  /*
   * Creates the blinker thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 800021c:	2300      	movs	r3, #0
 800021e:	9300      	str	r3, [sp, #0]
 8000220:	480e      	ldr	r0, [pc, #56]	; (800025c <__fini_array_end+0x9c>)
 8000222:	4b0f      	ldr	r3, [pc, #60]	; (8000260 <__fini_array_end+0xa0>)
 8000224:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8000228:	2240      	movs	r2, #64	; 0x40
 800022a:	f000 fc31 	bl	8000a90 <chThdCreateStatic>
   * sleeping in a loop and check the button state.
   */
  while (TRUE) {
    //if (!palReadPad(GPIOC, GPIOC_BUTTON))
      //TestThread(&SD2);
    chThdSleepMilliseconds(500);
 800022e:	f241 3088 	movw	r0, #5000	; 0x1388
 8000232:	f000 fc6d 	bl	8000b10 <chThdSleep>
  }
 8000236:	e7fa      	b.n	800022e <main+0x6e>
}

//****************************************************************************

void Debug_ITMDebugOutputString(char *Buffer){
	if (Debug_ITMDebug)
 8000238:	4c0a      	ldr	r4, [pc, #40]	; (8000264 <__fini_array_end+0xa4>)
 800023a:	2053      	movs	r0, #83	; 0x53
		while(*Buffer)
			Debug_ITMDebugOutputChar(*Buffer++);
 800023c:	f001 fe40 	bl	8001ec0 <Debug_ITMDebugOutputChar>

//****************************************************************************

void Debug_ITMDebugOutputString(char *Buffer){
	if (Debug_ITMDebug)
		while(*Buffer)
 8000240:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 8000244:	2800      	cmp	r0, #0
 8000246:	d1f9      	bne.n	800023c <main+0x7c>
 8000248:	e7c2      	b.n	80001d0 <main+0x10>
 800024a:	bf00      	nop
 800024c:	20001378 	.word	0x20001378
 8000250:	2000137c 	.word	0x2000137c
 8000254:	08002a3c 	.word	0x08002a3c
 8000258:	08002a28 	.word	0x08002a28
 800025c:	20001230 	.word	0x20001230
 8000260:	08001e11 	.word	0x08001e11
 8000264:	08002a2c 	.word	0x08002a2c
 8000268:	f3af 8000 	nop.w
 800026c:	f3af 8000 	nop.w

08000270 <_port_switch>:
 8000270:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000274:	f8c1 d00c 	str.w	sp, [r1, #12]
 8000278:	f8d0 d00c 	ldr.w	sp, [r0, #12]
 800027c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000280 <_port_thread_start>:
 8000280:	2300      	movs	r3, #0
 8000282:	f383 8811 	msr	BASEPRI, r3
 8000286:	4628      	mov	r0, r5
 8000288:	47a0      	blx	r4
 800028a:	f000 fc71 	bl	8000b70 <chThdExit>

0800028e <_port_switch_from_isr>:
 800028e:	f000 fb67 	bl	8000960 <chSchDoReschedule>

08000292 <_port_exit_from_isr>:
 8000292:	df00      	svc	0
 8000294:	e7fe      	b.n	8000294 <_port_exit_from_isr+0x2>
	...

080002a0 <memcpy>:
 80002a0:	4684      	mov	ip, r0
 80002a2:	ea41 0300 	orr.w	r3, r1, r0
 80002a6:	f013 0303 	ands.w	r3, r3, #3
 80002aa:	d16d      	bne.n	8000388 <memcpy+0xe8>
 80002ac:	3a40      	subs	r2, #64	; 0x40
 80002ae:	d341      	bcc.n	8000334 <memcpy+0x94>
 80002b0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002b4:	f840 3b04 	str.w	r3, [r0], #4
 80002b8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002bc:	f840 3b04 	str.w	r3, [r0], #4
 80002c0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002c4:	f840 3b04 	str.w	r3, [r0], #4
 80002c8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002cc:	f840 3b04 	str.w	r3, [r0], #4
 80002d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002d4:	f840 3b04 	str.w	r3, [r0], #4
 80002d8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002dc:	f840 3b04 	str.w	r3, [r0], #4
 80002e0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002e4:	f840 3b04 	str.w	r3, [r0], #4
 80002e8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002ec:	f840 3b04 	str.w	r3, [r0], #4
 80002f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002f4:	f840 3b04 	str.w	r3, [r0], #4
 80002f8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002fc:	f840 3b04 	str.w	r3, [r0], #4
 8000300:	f851 3b04 	ldr.w	r3, [r1], #4
 8000304:	f840 3b04 	str.w	r3, [r0], #4
 8000308:	f851 3b04 	ldr.w	r3, [r1], #4
 800030c:	f840 3b04 	str.w	r3, [r0], #4
 8000310:	f851 3b04 	ldr.w	r3, [r1], #4
 8000314:	f840 3b04 	str.w	r3, [r0], #4
 8000318:	f851 3b04 	ldr.w	r3, [r1], #4
 800031c:	f840 3b04 	str.w	r3, [r0], #4
 8000320:	f851 3b04 	ldr.w	r3, [r1], #4
 8000324:	f840 3b04 	str.w	r3, [r0], #4
 8000328:	f851 3b04 	ldr.w	r3, [r1], #4
 800032c:	f840 3b04 	str.w	r3, [r0], #4
 8000330:	3a40      	subs	r2, #64	; 0x40
 8000332:	d2bd      	bcs.n	80002b0 <memcpy+0x10>
 8000334:	3230      	adds	r2, #48	; 0x30
 8000336:	d311      	bcc.n	800035c <memcpy+0xbc>
 8000338:	f851 3b04 	ldr.w	r3, [r1], #4
 800033c:	f840 3b04 	str.w	r3, [r0], #4
 8000340:	f851 3b04 	ldr.w	r3, [r1], #4
 8000344:	f840 3b04 	str.w	r3, [r0], #4
 8000348:	f851 3b04 	ldr.w	r3, [r1], #4
 800034c:	f840 3b04 	str.w	r3, [r0], #4
 8000350:	f851 3b04 	ldr.w	r3, [r1], #4
 8000354:	f840 3b04 	str.w	r3, [r0], #4
 8000358:	3a10      	subs	r2, #16
 800035a:	d2ed      	bcs.n	8000338 <memcpy+0x98>
 800035c:	320c      	adds	r2, #12
 800035e:	d305      	bcc.n	800036c <memcpy+0xcc>
 8000360:	f851 3b04 	ldr.w	r3, [r1], #4
 8000364:	f840 3b04 	str.w	r3, [r0], #4
 8000368:	3a04      	subs	r2, #4
 800036a:	d2f9      	bcs.n	8000360 <memcpy+0xc0>
 800036c:	3204      	adds	r2, #4
 800036e:	d008      	beq.n	8000382 <memcpy+0xe2>
 8000370:	07d2      	lsls	r2, r2, #31
 8000372:	bf1c      	itt	ne
 8000374:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000378:	f800 3b01 	strbne.w	r3, [r0], #1
 800037c:	d301      	bcc.n	8000382 <memcpy+0xe2>
 800037e:	880b      	ldrh	r3, [r1, #0]
 8000380:	8003      	strh	r3, [r0, #0]
 8000382:	4660      	mov	r0, ip
 8000384:	4770      	bx	lr
 8000386:	bf00      	nop
 8000388:	2a08      	cmp	r2, #8
 800038a:	d313      	bcc.n	80003b4 <memcpy+0x114>
 800038c:	078b      	lsls	r3, r1, #30
 800038e:	d08d      	beq.n	80002ac <memcpy+0xc>
 8000390:	f010 0303 	ands.w	r3, r0, #3
 8000394:	d08a      	beq.n	80002ac <memcpy+0xc>
 8000396:	f1c3 0304 	rsb	r3, r3, #4
 800039a:	1ad2      	subs	r2, r2, r3
 800039c:	07db      	lsls	r3, r3, #31
 800039e:	bf1c      	itt	ne
 80003a0:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003a4:	f800 3b01 	strbne.w	r3, [r0], #1
 80003a8:	d380      	bcc.n	80002ac <memcpy+0xc>
 80003aa:	f831 3b02 	ldrh.w	r3, [r1], #2
 80003ae:	f820 3b02 	strh.w	r3, [r0], #2
 80003b2:	e77b      	b.n	80002ac <memcpy+0xc>
 80003b4:	3a04      	subs	r2, #4
 80003b6:	d3d9      	bcc.n	800036c <memcpy+0xcc>
 80003b8:	3a01      	subs	r2, #1
 80003ba:	f811 3b01 	ldrb.w	r3, [r1], #1
 80003be:	f800 3b01 	strb.w	r3, [r0], #1
 80003c2:	d2f9      	bcs.n	80003b8 <memcpy+0x118>
 80003c4:	780b      	ldrb	r3, [r1, #0]
 80003c6:	7003      	strb	r3, [r0, #0]
 80003c8:	784b      	ldrb	r3, [r1, #1]
 80003ca:	7043      	strb	r3, [r0, #1]
 80003cc:	788b      	ldrb	r3, [r1, #2]
 80003ce:	7083      	strb	r3, [r0, #2]
 80003d0:	4660      	mov	r0, ip
 80003d2:	4770      	bx	lr
	...

080003e0 <__late_init>:
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void __late_init(void) {}
 80003e0:	4770      	bx	lr
 80003e2:	bf00      	nop
 80003e4:	f3af 8000 	nop.w
 80003e8:	f3af 8000 	nop.w
 80003ec:	f3af 8000 	nop.w

080003f0 <_default_exit>:
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
void _default_exit(void) {
  while (1)
    ;
 80003f0:	e7fe      	b.n	80003f0 <_default_exit>
 80003f2:	bf00      	nop
 80003f4:	f3af 8000 	nop.w
 80003f8:	f3af 8000 	nop.w
 80003fc:	f3af 8000 	nop.w

08000400 <Reset_Handler>:
  uint32_t psp, reg;

  /* Process Stack initialization, it is allocated starting from the
     symbol __process_stack_end__ and its lower limit is the symbol
     __process_stack_base__.*/
  asm volatile ("cpsid   i");
 8000400:	b672      	cpsid	i
  psp = SYMVAL(__process_stack_end__);
 8000402:	4c31      	ldr	r4, [pc, #196]	; (80004c8 <Reset_Handler+0xc8>)
  asm volatile ("msr     PSP, %0" : : "r" (psp));
 8000404:	f384 8809 	msr	PSP, r4
  reg = CRT0_CONTROL_INIT | 4;
#else
  /* CPU mode initialization.*/
  reg = CRT0_CONTROL_INIT;
#endif
  asm volatile ("msr     CONTROL, %0" : : "r" (reg));
 8000408:	2302      	movs	r3, #2
 800040a:	f383 8814 	msr	CONTROL, r3
  asm volatile ("isb");
 800040e:	f3bf 8f6f 	isb	sy

  /* Early initialization hook invocation.*/
  __early_init();
 8000412:	f001 f9d5 	bl	80017c0 <__early_init>

#if CRT0_INIT_STACKS
  /* Main and Process stacks initialization.*/
  fill32(&__main_stack_base__,
 8000416:	4b2d      	ldr	r3, [pc, #180]	; (80004cc <Reset_Handler+0xcc>)
 8000418:	4a2d      	ldr	r2, [pc, #180]	; (80004d0 <Reset_Handler+0xd0>)
 800041a:	4293      	cmp	r3, r2
 800041c:	d20b      	bcs.n	8000436 <Reset_Handler+0x36>
 800041e:	43d9      	mvns	r1, r3
 8000420:	440a      	add	r2, r1
 8000422:	f022 0203 	bic.w	r2, r2, #3
 8000426:	3204      	adds	r2, #4
 8000428:	441a      	add	r2, r3
 800042a:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 800042e:	f843 1b04 	str.w	r1, [r3], #4
 8000432:	4293      	cmp	r3, r2
 8000434:	d1fb      	bne.n	800042e <Reset_Handler+0x2e>
         &__main_stack_end__,
         CRT0_STACKS_FILL_PATTERN);
  fill32(&__process_stack_base__,
 8000436:	4b27      	ldr	r3, [pc, #156]	; (80004d4 <Reset_Handler+0xd4>)
 8000438:	42a3      	cmp	r3, r4
 800043a:	d20c      	bcs.n	8000456 <Reset_Handler+0x56>
 800043c:	4a26      	ldr	r2, [pc, #152]	; (80004d8 <Reset_Handler+0xd8>)
 800043e:	1d19      	adds	r1, r3, #4
 8000440:	1a52      	subs	r2, r2, r1
 8000442:	f022 0203 	bic.w	r2, r2, #3
 8000446:	3204      	adds	r2, #4
 8000448:	441a      	add	r2, r3
 800044a:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 800044e:	f843 1b04 	str.w	r1, [r3], #4
 8000452:	4293      	cmp	r3, r2
 8000454:	d1fb      	bne.n	800044e <Reset_Handler+0x4e>
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 8000456:	4a21      	ldr	r2, [pc, #132]	; (80004dc <Reset_Handler+0xdc>)
 8000458:	4b21      	ldr	r3, [pc, #132]	; (80004e0 <Reset_Handler+0xe0>)
 800045a:	429a      	cmp	r2, r3
 800045c:	d20c      	bcs.n	8000478 <Reset_Handler+0x78>
 800045e:	43d0      	mvns	r0, r2
 8000460:	4418      	add	r0, r3
 8000462:	f020 0003 	bic.w	r0, r0, #3
 8000466:	4b1f      	ldr	r3, [pc, #124]	; (80004e4 <Reset_Handler+0xe4>)
 8000468:	3004      	adds	r0, #4
 800046a:	4418      	add	r0, r3
      *dp++ = *tp++;
 800046c:	f853 1b04 	ldr.w	r1, [r3], #4
 8000470:	f842 1b04 	str.w	r1, [r2], #4
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 8000474:	4283      	cmp	r3, r0
 8000476:	d1f9      	bne.n	800046c <Reset_Handler+0x6c>
  }
#endif

#if CRT0_INIT_BSS
  /* BSS segment initialization.*/
  fill32(&_bss_start, &_bss_end, 0);
 8000478:	4b1b      	ldr	r3, [pc, #108]	; (80004e8 <Reset_Handler+0xe8>)
 800047a:	4a1c      	ldr	r2, [pc, #112]	; (80004ec <Reset_Handler+0xec>)
 800047c:	4293      	cmp	r3, r2
 800047e:	d20a      	bcs.n	8000496 <Reset_Handler+0x96>
 8000480:	43d9      	mvns	r1, r3
 8000482:	440a      	add	r2, r1
 8000484:	f022 0203 	bic.w	r2, r2, #3
 8000488:	3204      	adds	r2, #4
 800048a:	441a      	add	r2, r3
 800048c:	2100      	movs	r1, #0
 800048e:	f843 1b04 	str.w	r1, [r3], #4
 8000492:	4293      	cmp	r3, r2
 8000494:	d1fb      	bne.n	800048e <Reset_Handler+0x8e>

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
    while (fpp < &__init_array_end) {
 8000496:	4d16      	ldr	r5, [pc, #88]	; (80004f0 <Reset_Handler+0xf0>)
 8000498:	4c16      	ldr	r4, [pc, #88]	; (80004f4 <Reset_Handler+0xf4>)
  /* BSS segment initialization.*/
  fill32(&_bss_start, &_bss_end, 0);
#endif

  /* Late initialization hook invocation.*/
  __late_init();
 800049a:	f7ff ffa1 	bl	80003e0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
    while (fpp < &__init_array_end) {
 800049e:	42ac      	cmp	r4, r5
 80004a0:	d204      	bcs.n	80004ac <Reset_Handler+0xac>
      (*fpp)();
 80004a2:	f854 3b04 	ldr.w	r3, [r4], #4
 80004a6:	4798      	blx	r3

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
    while (fpp < &__init_array_end) {
 80004a8:	42ac      	cmp	r4, r5
 80004aa:	d3fa      	bcc.n	80004a2 <Reset_Handler+0xa2>

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
    while (fpp < &__fini_array_end) {
 80004ac:	4d12      	ldr	r5, [pc, #72]	; (80004f8 <Reset_Handler+0xf8>)
 80004ae:	4c13      	ldr	r4, [pc, #76]	; (80004fc <Reset_Handler+0xfc>)
    }
  }
#endif

  /* Invoking application main() function.*/
  main();
 80004b0:	f7ff fe86 	bl	80001c0 <main>

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
    while (fpp < &__fini_array_end) {
 80004b4:	42ac      	cmp	r4, r5
 80004b6:	d204      	bcs.n	80004c2 <Reset_Handler+0xc2>
      (*fpp)();
 80004b8:	f854 3b04 	ldr.w	r3, [r4], #4
 80004bc:	4798      	blx	r3

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
    while (fpp < &__fini_array_end) {
 80004be:	42ac      	cmp	r4, r5
 80004c0:	d3fa      	bcc.n	80004b8 <Reset_Handler+0xb8>
    }
  }
#endif

  /* Invoking the exit handler.*/
  _default_exit();
 80004c2:	f7ff ff95 	bl	80003f0 <_default_exit>
 80004c6:	bf00      	nop
 80004c8:	20000800 	.word	0x20000800
 80004cc:	20000000 	.word	0x20000000
 80004d0:	20000400 	.word	0x20000400
 80004d4:	20000400 	.word	0x20000400
 80004d8:	20000803 	.word	0x20000803
 80004dc:	20000800 	.word	0x20000800
 80004e0:	2000103c 	.word	0x2000103c
 80004e4:	08002a58 	.word	0x08002a58
 80004e8:	2000103c 	.word	0x2000103c
 80004ec:	200013b4 	.word	0x200013b4
 80004f0:	080001c0 	.word	0x080001c0
 80004f4:	080001c0 	.word	0x080001c0
 80004f8:	080001c0 	.word	0x080001c0
 80004fc:	080001c0 	.word	0x080001c0

08000500 <_unhandled_exception>:
 * @notapi
 */
void _unhandled_exception(void) {

  while (true)
    ;
 8000500:	e7fe      	b.n	8000500 <_unhandled_exception>
 8000502:	bf00      	nop
 8000504:	f3af 8000 	nop.w
 8000508:	f3af 8000 	nop.w
 800050c:	f3af 8000 	nop.w

08000510 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000510:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000514:	3320      	adds	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000516:	f383 8809 	msr	PSP, r3

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800051a:	2300      	movs	r3, #0
 800051c:	f383 8811 	msr	BASEPRI, r3
 8000520:	4770      	bx	lr
 8000522:	bf00      	nop
 8000524:	f3af 8000 	nop.w
 8000528:	f3af 8000 	nop.w
 800052c:	f3af 8000 	nop.w

08000530 <_port_irq_epilogue>:
 8000530:	2320      	movs	r3, #32
 8000532:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0) {
 8000536:	4b0f      	ldr	r3, [pc, #60]	; (8000574 <_port_irq_epilogue+0x44>)
 8000538:	685b      	ldr	r3, [r3, #4]
 800053a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800053e:	d102      	bne.n	8000546 <_port_irq_epilogue+0x16>
 8000540:	f383 8811 	msr	BASEPRI, r3
 8000544:	4770      	bx	lr
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8000546:	b510      	push	{r4, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000548:	f3ef 8409 	mrs	r4, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800054c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8000550:	f844 3c04 	str.w	r3, [r4, #-4]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8000554:	f1a4 0320 	sub.w	r3, r4, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000558:	f383 8809 	msr	PSP, r3
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800055c:	f000 f9d0 	bl	8000900 <chSchIsPreemptionRequired>
 8000560:	b118      	cbz	r0, 800056a <_port_irq_epilogue+0x3a>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8000562:	4b05      	ldr	r3, [pc, #20]	; (8000578 <_port_irq_epilogue+0x48>)
 8000564:	f844 3c08 	str.w	r3, [r4, #-8]
 8000568:	bd10      	pop	{r4, pc}
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 800056a:	4b04      	ldr	r3, [pc, #16]	; (800057c <_port_irq_epilogue+0x4c>)
 800056c:	f844 3c08 	str.w	r3, [r4, #-8]
 8000570:	bd10      	pop	{r4, pc}
 8000572:	bf00      	nop
 8000574:	e000ed00 	.word	0xe000ed00
 8000578:	0800028f 	.word	0x0800028f
 800057c:	08000292 	.word	0x08000292

08000580 <_idle_thread>:
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {

  (void)p;
  chRegSetThreadName("idle");
 8000580:	4b02      	ldr	r3, [pc, #8]	; (800058c <_idle_thread+0xc>)
 8000582:	4a03      	ldr	r2, [pc, #12]	; (8000590 <_idle_thread+0x10>)
 8000584:	699b      	ldr	r3, [r3, #24]
 8000586:	619a      	str	r2, [r3, #24]
 8000588:	e7fe      	b.n	8000588 <_idle_thread+0x8>
 800058a:	bf00      	nop
 800058c:	20001040 	.word	0x20001040
 8000590:	080027a0 	.word	0x080027a0
 8000594:	f3af 8000 	nop.w
 8000598:	f3af 8000 	nop.w
 800059c:	f3af 8000 	nop.w

080005a0 <chSysInit>:
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 80005a0:	4b1e      	ldr	r3, [pc, #120]	; (800061c <chSysInit+0x7c>)
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
 80005a2:	4a1f      	ldr	r2, [pc, #124]	; (8000620 <chSysInit+0x80>)
  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80005a4:	481f      	ldr	r0, [pc, #124]	; (8000624 <chSysInit+0x84>)
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80005a6:	b5f0      	push	{r4, r5, r6, r7, lr}
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 80005a8:	2400      	movs	r4, #0
 80005aa:	609c      	str	r4, [r3, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80005ac:	68df      	ldr	r7, [r3, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80005ae:	4e1e      	ldr	r6, [pc, #120]	; (8000628 <chSysInit+0x88>)
  _dbg_trace_init();
#endif

#if !CH_CFG_NO_IDLE_THREAD
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80005b0:	4d1e      	ldr	r5, [pc, #120]	; (800062c <chSysInit+0x8c>)
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 80005b2:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 80005b6:	4039      	ands	r1, r7
  reg_value  =  (reg_value                                 |
 80005b8:	430a      	orrs	r2, r1
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80005ba:	60da      	str	r2, [r3, #12]
 80005bc:	68f2      	ldr	r2, [r6, #12]
 80005be:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80005c2:	60f2      	str	r2, [r6, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80005c4:	6802      	ldr	r2, [r0, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 80005c6:	2120      	movs	r1, #32
 80005c8:	f042 0201 	orr.w	r2, r2, #1
 80005cc:	2610      	movs	r6, #16
 80005ce:	6002      	str	r2, [r0, #0]
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80005d0:	b083      	sub	sp, #12
 80005d2:	77de      	strb	r6, [r3, #31]
 80005d4:	f883 1022 	strb.w	r1, [r3, #34]	; 0x22
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
  _scheduler_init();
 80005d8:	f000 f8fa 	bl	80007d0 <_scheduler_init>
  _vt_init();
 80005dc:	f000 f9c8 	bl	8000970 <_vt_init>
#if CH_CFG_USE_TM
  _tm_init();
 80005e0:	f000 f89e 	bl	8000720 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE
  _core_init();
 80005e4:	f000 fd0c 	bl	8001000 <_core_init>
#endif
#if CH_CFG_USE_HEAP
  _heap_init();
 80005e8:	f000 fd5a 	bl	80010a0 <_heap_init>
  _dbg_trace_init();
#endif

#if !CH_CFG_NO_IDLE_THREAD
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80005ec:	4628      	mov	r0, r5
 80005ee:	2140      	movs	r1, #64	; 0x40
 80005f0:	f000 fa2e 	bl	8000a50 <_thread_init>
 80005f4:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 80005f8:	2201      	movs	r2, #1
  _dbg_trace_init();
#endif

#if !CH_CFG_NO_IDLE_THREAD
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80005fa:	6198      	str	r0, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 80005fc:	7702      	strb	r2, [r0, #28]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80005fe:	f384 8811 	msr	BASEPRI, r4
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000602:	b662      	cpsie	i
#endif
  chSysEnable();

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 8000604:	699b      	ldr	r3, [r3, #24]
 8000606:	490a      	ldr	r1, [pc, #40]	; (8000630 <chSysInit+0x90>)
 8000608:	6199      	str	r1, [r3, #24]

#if !CH_CFG_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(ch.idle_thread_wa, sizeof(ch.idle_thread_wa), IDLEPRIO,
 800060a:	f105 0048 	add.w	r0, r5, #72	; 0x48
 800060e:	9400      	str	r4, [sp, #0]
 8000610:	21d8      	movs	r1, #216	; 0xd8
 8000612:	4b08      	ldr	r3, [pc, #32]	; (8000634 <chSysInit+0x94>)
 8000614:	f000 fa3c 	bl	8000a90 <chThdCreateStatic>
                    (tfunc_t)_idle_thread, NULL);
#endif
}
 8000618:	b003      	add	sp, #12
 800061a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800061c:	e000ed00 	.word	0xe000ed00
 8000620:	05fa0300 	.word	0x05fa0300
 8000624:	e0001000 	.word	0xe0001000
 8000628:	e000edf0 	.word	0xe000edf0
 800062c:	20001070 	.word	0x20001070
 8000630:	080027b0 	.word	0x080027b0
 8000634:	08000581 	.word	0x08000581
 8000638:	f3af 8000 	nop.w
 800063c:	f3af 8000 	nop.w

08000640 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8000640:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8000644:	4c1b      	ldr	r4, [pc, #108]	; (80006b4 <chSysTimerHandlerI+0x74>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000646:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 800064a:	69e3      	ldr	r3, [r4, #28]
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 800064c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800064e:	6a69      	ldr	r1, [r5, #36]	; 0x24

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8000650:	6898      	ldr	r0, [r3, #8]
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8000652:	1a8e      	subs	r6, r1, r2

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8000654:	4286      	cmp	r6, r0
 8000656:	f104 061c 	add.w	r6, r4, #28
 800065a:	d319      	bcc.n	8000690 <chSysTimerHandlerI+0x50>

    /* The timer is removed from the list and marked as non-armed.*/
    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = (vtfunc_t)NULL;
 800065c:	f04f 0800 	mov.w	r8, #0

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000660:	2720      	movs	r7, #32
    /* The "last time" becomes this timer's expiration time.*/
    delta -= vtp->vt_delta;
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    /* The timer is removed from the list and marked as non-armed.*/
    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000662:	6819      	ldr	r1, [r3, #0]
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 8000664:	f8d3 c00c 	ldr.w	ip, [r3, #12]
      break;
    }

    /* The "last time" becomes this timer's expiration time.*/
    delta -= vtp->vt_delta;
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8000668:	4402      	add	r2, r0
 800066a:	62a2      	str	r2, [r4, #40]	; 0x28

    /* The timer is removed from the list and marked as non-armed.*/
    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800066c:	604e      	str	r6, [r1, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 800066e:	61e1      	str	r1, [r4, #28]
    fn = vtp->vt_func;
    vtp->vt_func = (vtfunc_t)NULL;
 8000670:	f8c3 800c 	str.w	r8, [r3, #12]
 8000674:	f388 8811 	msr	BASEPRI, r8

    /* The callback is invoked outside the kernel critical zone.*/
    chSysUnlockFromISR();
    fn(vtp->vt_par);
 8000678:	6918      	ldr	r0, [r3, #16]
 800067a:	47e0      	blx	ip
 800067c:	f387 8811 	msr	BASEPRI, r7
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8000680:	69e3      	ldr	r3, [r4, #28]
 8000682:	6a69      	ldr	r1, [r5, #36]	; 0x24
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8000684:	6aa2      	ldr	r2, [r4, #40]	; 0x28

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8000686:	6898      	ldr	r0, [r3, #8]
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8000688:	ebc2 0e01 	rsb	lr, r2, r1

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 800068c:	4586      	cmp	lr, r0
 800068e:	d2e8      	bcs.n	8000662 <chSysTimerHandlerI+0x22>
    /* The callback is invoked outside the kernel critical zone.*/
    chSysUnlockFromISR();
    fn(vtp->vt_par);
    chSysLockFromISR();
  }
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000690:	42b3      	cmp	r3, r6
 8000692:	d00b      	beq.n	80006ac <chSysTimerHandlerI+0x6c>
    port_timer_stop_alarm();
  }
  else {
    /* Updating the alarm to the next deadline, deadline that must not be
       closer in time than the minimum time delta.*/
    if (vtp->vt_delta >= CH_CFG_ST_TIMEDELTA) {
 8000694:	2801      	cmp	r0, #1
 8000696:	d004      	beq.n	80006a2 <chSysTimerHandlerI+0x62>
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8000698:	4408      	add	r0, r1
#endif
  chVTDoTickI();
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 800069a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800069e:	f000 be6f 	b.w	8001380 <stSetAlarm>
 80006a2:	1c88      	adds	r0, r1, #2
 80006a4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80006a8:	f000 be6a 	b.w	8001380 <stSetAlarm>
 80006ac:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 80006b0:	f000 be5e 	b.w	8001370 <stStopAlarm>
 80006b4:	20001040 	.word	0x20001040
 80006b8:	f3af 8000 	nop.w
 80006bc:	f3af 8000 	nop.w

080006c0 <chTMStartMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80006c0:	4b01      	ldr	r3, [pc, #4]	; (80006c8 <chTMStartMeasurementX+0x8>)
 80006c2:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 80006c4:	6083      	str	r3, [r0, #8]
 80006c6:	4770      	bx	lr
 80006c8:	e0001000 	.word	0xe0001000
 80006cc:	f3af 8000 	nop.w

080006d0 <chTMStopMeasurementX>:
 80006d0:	4b0f      	ldr	r3, [pc, #60]	; (8000710 <chTMStopMeasurementX+0x40>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80006d2:	4910      	ldr	r1, [pc, #64]	; (8000714 <chTMStopMeasurementX+0x44>)
 80006d4:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = now - tmp->last - offset;
 80006d6:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80006d8:	b4f0      	push	{r4, r5, r6, r7}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80006da:	6f4f      	ldr	r7, [r1, #116]	; 0x74

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 80006dc:	68c6      	ldr	r6, [r0, #12]
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 80006de:	6841      	ldr	r1, [r0, #4]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 80006e0:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = now - tmp->last - offset;
 80006e4:	1ad3      	subs	r3, r2, r3
 80006e6:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
 80006e8:	18e4      	adds	r4, r4, r3
 80006ea:	f145 0500 	adc.w	r5, r5, #0

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 80006ee:	3601      	adds	r6, #1
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 80006f0:	428b      	cmp	r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 80006f2:	60c6      	str	r6, [r0, #12]
  tmp->last = now - tmp->last - offset;
 80006f4:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 80006f6:	e9c0 4504 	strd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
 80006fa:	d805      	bhi.n	8000708 <chTMStopMeasurementX+0x38>
    tmp->worst = tmp->last;
  }
  else if (tmp->last < tmp->best) {
 80006fc:	6802      	ldr	r2, [r0, #0]
 80006fe:	4293      	cmp	r3, r2
    tmp->best = tmp->last;
 8000700:	bf38      	it	cc
 8000702:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8000704:	bcf0      	pop	{r4, r5, r6, r7}
 8000706:	4770      	bx	lr

  tmp->n++;
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 8000708:	6043      	str	r3, [r0, #4]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 800070a:	bcf0      	pop	{r4, r5, r6, r7}
 800070c:	4770      	bx	lr
 800070e:	bf00      	nop
 8000710:	e0001000 	.word	0xe0001000
 8000714:	20001040 	.word	0x20001040
 8000718:	f3af 8000 	nop.w
 800071c:	f3af 8000 	nop.w

08000720 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8000720:	b5d0      	push	{r4, r6, r7, lr}
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
 8000722:	4c0c      	ldr	r4, [pc, #48]	; (8000754 <_tm_init+0x34>)
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8000724:	b086      	sub	sp, #24
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
 8000726:	2300      	movs	r3, #0
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8000728:	f04f 32ff 	mov.w	r2, #4294967295
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 800072c:	4668      	mov	r0, sp

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 800072e:	2600      	movs	r6, #0
 8000730:	2700      	movs	r7, #0
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
 8000732:	6763      	str	r3, [r4, #116]	; 0x74
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 8000734:	9301      	str	r3, [sp, #4]
  tmp->last       = (rtcnt_t)0;
 8000736:	9302      	str	r3, [sp, #8]
  tmp->n          = (ucnt_t)0;
 8000738:	9303      	str	r3, [sp, #12]
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 800073a:	9200      	str	r2, [sp, #0]
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 800073c:	e9cd 6704 	strd	r6, r7, [sp, #16]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8000740:	f7ff ffbe 	bl	80006c0 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 8000744:	4668      	mov	r0, sp
 8000746:	f7ff ffc3 	bl	80006d0 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 800074a:	9b02      	ldr	r3, [sp, #8]
 800074c:	6763      	str	r3, [r4, #116]	; 0x74
}
 800074e:	b006      	add	sp, #24
 8000750:	bdd0      	pop	{r4, r6, r7, pc}
 8000752:	bf00      	nop
 8000754:	20001040 	.word	0x20001040
 8000758:	f3af 8000 	nop.w
 800075c:	f3af 8000 	nop.w

08000760 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000760:	b410      	push	{r4}
 8000762:	2320      	movs	r3, #32
 8000764:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 8000768:	7f03      	ldrb	r3, [r0, #28]
 800076a:	2b07      	cmp	r3, #7
 800076c:	d80e      	bhi.n	800078c <wakeup+0x2c>
 800076e:	e8df f003 	tbb	[pc, r3]
 8000772:	0d27      	.short	0x0d27
 8000774:	0408230d 	.word	0x0408230d
 8000778:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *(thread_reference_t *)tp->p_u.wtobjp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES
  case CH_STATE_WTSEM:
    chSemFastSignalI((semaphore_t *)tp->p_u.wtobjp);
 800077a:	6a02      	ldr	r2, [r0, #32]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 800077c:	6893      	ldr	r3, [r2, #8]
 800077e:	3301      	adds	r3, #1
 8000780:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000782:	e890 000c 	ldmia.w	r0, {r2, r3}
 8000786:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000788:	6802      	ldr	r2, [r0, #0]
 800078a:	6053      	str	r3, [r2, #4]
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    queue_dequeue(tp);
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 800078c:	f04f 34ff 	mov.w	r4, #4294967295
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000790:	2200      	movs	r2, #0
 8000792:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000794:	4b0d      	ldr	r3, [pc, #52]	; (80007cc <wakeup+0x6c>)
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    queue_dequeue(tp);
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8000796:	6204      	str	r4, [r0, #32]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000798:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800079a:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800079c:	689a      	ldr	r2, [r3, #8]
 800079e:	428a      	cmp	r2, r1
 80007a0:	d2fb      	bcs.n	800079a <wakeup+0x3a>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80007a2:	685a      	ldr	r2, [r3, #4]
 80007a4:	6042      	str	r2, [r0, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80007a6:	6003      	str	r3, [r0, #0]
 80007a8:	2100      	movs	r1, #0
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 80007aa:	6058      	str	r0, [r3, #4]
 80007ac:	6010      	str	r0, [r2, #0]
 80007ae:	f381 8811 	msr	BASEPRI, r1
    queue_dequeue(tp);
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  chSchReadyI(tp);
  chSysUnlockFromISR();
}
 80007b2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80007b6:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *(thread_reference_t *)tp->p_u.wtobjp = NULL;
 80007b8:	6a03      	ldr	r3, [r0, #32]
 80007ba:	2200      	movs	r2, #0
 80007bc:	601a      	str	r2, [r3, #0]
    break;
 80007be:	e7e5      	b.n	800078c <wakeup+0x2c>
 80007c0:	2300      	movs	r3, #0
 80007c2:	f383 8811 	msr	BASEPRI, r3
    queue_dequeue(tp);
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  chSchReadyI(tp);
  chSysUnlockFromISR();
}
 80007c6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80007ca:	4770      	bx	lr
 80007cc:	20001040 	.word	0x20001040

080007d0 <_scheduler_init>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 80007d0:	4b03      	ldr	r3, [pc, #12]	; (80007e0 <_scheduler_init+0x10>)
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 80007d2:	2200      	movs	r2, #0
 80007d4:	605b      	str	r3, [r3, #4]
 80007d6:	601b      	str	r3, [r3, #0]
#if CH_CFG_USE_REGISTRY
  ch.rlist.r_newer = ch.rlist.r_older = (thread_t *)&ch.rlist;
 80007d8:	615b      	str	r3, [r3, #20]
 80007da:	611b      	str	r3, [r3, #16]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 80007dc:	609a      	str	r2, [r3, #8]
 80007de:	4770      	bx	lr
 80007e0:	20001040 	.word	0x20001040
 80007e4:	f3af 8000 	nop.w
 80007e8:	f3af 8000 	nop.w
 80007ec:	f3af 8000 	nop.w

080007f0 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80007f0:	2200      	movs	r2, #0
 80007f2:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 80007f4:	4b08      	ldr	r3, [pc, #32]	; (8000818 <chSchReadyI+0x28>)
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 80007f6:	b410      	push	{r4}
 80007f8:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80007fa:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 80007fc:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80007fe:	689a      	ldr	r2, [r3, #8]
 8000800:	428a      	cmp	r2, r1
 8000802:	d2fb      	bcs.n	80007fc <chSchReadyI+0xc>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000804:	685a      	ldr	r2, [r3, #4]
 8000806:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000808:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;

  return tp;
}
 800080a:	4620      	mov	r0, r4
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 800080c:	605c      	str	r4, [r3, #4]
 800080e:	6014      	str	r4, [r2, #0]

  return tp;
}
 8000810:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000814:	4770      	bx	lr
 8000816:	bf00      	nop
 8000818:	20001040 	.word	0x20001040
 800081c:	f3af 8000 	nop.w

08000820 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 8000820:	4b07      	ldr	r3, [pc, #28]	; (8000840 <chSchGoSleepS+0x20>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000822:	b430      	push	{r4, r5}
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8000824:	681a      	ldr	r2, [r3, #0]
  thread_t *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 8000826:	6999      	ldr	r1, [r3, #24]

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8000828:	6814      	ldr	r4, [r2, #0]
 800082a:	7708      	strb	r0, [r1, #28]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800082c:	2501      	movs	r5, #1
 800082e:	6063      	str	r3, [r4, #4]
 8000830:	7715      	strb	r5, [r2, #28]
 8000832:	601c      	str	r4, [r3, #0]
  chSysSwitch(currp, otp);
 8000834:	4610      	mov	r0, r2
}
 8000836:	bc30      	pop	{r4, r5}
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000838:	619a      	str	r2, [r3, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 800083a:	f7ff bd19 	b.w	8000270 <_port_switch>
 800083e:	bf00      	nop
 8000840:	20001040 	.word	0x20001040
 8000844:	f3af 8000 	nop.w
 8000848:	f3af 8000 	nop.w
 800084c:	f3af 8000 	nop.w

08000850 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000850:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000852:	1c4b      	adds	r3, r1, #1
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000854:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000856:	d012      	beq.n	800087e <chSchGoSleepTimeoutS+0x2e>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8000858:	4c0c      	ldr	r4, [pc, #48]	; (800088c <chSchGoSleepTimeoutS+0x3c>)
 800085a:	4a0d      	ldr	r2, [pc, #52]	; (8000890 <chSchGoSleepTimeoutS+0x40>)
 800085c:	69a3      	ldr	r3, [r4, #24]
 800085e:	4605      	mov	r5, r0
 8000860:	a801      	add	r0, sp, #4
 8000862:	f000 f895 	bl	8000990 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8000866:	4628      	mov	r0, r5
 8000868:	f7ff ffda 	bl	8000820 <chSchGoSleepS>
    if (chVTIsArmedI(&vt))
 800086c:	9b04      	ldr	r3, [sp, #16]
 800086e:	b113      	cbz	r3, 8000876 <chSchGoSleepTimeoutS+0x26>
      chVTDoResetI(&vt);
 8000870:	a801      	add	r0, sp, #4
 8000872:	f000 f8c5 	bl	8000a00 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 8000876:	69a3      	ldr	r3, [r4, #24]
}
 8000878:	6a18      	ldr	r0, [r3, #32]
 800087a:	b007      	add	sp, #28
 800087c:	bd30      	pop	{r4, r5, pc}
 800087e:	4c03      	ldr	r4, [pc, #12]	; (800088c <chSchGoSleepTimeoutS+0x3c>)
    chSchGoSleepS(newstate);
    if (chVTIsArmedI(&vt))
      chVTDoResetI(&vt);
  }
  else {
    chSchGoSleepS(newstate);
 8000880:	f7ff ffce 	bl	8000820 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8000884:	69a3      	ldr	r3, [r4, #24]
}
 8000886:	6a18      	ldr	r0, [r3, #32]
 8000888:	b007      	add	sp, #28
 800088a:	bd30      	pop	{r4, r5, pc}
 800088c:	20001040 	.word	0x20001040
 8000890:	08000761 	.word	0x08000761
 8000894:	f3af 8000 	nop.w
 8000898:	f3af 8000 	nop.w
 800089c:	f3af 8000 	nop.w

080008a0 <chSchWakeupS>:

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80008a0:	4b14      	ldr	r3, [pc, #80]	; (80008f4 <chSchWakeupS+0x54>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80008a2:	b4f0      	push	{r4, r5, r6, r7}

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80008a4:	699e      	ldr	r6, [r3, #24]
 80008a6:	6884      	ldr	r4, [r0, #8]
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80008a8:	4605      	mov	r5, r0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80008aa:	68b0      	ldr	r0, [r6, #8]

  chDbgCheckClassS();

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 80008ac:	6229      	str	r1, [r5, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80008ae:	4284      	cmp	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80008b0:	f04f 0200 	mov.w	r2, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80008b4:	d80b      	bhi.n	80008ce <chSchWakeupS+0x2e>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80008b6:	772a      	strb	r2, [r5, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 80008b8:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80008ba:	689a      	ldr	r2, [r3, #8]
 80008bc:	4294      	cmp	r4, r2
 80008be:	d9fb      	bls.n	80008b8 <chSchWakeupS+0x18>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80008c0:	685a      	ldr	r2, [r3, #4]
 80008c2:	606a      	str	r2, [r5, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80008c4:	602b      	str	r3, [r5, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 80008c6:	605d      	str	r5, [r3, #4]
 80008c8:	6015      	str	r5, [r2, #0]
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 80008ca:	bcf0      	pop	{r4, r5, r6, r7}
 80008cc:	4770      	bx	lr
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80008ce:	7732      	strb	r2, [r6, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 80008d0:	461a      	mov	r2, r3
  do {
    cp = cp->p_next;
 80008d2:	6812      	ldr	r2, [r2, #0]
  } while (cp->p_prio >= tp->p_prio);
 80008d4:	6891      	ldr	r1, [r2, #8]
 80008d6:	4288      	cmp	r0, r1
 80008d8:	d9fb      	bls.n	80008d2 <chSchWakeupS+0x32>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80008da:	6854      	ldr	r4, [r2, #4]
 80008dc:	6074      	str	r4, [r6, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 80008de:	2701      	movs	r7, #1
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80008e0:	6032      	str	r2, [r6, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 80008e2:	6056      	str	r6, [r2, #4]
 80008e4:	6026      	str	r6, [r4, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 80008e6:	772f      	strb	r7, [r5, #28]
    chSysSwitch(ntp, otp);
 80008e8:	4631      	mov	r1, r6
 80008ea:	4628      	mov	r0, r5
  if (ntp->p_prio <= currp->p_prio) {
    chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 80008ec:	619d      	str	r5, [r3, #24]
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 80008ee:	bcf0      	pop	{r4, r5, r6, r7}
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 80008f0:	f7ff bcbe 	b.w	8000270 <_port_switch>
 80008f4:	20001040 	.word	0x20001040
 80008f8:	f3af 8000 	nop.w
 80008fc:	f3af 8000 	nop.w

08000900 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8000900:	4b04      	ldr	r3, [pc, #16]	; (8000914 <chSchIsPreemptionRequired+0x14>)
 8000902:	681a      	ldr	r2, [r3, #0]
  tprio_t p2 = currp->p_prio;
 8000904:	699b      	ldr	r3, [r3, #24]
     if the first thread on the ready queue has equal or higher priority.*/
  return currp->p_preempt ? p1 > p2 : p1 >= p2;
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8000906:	6890      	ldr	r0, [r2, #8]
 8000908:	689b      	ldr	r3, [r3, #8]
#endif
}
 800090a:	4298      	cmp	r0, r3
 800090c:	bf94      	ite	ls
 800090e:	2000      	movls	r0, #0
 8000910:	2001      	movhi	r0, #1
 8000912:	4770      	bx	lr
 8000914:	20001040 	.word	0x20001040
 8000918:	f3af 8000 	nop.w
 800091c:	f3af 8000 	nop.w

08000920 <chSchDoRescheduleAhead>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 8000920:	4a0d      	ldr	r2, [pc, #52]	; (8000958 <chSchDoRescheduleAhead+0x38>)
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8000922:	6810      	ldr	r0, [r2, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8000924:	b470      	push	{r4, r5, r6}

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8000926:	6803      	ldr	r3, [r0, #0]
  thread_t *otp, *cp;

  otp = currp;
 8000928:	6994      	ldr	r4, [r2, #24]
 800092a:	6013      	str	r3, [r2, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800092c:	2601      	movs	r6, #1

  otp->p_state = CH_STATE_READY;
 800092e:	2500      	movs	r5, #0
 8000930:	68a1      	ldr	r1, [r4, #8]
 8000932:	605a      	str	r2, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000934:	7706      	strb	r6, [r0, #28]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000936:	6190      	str	r0, [r2, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 8000938:	7725      	strb	r5, [r4, #28]
 800093a:	e000      	b.n	800093e <chSchDoRescheduleAhead+0x1e>
 800093c:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 800093e:	689a      	ldr	r2, [r3, #8]
 8000940:	428a      	cmp	r2, r1
 8000942:	d8fb      	bhi.n	800093c <chSchDoRescheduleAhead+0x1c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8000944:	685a      	ldr	r2, [r3, #4]
 8000946:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8000948:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
 800094a:	4621      	mov	r1, r4
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;
 800094c:	605c      	str	r4, [r3, #4]
 800094e:	6014      	str	r4, [r2, #0]

  chSysSwitch(currp, otp);
}
 8000950:	bc70      	pop	{r4, r5, r6}
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
 8000952:	f7ff bc8d 	b.w	8000270 <_port_switch>
 8000956:	bf00      	nop
 8000958:	20001040 	.word	0x20001040
 800095c:	f3af 8000 	nop.w

08000960 <chSchDoReschedule>:
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8000960:	f7ff bfde 	b.w	8000920 <chSchDoRescheduleAhead>
 8000964:	f3af 8000 	nop.w
 8000968:	f3af 8000 	nop.w
 800096c:	f3af 8000 	nop.w

08000970 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
 8000970:	4b05      	ldr	r3, [pc, #20]	; (8000988 <_vt_init+0x18>)
  ch.vtlist.vt_delta = (systime_t)-1;
 8000972:	f04f 30ff 	mov.w	r0, #4294967295
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
 8000976:	f103 021c 	add.w	r2, r3, #28
  ch.vtlist.vt_delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = 0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = 0;
 800097a:	2100      	movs	r1, #0
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 800097c:	6258      	str	r0, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = 0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = 0;
 800097e:	6299      	str	r1, [r3, #40]	; 0x28
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
 8000980:	621a      	str	r2, [r3, #32]
 8000982:	61da      	str	r2, [r3, #28]
 8000984:	4770      	bx	lr
 8000986:	bf00      	nop
 8000988:	20001040 	.word	0x20001040
 800098c:	f3af 8000 	nop.w

08000990 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8000990:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = ch.vtlist.vt_next;
 8000992:	4f1a      	ldr	r7, [pc, #104]	; (80009fc <chVTDoSetI+0x6c>)
 8000994:	46be      	mov	lr, r7
    systime_t now = port_timer_get_time();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < CH_CFG_ST_TIMEDELTA) {
      delay = CH_CFG_ST_TIMEDELTA;
 8000996:	2901      	cmp	r1, #1
 8000998:	bf8c      	ite	hi
 800099a:	460d      	movhi	r5, r1
 800099c:	2502      	movls	r5, #2
  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = ch.vtlist.vt_next;
 800099e:	f85e 4f1c 	ldr.w	r4, [lr, #28]!
  virtual_timer_t *p;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 80009a2:	6103      	str	r3, [r0, #16]
 80009a4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
       is raised to the minimum safe value.*/
    if (delay < CH_CFG_ST_TIMEDELTA) {
      delay = CH_CFG_ST_TIMEDELTA;
    }

    if (&ch.vtlist == (virtual_timers_list_t *)p) {
 80009a8:	4574      	cmp	r4, lr

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 80009aa:	60c2      	str	r2, [r0, #12]
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 80009ac:	4606      	mov	r6, r0
 80009ae:	6a5a      	ldr	r2, [r3, #36]	; 0x24
       is raised to the minimum safe value.*/
    if (delay < CH_CFG_ST_TIMEDELTA) {
      delay = CH_CFG_ST_TIMEDELTA;
    }

    if (&ch.vtlist == (virtual_timers_list_t *)p) {
 80009b0:	d01d      	beq.n	80009ee <chVTDoSetI+0x5e>
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
    }
    else {
      /* Now the delay is calculated as delta from the last tick interrupt
         time.*/
      delay += now - ch.vtlist.vt_lasttime;
 80009b2:	6ab8      	ldr	r0, [r7, #40]	; 0x28

      /* If the specified delay is closer in time than the first element
         in the delta list then it becomes the next alarm event in time.*/
      if (delay < p->vt_delta) {
 80009b4:	68a3      	ldr	r3, [r4, #8]
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
    }
    else {
      /* Now the delay is calculated as delta from the last tick interrupt
         time.*/
      delay += now - ch.vtlist.vt_lasttime;
 80009b6:	1a12      	subs	r2, r2, r0
 80009b8:	4415      	add	r5, r2

      /* If the specified delay is closer in time than the first element
         in the delta list then it becomes the next alarm event in time.*/
      if (delay < p->vt_delta) {
 80009ba:	429d      	cmp	r5, r3
 80009bc:	d203      	bcs.n	80009c6 <chVTDoSetI+0x36>
 80009be:	e011      	b.n	80009e4 <chVTDoSetI+0x54>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delay) {
    delay -= p->vt_delta;
    p = p->vt_next;
 80009c0:	6824      	ldr	r4, [r4, #0]
#endif /* CH_CFG_ST_TIMEDELTA > 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delay) {
    delay -= p->vt_delta;
 80009c2:	1aed      	subs	r5, r5, r3
  }
#endif /* CH_CFG_ST_TIMEDELTA > 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delay) {
 80009c4:	68a3      	ldr	r3, [r4, #8]
 80009c6:	42ab      	cmp	r3, r5
 80009c8:	d3fa      	bcc.n	80009c0 <chVTDoSetI+0x30>
    delay -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
 80009ca:	6863      	ldr	r3, [r4, #4]
 80009cc:	6073      	str	r3, [r6, #4]
 80009ce:	6034      	str	r4, [r6, #0]
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
 80009d0:	6066      	str	r6, [r4, #4]
 80009d2:	601e      	str	r6, [r3, #0]
  vtp->vt_delta = delay
 80009d4:	60b5      	str	r5, [r6, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delay;
 80009d6:	68a1      	ldr	r1, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 80009d8:	f04f 33ff 	mov.w	r3, #4294967295
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
  vtp->vt_delta = delay

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delay;
 80009dc:	1b49      	subs	r1, r1, r5
 80009de:	60a1      	str	r1, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 80009e0:	627b      	str	r3, [r7, #36]	; 0x24
 80009e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 80009e4:	4428      	add	r0, r5
 80009e6:	f000 fccb 	bl	8001380 <stSetAlarm>
 80009ea:	68a3      	ldr	r3, [r4, #8]
 80009ec:	e7eb      	b.n	80009c6 <chVTDoSetI+0x36>
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {

  stStartAlarm(time);
 80009ee:	18a8      	adds	r0, r5, r2
    }

    if (&ch.vtlist == (virtual_timers_list_t *)p) {
      /* The delta list is empty, the current time becomes the new
         delta list base time.*/
      ch.vtlist.vt_lasttime = now;
 80009f0:	62ba      	str	r2, [r7, #40]	; 0x28
 80009f2:	f000 fcb5 	bl	8001360 <stStartAlarm>
 80009f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80009f8:	e7e5      	b.n	80009c6 <chVTDoSetI+0x36>
 80009fa:	bf00      	nop
 80009fc:	20001040 	.word	0x20001040

08000a00 <chVTDoResetI>:
  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8000a00:	6802      	ldr	r2, [r0, #0]
 8000a02:	6883      	ldr	r3, [r0, #8]
 8000a04:	6891      	ldr	r1, [r2, #8]
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8000a06:	b430      	push	{r4, r5}
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = (vtfunc_t)NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8000a08:	4c10      	ldr	r4, [pc, #64]	; (8000a4c <chVTDoResetI+0x4c>)
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
 8000a0a:	6845      	ldr	r5, [r0, #4]
  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8000a0c:	4419      	add	r1, r3
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000a0e:	4623      	mov	r3, r4
  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8000a10:	6091      	str	r1, [r2, #8]
  vtp->vt_prev->vt_next = vtp->vt_next;
 8000a12:	602a      	str	r2, [r5, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
 8000a14:	6801      	ldr	r1, [r0, #0]
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000a16:	f853 2f1c 	ldr.w	r2, [r3, #28]!
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
 8000a1a:	604d      	str	r5, [r1, #4]
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000a1c:	429a      	cmp	r2, r3

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = (vtfunc_t)NULL;
 8000a1e:	f04f 0500 	mov.w	r5, #0

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8000a22:	f04f 31ff 	mov.w	r1, #4294967295

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = (vtfunc_t)NULL;
 8000a26:	60c5      	str	r5, [r0, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8000a28:	6261      	str	r1, [r4, #36]	; 0x24

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000a2a:	d00b      	beq.n	8000a44 <chVTDoResetI+0x44>
      port_timer_stop_alarm();
    }
    else {
      /* Updating the alarm to the next deadline, deadline that must not be
         closer in time than the minimum time delta.*/
      if (ch.vtlist.vt_next->vt_delta >= CH_CFG_ST_TIMEDELTA) {
 8000a2c:	6893      	ldr	r3, [r2, #8]
        port_timer_set_alarm(ch.vtlist.vt_lasttime +
 8000a2e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
      port_timer_stop_alarm();
    }
    else {
      /* Updating the alarm to the next deadline, deadline that must not be
         closer in time than the minimum time delta.*/
      if (ch.vtlist.vt_next->vt_delta >= CH_CFG_ST_TIMEDELTA) {
 8000a30:	2b01      	cmp	r3, #1
 8000a32:	d903      	bls.n	8000a3c <chVTDoResetI+0x3c>
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8000a34:	4418      	add	r0, r3
                             CH_CFG_ST_TIMEDELTA);
      }
    }
  }
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000a36:	bc30      	pop	{r4, r5}
 8000a38:	f000 bca2 	b.w	8001380 <stSetAlarm>
 8000a3c:	3002      	adds	r0, #2
 8000a3e:	bc30      	pop	{r4, r5}
 8000a40:	f000 bc9e 	b.w	8001380 <stSetAlarm>
 8000a44:	bc30      	pop	{r4, r5}
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 8000a46:	f000 bc93 	b.w	8001370 <stStopAlarm>
 8000a4a:	bf00      	nop
 8000a4c:	20001040 	.word	0x20001040

08000a50 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8000a50:	b5f0      	push	{r4, r5, r6, r7, lr}
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000a52:	4c0e      	ldr	r4, [pc, #56]	; (8000a8c <_thread_init+0x3c>)
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
 8000a54:	63c1      	str	r1, [r0, #60]	; 0x3c
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000a56:	6966      	ldr	r6, [r4, #20]
 8000a58:	6146      	str	r6, [r0, #20]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8000a5a:	2200      	movs	r2, #0
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
 8000a5c:	f100 0528 	add.w	r5, r0, #40	; 0x28
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8000a60:	f04f 0c02 	mov.w	ip, #2
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 8000a64:	f04f 0e01 	mov.w	lr, #1
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
 8000a68:	f100 0724 	add.w	r7, r0, #36	; 0x24
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8000a6c:	6081      	str	r1, [r0, #8]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000a6e:	6104      	str	r4, [r0, #16]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8000a70:	f880 c01c 	strb.w	ip, [r0, #28]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000a74:	6160      	str	r0, [r4, #20]
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 8000a76:	f880 e01e 	strb.w	lr, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8000a7a:	7742      	strb	r2, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8000a7c:	6382      	str	r2, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS
  tp->p_epending = 0;
 8000a7e:	6342      	str	r2, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
 8000a80:	6182      	str	r2, [r0, #24]
  REG_INSERT(tp);
 8000a82:	6130      	str	r0, [r6, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8000a84:	6247      	str	r7, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8000a86:	62c5      	str	r5, [r0, #44]	; 0x2c
 8000a88:	6285      	str	r5, [r0, #40]	; 0x28
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
}
 8000a8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000a8c:	20001040 	.word	0x20001040

08000a90 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8000a90:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000a94:	4699      	mov	r9, r3
 8000a96:	4604      	mov	r4, r0
 8000a98:	2320      	movs	r3, #32
 8000a9a:	f383 8811 	msr	BASEPRI, r3
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000a9e:	4e1a      	ldr	r6, [pc, #104]	; (8000b08 <chThdCreateStatic+0x78>)

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000aa0:	4b1a      	ldr	r3, [pc, #104]	; (8000b0c <chThdCreateStatic+0x7c>)
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000aa2:	6977      	ldr	r7, [r6, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000aa4:	3924      	subs	r1, #36	; 0x24
 8000aa6:	eb00 0a01 	add.w	sl, r0, r1
 8000aaa:	f8c0 a00c 	str.w	sl, [r0, #12]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8000aae:	2500      	movs	r5, #0

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000ab0:	f840 9001 	str.w	r9, [r0, r1]
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 8000ab4:	f04f 0c01 	mov.w	ip, #1
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
 8000ab8:	f100 0928 	add.w	r9, r0, #40	; 0x28

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000abc:	9908      	ldr	r1, [sp, #32]
 8000abe:	f8ca 1004 	str.w	r1, [sl, #4]
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
 8000ac2:	f100 0e24 	add.w	lr, r0, #36	; 0x24
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8000ac6:	f04f 0802 	mov.w	r8, #2

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000aca:	f8ca 3020 	str.w	r3, [sl, #32]
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), MSG_OK);
 8000ace:	4629      	mov	r1, r5
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8000ad0:	6082      	str	r2, [r0, #8]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000ad2:	6106      	str	r6, [r0, #16]
 8000ad4:	6147      	str	r7, [r0, #20]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
 8000ad6:	63c2      	str	r2, [r0, #60]	; 0x3c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8000ad8:	f880 801c 	strb.w	r8, [r0, #28]
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 8000adc:	f880 c01e 	strb.w	ip, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8000ae0:	7745      	strb	r5, [r0, #29]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000ae2:	6170      	str	r0, [r6, #20]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8000ae4:	6385      	str	r5, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS
  tp->p_epending = 0;
 8000ae6:	6345      	str	r5, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
 8000ae8:	6185      	str	r5, [r0, #24]
  REG_INSERT(tp);
 8000aea:	6138      	str	r0, [r7, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8000aec:	f8c0 e024 	str.w	lr, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8000af0:	f8c0 902c 	str.w	r9, [r0, #44]	; 0x2c
 8000af4:	f8c0 9028 	str.w	r9, [r0, #40]	; 0x28
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), MSG_OK);
 8000af8:	f7ff fed2 	bl	80008a0 <chSchWakeupS>
 8000afc:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
 8000b00:	4620      	mov	r0, r4
 8000b02:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000b06:	bf00      	nop
 8000b08:	20001040 	.word	0x20001040
 8000b0c:	08000281 	.word	0x08000281

08000b10 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8000b10:	b508      	push	{r3, lr}
 8000b12:	4601      	mov	r1, r0
 8000b14:	2320      	movs	r3, #32
 8000b16:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8000b1a:	2008      	movs	r0, #8
 8000b1c:	f7ff fe98 	bl	8000850 <chSchGoSleepTimeoutS>
 8000b20:	2300      	movs	r3, #0
 8000b22:	f383 8811 	msr	BASEPRI, r3
 8000b26:	bd08      	pop	{r3, pc}
 8000b28:	f3af 8000 	nop.w
 8000b2c:	f3af 8000 	nop.w

08000b30 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8000b30:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
 8000b32:	4b0e      	ldr	r3, [pc, #56]	; (8000b6c <chThdExitS+0x3c>)
 8000b34:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8000b36:	6a63      	ldr	r3, [r4, #36]	; 0x24

  tp->p_u.exitcode = msg;
 8000b38:	6220      	str	r0, [r4, #32]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  while (list_notempty(&tp->p_waiting)) {
 8000b3a:	f104 0524 	add.w	r5, r4, #36	; 0x24
 8000b3e:	429d      	cmp	r5, r3
 8000b40:	d007      	beq.n	8000b52 <chThdExitS+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 8000b42:	681a      	ldr	r2, [r3, #0]
 8000b44:	6262      	str	r2, [r4, #36]	; 0x24
    chSchReadyI(list_remove(&tp->p_waiting));
 8000b46:	4618      	mov	r0, r3
 8000b48:	f7ff fe52 	bl	80007f0 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8000b4c:	6a63      	ldr	r3, [r4, #36]	; 0x24
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  while (list_notempty(&tp->p_waiting)) {
 8000b4e:	42ab      	cmp	r3, r5
 8000b50:	d1f7      	bne.n	8000b42 <chThdExitS+0x12>
  }
#endif
#if CH_CFG_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8000b52:	7f63      	ldrb	r3, [r4, #29]
 8000b54:	079b      	lsls	r3, r3, #30
 8000b56:	d104      	bne.n	8000b62 <chThdExitS+0x32>
    REG_REMOVE(tp);
 8000b58:	6963      	ldr	r3, [r4, #20]
 8000b5a:	6922      	ldr	r2, [r4, #16]
 8000b5c:	611a      	str	r2, [r3, #16]
 8000b5e:	6922      	ldr	r2, [r4, #16]
 8000b60:	6153      	str	r3, [r2, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8000b62:	200f      	movs	r0, #15

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 8000b64:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8000b68:	f7ff be5a 	b.w	8000820 <chSchGoSleepS>
 8000b6c:	20001040 	.word	0x20001040

08000b70 <chThdExit>:
 8000b70:	2320      	movs	r3, #32
 8000b72:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
 8000b76:	f7ff bfdb 	b.w	8000b30 <chThdExitS>
 8000b7a:	bf00      	nop
 8000b7c:	f3af 8000 	nop.w

08000b80 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 8000b80:	b169      	cbz	r1, 8000b9e <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000b82:	4b08      	ldr	r3, [pc, #32]	; (8000ba4 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8000b84:	b410      	push	{r4}
 8000b86:	4602      	mov	r2, r0
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8000b88:	6844      	ldr	r4, [r0, #4]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000b8a:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000b8c:	2004      	movs	r0, #4
 8000b8e:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->p_prev->p_next = tqp->p_prev = tp;
 8000b92:	6053      	str	r3, [r2, #4]
 8000b94:	6023      	str	r3, [r4, #0]
}
 8000b96:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000b9a:	f7ff be59 	b.w	8000850 <chSchGoSleepTimeoutS>
}
 8000b9e:	f04f 30ff 	mov.w	r0, #4294967295
 8000ba2:	4770      	bx	lr
 8000ba4:	20001040 	.word	0x20001040
 8000ba8:	f3af 8000 	nop.w
 8000bac:	f3af 8000 	nop.w

08000bb0 <chThdDequeueNextI>:
 *
 * @notapi
 */
static inline bool queue_notempty(threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (thread_t *)tqp);
 8000bb0:	6802      	ldr	r2, [r0, #0]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8000bb2:	4290      	cmp	r0, r2
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8000bb4:	4603      	mov	r3, r0

  if (queue_notempty(tqp)) {
 8000bb6:	d009      	beq.n	8000bcc <chThdDequeueNextI+0x1c>
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8000bb8:	b410      	push	{r4}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8000bba:	6814      	ldr	r4, [r2, #0]
 8000bbc:	6004      	str	r4, [r0, #0]
 8000bbe:	6063      	str	r3, [r4, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8000bc0:	6211      	str	r1, [r2, #32]
  chSchReadyI(tp);
 8000bc2:	4610      	mov	r0, r2

  if (queue_notempty(tqp)) {
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8000bc4:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000bc8:	f7ff be12 	b.w	80007f0 <chSchReadyI>
 8000bcc:	4770      	bx	lr
 8000bce:	bf00      	nop

08000bd0 <chMtxObjectInit>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 8000bd0:	2300      	movs	r3, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8000bd2:	6040      	str	r0, [r0, #4]
 8000bd4:	6000      	str	r0, [r0, #0]
 8000bd6:	6083      	str	r3, [r0, #8]
 8000bd8:	4770      	bx	lr
 8000bda:	bf00      	nop
 8000bdc:	f3af 8000 	nop.w

08000be0 <chMtxLockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8000be0:	4b30      	ldr	r3, [pc, #192]	; (8000ca4 <chMtxLockS+0xc4>)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8000be2:	6882      	ldr	r2, [r0, #8]
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8000be4:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8000be6:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8000be8:	2a00      	cmp	r2, #0
 8000bea:	d055      	beq.n	8000c98 <chMtxLockS+0xb8>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8000bec:	68a1      	ldr	r1, [r4, #8]
 8000bee:	6893      	ldr	r3, [r2, #8]
 8000bf0:	4299      	cmp	r1, r3
 8000bf2:	4605      	mov	r5, r0
 8000bf4:	d906      	bls.n	8000c04 <chMtxLockS+0x24>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8000bf6:	7f13      	ldrb	r3, [r2, #28]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 8000bf8:	6091      	str	r1, [r2, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8000bfa:	2b06      	cmp	r3, #6
 8000bfc:	d033      	beq.n	8000c66 <chMtxLockS+0x86>
 8000bfe:	2b07      	cmp	r3, #7
 8000c00:	d01d      	beq.n	8000c3e <chMtxLockS+0x5e>
 8000c02:	b19b      	cbz	r3, 8000c2c <chMtxLockS+0x4c>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000c04:	462b      	mov	r3, r5
 8000c06:	e003      	b.n	8000c10 <chMtxLockS+0x30>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000c08:	6899      	ldr	r1, [r3, #8]
 8000c0a:	68a2      	ldr	r2, [r4, #8]
 8000c0c:	4291      	cmp	r1, r2
 8000c0e:	d302      	bcc.n	8000c16 <chMtxLockS+0x36>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8000c10:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000c12:	429d      	cmp	r5, r3
 8000c14:	d1f8      	bne.n	8000c08 <chMtxLockS+0x28>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000c16:	685a      	ldr	r2, [r3, #4]
 8000c18:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8000c1a:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 8000c1c:	605c      	str	r4, [r3, #4]
 8000c1e:	6014      	str	r4, [r2, #0]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtobjp = mp;
 8000c20:	6225      	str	r5, [r4, #32]
      chSchGoSleepS(CH_STATE_WTMTX);
 8000c22:	2006      	movs	r0, #6
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
  }
}
 8000c24:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtobjp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8000c28:	f7ff bdfa 	b.w	8000820 <chSchGoSleepS>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000c2c:	e892 000a 	ldmia.w	r2, {r1, r3}
 8000c30:	6019      	str	r1, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000c32:	6811      	ldr	r1, [r2, #0]
  #if CH_DBG_ENABLE_ASSERTS
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
  #endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          chSchReadyI(queue_dequeue(tp));
 8000c34:	4610      	mov	r0, r2
 8000c36:	604b      	str	r3, [r1, #4]
 8000c38:	f7ff fdda 	bl	80007f0 <chSchReadyI>
          break;
 8000c3c:	e7e2      	b.n	8000c04 <chMtxLockS+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000c3e:	e892 0009 	ldmia.w	r2, {r0, r3}
 8000c42:	6018      	str	r0, [r3, #0]
  #if CH_CFG_USE_MESSAGES && CH_CFG_USE_MESSAGES_PRIORITY
        case CH_STATE_SNDMSGQ:
  #endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp),
                            (threads_queue_t *)tp->p_u.wtobjp);
 8000c44:	6a16      	ldr	r6, [r2, #32]
  tp->p_next->p_prev = tp->p_prev;
 8000c46:	6810      	ldr	r0, [r2, #0]
 8000c48:	6043      	str	r3, [r0, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000c4a:	4633      	mov	r3, r6
 8000c4c:	e002      	b.n	8000c54 <chMtxLockS+0x74>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000c4e:	6898      	ldr	r0, [r3, #8]
 8000c50:	4288      	cmp	r0, r1
 8000c52:	d302      	bcc.n	8000c5a <chMtxLockS+0x7a>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8000c54:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000c56:	429e      	cmp	r6, r3
 8000c58:	d1f9      	bne.n	8000c4e <chMtxLockS+0x6e>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000c5a:	6859      	ldr	r1, [r3, #4]
 8000c5c:	6051      	str	r1, [r2, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8000c5e:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 8000c60:	605a      	str	r2, [r3, #4]
 8000c62:	600a      	str	r2, [r1, #0]
 8000c64:	e7ce      	b.n	8000c04 <chMtxLockS+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000c66:	e892 0009 	ldmia.w	r2, {r0, r3}
 8000c6a:	6018      	str	r0, [r3, #0]
        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp),
                            (threads_queue_t *)tp->p_u.wtobjp);
 8000c6c:	6a16      	ldr	r6, [r2, #32]
  tp->p_next->p_prev = tp->p_prev;
 8000c6e:	6810      	ldr	r0, [r2, #0]
 8000c70:	6043      	str	r3, [r0, #4]
 8000c72:	4633      	mov	r3, r6
 8000c74:	e002      	b.n	8000c7c <chMtxLockS+0x9c>
static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000c76:	6898      	ldr	r0, [r3, #8]
 8000c78:	4288      	cmp	r0, r1
 8000c7a:	d302      	bcc.n	8000c82 <chMtxLockS+0xa2>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8000c7c:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000c7e:	429e      	cmp	r6, r3
 8000c80:	d1f9      	bne.n	8000c76 <chMtxLockS+0x96>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000c82:	6859      	ldr	r1, [r3, #4]
 8000c84:	6051      	str	r1, [r2, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8000c86:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 8000c88:	605a      	str	r2, [r3, #4]
 8000c8a:	600a      	str	r2, [r1, #0]
          tp = ((mutex_t *)tp->p_u.wtobjp)->m_owner;
 8000c8c:	68b2      	ldr	r2, [r6, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8000c8e:	68a1      	ldr	r1, [r4, #8]
 8000c90:	6893      	ldr	r3, [r2, #8]
 8000c92:	428b      	cmp	r3, r1
 8000c94:	d3af      	bcc.n	8000bf6 <chMtxLockS+0x16>
 8000c96:	e7b5      	b.n	8000c04 <chMtxLockS+0x24>

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
 8000c98:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000c9a:	60c3      	str	r3, [r0, #12]
    chDbgAssert(mp->m_cnt == 0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 8000c9c:	6084      	str	r4, [r0, #8]
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
 8000c9e:	63a0      	str	r0, [r4, #56]	; 0x38
 8000ca0:	bd70      	pop	{r4, r5, r6, pc}
 8000ca2:	bf00      	nop
 8000ca4:	20001040 	.word	0x20001040
 8000ca8:	f3af 8000 	nop.w
 8000cac:	f3af 8000 	nop.w

08000cb0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8000cb0:	b508      	push	{r3, lr}
 8000cb2:	2320      	movs	r3, #32
 8000cb4:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chMtxLockS(mp);
 8000cb8:	f7ff ff92 	bl	8000be0 <chMtxLockS>
 8000cbc:	2300      	movs	r3, #0
 8000cbe:	f383 8811 	msr	BASEPRI, r3
 8000cc2:	bd08      	pop	{r3, pc}
 8000cc4:	f3af 8000 	nop.w
 8000cc8:	f3af 8000 	nop.w
 8000ccc:	f3af 8000 	nop.w

08000cd0 <chMtxUnlock>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 8000cd0:	4b16      	ldr	r3, [pc, #88]	; (8000d2c <chMtxUnlock+0x5c>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8000cd2:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8000cd4:	699d      	ldr	r5, [r3, #24]
 8000cd6:	2320      	movs	r3, #32
 8000cd8:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (thread_t *)tqp);
 8000cdc:	6804      	ldr	r4, [r0, #0]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 8000cde:	68c3      	ldr	r3, [r0, #12]
 8000ce0:	63ab      	str	r3, [r5, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8000ce2:	42a0      	cmp	r0, r4
 8000ce4:	d01c      	beq.n	8000d20 <chMtxUnlock+0x50>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8000ce6:	6be9      	ldr	r1, [r5, #60]	; 0x3c
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8000ce8:	b14b      	cbz	r3, 8000cfe <chMtxUnlock+0x2e>
 8000cea:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8000cec:	4293      	cmp	r3, r2
 8000cee:	d003      	beq.n	8000cf8 <chMtxUnlock+0x28>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 8000cf0:	6892      	ldr	r2, [r2, #8]
 8000cf2:	4291      	cmp	r1, r2
 8000cf4:	bf38      	it	cc
 8000cf6:	4611      	movcc	r1, r2
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 8000cf8:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8000cfa:	2b00      	cmp	r3, #0
 8000cfc:	d1f5      	bne.n	8000cea <chMtxUnlock+0x1a>
 8000cfe:	4603      	mov	r3, r0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8000d00:	6822      	ldr	r2, [r4, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE
      mp->m_cnt = 1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 8000d02:	6ba6      	ldr	r6, [r4, #56]	; 0x38
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 8000d04:	60a9      	str	r1, [r5, #8]
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
      chSchWakeupS(tp, MSG_OK);
 8000d06:	4620      	mov	r0, r4
 8000d08:	601a      	str	r2, [r3, #0]
 8000d0a:	2100      	movs	r1, #0
 8000d0c:	6053      	str	r3, [r2, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE
      mp->m_cnt = 1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 8000d0e:	609c      	str	r4, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 8000d10:	60de      	str	r6, [r3, #12]
      tp->p_mtxlist = mp;
 8000d12:	63a3      	str	r3, [r4, #56]	; 0x38
      chSchWakeupS(tp, MSG_OK);
 8000d14:	f7ff fdc4 	bl	80008a0 <chSchWakeupS>
 8000d18:	2300      	movs	r3, #0
 8000d1a:	f383 8811 	msr	BASEPRI, r3
 8000d1e:	bd70      	pop	{r4, r5, r6, pc}
    }
    else {
      mp->m_owner = NULL;
 8000d20:	2300      	movs	r3, #0
 8000d22:	6083      	str	r3, [r0, #8]
 8000d24:	2300      	movs	r3, #0
 8000d26:	f383 8811 	msr	BASEPRI, r3
 8000d2a:	bd70      	pop	{r4, r5, r6, pc}
 8000d2c:	20001040 	.word	0x20001040

08000d30 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8000d30:	6b43      	ldr	r3, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000d32:	7f02      	ldrb	r2, [r0, #28]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8000d34:	4319      	orrs	r1, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000d36:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8000d38:	6341      	str	r1, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000d3a:	d00a      	beq.n	8000d52 <chEvtSignalI+0x22>
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
 8000d3c:	2a0b      	cmp	r2, #11
 8000d3e:	d000      	beq.n	8000d42 <chEvtSignalI+0x12>
 8000d40:	4770      	bx	lr
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8000d42:	6a03      	ldr	r3, [r0, #32]
 8000d44:	4019      	ands	r1, r3

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8000d46:	428b      	cmp	r3, r1
 8000d48:	d1fa      	bne.n	8000d40 <chEvtSignalI+0x10>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8000d4a:	2300      	movs	r3, #0
 8000d4c:	6203      	str	r3, [r0, #32]
    chSchReadyI(tp);
 8000d4e:	f7ff bd4f 	b.w	80007f0 <chSchReadyI>
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
 8000d52:	6a03      	ldr	r3, [r0, #32]
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000d54:	4219      	tst	r1, r3
 8000d56:	d1f8      	bne.n	8000d4a <chEvtSignalI+0x1a>
 8000d58:	4770      	bx	lr
 8000d5a:	bf00      	nop
 8000d5c:	f3af 8000 	nop.w

08000d60 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000d60:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8000d62:	6804      	ldr	r4, [r0, #0]
  while (elp != (event_listener_t *)esp) {
 8000d64:	42a0      	cmp	r0, r4
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000d66:	4606      	mov	r6, r0
 8000d68:	460d      	mov	r5, r1

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  while (elp != (event_listener_t *)esp) {
 8000d6a:	d00d      	beq.n	8000d88 <chEvtBroadcastFlagsI+0x28>
    elp->el_flags |= flags;
 8000d6c:	68e3      	ldr	r3, [r4, #12]
 8000d6e:	432b      	orrs	r3, r5
 8000d70:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == 0) || ((elp->el_flags & elp->el_wflags) != 0)) {
 8000d72:	b115      	cbz	r5, 8000d7a <chEvtBroadcastFlagsI+0x1a>
 8000d74:	6922      	ldr	r2, [r4, #16]
 8000d76:	4213      	tst	r3, r2
 8000d78:	d003      	beq.n	8000d82 <chEvtBroadcastFlagsI+0x22>
      chEvtSignalI(elp->el_listener, elp->el_events);
 8000d7a:	6860      	ldr	r0, [r4, #4]
 8000d7c:	68a1      	ldr	r1, [r4, #8]
 8000d7e:	f7ff ffd7 	bl	8000d30 <chEvtSignalI>
    }
    elp = elp->el_next;
 8000d82:	6824      	ldr	r4, [r4, #0]

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  while (elp != (event_listener_t *)esp) {
 8000d84:	42a6      	cmp	r6, r4
 8000d86:	d1f1      	bne.n	8000d6c <chEvtBroadcastFlagsI+0xc>
 8000d88:	bd70      	pop	{r4, r5, r6, pc}
 8000d8a:	bf00      	nop
 8000d8c:	f3af 8000 	nop.w

08000d90 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 8000d90:	b430      	push	{r4, r5}
 8000d92:	9c02      	ldr	r4, [sp, #8]
  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
  iqp->q_top = bp + size;
  iqp->q_notify = infy;
  iqp->q_link = link;
 8000d94:	6204      	str	r4, [r0, #32]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8000d96:	2500      	movs	r5, #0
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
  iqp->q_top = bp + size;
 8000d98:	440a      	add	r2, r1
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8000d9a:	6085      	str	r5, [r0, #8]
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
  iqp->q_top = bp + size;
 8000d9c:	6102      	str	r2, [r0, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8000d9e:	6040      	str	r0, [r0, #4]
 8000da0:	6000      	str	r0, [r0, #0]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
 8000da2:	6141      	str	r1, [r0, #20]
 8000da4:	6181      	str	r1, [r0, #24]
 8000da6:	60c1      	str	r1, [r0, #12]
  iqp->q_top = bp + size;
  iqp->q_notify = infy;
 8000da8:	61c3      	str	r3, [r0, #28]
  iqp->q_link = link;
}
 8000daa:	bc30      	pop	{r4, r5}
 8000dac:	4770      	bx	lr
 8000dae:	bf00      	nop

08000db0 <chIQPutI>:
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0));
 8000db0:	6983      	ldr	r3, [r0, #24]
 8000db2:	6942      	ldr	r2, [r0, #20]
 8000db4:	429a      	cmp	r2, r3
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 8000db6:	b510      	push	{r4, lr}
 8000db8:	6883      	ldr	r3, [r0, #8]
 8000dba:	d00f      	beq.n	8000ddc <chIQPutI+0x2c>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8000dbc:	3301      	adds	r3, #1
  *iqp->q_wrptr++ = b;
 8000dbe:	1c54      	adds	r4, r2, #1

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8000dc0:	6083      	str	r3, [r0, #8]
  *iqp->q_wrptr++ = b;
 8000dc2:	6144      	str	r4, [r0, #20]
 8000dc4:	7011      	strb	r1, [r2, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8000dc6:	6942      	ldr	r2, [r0, #20]
 8000dc8:	6903      	ldr	r3, [r0, #16]
 8000dca:	429a      	cmp	r2, r3
 8000dcc:	d301      	bcc.n	8000dd2 <chIQPutI+0x22>
    iqp->q_wrptr = iqp->q_buffer;
 8000dce:	68c3      	ldr	r3, [r0, #12]
 8000dd0:	6143      	str	r3, [r0, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 8000dd2:	2100      	movs	r1, #0
 8000dd4:	f7ff feec 	bl	8000bb0 <chThdDequeueNextI>

  return Q_OK;
 8000dd8:	2000      	movs	r0, #0
 8000dda:	bd10      	pop	{r4, pc}
 8000ddc:	2b00      	cmp	r3, #0
 8000dde:	d0ed      	beq.n	8000dbc <chIQPutI+0xc>
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
 8000de0:	f06f 0003 	mvn.w	r0, #3
 8000de4:	bd10      	pop	{r4, pc}
 8000de6:	bf00      	nop
 8000de8:	f3af 8000 	nop.w
 8000dec:	f3af 8000 	nop.w

08000df0 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t time) {
 8000df0:	b570      	push	{r4, r5, r6, lr}
 8000df2:	2320      	movs	r3, #32
 8000df4:	460e      	mov	r6, r1
 8000df6:	4604      	mov	r4, r0
 8000df8:	f383 8811 	msr	BASEPRI, r3
  uint8_t b;

  chSysLock();
  if (iqp->q_notify) {
 8000dfc:	69c3      	ldr	r3, [r0, #28]
 8000dfe:	b12b      	cbz	r3, 8000e0c <chIQGetTimeout+0x1c>
    iqp->q_notify(iqp);
 8000e00:	4798      	blx	r3
 8000e02:	e003      	b.n	8000e0c <chIQGetTimeout+0x1c>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg;
    if ((msg = chThdEnqueueTimeoutS(&iqp->q_waiting, time)) < Q_OK) {
 8000e04:	f7ff febc 	bl	8000b80 <chThdEnqueueTimeoutS>
 8000e08:	2800      	cmp	r0, #0
 8000e0a:	db15      	blt.n	8000e38 <chIQGetTimeout+0x48>
 8000e0c:	68a5      	ldr	r5, [r4, #8]
 8000e0e:	4620      	mov	r0, r4
 8000e10:	4631      	mov	r1, r6
  chSysLock();
  if (iqp->q_notify) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 8000e12:	2d00      	cmp	r5, #0
 8000e14:	d0f6      	beq.n	8000e04 <chIQGetTimeout+0x14>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8000e16:	69a2      	ldr	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
 8000e18:	6921      	ldr	r1, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8000e1a:	1c53      	adds	r3, r2, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 8000e1c:	428b      	cmp	r3, r1
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8000e1e:	f105 35ff 	add.w	r5, r5, #4294967295
  b = *iqp->q_rdptr++;
 8000e22:	61a3      	str	r3, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8000e24:	60a5      	str	r5, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8000e26:	bf28      	it	cs
 8000e28:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8000e2a:	7810      	ldrb	r0, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8000e2c:	bf28      	it	cs
 8000e2e:	61a3      	strcs	r3, [r4, #24]
 8000e30:	2300      	movs	r3, #0
 8000e32:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return b;
}
 8000e36:	bd70      	pop	{r4, r5, r6, pc}
 8000e38:	f385 8811 	msr	BASEPRI, r5

  while (chIQIsEmptyI(iqp)) {
    msg_t msg;
    if ((msg = chThdEnqueueTimeoutS(&iqp->q_waiting, time)) < Q_OK) {
      chSysUnlock();
      return msg;
 8000e3c:	bd70      	pop	{r4, r5, r6, pc}
 8000e3e:	bf00      	nop

08000e40 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t time) {
 8000e40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000e44:	4604      	mov	r4, r0
 8000e46:	b083      	sub	sp, #12
 8000e48:	4689      	mov	r9, r1
 8000e4a:	4693      	mov	fp, r2
 8000e4c:	461d      	mov	r5, r3
  qnotify_t nfy = iqp->q_notify;
 8000e4e:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8000e52:	2720      	movs	r7, #32
 8000e54:	f387 8811 	msr	BASEPRI, r7
  size_t r = 0;
 8000e58:	2600      	movs	r6, #0
 8000e5a:	9701      	str	r7, [sp, #4]
 8000e5c:	46b2      	mov	sl, r6

  chDbgCheck(n > 0);

  chSysLock();
  while (true) {
    if (nfy) {
 8000e5e:	f1b8 0f00 	cmp.w	r8, #0
 8000e62:	d005      	beq.n	8000e70 <chIQReadTimeout+0x30>
      nfy(iqp);
 8000e64:	4620      	mov	r0, r4
 8000e66:	47c0      	blx	r8
 8000e68:	e002      	b.n	8000e70 <chIQReadTimeout+0x30>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, time) != Q_OK) {
 8000e6a:	f7ff fe89 	bl	8000b80 <chThdEnqueueTimeoutS>
 8000e6e:	b9d8      	cbnz	r0, 8000ea8 <chIQReadTimeout+0x68>
 8000e70:	68a7      	ldr	r7, [r4, #8]
 8000e72:	4620      	mov	r0, r4
 8000e74:	4629      	mov	r1, r5
  while (true) {
    if (nfy) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 8000e76:	2f00      	cmp	r7, #0
 8000e78:	d0f7      	beq.n	8000e6a <chIQReadTimeout+0x2a>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8000e7a:	69a2      	ldr	r2, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8000e7c:	1e7b      	subs	r3, r7, #1
    *bp++ = *iqp->q_rdptr++;
 8000e7e:	1c51      	adds	r1, r2, #1
 8000e80:	61a1      	str	r1, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8000e82:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8000e84:	7813      	ldrb	r3, [r2, #0]
 8000e86:	f809 3b01 	strb.w	r3, [r9], #1
    if (iqp->q_rdptr >= iqp->q_top)
 8000e8a:	6923      	ldr	r3, [r4, #16]
 8000e8c:	69a2      	ldr	r2, [r4, #24]
 8000e8e:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 8000e90:	bf24      	itt	cs
 8000e92:	68e3      	ldrcs	r3, [r4, #12]
 8000e94:	61a3      	strcs	r3, [r4, #24]
 8000e96:	f38a 8811 	msr	BASEPRI, sl

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    r++;
 8000e9a:	3601      	adds	r6, #1
    if (--n == 0) {
 8000e9c:	45b3      	cmp	fp, r6
 8000e9e:	d005      	beq.n	8000eac <chIQReadTimeout+0x6c>
 8000ea0:	9b01      	ldr	r3, [sp, #4]
 8000ea2:	f383 8811 	msr	BASEPRI, r3
 8000ea6:	e7da      	b.n	8000e5e <chIQReadTimeout+0x1e>
 8000ea8:	f387 8811 	msr	BASEPRI, r7
      return r;
    }

    chSysLock();
  }
}
 8000eac:	4630      	mov	r0, r6
 8000eae:	b003      	add	sp, #12
 8000eb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000eb4:	f3af 8000 	nop.w
 8000eb8:	f3af 8000 	nop.w
 8000ebc:	f3af 8000 	nop.w

08000ec0 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 8000ec0:	b430      	push	{r4, r5}
 8000ec2:	9c02      	ldr	r4, [sp, #8]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
  oqp->q_top = bp + size;
  oqp->q_notify = onfy;
  oqp->q_link = link;
 8000ec4:	6204      	str	r4, [r0, #32]
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
  oqp->q_top = bp + size;
 8000ec6:	188d      	adds	r5, r1, r2
 8000ec8:	6105      	str	r5, [r0, #16]
 8000eca:	6040      	str	r0, [r0, #4]
 8000ecc:	6000      	str	r0, [r0, #0]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8000ece:	6082      	str	r2, [r0, #8]
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
 8000ed0:	6141      	str	r1, [r0, #20]
 8000ed2:	6181      	str	r1, [r0, #24]
 8000ed4:	60c1      	str	r1, [r0, #12]
  oqp->q_top = bp + size;
  oqp->q_notify = onfy;
 8000ed6:	61c3      	str	r3, [r0, #28]
  oqp->q_link = link;
}
 8000ed8:	bc30      	pop	{r4, r5}
 8000eda:	4770      	bx	lr
 8000edc:	f3af 8000 	nop.w

08000ee0 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t time) {
 8000ee0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000ee2:	4604      	mov	r4, r0
 8000ee4:	460f      	mov	r7, r1
 8000ee6:	4616      	mov	r6, r2
 8000ee8:	2320      	movs	r3, #32
 8000eea:	f383 8811 	msr	BASEPRI, r3
 8000eee:	e003      	b.n	8000ef8 <chOQPutTimeout+0x18>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg;

    if ((msg = chThdEnqueueTimeoutS(&oqp->q_waiting, time)) < Q_OK) {
 8000ef0:	f7ff fe46 	bl	8000b80 <chThdEnqueueTimeoutS>
 8000ef4:	2800      	cmp	r0, #0
 8000ef6:	db18      	blt.n	8000f2a <chOQPutTimeout+0x4a>
 8000ef8:	68a5      	ldr	r5, [r4, #8]
 8000efa:	4620      	mov	r0, r4
 8000efc:	4631      	mov	r1, r6
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t time) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 8000efe:	2d00      	cmp	r5, #0
 8000f00:	d0f6      	beq.n	8000ef0 <chOQPutTimeout+0x10>
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8000f02:	6963      	ldr	r3, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8000f04:	3d01      	subs	r5, #1
  *oqp->q_wrptr++ = b;
 8000f06:	1c5a      	adds	r2, r3, #1
 8000f08:	6162      	str	r2, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8000f0a:	60a5      	str	r5, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000f0c:	701f      	strb	r7, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8000f0e:	6923      	ldr	r3, [r4, #16]
 8000f10:	6962      	ldr	r2, [r4, #20]
 8000f12:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8000f14:	bf24      	itt	cs
 8000f16:	68e3      	ldrcs	r3, [r4, #12]
 8000f18:	6163      	strcs	r3, [r4, #20]
  }

  if (oqp->q_notify) {
 8000f1a:	69e3      	ldr	r3, [r4, #28]
 8000f1c:	b10b      	cbz	r3, 8000f22 <chOQPutTimeout+0x42>
    oqp->q_notify(oqp);
 8000f1e:	4620      	mov	r0, r4
 8000f20:	4798      	blx	r3
 8000f22:	2000      	movs	r0, #0
 8000f24:	f380 8811 	msr	BASEPRI, r0
  }
  chSysUnlock();

  return Q_OK;
}
 8000f28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000f2a:	f385 8811 	msr	BASEPRI, r5
  while (chOQIsFullI(oqp)) {
    msg_t msg;

    if ((msg = chThdEnqueueTimeoutS(&oqp->q_waiting, time)) < Q_OK) {
      chSysUnlock();
      return msg;
 8000f2e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000f30 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 8000f30:	b538      	push	{r3, r4, r5, lr}
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0));
 8000f32:	6982      	ldr	r2, [r0, #24]
 8000f34:	6943      	ldr	r3, [r0, #20]
 8000f36:	4293      	cmp	r3, r2
 8000f38:	6883      	ldr	r3, [r0, #8]
 8000f3a:	d00e      	beq.n	8000f5a <chOQGetI+0x2a>
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 8000f3c:	6905      	ldr	r5, [r0, #16]
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8000f3e:	1c51      	adds	r1, r2, #1

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8000f40:	3301      	adds	r3, #1
 8000f42:	6083      	str	r3, [r0, #8]
  b = *oqp->q_rdptr++;
 8000f44:	6181      	str	r1, [r0, #24]
  if (oqp->q_rdptr >= oqp->q_top) {
 8000f46:	42a9      	cmp	r1, r5
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8000f48:	7814      	ldrb	r4, [r2, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 8000f4a:	d301      	bcc.n	8000f50 <chOQGetI+0x20>
    oqp->q_rdptr = oqp->q_buffer;
 8000f4c:	68c3      	ldr	r3, [r0, #12]
 8000f4e:	6183      	str	r3, [r0, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 8000f50:	2100      	movs	r1, #0
 8000f52:	f7ff fe2d 	bl	8000bb0 <chThdDequeueNextI>

  return b;
 8000f56:	4620      	mov	r0, r4
 8000f58:	bd38      	pop	{r3, r4, r5, pc}
 8000f5a:	2b00      	cmp	r3, #0
 8000f5c:	d0ee      	beq.n	8000f3c <chOQGetI+0xc>
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
 8000f5e:	f06f 0002 	mvn.w	r0, #2
 8000f62:	bd38      	pop	{r3, r4, r5, pc}
 8000f64:	f3af 8000 	nop.w
 8000f68:	f3af 8000 	nop.w
 8000f6c:	f3af 8000 	nop.w

08000f70 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t time) {
 8000f70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000f74:	b083      	sub	sp, #12
 8000f76:	4604      	mov	r4, r0
 8000f78:	468b      	mov	fp, r1
 8000f7a:	4616      	mov	r6, r2
 8000f7c:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 8000f7e:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8000f82:	f04f 0920 	mov.w	r9, #32
 8000f86:	f389 8811 	msr	BASEPRI, r9
  size_t w = 0;
 8000f8a:	2700      	movs	r7, #0
 8000f8c:	f8cd 9000 	str.w	r9, [sp]
 8000f90:	46ba      	mov	sl, r7
 8000f92:	68a5      	ldr	r5, [r4, #8]
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8000f94:	f10b 0901 	add.w	r9, fp, #1
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 8000f98:	1e6a      	subs	r2, r5, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy) {
      nfy(oqp);
 8000f9a:	4620      	mov	r0, r4

  chDbgCheck(n > 0);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8000f9c:	b30d      	cbz	r5, 8000fe2 <chOQWriteTimeout+0x72>
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8000f9e:	6963      	ldr	r3, [r4, #20]
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 8000fa0:	60a2      	str	r2, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8000fa2:	1c5a      	adds	r2, r3, #1
 8000fa4:	6162      	str	r2, [r4, #20]
 8000fa6:	f89b 2000 	ldrb.w	r2, [fp]
 8000faa:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8000fac:	6923      	ldr	r3, [r4, #16]
 8000fae:	6962      	ldr	r2, [r4, #20]
 8000fb0:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 8000fb2:	bf24      	itt	cs
 8000fb4:	68e3      	ldrcs	r3, [r4, #12]
 8000fb6:	6163      	strcs	r3, [r4, #20]
    }

    if (nfy) {
 8000fb8:	f1b8 0f00 	cmp.w	r8, #0
 8000fbc:	d000      	beq.n	8000fc0 <chOQWriteTimeout+0x50>
      nfy(oqp);
 8000fbe:	47c0      	blx	r8
 8000fc0:	f38a 8811 	msr	BASEPRI, sl
    }

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    w++;
    if (--n == 0) {
 8000fc4:	3e01      	subs	r6, #1
    if (nfy) {
      nfy(oqp);
    }

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    w++;
 8000fc6:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0) {
 8000fca:	d012      	beq.n	8000ff2 <chOQWriteTimeout+0x82>
 8000fcc:	9b00      	ldr	r3, [sp, #0]
 8000fce:	f383 8811 	msr	BASEPRI, r3
 8000fd2:	68a5      	ldr	r5, [r4, #8]
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8000fd4:	46cb      	mov	fp, r9
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 8000fd6:	1e6a      	subs	r2, r5, #1
    *oqp->q_wrptr++ = *bp++;
 8000fd8:	f10b 0901 	add.w	r9, fp, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy) {
      nfy(oqp);
 8000fdc:	4620      	mov	r0, r4

  chDbgCheck(n > 0);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8000fde:	2d00      	cmp	r5, #0
 8000fe0:	d1dd      	bne.n	8000f9e <chOQWriteTimeout+0x2e>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
 8000fe2:	4620      	mov	r0, r4
 8000fe4:	9901      	ldr	r1, [sp, #4]
 8000fe6:	f7ff fdcb 	bl	8000b80 <chThdEnqueueTimeoutS>
 8000fea:	2800      	cmp	r0, #0
 8000fec:	d0d1      	beq.n	8000f92 <chOQWriteTimeout+0x22>
 8000fee:	f385 8811 	msr	BASEPRI, r5
    if (--n == 0) {
      return w;
    }
    chSysLock();
  }
}
 8000ff2:	4638      	mov	r0, r7
 8000ff4:	b003      	add	sp, #12
 8000ff6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000ffa:	bf00      	nop
 8000ffc:	f3af 8000 	nop.w

08001000 <_core_init>:
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001000:	4a05      	ldr	r2, [pc, #20]	; (8001018 <_core_init+0x18>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001002:	4b06      	ldr	r3, [pc, #24]	; (800101c <_core_init+0x1c>)
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001004:	4806      	ldr	r0, [pc, #24]	; (8001020 <_core_init+0x20>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001006:	4907      	ldr	r1, [pc, #28]	; (8001024 <_core_init+0x24>)
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001008:	f022 0207 	bic.w	r2, r2, #7
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800100c:	f023 0307 	bic.w	r3, r3, #7
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001010:	6002      	str	r2, [r0, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001012:	600b      	str	r3, [r1, #0]
 8001014:	4770      	bx	lr
 8001016:	bf00      	nop
 8001018:	200013bb 	.word	0x200013bb
 800101c:	20018000 	.word	0x20018000
 8001020:	20001194 	.word	0x20001194
 8001024:	20001190 	.word	0x20001190
 8001028:	f3af 8000 	nop.w
 800102c:	f3af 8000 	nop.w

08001030 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8001030:	b410      	push	{r4}
 8001032:	2320      	movs	r3, #32
 8001034:	f383 8811 	msr	BASEPRI, r3
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  if ((size_t)(endmem - nextmem) < size) {
 8001038:	4c09      	ldr	r4, [pc, #36]	; (8001060 <chCoreAlloc+0x30>)
 800103a:	4b0a      	ldr	r3, [pc, #40]	; (8001064 <chCoreAlloc+0x34>)
 800103c:	6822      	ldr	r2, [r4, #0]
 800103e:	6819      	ldr	r1, [r3, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8001040:	1dc3      	adds	r3, r0, #7
 8001042:	f023 0307 	bic.w	r3, r3, #7
  if ((size_t)(endmem - nextmem) < size) {
 8001046:	1a89      	subs	r1, r1, r2
 8001048:	428b      	cmp	r3, r1
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 800104a:	bf9d      	ittte	ls
 800104c:	189b      	addls	r3, r3, r2
 800104e:	6023      	strls	r3, [r4, #0]

  return p;
 8001050:	4610      	movls	r0, r2

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  if ((size_t)(endmem - nextmem) < size) {
    return NULL;
 8001052:	2000      	movhi	r0, #0
 8001054:	2300      	movs	r3, #0
 8001056:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 800105a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800105e:	4770      	bx	lr
 8001060:	20001194 	.word	0x20001194
 8001064:	20001190 	.word	0x20001190
 8001068:	f3af 8000 	nop.w
 800106c:	f3af 8000 	nop.w

08001070 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8001070:	b40e      	push	{r1, r2, r3}
 8001072:	b500      	push	{lr}
 8001074:	b082      	sub	sp, #8
 8001076:	aa03      	add	r2, sp, #12
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
 8001078:	4805      	ldr	r0, [pc, #20]	; (8001090 <chprintf.constprop.0+0x20>)
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 800107a:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800107e:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8001080:	f000 fbe6 	bl	8001850 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8001084:	b002      	add	sp, #8
 8001086:	f85d eb04 	ldr.w	lr, [sp], #4
 800108a:	b003      	add	sp, #12
 800108c:	4770      	bx	lr
 800108e:	bf00      	nop
 8001090:	2000137c 	.word	0x2000137c
 8001094:	f3af 8000 	nop.w
 8001098:	f3af 8000 	nop.w
 800109c:	f3af 8000 	nop.w

080010a0 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 80010a0:	4b04      	ldr	r3, [pc, #16]	; (80010b4 <_heap_init+0x14>)
 80010a2:	4a05      	ldr	r2, [pc, #20]	; (80010b8 <_heap_init+0x18>)
 80010a4:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = (union heap_header *)NULL;
  default_heap.h_free.h.size = 0;
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 80010a6:	f103 0010 	add.w	r0, r3, #16
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
  default_heap.h_free.h.u.next = (union heap_header *)NULL;
 80010aa:	2200      	movs	r2, #0
 80010ac:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 80010ae:	60da      	str	r2, [r3, #12]
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 80010b0:	f7ff bd8e 	b.w	8000bd0 <chMtxObjectInit>
 80010b4:	20001198 	.word	0x20001198
 80010b8:	08001031 	.word	0x08001031
 80010bc:	f3af 8000 	nop.w

080010c0 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 80010c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL)
    heapp = &default_heap;
 80010c2:	4e33      	ldr	r6, [pc, #204]	; (8001190 <chHeapAlloc+0xd0>)
  
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "memory allign");
 80010c4:	4a33      	ldr	r2, [pc, #204]	; (8001194 <chHeapAlloc+0xd4>)
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL)
    heapp = &default_heap;
 80010c6:	2800      	cmp	r0, #0
 80010c8:	bf18      	it	ne
 80010ca:	4606      	movne	r6, r0
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 80010cc:	460d      	mov	r5, r1
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL)
    heapp = &default_heap;
  
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "memory allign");
 80010ce:	4832      	ldr	r0, [pc, #200]	; (8001198 <chHeapAlloc+0xd8>)
 80010d0:	4932      	ldr	r1, [pc, #200]	; (800119c <chHeapAlloc+0xdc>)
 80010d2:	f7ff ffcd 	bl	8001070 <chprintf.constprop.0>
  size = MEM_ALIGN_NEXT(size);
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "memory alligned");
 80010d6:	4931      	ldr	r1, [pc, #196]	; (800119c <chHeapAlloc+0xdc>)
 80010d8:	4a31      	ldr	r2, [pc, #196]	; (80011a0 <chHeapAlloc+0xe0>)
 80010da:	482f      	ldr	r0, [pc, #188]	; (8001198 <chHeapAlloc+0xd8>)
 80010dc:	f7ff ffc8 	bl	8001070 <chprintf.constprop.0>
  qp = &heapp->h_free;
  
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "H_LOCK");
  H_LOCK(heapp);
 80010e0:	f106 0710 	add.w	r7, r6, #16
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "memory allign");
  size = MEM_ALIGN_NEXT(size);
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "memory alligned");
  qp = &heapp->h_free;
  
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "H_LOCK");
 80010e4:	492d      	ldr	r1, [pc, #180]	; (800119c <chHeapAlloc+0xdc>)
 80010e6:	4a2f      	ldr	r2, [pc, #188]	; (80011a4 <chHeapAlloc+0xe4>)
 80010e8:	482b      	ldr	r0, [pc, #172]	; (8001198 <chHeapAlloc+0xd8>)
 80010ea:	f7ff ffc1 	bl	8001070 <chprintf.constprop.0>
  H_LOCK(heapp);
 80010ee:	4638      	mov	r0, r7
 80010f0:	f7ff fdde 	bl	8000cb0 <chMtxLock>

  if (heapp == NULL)
    heapp = &default_heap;
  
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "memory allign");
  size = MEM_ALIGN_NEXT(size);
 80010f4:	3507      	adds	r5, #7
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "memory alligned");
  qp = &heapp->h_free;
  
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "H_LOCK");
  H_LOCK(heapp);
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "H_LOCK done");
 80010f6:	4929      	ldr	r1, [pc, #164]	; (800119c <chHeapAlloc+0xdc>)
 80010f8:	4a2b      	ldr	r2, [pc, #172]	; (80011a8 <chHeapAlloc+0xe8>)
 80010fa:	4827      	ldr	r0, [pc, #156]	; (8001198 <chHeapAlloc+0xd8>)

  if (heapp == NULL)
    heapp = &default_heap;
  
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "memory allign");
  size = MEM_ALIGN_NEXT(size);
 80010fc:	f025 0507 	bic.w	r5, r5, #7
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "memory alligned");
  qp = &heapp->h_free;
 8001100:	f106 0408 	add.w	r4, r6, #8
  
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "H_LOCK");
  H_LOCK(heapp);
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "H_LOCK done");
 8001104:	f7ff ffb4 	bl	8001070 <chprintf.constprop.0>
  while (qp->h.u.next != NULL) {
 8001108:	e006      	b.n	8001118 <chHeapAlloc+0x58>
    chprintf((BaseSequentialStream *)&itm_port, "qp->h.u.next: %i\n", qp->h.u.next);
 800110a:	f7ff ffb1 	bl	8001070 <chprintf.constprop.0>
    hp = qp->h.u.next;
 800110e:	6820      	ldr	r0, [r4, #0]
    if (hp->h.size >= size) {
 8001110:	6843      	ldr	r3, [r0, #4]
 8001112:	429d      	cmp	r5, r3
 8001114:	d91e      	bls.n	8001154 <chHeapAlloc+0x94>
 8001116:	4604      	mov	r4, r0
  qp = &heapp->h_free;
  
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "H_LOCK");
  H_LOCK(heapp);
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "H_LOCK done");
  while (qp->h.u.next != NULL) {
 8001118:	6823      	ldr	r3, [r4, #0]
    chprintf((BaseSequentialStream *)&itm_port, "qp->h.u.next: %i\n", qp->h.u.next);
 800111a:	481f      	ldr	r0, [pc, #124]	; (8001198 <chHeapAlloc+0xd8>)
 800111c:	4923      	ldr	r1, [pc, #140]	; (80011ac <chHeapAlloc+0xec>)
 800111e:	461a      	mov	r2, r3
  qp = &heapp->h_free;
  
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "H_LOCK");
  H_LOCK(heapp);
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "H_LOCK done");
  while (qp->h.u.next != NULL) {
 8001120:	2b00      	cmp	r3, #0
 8001122:	d1f2      	bne.n	800110a <chHeapAlloc+0x4a>

      return (void *)(hp + 1);
    }
    qp = hp;
  }
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "H_UNLOCK");
 8001124:	491d      	ldr	r1, [pc, #116]	; (800119c <chHeapAlloc+0xdc>)
 8001126:	4a22      	ldr	r2, [pc, #136]	; (80011b0 <chHeapAlloc+0xf0>)
 8001128:	f7ff ffa2 	bl	8001070 <chprintf.constprop.0>
  H_UNLOCK(heapp);
 800112c:	4638      	mov	r0, r7
 800112e:	f7ff fdcf 	bl	8000cd0 <chMtxUnlock>
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "H_UNLOCK done");
 8001132:	4819      	ldr	r0, [pc, #100]	; (8001198 <chHeapAlloc+0xd8>)
 8001134:	4919      	ldr	r1, [pc, #100]	; (800119c <chHeapAlloc+0xdc>)
 8001136:	4a1f      	ldr	r2, [pc, #124]	; (80011b4 <chHeapAlloc+0xf4>)
 8001138:	f7ff ff9a 	bl	8001070 <chprintf.constprop.0>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider) {
 800113c:	6833      	ldr	r3, [r6, #0]
 800113e:	b32b      	cbz	r3, 800118c <chHeapAlloc+0xcc>
    hp = heapp->h_provider(size + sizeof(union heap_header));
 8001140:	f105 0008 	add.w	r0, r5, #8
 8001144:	4798      	blx	r3
    if (hp != NULL) {
 8001146:	b308      	cbz	r0, 800118c <chHeapAlloc+0xcc>
      hp->h.u.heap = heapp;
 8001148:	6006      	str	r6, [r0, #0]
      hp->h.size = size;
 800114a:	6045      	str	r5, [r0, #4]
      hp++;
 800114c:	f100 0408 	add.w	r4, r0, #8
      return (void *)hp;
    }
  }

  return NULL;
}
 8001150:	4620      	mov	r0, r4
 8001152:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chprintf((BaseSequentialStream *)&itm_port, "chHeapAlloc: %s\n", "H_LOCK done");
  while (qp->h.u.next != NULL) {
    chprintf((BaseSequentialStream *)&itm_port, "qp->h.u.next: %i\n", qp->h.u.next);
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
      if (hp->h.size < size + sizeof(union heap_header)) {
 8001154:	f105 0208 	add.w	r2, r5, #8
 8001158:	429a      	cmp	r2, r3
 800115a:	d909      	bls.n	8001170 <chHeapAlloc+0xb0>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 800115c:	6803      	ldr	r3, [r0, #0]
 800115e:	6023      	str	r3, [r4, #0]
        fp->h.u.next = hp->h.u.next;
        fp->h.size = hp->h.size - sizeof(union heap_header) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
 8001160:	4604      	mov	r4, r0
      H_UNLOCK(heapp);
 8001162:	4638      	mov	r0, r7
        fp->h.u.next = hp->h.u.next;
        fp->h.size = hp->h.size - sizeof(union heap_header) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
 8001164:	f844 6b08 	str.w	r6, [r4], #8
      H_UNLOCK(heapp);
 8001168:	f7ff fdb2 	bl	8000cd0 <chMtxUnlock>
      return (void *)hp;
    }
  }

  return NULL;
}
 800116c:	4620      	mov	r0, r4
 800116e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001170:	f06f 0107 	mvn.w	r1, #7
 8001174:	1b49      	subs	r1, r1, r5
           useful.*/
        qp->h.u.next = hp->h.u.next;
      }
      else {
        /* Block bigger enough, must split it.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
 8001176:	eb00 0e02 	add.w	lr, r0, r2
        fp->h.u.next = hp->h.u.next;
        fp->h.size = hp->h.size - sizeof(union heap_header) - size;
 800117a:	440b      	add	r3, r1
        qp->h.u.next = hp->h.u.next;
      }
      else {
        /* Block bigger enough, must split it.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        fp->h.u.next = hp->h.u.next;
 800117c:	6801      	ldr	r1, [r0, #0]
 800117e:	5081      	str	r1, [r0, r2]
        fp->h.size = hp->h.size - sizeof(union heap_header) - size;
 8001180:	f8ce 3004 	str.w	r3, [lr, #4]
        qp->h.u.next = fp;
 8001184:	f8c4 e000 	str.w	lr, [r4]
        hp->h.size = size;
 8001188:	6045      	str	r5, [r0, #4]
 800118a:	e7e9      	b.n	8001160 <chHeapAlloc+0xa0>

      return (void *)hp;
    }
  }

  return NULL;
 800118c:	2400      	movs	r4, #0
 800118e:	e7df      	b.n	8001150 <chHeapAlloc+0x90>
 8001190:	20001198 	.word	0x20001198
 8001194:	080027e4 	.word	0x080027e4
 8001198:	2000137c 	.word	0x2000137c
 800119c:	080027d0 	.word	0x080027d0
 80011a0:	080027f4 	.word	0x080027f4
 80011a4:	08002804 	.word	0x08002804
 80011a8:	0800280c 	.word	0x0800280c
 80011ac:	08002818 	.word	0x08002818
 80011b0:	0800282c 	.word	0x0800282c
 80011b4:	08002838 	.word	0x08002838
 80011b8:	f3af 8000 	nop.w
 80011bc:	f3af 8000 	nop.w

080011c0 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80011c0:	b40e      	push	{r1, r2, r3}
 80011c2:	b500      	push	{lr}
 80011c4:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80011c6:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 80011c8:	461a      	mov	r2, r3
 80011ca:	4905      	ldr	r1, [pc, #20]	; (80011e0 <chprintf.constprop.0+0x20>)
 80011cc:	4805      	ldr	r0, [pc, #20]	; (80011e4 <chprintf.constprop.0+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80011ce:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80011d0:	f000 fb3e 	bl	8001850 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 80011d4:	b002      	add	sp, #8
 80011d6:	f85d eb04 	ldr.w	lr, [sp], #4
 80011da:	b003      	add	sp, #12
 80011dc:	4770      	bx	lr
 80011de:	bf00      	nop
 80011e0:	08002850 	.word	0x08002850
 80011e4:	2000137c 	.word	0x2000137c
 80011e8:	f3af 8000 	nop.w
 80011ec:	f3af 8000 	nop.w

080011f0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 80011f0:	b538      	push	{r3, r4, r5, lr}
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
  
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "hal_lld_init");
 80011f2:	4d0c      	ldr	r5, [pc, #48]	; (8001224 <halInit+0x34>)
 80011f4:	4c0c      	ldr	r4, [pc, #48]	; (8001228 <halInit+0x38>)

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 80011f6:	f000 f8eb 	bl	80013d0 <hal_lld_init>
  
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "hal_lld_init");
 80011fa:	4621      	mov	r1, r4
 80011fc:	4a0b      	ldr	r2, [pc, #44]	; (800122c <halInit+0x3c>)
 80011fe:	4628      	mov	r0, r5
 8001200:	f7ff ffde 	bl	80011c0 <chprintf.constprop.0>

#if HAL_USE_PAL || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8001204:	480a      	ldr	r0, [pc, #40]	; (8001230 <halInit+0x40>)
 8001206:	f000 f97b 	bl	8001500 <_pal_lld_init>
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "palInit");
 800120a:	4621      	mov	r1, r4
 800120c:	4a09      	ldr	r2, [pc, #36]	; (8001234 <halInit+0x44>)
 800120e:	4628      	mov	r0, r5
 8001210:	f7ff ffd6 	bl	80011c0 <chprintf.constprop.0>
#endif
#if HAL_USE_PWM || defined(__DOXYGEN__)
  pwmInit();
#endif
#if HAL_USE_SERIAL || defined(__DOXYGEN__)
  sdInit();
 8001214:	f000 f854 	bl	80012c0 <sdInit>
#if HAL_USE_COMMUNITY || defined(__DOXYGEN__)
  halCommunityInit();
#endif

  /* Board specific initialization.*/
  boardInit();
 8001218:	f000 fada 	bl	80017d0 <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
 800121c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8001220:	f000 b896 	b.w	8001350 <stInit>
 8001224:	2000137c 	.word	0x2000137c
 8001228:	08002850 	.word	0x08002850
 800122c:	08002854 	.word	0x08002854
 8001230:	08002890 	.word	0x08002890
 8001234:	08002864 	.word	0x08002864
 8001238:	f3af 8000 	nop.w
 800123c:	f3af 8000 	nop.w

08001240 <readt>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t time) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, time);
 8001240:	300c      	adds	r0, #12
 8001242:	f7ff bdfd 	b.w	8000e40 <chIQReadTimeout>
 8001246:	bf00      	nop
 8001248:	f3af 8000 	nop.w
 800124c:	f3af 8000 	nop.w

08001250 <read>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8001250:	300c      	adds	r0, #12
 8001252:	f04f 33ff 	mov.w	r3, #4294967295
 8001256:	f7ff bdf3 	b.w	8000e40 <chIQReadTimeout>
 800125a:	bf00      	nop
 800125c:	f3af 8000 	nop.w

08001260 <writet>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t time) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
 8001260:	3030      	adds	r0, #48	; 0x30
 8001262:	f7ff be85 	b.w	8000f70 <chOQWriteTimeout>
 8001266:	bf00      	nop
 8001268:	f3af 8000 	nop.w
 800126c:	f3af 8000 	nop.w

08001270 <write>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8001270:	3030      	adds	r0, #48	; 0x30
 8001272:	f04f 33ff 	mov.w	r3, #4294967295
 8001276:	f7ff be7b 	b.w	8000f70 <chOQWriteTimeout>
 800127a:	bf00      	nop
 800127c:	f3af 8000 	nop.w

08001280 <gett>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8001280:	300c      	adds	r0, #12
 8001282:	f7ff bdb5 	b.w	8000df0 <chIQGetTimeout>
 8001286:	bf00      	nop
 8001288:	f3af 8000 	nop.w
 800128c:	f3af 8000 	nop.w

08001290 <get>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8001290:	300c      	adds	r0, #12
 8001292:	f04f 31ff 	mov.w	r1, #4294967295
 8001296:	f7ff bdab 	b.w	8000df0 <chIQGetTimeout>
 800129a:	bf00      	nop
 800129c:	f3af 8000 	nop.w

080012a0 <putt>:
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80012a0:	3030      	adds	r0, #48	; 0x30
 80012a2:	f7ff be1d 	b.w	8000ee0 <chOQPutTimeout>
 80012a6:	bf00      	nop
 80012a8:	f3af 8000 	nop.w
 80012ac:	f3af 8000 	nop.w

080012b0 <put>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80012b0:	3030      	adds	r0, #48	; 0x30
 80012b2:	f04f 32ff 	mov.w	r2, #4294967295
 80012b6:	f7ff be13 	b.w	8000ee0 <chOQPutTimeout>
 80012ba:	bf00      	nop
 80012bc:	f3af 8000 	nop.w

080012c0 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
 80012c0:	f000 ba6e 	b.w	80017a0 <sd_lld_init>
 80012c4:	f3af 8000 	nop.w
 80012c8:	f3af 8000 	nop.w
 80012cc:	f3af 8000 	nop.w

080012d0 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80012d0:	b570      	push	{r4, r5, r6, lr}

  sdp->vmt = &vmt;
 80012d2:	4b0e      	ldr	r3, [pc, #56]	; (800130c <sdObjectInit+0x3c>)
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80012d4:	4604      	mov	r4, r0
 80012d6:	b082      	sub	sp, #8

  sdp->vmt = &vmt;
 80012d8:	f840 3b04 	str.w	r3, [r0], #4
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 80012dc:	2601      	movs	r6, #1
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80012de:	9400      	str	r4, [sp, #0]
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80012e0:	460b      	mov	r3, r1
 80012e2:	4615      	mov	r5, r2
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)(void *)esp;
 80012e4:	6060      	str	r0, [r4, #4]

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80012e6:	f104 0154 	add.w	r1, r4, #84	; 0x54
 80012ea:	f104 000c 	add.w	r0, r4, #12
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 80012ee:	7226      	strb	r6, [r4, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80012f0:	2210      	movs	r2, #16
 80012f2:	f7ff fd4d 	bl	8000d90 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 80012f6:	9400      	str	r4, [sp, #0]
 80012f8:	462b      	mov	r3, r5
 80012fa:	f104 0030 	add.w	r0, r4, #48	; 0x30
 80012fe:	f104 0164 	add.w	r1, r4, #100	; 0x64
 8001302:	2210      	movs	r2, #16
 8001304:	f7ff fddc 	bl	8000ec0 <chOQObjectInit>
}
 8001308:	b002      	add	sp, #8
 800130a:	bd70      	pop	{r4, r5, r6, pc}
 800130c:	08002870 	.word	0x08002870

08001310 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8001310:	b538      	push	{r3, r4, r5, lr}

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8001312:	6943      	ldr	r3, [r0, #20]
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8001314:	4604      	mov	r4, r0
 8001316:	460d      	mov	r5, r1

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8001318:	b13b      	cbz	r3, 800132a <sdIncomingDataI+0x1a>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 800131a:	4629      	mov	r1, r5
 800131c:	f104 000c 	add.w	r0, r4, #12
 8001320:	f7ff fd46 	bl	8000db0 <chIQPutI>
 8001324:	2800      	cmp	r0, #0
 8001326:	db0b      	blt.n	8001340 <sdIncomingDataI+0x30>
 8001328:	bd38      	pop	{r3, r4, r5, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800132a:	3004      	adds	r0, #4
 800132c:	2104      	movs	r1, #4
 800132e:	f7ff fd17 	bl	8000d60 <chEvtBroadcastFlagsI>
 8001332:	4629      	mov	r1, r5
 8001334:	f104 000c 	add.w	r0, r4, #12
 8001338:	f7ff fd3a 	bl	8000db0 <chIQPutI>
 800133c:	2800      	cmp	r0, #0
 800133e:	daf3      	bge.n	8001328 <sdIncomingDataI+0x18>
 8001340:	1d20      	adds	r0, r4, #4
 8001342:	2180      	movs	r1, #128	; 0x80
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
}
 8001344:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8001348:	f7ff bd0a 	b.w	8000d60 <chEvtBroadcastFlagsI>
 800134c:	f3af 8000 	nop.w

08001350 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
 8001350:	f000 b96e 	b.w	8001630 <st_lld_init>
 8001354:	f3af 8000 	nop.w
 8001358:	f3af 8000 	nop.w
 800135c:	f3af 8000 	nop.w

08001360 <stStartAlarm>:
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001360:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->SR     = 0;
 8001364:	2100      	movs	r1, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8001366:	2202      	movs	r2, #2
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001368:	6358      	str	r0, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800136a:	6119      	str	r1, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800136c:	60da      	str	r2, [r3, #12]
 800136e:	4770      	bx	lr

08001370 <stStopAlarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8001370:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001374:	2200      	movs	r2, #0
 8001376:	60da      	str	r2, [r3, #12]
 8001378:	4770      	bx	lr
 800137a:	bf00      	nop
 800137c:	f3af 8000 	nop.w

08001380 <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001380:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001384:	6358      	str	r0, [r3, #52]	; 0x34
 8001386:	4770      	bx	lr
 8001388:	f3af 8000 	nop.w
 800138c:	f3af 8000 	nop.w

08001390 <nvicEnableVector>:
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8001390:	0943      	lsrs	r3, r0, #5
 8001392:	009b      	lsls	r3, r3, #2
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8001394:	b410      	push	{r4}
 8001396:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 800139a:	f100 4460 	add.w	r4, r0, #3758096384	; 0xe0000000
 800139e:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
 80013a2:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 80013a6:	0109      	lsls	r1, r1, #4
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 80013a8:	f000 001f 	and.w	r0, r0, #31
 80013ac:	2201      	movs	r2, #1
 80013ae:	4082      	lsls	r2, r0
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 80013b0:	b2c9      	uxtb	r1, r1
 80013b2:	f884 1300 	strb.w	r1, [r4, #768]	; 0x300
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 80013b6:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 80013ba:	601a      	str	r2, [r3, #0]
}
 80013bc:	f85d 4b04 	ldr.w	r4, [sp], #4
 80013c0:	4770      	bx	lr
 80013c2:	bf00      	nop
 80013c4:	f3af 8000 	nop.w
 80013c8:	f3af 8000 	nop.w
 80013cc:	f3af 8000 	nop.w

080013d0 <hal_lld_init>:
 */
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 80013d0:	4b16      	ldr	r3, [pc, #88]	; (800142c <hal_lld_init+0x5c>)
 80013d2:	f04f 31ff 	mov.w	r1, #4294967295
 80013d6:	691a      	ldr	r2, [r3, #16]
 80013d8:	2200      	movs	r2, #0
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80013da:	b410      	push	{r4}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 80013dc:	6119      	str	r1, [r3, #16]
 80013de:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 80013e0:	6958      	ldr	r0, [r3, #20]
 80013e2:	6159      	str	r1, [r3, #20]
 80013e4:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 80013e6:	6a18      	ldr	r0, [r3, #32]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80013e8:	4c11      	ldr	r4, [pc, #68]	; (8001430 <hal_lld_init+0x60>)

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
  rccResetAHB2(~0);
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 80013ea:	f060 5080 	orn	r0, r0, #268435456	; 0x10000000
 80013ee:	6218      	str	r0, [r3, #32]
 80013f0:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 80013f2:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80013f4:	6259      	str	r1, [r3, #36]	; 0x24
 80013f6:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80013f8:	6c19      	ldr	r1, [r3, #64]	; 0x40
 80013fa:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 80013fe:	6419      	str	r1, [r3, #64]	; 0x40
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001400:	6821      	ldr	r1, [r4, #0]
 8001402:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8001406:	6021      	str	r1, [r4, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8001408:	6f19      	ldr	r1, [r3, #112]	; 0x70
 800140a:	f401 7140 	and.w	r1, r1, #768	; 0x300
 800140e:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8001412:	d003      	beq.n	800141c <hal_lld_init+0x4c>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8001414:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8001418:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 800141a:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 800141c:	4a04      	ldr	r2, [pc, #16]	; (8001430 <hal_lld_init+0x60>)

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800141e:	f85d 4b04 	ldr.w	r4, [sp], #4

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8001422:	6853      	ldr	r3, [r2, #4]
 8001424:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8001428:	6053      	str	r3, [r2, #4]

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800142a:	4770      	bx	lr
 800142c:	40023800 	.word	0x40023800
 8001430:	40007000 	.word	0x40007000
 8001434:	f3af 8000 	nop.w
 8001438:	f3af 8000 	nop.w
 800143c:	f3af 8000 	nop.w

08001440 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001440:	4928      	ldr	r1, [pc, #160]	; (80014e4 <stm32_clock_init+0xa4>)

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8001442:	4b29      	ldr	r3, [pc, #164]	; (80014e8 <stm32_clock_init+0xa8>)
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001444:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8001448:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800144c:	6408      	str	r0, [r1, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 800144e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001450:	680b      	ldr	r3, [r1, #0]
 8001452:	f043 0301 	orr.w	r3, r3, #1
 8001456:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001458:	680a      	ldr	r2, [r1, #0]
 800145a:	4b22      	ldr	r3, [pc, #136]	; (80014e4 <stm32_clock_init+0xa4>)
 800145c:	0792      	lsls	r2, r2, #30
 800145e:	d5fb      	bpl.n	8001458 <stm32_clock_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8001460:	689a      	ldr	r2, [r3, #8]
 8001462:	f022 0203 	bic.w	r2, r2, #3
 8001466:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001468:	689a      	ldr	r2, [r3, #8]
 800146a:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800146c:	4619      	mov	r1, r3
 800146e:	688b      	ldr	r3, [r1, #8]
 8001470:	4a1c      	ldr	r2, [pc, #112]	; (80014e4 <stm32_clock_init+0xa4>)
 8001472:	f013 030c 	ands.w	r3, r3, #12
 8001476:	d1fa      	bne.n	800146e <stm32_clock_init+0x2e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001478:	6811      	ldr	r1, [r2, #0]
 800147a:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 800147e:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001480:	6093      	str	r3, [r2, #8]
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001482:	6f53      	ldr	r3, [r2, #116]	; 0x74
 8001484:	f043 0301 	orr.w	r3, r3, #1
 8001488:	6753      	str	r3, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800148a:	6f53      	ldr	r3, [r2, #116]	; 0x74
 800148c:	4915      	ldr	r1, [pc, #84]	; (80014e4 <stm32_clock_init+0xa4>)
 800148e:	0798      	lsls	r0, r3, #30
 8001490:	d5fb      	bpl.n	800148a <stm32_clock_init+0x4a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8001492:	4b16      	ldr	r3, [pc, #88]	; (80014ec <stm32_clock_init+0xac>)
 8001494:	604b      	str	r3, [r1, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8001496:	680b      	ldr	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8001498:	4a13      	ldr	r2, [pc, #76]	; (80014e8 <stm32_clock_init+0xa8>)

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 800149a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800149e:	600b      	str	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 80014a0:	6853      	ldr	r3, [r2, #4]
 80014a2:	0459      	lsls	r1, r3, #17
 80014a4:	d5fc      	bpl.n	80014a0 <stm32_clock_init+0x60>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80014a6:	490f      	ldr	r1, [pc, #60]	; (80014e4 <stm32_clock_init+0xa4>)
 80014a8:	680a      	ldr	r2, [r1, #0]
 80014aa:	4b0e      	ldr	r3, [pc, #56]	; (80014e4 <stm32_clock_init+0xa4>)
 80014ac:	0192      	lsls	r2, r2, #6
 80014ae:	d5fb      	bpl.n	80014a8 <stm32_clock_init+0x68>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 80014b0:	4a0f      	ldr	r2, [pc, #60]	; (80014f0 <stm32_clock_init+0xb0>)
  while (!(RCC->CR & RCC_CR_PLLI2SRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 80014b2:	4910      	ldr	r1, [pc, #64]	; (80014f4 <stm32_clock_init+0xb4>)
 80014b4:	6099      	str	r1, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 80014b6:	f240 7102 	movw	r1, #1794	; 0x702
 80014ba:	6011      	str	r1, [r2, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 80014bc:	689a      	ldr	r2, [r3, #8]
 80014be:	f042 0202 	orr.w	r2, r2, #2
 80014c2:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80014c4:	461a      	mov	r2, r3
 80014c6:	6893      	ldr	r3, [r2, #8]
 80014c8:	4906      	ldr	r1, [pc, #24]	; (80014e4 <stm32_clock_init+0xa4>)
 80014ca:	f003 030c 	and.w	r3, r3, #12
 80014ce:	2b08      	cmp	r3, #8
 80014d0:	d1f9      	bne.n	80014c6 <stm32_clock_init+0x86>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80014d2:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 80014d4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80014d8:	644b      	str	r3, [r1, #68]	; 0x44
 80014da:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 80014dc:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80014e0:	664b      	str	r3, [r1, #100]	; 0x64
 80014e2:	4770      	bx	lr
 80014e4:	40023800 	.word	0x40023800
 80014e8:	40007000 	.word	0x40007000
 80014ec:	07015410 	.word	0x07015410
 80014f0:	40023c00 	.word	0x40023c00
 80014f4:	38081000 	.word	0x38081000
 80014f8:	f3af 8000 	nop.w
 80014fc:	f3af 8000 	nop.w

08001500 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8001500:	b5f0      	push	{r4, r5, r6, r7, lr}
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8001502:	4f39      	ldr	r7, [pc, #228]	; (80015e8 <_pal_lld_init+0xe8>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001504:	4e39      	ldr	r6, [pc, #228]	; (80015ec <_pal_lld_init+0xec>)
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8001506:	f8d7 e030 	ldr.w	lr, [r7, #48]	; 0x30
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800150a:	4d39      	ldr	r5, [pc, #228]	; (80015f0 <_pal_lld_init+0xf0>)
 800150c:	4c39      	ldr	r4, [pc, #228]	; (80015f4 <_pal_lld_init+0xf4>)
 800150e:	493a      	ldr	r1, [pc, #232]	; (80015f8 <_pal_lld_init+0xf8>)
 8001510:	4a3a      	ldr	r2, [pc, #232]	; (80015fc <_pal_lld_init+0xfc>)
 8001512:	4b3b      	ldr	r3, [pc, #236]	; (8001600 <_pal_lld_init+0x100>)
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8001514:	f04e 0e1f 	orr.w	lr, lr, #31
 8001518:	f8c7 e030 	str.w	lr, [r7, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 800151c:	f8d7 e050 	ldr.w	lr, [r7, #80]	; 0x50
 8001520:	f04e 0e1f 	orr.w	lr, lr, #31
 8001524:	f8c7 e050 	str.w	lr, [r7, #80]	; 0x50
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001528:	6847      	ldr	r7, [r0, #4]
 800152a:	6077      	str	r7, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800152c:	6887      	ldr	r7, [r0, #8]
 800152e:	60b7      	str	r7, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 8001530:	68c7      	ldr	r7, [r0, #12]
 8001532:	60f7      	str	r7, [r6, #12]
  gpiop->ODR     = config->odr;
 8001534:	6907      	ldr	r7, [r0, #16]
 8001536:	6177      	str	r7, [r6, #20]
  gpiop->AFRL    = config->afrl;
 8001538:	6947      	ldr	r7, [r0, #20]
 800153a:	6237      	str	r7, [r6, #32]
  gpiop->AFRH    = config->afrh;
 800153c:	6987      	ldr	r7, [r0, #24]
 800153e:	6277      	str	r7, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001540:	6807      	ldr	r7, [r0, #0]
 8001542:	6037      	str	r7, [r6, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001544:	6a06      	ldr	r6, [r0, #32]
 8001546:	606e      	str	r6, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001548:	6a46      	ldr	r6, [r0, #36]	; 0x24
 800154a:	60ae      	str	r6, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 800154c:	6a86      	ldr	r6, [r0, #40]	; 0x28
 800154e:	60ee      	str	r6, [r5, #12]
  gpiop->ODR     = config->odr;
 8001550:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
 8001552:	616e      	str	r6, [r5, #20]
  gpiop->AFRL    = config->afrl;
 8001554:	6b06      	ldr	r6, [r0, #48]	; 0x30
 8001556:	622e      	str	r6, [r5, #32]
  gpiop->AFRH    = config->afrh;
 8001558:	6b46      	ldr	r6, [r0, #52]	; 0x34
 800155a:	626e      	str	r6, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800155c:	69c6      	ldr	r6, [r0, #28]
 800155e:	602e      	str	r6, [r5, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001560:	6bc5      	ldr	r5, [r0, #60]	; 0x3c
 8001562:	6065      	str	r5, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001564:	6c05      	ldr	r5, [r0, #64]	; 0x40
 8001566:	60a5      	str	r5, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8001568:	6c45      	ldr	r5, [r0, #68]	; 0x44
 800156a:	60e5      	str	r5, [r4, #12]
  gpiop->ODR     = config->odr;
 800156c:	6c85      	ldr	r5, [r0, #72]	; 0x48
 800156e:	6165      	str	r5, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8001570:	6cc5      	ldr	r5, [r0, #76]	; 0x4c
 8001572:	6225      	str	r5, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8001574:	6d05      	ldr	r5, [r0, #80]	; 0x50
 8001576:	6265      	str	r5, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001578:	6b85      	ldr	r5, [r0, #56]	; 0x38
 800157a:	6025      	str	r5, [r4, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800157c:	6d84      	ldr	r4, [r0, #88]	; 0x58
 800157e:	604c      	str	r4, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001580:	6dc4      	ldr	r4, [r0, #92]	; 0x5c
 8001582:	608c      	str	r4, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8001584:	6e04      	ldr	r4, [r0, #96]	; 0x60
 8001586:	60cc      	str	r4, [r1, #12]
  gpiop->ODR     = config->odr;
 8001588:	6e44      	ldr	r4, [r0, #100]	; 0x64
 800158a:	614c      	str	r4, [r1, #20]
  gpiop->AFRL    = config->afrl;
 800158c:	6e84      	ldr	r4, [r0, #104]	; 0x68
 800158e:	620c      	str	r4, [r1, #32]
  gpiop->AFRH    = config->afrh;
 8001590:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
 8001592:	624c      	str	r4, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001594:	6d44      	ldr	r4, [r0, #84]	; 0x54
 8001596:	600c      	str	r4, [r1, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001598:	6f41      	ldr	r1, [r0, #116]	; 0x74
 800159a:	6051      	str	r1, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800159c:	6f81      	ldr	r1, [r0, #120]	; 0x78
 800159e:	6091      	str	r1, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 80015a0:	6fc1      	ldr	r1, [r0, #124]	; 0x7c
 80015a2:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 80015a4:	f8d0 1080 	ldr.w	r1, [r0, #128]	; 0x80
 80015a8:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 80015aa:	f8d0 1084 	ldr.w	r1, [r0, #132]	; 0x84
 80015ae:	6211      	str	r1, [r2, #32]
  gpiop->AFRH    = config->afrh;
 80015b0:	f8d0 1088 	ldr.w	r1, [r0, #136]	; 0x88
 80015b4:	6251      	str	r1, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80015b6:	6f01      	ldr	r1, [r0, #112]	; 0x70
 80015b8:	6011      	str	r1, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80015ba:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 80015be:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80015c0:	f8d0 2094 	ldr.w	r2, [r0, #148]	; 0x94
 80015c4:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 80015c6:	f8d0 2098 	ldr.w	r2, [r0, #152]	; 0x98
 80015ca:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 80015cc:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
 80015d0:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 80015d2:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
 80015d6:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 80015d8:	f8d0 20a4 	ldr.w	r2, [r0, #164]	; 0xa4
 80015dc:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80015de:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
 80015e2:	601a      	str	r2, [r3, #0]
 80015e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80015e6:	bf00      	nop
 80015e8:	40023800 	.word	0x40023800
 80015ec:	40020000 	.word	0x40020000
 80015f0:	40020400 	.word	0x40020400
 80015f4:	40020800 	.word	0x40020800
 80015f8:	40020c00 	.word	0x40020c00
 80015fc:	40021000 	.word	0x40021000
 8001600:	40021c00 	.word	0x40021c00
 8001604:	f3af 8000 	nop.w
 8001608:	f3af 8000 	nop.w
 800160c:	f3af 8000 	nop.w

08001610 <VectorB0>:
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  STM32_ST_TIM->SR = 0;
 8001610:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8001614:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  STM32_ST_TIM->SR = 0;
 8001616:	2400      	movs	r4, #0
 8001618:	611c      	str	r4, [r3, #16]
 800161a:	2320      	movs	r3, #32
 800161c:	f383 8811 	msr	BASEPRI, r3
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
 8001620:	f7ff f80e 	bl	8000640 <chSysTimerHandlerI>
 8001624:	f384 8811 	msr	BASEPRI, r4
  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
}
 8001628:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
 800162c:	f7fe bf80 	b.w	8000530 <_port_irq_epilogue>

08001630 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8001630:	b470      	push	{r4, r5, r6}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001632:	480d      	ldr	r0, [pc, #52]	; (8001668 <st_lld_init+0x38>)
 8001634:	6c01      	ldr	r1, [r0, #64]	; 0x40

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001636:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 800163a:	2200      	movs	r2, #0
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800163c:	2401      	movs	r4, #1

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 800163e:	f041 0101 	orr.w	r1, r1, #1

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001642:	f242 06cf 	movw	r6, #8399	; 0x20cf
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001646:	f04f 35ff 	mov.w	r5, #4294967295

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 800164a:	6401      	str	r1, [r0, #64]	; 0x40

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 800164c:	629e      	str	r6, [r3, #40]	; 0x28
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 800164e:	201c      	movs	r0, #28
  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001650:	62dd      	str	r5, [r3, #44]	; 0x2c
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8001652:	2108      	movs	r1, #8
  ST_ENABLE_CLOCK();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 8001654:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8001656:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8001658:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 800165a:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800165c:	615c      	str	r4, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 800165e:	601c      	str	r4, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8001660:	bc70      	pop	{r4, r5, r6}
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8001662:	f7ff be95 	b.w	8001390 <nvicEnableVector>
 8001666:	bf00      	nop
 8001668:	40023800 	.word	0x40023800
 800166c:	f3af 8000 	nop.w

08001670 <notify2>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 8001670:	4a02      	ldr	r2, [pc, #8]	; (800167c <notify2+0xc>)
 8001672:	68d3      	ldr	r3, [r2, #12]
 8001674:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001678:	60d3      	str	r3, [r2, #12]
 800167a:	4770      	bx	lr
 800167c:	40004400 	.word	0x40004400

08001680 <VectorD8>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8001680:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8001682:	4e43      	ldr	r6, [pc, #268]	; (8001790 <VectorD8+0x110>)
 8001684:	6f75      	ldr	r5, [r6, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 8001686:	68ef      	ldr	r7, [r5, #12]
  uint16_t sr = u->SR;
 8001688:	682b      	ldr	r3, [r5, #0]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 800168a:	05da      	lsls	r2, r3, #23
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
  uint16_t sr = u->SR;
 800168c:	b29c      	uxth	r4, r3

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 800168e:	d44f      	bmi.n	8001730 <VectorD8+0xb0>
 8001690:	2320      	movs	r3, #32
 8001692:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8001696:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 800169a:	d108      	bne.n	80016ae <VectorD8+0x2e>
 800169c:	e029      	b.n	80016f2 <VectorD8+0x72>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 800169e:	06a0      	lsls	r0, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 80016a0:	6869      	ldr	r1, [r5, #4]
    if (sr & USART_SR_RXNE)
 80016a2:	d41d      	bmi.n	80016e0 <VectorD8+0x60>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 80016a4:	682c      	ldr	r4, [r5, #0]
 80016a6:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80016a8:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 80016ac:	d021      	beq.n	80016f2 <VectorD8+0x72>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 80016ae:	0723      	lsls	r3, r4, #28
 80016b0:	d0f5      	beq.n	800169e <VectorD8+0x1e>
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
  eventflags_t sts = 0;

  if (sr & USART_SR_ORE)
    sts |= SD_OVERRUN_ERROR;
 80016b2:	f014 0f08 	tst.w	r4, #8
 80016b6:	bf0c      	ite	eq
 80016b8:	2100      	moveq	r1, #0
 80016ba:	2180      	movne	r1, #128	; 0x80
  if (sr & USART_SR_PE)
 80016bc:	07e0      	lsls	r0, r4, #31
    sts |= SD_PARITY_ERROR;
 80016be:	bf48      	it	mi
 80016c0:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 80016c4:	07a2      	lsls	r2, r4, #30
    sts |= SD_FRAMING_ERROR;
 80016c6:	bf48      	it	mi
 80016c8:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 80016cc:	0763      	lsls	r3, r4, #29
    sts |= SD_NOISE_ERROR;
 80016ce:	bf48      	it	mi
 80016d0:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 80016d4:	482f      	ldr	r0, [pc, #188]	; (8001794 <VectorD8+0x114>)
 80016d6:	f7ff fb43 	bl	8000d60 <chEvtBroadcastFlagsI>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 80016da:	06a0      	lsls	r0, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 80016dc:	6869      	ldr	r1, [r5, #4]
    if (sr & USART_SR_RXNE)
 80016de:	d5e1      	bpl.n	80016a4 <VectorD8+0x24>
      sdIncomingDataI(sdp, b);
 80016e0:	b2c9      	uxtb	r1, r1
 80016e2:	482b      	ldr	r0, [pc, #172]	; (8001790 <VectorD8+0x110>)
 80016e4:	f7ff fe14 	bl	8001310 <sdIncomingDataI>
    sr = u->SR;
 80016e8:	682c      	ldr	r4, [r5, #0]
 80016ea:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80016ec:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 80016f0:	d1dd      	bne.n	80016ae <VectorD8+0x2e>
 80016f2:	2300      	movs	r3, #0
 80016f4:	f383 8811 	msr	BASEPRI, r3
    sr = u->SR;
  }
  osalSysUnlockFromISR();

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 80016f8:	0639      	lsls	r1, r7, #24
 80016fa:	d501      	bpl.n	8001700 <VectorD8+0x80>
 80016fc:	0622      	lsls	r2, r4, #24
 80016fe:	d426      	bmi.n	800174e <VectorD8+0xce>
      u->DR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 8001700:	0663      	lsls	r3, r4, #25
 8001702:	d511      	bpl.n	8001728 <VectorD8+0xa8>
 8001704:	2320      	movs	r3, #32
 8001706:	f383 8811 	msr	BASEPRI, r3
 800170a:	6c72      	ldr	r2, [r6, #68]	; 0x44
 800170c:	6cb3      	ldr	r3, [r6, #72]	; 0x48
 800170e:	4820      	ldr	r0, [pc, #128]	; (8001790 <VectorD8+0x110>)
 8001710:	429a      	cmp	r2, r3
 8001712:	d029      	beq.n	8001768 <VectorD8+0xe8>
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8001714:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 8001718:	403b      	ands	r3, r7
    u->SR = ~USART_SR_TC;
 800171a:	f06f 0240 	mvn.w	r2, #64	; 0x40
  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 800171e:	60eb      	str	r3, [r5, #12]
 8001720:	2300      	movs	r3, #0
    u->SR = ~USART_SR_TC;
 8001722:	602a      	str	r2, [r5, #0]
 8001724:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
}
 8001728:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
 800172c:	f7fe bf00 	b.w	8000530 <_port_irq_epilogue>
 8001730:	2320      	movs	r3, #32
 8001732:	f383 8811 	msr	BASEPRI, r3
 8001736:	f44f 7100 	mov.w	r1, #512	; 0x200
 800173a:	1d30      	adds	r0, r6, #4
 800173c:	f7ff fb10 	bl	8000d60 <chEvtBroadcastFlagsI>

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    u->SR = ~USART_SR_LBD;
 8001740:	f46f 7380 	mvn.w	r3, #256	; 0x100
 8001744:	602b      	str	r3, [r5, #0]
 8001746:	2300      	movs	r3, #0
 8001748:	f383 8811 	msr	BASEPRI, r3
 800174c:	e7a0      	b.n	8001690 <VectorD8+0x10>
 800174e:	2320      	movs	r3, #32
 8001750:	f383 8811 	msr	BASEPRI, r3

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
 8001754:	4810      	ldr	r0, [pc, #64]	; (8001798 <VectorD8+0x118>)
 8001756:	f7ff fbeb 	bl	8000f30 <chOQGetI>
    if (b < Q_OK) {
 800175a:	2800      	cmp	r0, #0
 800175c:	db0c      	blt.n	8001778 <VectorD8+0xf8>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->DR = b;
 800175e:	6068      	str	r0, [r5, #4]
 8001760:	2300      	movs	r3, #0
 8001762:	f383 8811 	msr	BASEPRI, r3
 8001766:	e7cb      	b.n	8001700 <VectorD8+0x80>
 8001768:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800176a:	2b00      	cmp	r3, #0
 800176c:	d0d2      	beq.n	8001714 <VectorD8+0x94>
 800176e:	3004      	adds	r0, #4
 8001770:	2110      	movs	r1, #16
 8001772:	f7ff faf5 	bl	8000d60 <chEvtBroadcastFlagsI>
 8001776:	e7cd      	b.n	8001714 <VectorD8+0x94>
 8001778:	4806      	ldr	r0, [pc, #24]	; (8001794 <VectorD8+0x114>)
 800177a:	2108      	movs	r1, #8
 800177c:	f7ff faf0 	bl	8000d60 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8001780:	f64f 733f 	movw	r3, #65343	; 0xff3f
 8001784:	403b      	ands	r3, r7
 8001786:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800178a:	60eb      	str	r3, [r5, #12]
 800178c:	e7e8      	b.n	8001760 <VectorD8+0xe0>
 800178e:	bf00      	nop
 8001790:	200011b8 	.word	0x200011b8
 8001794:	200011bc 	.word	0x200011bc
 8001798:	200011e8 	.word	0x200011e8
 800179c:	f3af 8000 	nop.w

080017a0 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 80017a0:	b510      	push	{r4, lr}
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 80017a2:	4c04      	ldr	r4, [pc, #16]	; (80017b4 <sd_lld_init+0x14>)
 80017a4:	4a04      	ldr	r2, [pc, #16]	; (80017b8 <sd_lld_init+0x18>)
 80017a6:	4620      	mov	r0, r4
 80017a8:	2100      	movs	r1, #0
 80017aa:	f7ff fd91 	bl	80012d0 <sdObjectInit>
  SD2.usart = USART2;
 80017ae:	4b03      	ldr	r3, [pc, #12]	; (80017bc <sd_lld_init+0x1c>)
 80017b0:	6763      	str	r3, [r4, #116]	; 0x74
 80017b2:	bd10      	pop	{r4, pc}
 80017b4:	200011b8 	.word	0x200011b8
 80017b8:	08001671 	.word	0x08001671
 80017bc:	40004400 	.word	0x40004400

080017c0 <__early_init>:
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
 80017c0:	f7ff be3e 	b.w	8001440 <stm32_clock_init>
 80017c4:	f3af 8000 	nop.w
 80017c8:	f3af 8000 	nop.w
 80017cc:	f3af 8000 	nop.w

080017d0 <boardInit>:

/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
 80017d0:	4770      	bx	lr
 80017d2:	bf00      	nop
 80017d4:	f3af 8000 	nop.w
 80017d8:	f3af 8000 	nop.w
 80017dc:	f3af 8000 	nop.w

080017e0 <_sbrk_r>:
}

/***************************************************************************/

caddr_t _sbrk_r(struct _reent *r, int incr)
{
 80017e0:	b510      	push	{r4, lr}
 80017e2:	4604      	mov	r4, r0
#if CH_CFG_USE_MEMCORE
  void *p;

  chDbgCheck(incr > 0);

  p = chCoreAlloc((size_t)incr);
 80017e4:	4608      	mov	r0, r1
 80017e6:	f7ff fc23 	bl	8001030 <chCoreAlloc>
  if (p == NULL) {
 80017ea:	b100      	cbz	r0, 80017ee <_sbrk_r+0xe>
#else
  (void)incr;
  __errno_r(r) = ENOMEM;
  return (caddr_t)-1;
#endif
}
 80017ec:	bd10      	pop	{r4, pc}

  chDbgCheck(incr > 0);

  p = chCoreAlloc((size_t)incr);
  if (p == NULL) {
    __errno_r(r) = ENOMEM;
 80017ee:	230c      	movs	r3, #12
 80017f0:	6023      	str	r3, [r4, #0]
    return (caddr_t)-1;
 80017f2:	f04f 30ff 	mov.w	r0, #4294967295
#else
  (void)incr;
  __errno_r(r) = ENOMEM;
  return (caddr_t)-1;
#endif
}
 80017f6:	bd10      	pop	{r4, pc}
 80017f8:	f3af 8000 	nop.w
 80017fc:	f3af 8000 	nop.w

08001800 <long_to_string_with_divisor.constprop.0>:
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
 8001800:	b4f0      	push	{r4, r5, r6, r7}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8001802:	f100 070b 	add.w	r7, r0, #11
 8001806:	463c      	mov	r4, r7
 8001808:	460d      	mov	r5, r1
  do {
    i = (int)(l % radix);
 800180a:	fbb1 f6f2 	udiv	r6, r1, r2
 800180e:	fb02 1116 	mls	r1, r2, r6, r1
    i += '0';
 8001812:	f101 0330 	add.w	r3, r1, #48	; 0x30
    if (i > '9')
 8001816:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
 8001818:	bfc8      	it	gt
 800181a:	f101 0337 	addgt.w	r3, r1, #55	; 0x37
    *--q = i;
 800181e:	b2db      	uxtb	r3, r3
 8001820:	f804 3d01 	strb.w	r3, [r4, #-1]!
    l /= radix;
  } while ((ll /= radix) != 0);
 8001824:	fbb5 f5f2 	udiv	r5, r5, r2
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
 8001828:	4631      	mov	r1, r6
  } while ((ll /= radix) != 0);
 800182a:	2d00      	cmp	r5, #0
 800182c:	d1ed      	bne.n	800180a <long_to_string_with_divisor.constprop.0+0xa>

  i = (int)(p + MAX_FILLER - q);
 800182e:	1b3a      	subs	r2, r7, r4
 8001830:	4402      	add	r2, r0
 8001832:	e001      	b.n	8001838 <long_to_string_with_divisor.constprop.0+0x38>
 8001834:	f814 3f01 	ldrb.w	r3, [r4, #1]!
  do
    *p++ = *q++;
 8001838:	f800 3b01 	strb.w	r3, [r0], #1
  while (--i);
 800183c:	4290      	cmp	r0, r2
 800183e:	d1f9      	bne.n	8001834 <long_to_string_with_divisor.constprop.0+0x34>

  return p;
}
 8001840:	bcf0      	pop	{r4, r5, r6, r7}
 8001842:	4770      	bx	lr
 8001844:	f3af 8000 	nop.w
 8001848:	f3af 8000 	nop.w
 800184c:	f3af 8000 	nop.w

08001850 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8001850:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001854:	b087      	sub	sp, #28
 8001856:	4615      	mov	r5, r2
 8001858:	f10d 030d 	add.w	r3, sp, #13
 800185c:	aa03      	add	r2, sp, #12
 800185e:	1a9b      	subs	r3, r3, r2
 8001860:	4681      	mov	r9, r0
 8001862:	468a      	mov	sl, r1
 8001864:	9301      	str	r3, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8001866:	f04f 0800 	mov.w	r8, #0
 800186a:	468b      	mov	fp, r1
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 800186c:	f89b 1000 	ldrb.w	r1, [fp]
 8001870:	f10b 0301 	add.w	r3, fp, #1
    if (c == 0)
 8001874:	b179      	cbz	r1, 8001896 <chvprintf+0x46>
      return n;
    if (c != '%') {
 8001876:	2925      	cmp	r1, #37	; 0x25
 8001878:	d011      	beq.n	800189e <chvprintf+0x4e>
      chSequentialStreamPut(chp, (uint8_t)c);
 800187a:	f8d9 2000 	ldr.w	r2, [r9]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 800187e:	469b      	mov	fp, r3
    if (c == 0)
      return n;
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
 8001880:	6892      	ldr	r2, [r2, #8]
 8001882:	4648      	mov	r0, r9
 8001884:	4790      	blx	r2
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 8001886:	f89b 1000 	ldrb.w	r1, [fp]
    if (c == 0)
      return n;
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
 800188a:	f108 0801 	add.w	r8, r8, #1
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 800188e:	f10b 0301 	add.w	r3, fp, #1
    if (c == 0)
 8001892:	2900      	cmp	r1, #0
 8001894:	d1ef      	bne.n	8001876 <chvprintf+0x26>
      chSequentialStreamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 8001896:	4640      	mov	r0, r8
 8001898:	b007      	add	sp, #28
 800189a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 800189e:	f89b 2001 	ldrb.w	r2, [fp, #1]
 80018a2:	2a2d      	cmp	r2, #45	; 0x2d
 80018a4:	bf03      	ittte	eq
 80018a6:	f89b 2002 	ldrbeq.w	r2, [fp, #2]
      fmt++;
 80018aa:	f10b 0302 	addeq.w	r3, fp, #2
      left_align = TRUE;
 80018ae:	f04f 0a01 	moveq.w	sl, #1
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
 80018b2:	f04f 0a00 	movne.w	sl, #0
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
 80018b6:	2a30      	cmp	r2, #48	; 0x30
 80018b8:	bf03      	ittte	eq
 80018ba:	785a      	ldrbeq	r2, [r3, #1]
      fmt++;
 80018bc:	3301      	addeq	r3, #1
      filler = '0';
 80018be:	2730      	moveq	r7, #48	; 0x30
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
 80018c0:	2720      	movne	r7, #32
 80018c2:	1c59      	adds	r1, r3, #1
    if (*fmt == '0') {
      fmt++;
      filler = '0';
    }
    width = 0;
 80018c4:	2600      	movs	r6, #0
 80018c6:	e006      	b.n	80018d6 <chvprintf+0x86>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
 80018c8:	782b      	ldrb	r3, [r5, #0]
 80018ca:	3504      	adds	r5, #4
 80018cc:	f89b 2000 	ldrb.w	r2, [fp]
      else
        break;
      width = width * 10 + c;
 80018d0:	eb03 0640 	add.w	r6, r3, r0, lsl #1
 80018d4:	3101      	adds	r1, #1
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 80018d6:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 80018da:	b2db      	uxtb	r3, r3
 80018dc:	2b09      	cmp	r3, #9
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
 80018de:	468b      	mov	fp, r1
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
 80018e0:	eb06 0086 	add.w	r0, r6, r6, lsl #2
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 80018e4:	d9f2      	bls.n	80018cc <chvprintf+0x7c>
        c -= '0';
      else if (c == '*')
 80018e6:	2a2a      	cmp	r2, #42	; 0x2a
 80018e8:	d0ee      	beq.n	80018c8 <chvprintf+0x78>
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
 80018ea:	2a2e      	cmp	r2, #46	; 0x2e
 80018ec:	f04f 0100 	mov.w	r1, #0
 80018f0:	d043      	beq.n	800197a <chvprintf+0x12a>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 80018f2:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 80018f6:	2b4c      	cmp	r3, #76	; 0x4c
 80018f8:	d04e      	beq.n	8001998 <chvprintf+0x148>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80018fa:	f1a2 0044 	sub.w	r0, r2, #68	; 0x44
 80018fe:	2834      	cmp	r0, #52	; 0x34
 8001900:	f200 80f7 	bhi.w	8001af2 <chvprintf+0x2a2>
 8001904:	e8df f010 	tbh	[pc, r0, lsl #1]
 8001908:	00f500ea 	.word	0x00f500ea
 800190c:	00f500f5 	.word	0x00f500f5
 8001910:	00ea00f5 	.word	0x00ea00f5
 8001914:	00f500f5 	.word	0x00f500f5
 8001918:	00f500f5 	.word	0x00f500f5
 800191c:	00e800f5 	.word	0x00e800f5
 8001920:	00f500f5 	.word	0x00f500f5
 8001924:	00f500f5 	.word	0x00f500f5
 8001928:	00dd00f5 	.word	0x00dd00f5
 800192c:	00f500f5 	.word	0x00f500f5
 8001930:	00f500f2 	.word	0x00f500f2
 8001934:	00f500f5 	.word	0x00f500f5
 8001938:	00f500f5 	.word	0x00f500f5
 800193c:	00f500f5 	.word	0x00f500f5
 8001940:	00f500f5 	.word	0x00f500f5
 8001944:	00a100f5 	.word	0x00a100f5
 8001948:	00f500ea 	.word	0x00f500ea
 800194c:	00f500f5 	.word	0x00f500f5
 8001950:	00ea00f5 	.word	0x00ea00f5
 8001954:	00f500f5 	.word	0x00f500f5
 8001958:	00f500f5 	.word	0x00f500f5
 800195c:	00e800f5 	.word	0x00e800f5
 8001960:	00f500f5 	.word	0x00f500f5
 8001964:	007100f5 	.word	0x007100f5
 8001968:	00dd00f5 	.word	0x00dd00f5
 800196c:	00f500f5 	.word	0x00f500f5
 8001970:	00f2      	.short	0x00f2
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
 8001972:	782b      	ldrb	r3, [r5, #0]
 8001974:	3504      	adds	r5, #4
        else
          break;
        precision *= 10;
        precision += c;
 8001976:	eb03 0140 	add.w	r1, r3, r0, lsl #1
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 800197a:	f81b 2b01 	ldrb.w	r2, [fp], #1
        if (c >= '0' && c <= '9')
 800197e:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8001982:	b2db      	uxtb	r3, r3
 8001984:	2b09      	cmp	r3, #9
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
        else
          break;
        precision *= 10;
 8001986:	eb01 0081 	add.w	r0, r1, r1, lsl #2
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
 800198a:	d9f4      	bls.n	8001976 <chvprintf+0x126>
          c -= '0';
        else if (c == '*')
 800198c:	2a2a      	cmp	r2, #42	; 0x2a
 800198e:	d0f0      	beq.n	8001972 <chvprintf+0x122>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8001990:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 8001994:	2b4c      	cmp	r3, #76	; 0x4c
 8001996:	d1b0      	bne.n	80018fa <chvprintf+0xaa>
      is_long = TRUE;
      if (*fmt)
 8001998:	f89b 3000 	ldrb.w	r3, [fp]
 800199c:	2b00      	cmp	r3, #0
 800199e:	f000 80a8 	beq.w	8001af2 <chvprintf+0x2a2>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80019a2:	f1a3 0244 	sub.w	r2, r3, #68	; 0x44
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 80019a6:	f10b 0b01 	add.w	fp, fp, #1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80019aa:	2a34      	cmp	r2, #52	; 0x34
 80019ac:	f200 80a0 	bhi.w	8001af0 <chvprintf+0x2a0>
 80019b0:	e8df f002 	tbb	[pc, r2]
 80019b4:	9e9e9e94 	.word	0x9e9e9e94
 80019b8:	9e9e949e 	.word	0x9e9e949e
 80019bc:	929e9e9e 	.word	0x929e9e9e
 80019c0:	9e9e9e9e 	.word	0x9e9e9e9e
 80019c4:	9e9e879e 	.word	0x9e9e879e
 80019c8:	9e9e9e9c 	.word	0x9e9e9e9c
 80019cc:	9e9e9e9e 	.word	0x9e9e9e9e
 80019d0:	4b9e9e9e 	.word	0x4b9e9e9e
 80019d4:	9e9e9e94 	.word	0x9e9e9e94
 80019d8:	9e9e949e 	.word	0x9e9e949e
 80019dc:	929e9e9e 	.word	0x929e9e9e
 80019e0:	1b9e9e9e 	.word	0x1b9e9e9e
 80019e4:	9e9e879e 	.word	0x9e9e879e
 80019e8:	9c          	.byte	0x9c
 80019e9:	00          	.byte	0x00
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 80019ea:	682c      	ldr	r4, [r5, #0]
        s = "(null)";
 80019ec:	4b5a      	ldr	r3, [pc, #360]	; (8001b58 <chvprintf+0x308>)
 80019ee:	2c00      	cmp	r4, #0
 80019f0:	bf08      	it	eq
 80019f2:	461c      	moveq	r4, r3
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 80019f4:	3504      	adds	r5, #4
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 80019f6:	7823      	ldrb	r3, [r4, #0]
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
 80019f8:	2900      	cmp	r1, #0
 80019fa:	f000 8094 	beq.w	8001b26 <chvprintf+0x2d6>
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 80019fe:	2b00      	cmp	r3, #0
 8001a00:	f000 8096 	beq.w	8001b30 <chvprintf+0x2e0>
 8001a04:	3901      	subs	r1, #1
 8001a06:	4620      	mov	r0, r4
 8001a08:	e001      	b.n	8001a0e <chvprintf+0x1be>
 8001a0a:	3901      	subs	r1, #1
 8001a0c:	d403      	bmi.n	8001a16 <chvprintf+0x1c6>
 8001a0e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8001a12:	2b00      	cmp	r3, #0
 8001a14:	d1f9      	bne.n	8001a0a <chvprintf+0x1ba>
 8001a16:	1b00      	subs	r0, r0, r4
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 8001a18:	1a36      	subs	r6, r6, r0
 8001a1a:	1e43      	subs	r3, r0, #1
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 8001a1c:	2720      	movs	r7, #32
 8001a1e:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8001a22:	f1ba 0f00 	cmp.w	sl, #0
 8001a26:	d01f      	beq.n	8001a68 <chvprintf+0x218>
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8001a28:	2b00      	cmp	r3, #0
 8001a2a:	9300      	str	r3, [sp, #0]
 8001a2c:	da34      	bge.n	8001a98 <chvprintf+0x248>
      chSequentialStreamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8001a2e:	2e00      	cmp	r6, #0
 8001a30:	f43f af1c 	beq.w	800186c <chvprintf+0x1c>
 8001a34:	4634      	mov	r4, r6
      chSequentialStreamPut(chp, (uint8_t)filler);
 8001a36:	f8d9 3000 	ldr.w	r3, [r9]
 8001a3a:	4648      	mov	r0, r9
 8001a3c:	689b      	ldr	r3, [r3, #8]
 8001a3e:	4639      	mov	r1, r7
 8001a40:	4798      	blx	r3
    while (--i >= 0) {
      chSequentialStreamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8001a42:	3c01      	subs	r4, #1
 8001a44:	d1f7      	bne.n	8001a36 <chvprintf+0x1e6>
 8001a46:	44b0      	add	r8, r6
 8001a48:	e710      	b.n	800186c <chvprintf+0x1c>

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 8001a4a:	682b      	ldr	r3, [r5, #0]
 8001a4c:	f88d 300c 	strb.w	r3, [sp, #12]
 8001a50:	9b01      	ldr	r3, [sp, #4]
 8001a52:	3504      	adds	r5, #4
 8001a54:	4618      	mov	r0, r3
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 8001a56:	2720      	movs	r7, #32
 8001a58:	3b01      	subs	r3, #1
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8001a5a:	ac03      	add	r4, sp, #12
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 8001a5c:	1a36      	subs	r6, r6, r0
 8001a5e:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      width = 0;
    if (left_align == FALSE)
 8001a62:	f1ba 0f00 	cmp.w	sl, #0
 8001a66:	d1df      	bne.n	8001a28 <chvprintf+0x1d8>
 8001a68:	9300      	str	r3, [sp, #0]
      width = -width;
 8001a6a:	f1c6 0a00 	rsb	sl, r6, #0
    if (width < 0) {
 8001a6e:	f1ba 0f00 	cmp.w	sl, #0
 8001a72:	d045      	beq.n	8001b00 <chvprintf+0x2b0>
      if (*s == '-' && filler == '0') {
 8001a74:	7821      	ldrb	r1, [r4, #0]
 8001a76:	292d      	cmp	r1, #45	; 0x2d
 8001a78:	d047      	beq.n	8001b0a <chvprintf+0x2ba>
        chSequentialStreamPut(chp, (uint8_t)*s++);
        n++;
 8001a7a:	4656      	mov	r6, sl
        i--;
      }
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
 8001a7c:	f8d9 3000 	ldr.w	r3, [r9]
 8001a80:	4648      	mov	r0, r9
 8001a82:	689b      	ldr	r3, [r3, #8]
 8001a84:	4639      	mov	r1, r7
 8001a86:	4798      	blx	r3
        n++;
      } while (++width != 0);
 8001a88:	3601      	adds	r6, #1
 8001a8a:	d1f7      	bne.n	8001a7c <chvprintf+0x22c>
    }
    while (--i >= 0) {
 8001a8c:	9b00      	ldr	r3, [sp, #0]
 8001a8e:	2b00      	cmp	r3, #0
 8001a90:	ebca 0808 	rsb	r8, sl, r8
 8001a94:	f6ff aeea 	blt.w	800186c <chvprintf+0x1c>
 8001a98:	f8dd a000 	ldr.w	sl, [sp]
      chSequentialStreamPut(chp, (uint8_t)*s++);
 8001a9c:	f8d9 3000 	ldr.w	r3, [r9]
 8001aa0:	f814 1b01 	ldrb.w	r1, [r4], #1
 8001aa4:	689b      	ldr	r3, [r3, #8]
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8001aa6:	f10a 3aff 	add.w	sl, sl, #4294967295
      chSequentialStreamPut(chp, (uint8_t)*s++);
 8001aaa:	4648      	mov	r0, r9
 8001aac:	4798      	blx	r3
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8001aae:	f1ba 3fff 	cmp.w	sl, #4294967295
 8001ab2:	d1f3      	bne.n	8001a9c <chvprintf+0x24c>
 8001ab4:	9b00      	ldr	r3, [sp, #0]
 8001ab6:	f108 0801 	add.w	r8, r8, #1
 8001aba:	2b00      	cmp	r3, #0
 8001abc:	bfa8      	it	ge
 8001abe:	4498      	addge	r8, r3
 8001ac0:	e7b5      	b.n	8001a2e <chvprintf+0x1de>
      c = 16;
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
      goto unsigned_common;
 8001ac2:	220a      	movs	r2, #10
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 8001ac4:	6829      	ldr	r1, [r5, #0]
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8001ac6:	a803      	add	r0, sp, #12
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 8001ac8:	3504      	adds	r5, #4
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8001aca:	f7ff fe99 	bl	8001800 <long_to_string_with_divisor.constprop.0>
 8001ace:	ab03      	add	r3, sp, #12
 8001ad0:	1ac0      	subs	r0, r0, r3
 8001ad2:	1e43      	subs	r3, r0, #1
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8001ad4:	ac03      	add	r4, sp, #12
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
 8001ad6:	e7c1      	b.n	8001a5c <chvprintf+0x20c>
 8001ad8:	2208      	movs	r2, #8
 8001ada:	e7f3      	b.n	8001ac4 <chvprintf+0x274>
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 8001adc:	6829      	ldr	r1, [r5, #0]
      if (l < 0) {
 8001ade:	2900      	cmp	r1, #0
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 8001ae0:	f105 0504 	add.w	r5, r5, #4
      if (l < 0) {
 8001ae4:	db2e      	blt.n	8001b44 <chvprintf+0x2f4>
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 8001ae6:	a803      	add	r0, sp, #12
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8001ae8:	220a      	movs	r2, #10
 8001aea:	e7ee      	b.n	8001aca <chvprintf+0x27a>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8001aec:	2210      	movs	r2, #16
 8001aee:	e7e9      	b.n	8001ac4 <chvprintf+0x274>
 8001af0:	461a      	mov	r2, r3
 8001af2:	9b01      	ldr	r3, [sp, #4]
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8001af4:	f88d 200c 	strb.w	r2, [sp, #12]
 8001af8:	4618      	mov	r0, r3
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8001afa:	ac03      	add	r4, sp, #12
 8001afc:	3b01      	subs	r3, #1
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
      break;
 8001afe:	e7ad      	b.n	8001a5c <chvprintf+0x20c>
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8001b00:	9b00      	ldr	r3, [sp, #0]
 8001b02:	2b00      	cmp	r3, #0
 8001b04:	4656      	mov	r6, sl
 8001b06:	dac7      	bge.n	8001a98 <chvprintf+0x248>
 8001b08:	e6b0      	b.n	800186c <chvprintf+0x1c>
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
 8001b0a:	2f30      	cmp	r7, #48	; 0x30
 8001b0c:	d1b5      	bne.n	8001a7a <chvprintf+0x22a>
        chSequentialStreamPut(chp, (uint8_t)*s++);
 8001b0e:	f8d9 3000 	ldr.w	r3, [r9]
 8001b12:	4648      	mov	r0, r9
 8001b14:	689b      	ldr	r3, [r3, #8]
 8001b16:	4798      	blx	r3
 8001b18:	9b00      	ldr	r3, [sp, #0]
 8001b1a:	3b01      	subs	r3, #1
 8001b1c:	3401      	adds	r4, #1
        n++;
 8001b1e:	f108 0801 	add.w	r8, r8, #1
 8001b22:	9300      	str	r3, [sp, #0]
 8001b24:	e7a9      	b.n	8001a7a <chvprintf+0x22a>
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8001b26:	f647 71fe 	movw	r1, #32766	; 0x7ffe
 8001b2a:	2b00      	cmp	r3, #0
 8001b2c:	f47f af6b 	bne.w	8001a06 <chvprintf+0x1b6>
 8001b30:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8001b34:	f1ba 0f00 	cmp.w	sl, #0
 8001b38:	d10b      	bne.n	8001b52 <chvprintf+0x302>
 8001b3a:	f04f 33ff 	mov.w	r3, #4294967295
 8001b3e:	9300      	str	r3, [sp, #0]
 8001b40:	2720      	movs	r7, #32
 8001b42:	e792      	b.n	8001a6a <chvprintf+0x21a>
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8001b44:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 8001b46:	4249      	negs	r1, r1
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8001b48:	f88d 300c 	strb.w	r3, [sp, #12]
 8001b4c:	f10d 000d 	add.w	r0, sp, #13
 8001b50:	e7ca      	b.n	8001ae8 <chvprintf+0x298>
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8001b52:	2720      	movs	r7, #32
 8001b54:	e76b      	b.n	8001a2e <chvprintf+0x1de>
 8001b56:	bf00      	nop
 8001b58:	08002940 	.word	0x08002940
 8001b5c:	f3af 8000 	nop.w

08001b60 <get>:
static msg_t get(void *ip) {

  (void)ip;

  return 4;
}
 8001b60:	2004      	movs	r0, #4
 8001b62:	4770      	bx	lr
 8001b64:	f3af 8000 	nop.w
 8001b68:	f3af 8000 	nop.w
 8001b6c:	f3af 8000 	nop.w

08001b70 <reads>:
  (void)ip;
  (void)bp;
  (void)n;

  return 0;
}
 8001b70:	2000      	movs	r0, #0
 8001b72:	4770      	bx	lr
 8001b74:	f3af 8000 	nop.w
 8001b78:	f3af 8000 	nop.w
 8001b7c:	f3af 8000 	nop.w

08001b80 <put>:
extern void Debug_ITMDebugOutputChar(char ch);

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static msg_t put(void *ip, uint8_t b) {
 8001b80:	b508      	push	{r3, lr}

  (void)ip;
  
  Debug_ITMDebugOutputChar(b);
 8001b82:	4608      	mov	r0, r1
 8001b84:	f000 f99c 	bl	8001ec0 <Debug_ITMDebugOutputChar>

  return MSG_OK;
}
 8001b88:	2000      	movs	r0, #0
 8001b8a:	bd08      	pop	{r3, pc}
 8001b8c:	f3af 8000 	nop.w

08001b90 <writes>:
  (void)ip;

  return 4;
}

static size_t writes(void *ip, const uint8_t *bp, size_t n) {
 8001b90:	b570      	push	{r4, r5, r6, lr}
  size_t cnt = n;

  while (cnt > 0) {
 8001b92:	4616      	mov	r6, r2
 8001b94:	b13a      	cbz	r2, 8001ba6 <writes+0x16>
 8001b96:	460d      	mov	r5, r1
 8001b98:	4614      	mov	r4, r2
/*===========================================================================*/
static msg_t put(void *ip, uint8_t b) {

  (void)ip;
  
  Debug_ITMDebugOutputChar(b);
 8001b9a:	f815 0b01 	ldrb.w	r0, [r5], #1
 8001b9e:	f000 f98f 	bl	8001ec0 <Debug_ITMDebugOutputChar>
}

static size_t writes(void *ip, const uint8_t *bp, size_t n) {
  size_t cnt = n;

  while (cnt > 0) {
 8001ba2:	3c01      	subs	r4, #1
 8001ba4:	d1f9      	bne.n	8001b9a <writes+0xa>
    bp++;
    cnt--;
  }

  return n;
}
 8001ba6:	4630      	mov	r0, r6
 8001ba8:	bd70      	pop	{r4, r5, r6, pc}
 8001baa:	bf00      	nop
 8001bac:	f3af 8000 	nop.w

08001bb0 <itmObjectInit>:
 * @brief   ITM stream object initialization.
 *
 * @param[out] pitm      pointer to the @p ITMStream object to be initialized
 */
void itmObjectInit(ITMStream *pitm) {
   pitm->vmt = &vmt;
 8001bb0:	4b01      	ldr	r3, [pc, #4]	; (8001bb8 <itmObjectInit+0x8>)
 8001bb2:	6003      	str	r3, [r0, #0]
 8001bb4:	4770      	bx	lr
 8001bb6:	bf00      	nop
 8001bb8:	08002950 	.word	0x08002950
 8001bbc:	f3af 8000 	nop.w

08001bc0 <arrayCopy>:
#include <stdlib.h>

#include "ArrayUtil.h"

void arrayCopy(void *dest, int dIndex, const void* src, int sIndex, int len, int destLen, size_t size)
{
 8001bc0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001bc4:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8001bc6:	9d08      	ldr	r5, [sp, #32]
 8001bc8:	f8dd e024 	ldr.w	lr, [sp, #36]	; 0x24
	dIndex	*= size;
	sIndex	*= size;
	len		*= size;
	destLen	*= size;
	
	if(src != dest)
 8001bcc:	4282      	cmp	r2, r0
#include <stdlib.h>

#include "ArrayUtil.h"

void arrayCopy(void *dest, int dIndex, const void* src, int sIndex, int len, int destLen, size_t size)
{
 8001bce:	4616      	mov	r6, r2
	uint8_t *udest 	= (uint8_t*) dest;
	uint8_t *usrc	= (uint8_t*) src;
	dIndex	*= size;
	sIndex	*= size;
	len		*= size;
 8001bd0:	fb05 f504 	mul.w	r5, r5, r4

void arrayCopy(void *dest, int dIndex, const void* src, int sIndex, int len, int destLen, size_t size)
{
	uint8_t *udest 	= (uint8_t*) dest;
	uint8_t *usrc	= (uint8_t*) src;
	dIndex	*= size;
 8001bd4:	fb04 f701 	mul.w	r7, r4, r1
	sIndex	*= size;
 8001bd8:	fb04 f803 	mul.w	r8, r4, r3
	len		*= size;
	destLen	*= size;
	
	if(src != dest)
 8001bdc:	d007      	beq.n	8001bee <arrayCopy+0x2e>
	{
		memcpy(&udest[dIndex], &usrc[sIndex], len);
 8001bde:	eb02 0108 	add.w	r1, r2, r8
 8001be2:	4438      	add	r0, r7
 8001be4:	462a      	mov	r2, r5
		{
			memcpy(&udest[dIndex], &usrc[sIndex], (destLen - sIndex) + 1);
		}else
			return;
	}
 8001be6:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	len		*= size;
	destLen	*= size;
	
	if(src != dest)
	{
		memcpy(&udest[dIndex], &usrc[sIndex], len);
 8001bea:	f7fe bb59 	b.w	80002a0 <memcpy>
	}else
	{
		if(dIndex > sIndex)
 8001bee:	4547      	cmp	r7, r8
	uint8_t *udest 	= (uint8_t*) dest;
	uint8_t *usrc	= (uint8_t*) src;
	dIndex	*= size;
	sIndex	*= size;
	len		*= size;
	destLen	*= size;
 8001bf0:	fb0e f004 	mul.w	r0, lr, r4
	if(src != dest)
	{
		memcpy(&udest[dIndex], &usrc[sIndex], len);
	}else
	{
		if(dIndex > sIndex)
 8001bf4:	dc0c      	bgt.n	8001c10 <arrayCopy+0x50>
			uint8_t *tmp = (uint8_t*) calloc(destLen, size);
			memcpy(tmp, &udest[dIndex], (destLen - dIndex));
			memcpy(&udest[dIndex], &usrc[sIndex], len);
			memcpy(&udest[dIndex + len], tmp, (destLen - dIndex));
			free(tmp);
		}else if(sIndex > dIndex)
 8001bf6:	db01      	blt.n	8001bfc <arrayCopy+0x3c>
 8001bf8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		{
			memcpy(&udest[dIndex], &usrc[sIndex], (destLen - sIndex) + 1);
 8001bfc:	ebc8 0200 	rsb	r2, r8, r0
 8001c00:	eb06 0108 	add.w	r1, r6, r8
 8001c04:	19f0      	adds	r0, r6, r7
 8001c06:	3201      	adds	r2, #1
		}else
			return;
	}
 8001c08:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			memcpy(&udest[dIndex], &usrc[sIndex], len);
			memcpy(&udest[dIndex + len], tmp, (destLen - dIndex));
			free(tmp);
		}else if(sIndex > dIndex)
		{
			memcpy(&udest[dIndex], &usrc[sIndex], (destLen - sIndex) + 1);
 8001c0c:	f7fe bb48 	b.w	80002a0 <memcpy>
		memcpy(&udest[dIndex], &usrc[sIndex], len);
	}else
	{
		if(dIndex > sIndex)
		{
			uint8_t *tmp = (uint8_t*) calloc(destLen, size);
 8001c10:	4621      	mov	r1, r4
			memcpy(tmp, &udest[dIndex], (destLen - dIndex));
 8001c12:	eb02 0a07 	add.w	sl, r2, r7
 8001c16:	ebc7 0900 	rsb	r9, r7, r0
		memcpy(&udest[dIndex], &usrc[sIndex], len);
	}else
	{
		if(dIndex > sIndex)
		{
			uint8_t *tmp = (uint8_t*) calloc(destLen, size);
 8001c1a:	f000 f969 	bl	8001ef0 <calloc>
			memcpy(tmp, &udest[dIndex], (destLen - dIndex));
 8001c1e:	464a      	mov	r2, r9
 8001c20:	4651      	mov	r1, sl
		memcpy(&udest[dIndex], &usrc[sIndex], len);
	}else
	{
		if(dIndex > sIndex)
		{
			uint8_t *tmp = (uint8_t*) calloc(destLen, size);
 8001c22:	4604      	mov	r4, r0
			memcpy(tmp, &udest[dIndex], (destLen - dIndex));
 8001c24:	f7fe fb3c 	bl	80002a0 <memcpy>
			memcpy(&udest[dIndex], &usrc[sIndex], len);
 8001c28:	eb06 0108 	add.w	r1, r6, r8
 8001c2c:	462a      	mov	r2, r5
 8001c2e:	4650      	mov	r0, sl
 8001c30:	f7fe fb36 	bl	80002a0 <memcpy>
			memcpy(&udest[dIndex + len], tmp, (destLen - dIndex));
 8001c34:	1978      	adds	r0, r7, r5
 8001c36:	464a      	mov	r2, r9
 8001c38:	4430      	add	r0, r6
 8001c3a:	4621      	mov	r1, r4
 8001c3c:	f7fe fb30 	bl	80002a0 <memcpy>
			free(tmp);
 8001c40:	4620      	mov	r0, r4
		{
			memcpy(&udest[dIndex], &usrc[sIndex], (destLen - sIndex) + 1);
		}else
			return;
	}
 8001c42:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		{
			uint8_t *tmp = (uint8_t*) calloc(destLen, size);
			memcpy(tmp, &udest[dIndex], (destLen - dIndex));
			memcpy(&udest[dIndex], &usrc[sIndex], len);
			memcpy(&udest[dIndex + len], tmp, (destLen - dIndex));
			free(tmp);
 8001c46:	f000 b98b 	b.w	8001f60 <free>
 8001c4a:	bf00      	nop
 8001c4c:	f3af 8000 	nop.w

08001c50 <chprintf.constprop.2>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8001c50:	b40e      	push	{r1, r2, r3}
 8001c52:	b500      	push	{lr}
 8001c54:	b082      	sub	sp, #8
 8001c56:	aa03      	add	r2, sp, #12
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
 8001c58:	4805      	ldr	r0, [pc, #20]	; (8001c70 <chprintf.constprop.2+0x20>)
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8001c5a:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8001c5e:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8001c60:	f7ff fdf6 	bl	8001850 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8001c64:	b002      	add	sp, #8
 8001c66:	f85d eb04 	ldr.w	lr, [sp], #4
 8001c6a:	b003      	add	sp, #12
 8001c6c:	4770      	bx	lr
 8001c6e:	bf00      	nop
 8001c70:	2000137c 	.word	0x2000137c
 8001c74:	f3af 8000 	nop.w
 8001c78:	f3af 8000 	nop.w
 8001c7c:	f3af 8000 	nop.w

08001c80 <initWithSizeAndIncRate>:
{
	initWithSizeAndIncRate(list, size, 50);
}

void initWithSizeAndIncRate(DeviceList* const list, int size, int rate)
{
 8001c80:	b510      	push	{r4, lr}
 8001c82:	4604      	mov	r4, r0
	list->size = size;
	list->increment_rate = rate;
 8001c84:	6082      	str	r2, [r0, #8]
	initWithSizeAndIncRate(list, size, 50);
}

void initWithSizeAndIncRate(DeviceList* const list, int size, int rate)
{
	list->size = size;
 8001c86:	6041      	str	r1, [r0, #4]
	list->increment_rate = rate;
	list->elements = (Element*) chHeapAlloc( NULL, list->size * sizeof(Element));
 8001c88:	0089      	lsls	r1, r1, #2
 8001c8a:	2000      	movs	r0, #0
 8001c8c:	f7ff fa18 	bl	80010c0 <chHeapAlloc>
	chprintf((BaseSequentialStream *)&itm_port, "list->elements: %i\n", list->elements);
 8001c90:	4904      	ldr	r1, [pc, #16]	; (8001ca4 <initWithSizeAndIncRate+0x24>)

void initWithSizeAndIncRate(DeviceList* const list, int size, int rate)
{
	list->size = size;
	list->increment_rate = rate;
	list->elements = (Element*) chHeapAlloc( NULL, list->size * sizeof(Element));
 8001c92:	60e0      	str	r0, [r4, #12]
 8001c94:	4602      	mov	r2, r0
	chprintf((BaseSequentialStream *)&itm_port, "list->elements: %i\n", list->elements);
 8001c96:	4804      	ldr	r0, [pc, #16]	; (8001ca8 <initWithSizeAndIncRate+0x28>)
 8001c98:	f7ff ffda 	bl	8001c50 <chprintf.constprop.2>
	list->current = -1;
 8001c9c:	f04f 33ff 	mov.w	r3, #4294967295
 8001ca0:	6023      	str	r3, [r4, #0]
 8001ca2:	bd10      	pop	{r4, pc}
 8001ca4:	08002960 	.word	0x08002960
 8001ca8:	2000137c 	.word	0x2000137c
 8001cac:	f3af 8000 	nop.w

08001cb0 <init>:
	initWithSize(list, 16);
}

void initWithSize(DeviceList* const list, int size)
{
	initWithSizeAndIncRate(list, size, 50);
 8001cb0:	2110      	movs	r1, #16
 8001cb2:	2232      	movs	r2, #50	; 0x32
 8001cb4:	f7ff bfe4 	b.w	8001c80 <initWithSizeAndIncRate>
 8001cb8:	f3af 8000 	nop.w
 8001cbc:	f3af 8000 	nop.w

08001cc0 <add>:
	}
	return NULL;
}

int add(DeviceList* const list, Element e)
{
 8001cc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if(++list->current < list->size)
 8001cc4:	e890 0060 	ldmia.w	r0, {r5, r6}
 8001cc8:	3501      	adds	r5, #1
 8001cca:	42b5      	cmp	r5, r6
	}
	return NULL;
}

int add(DeviceList* const list, Element e)
{
 8001ccc:	b084      	sub	sp, #16
 8001cce:	4604      	mov	r4, r0
 8001cd0:	460f      	mov	r7, r1
	if(++list->current < list->size)
 8001cd2:	6005      	str	r5, [r0, #0]
 8001cd4:	db1c      	blt.n	8001d10 <add+0x50>
	return 0;
}

static void wide(DeviceList* const list)
{
	list->size += list->increment_rate;
 8001cd6:	6883      	ldr	r3, [r0, #8]
 8001cd8:	441e      	add	r6, r3
 8001cda:	6046      	str	r6, [r0, #4]
	Element *newArr = (Element*) calloc(sizeof(Element), list->size);
 8001cdc:	4631      	mov	r1, r6
 8001cde:	2004      	movs	r0, #4
 8001ce0:	f000 f906 	bl	8001ef0 <calloc>
	arrayCopy(newArr, 0, list->elements, 0, list->current, list->size, sizeof(Element));
 8001ce4:	2100      	movs	r1, #0
 8001ce6:	2304      	movs	r3, #4
 8001ce8:	68e2      	ldr	r2, [r4, #12]
 8001cea:	9302      	str	r3, [sp, #8]
 8001cec:	9601      	str	r6, [sp, #4]
 8001cee:	460b      	mov	r3, r1
 8001cf0:	9500      	str	r5, [sp, #0]
}

static void wide(DeviceList* const list)
{
	list->size += list->increment_rate;
	Element *newArr = (Element*) calloc(sizeof(Element), list->size);
 8001cf2:	4680      	mov	r8, r0
	arrayCopy(newArr, 0, list->elements, 0, list->current, list->size, sizeof(Element));
 8001cf4:	f7ff ff64 	bl	8001bc0 <arrayCopy>
	free(list->elements);
 8001cf8:	68e0      	ldr	r0, [r4, #12]
 8001cfa:	f000 f931 	bl	8001f60 <free>
		chprintf((BaseSequentialStream *)&itm_port, "list->elements[list->current]: %i\n", list->elements[list->current]);
		return 1;
	}else
	{
		wide(list);
		list->elements[list->current] = e;
 8001cfe:	6823      	ldr	r3, [r4, #0]
{
	list->size += list->increment_rate;
	Element *newArr = (Element*) calloc(sizeof(Element), list->size);
	arrayCopy(newArr, 0, list->elements, 0, list->current, list->size, sizeof(Element));
	free(list->elements);
	list->elements = newArr;
 8001d00:	f8c4 800c 	str.w	r8, [r4, #12]
		wide(list);
		list->elements[list->current] = e;
		return 1;
	}
	return 0;
}
 8001d04:	2001      	movs	r0, #1
		chprintf((BaseSequentialStream *)&itm_port, "list->elements[list->current]: %i\n", list->elements[list->current]);
		return 1;
	}else
	{
		wide(list);
		list->elements[list->current] = e;
 8001d06:	f848 7023 	str.w	r7, [r8, r3, lsl #2]
		return 1;
	}
	return 0;
}
 8001d0a:	b004      	add	sp, #16
 8001d0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

int add(DeviceList* const list, Element e)
{
	if(++list->current < list->size)
	{
		chprintf((BaseSequentialStream *)&itm_port, "list->current: %i\n", list->current);
 8001d10:	462a      	mov	r2, r5
 8001d12:	490b      	ldr	r1, [pc, #44]	; (8001d40 <add+0x80>)
 8001d14:	480b      	ldr	r0, [pc, #44]	; (8001d44 <add+0x84>)
 8001d16:	f7ff ff9b 	bl	8001c50 <chprintf.constprop.2>
		chprintf((BaseSequentialStream *)&itm_port, "e.data: %i\n", e.data);
 8001d1a:	463a      	mov	r2, r7
 8001d1c:	490a      	ldr	r1, [pc, #40]	; (8001d48 <add+0x88>)
 8001d1e:	4809      	ldr	r0, [pc, #36]	; (8001d44 <add+0x84>)
 8001d20:	f7ff ff96 	bl	8001c50 <chprintf.constprop.2>
		list->elements[list->current] = e;
 8001d24:	6822      	ldr	r2, [r4, #0]
 8001d26:	68e3      	ldr	r3, [r4, #12]
		chprintf((BaseSequentialStream *)&itm_port, "list->elements[list->current]: %i\n", list->elements[list->current]);
 8001d28:	4908      	ldr	r1, [pc, #32]	; (8001d4c <add+0x8c>)
{
	if(++list->current < list->size)
	{
		chprintf((BaseSequentialStream *)&itm_port, "list->current: %i\n", list->current);
		chprintf((BaseSequentialStream *)&itm_port, "e.data: %i\n", e.data);
		list->elements[list->current] = e;
 8001d2a:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
		chprintf((BaseSequentialStream *)&itm_port, "list->elements[list->current]: %i\n", list->elements[list->current]);
 8001d2e:	4805      	ldr	r0, [pc, #20]	; (8001d44 <add+0x84>)
 8001d30:	463a      	mov	r2, r7
 8001d32:	f7ff ff8d 	bl	8001c50 <chprintf.constprop.2>
		wide(list);
		list->elements[list->current] = e;
		return 1;
	}
	return 0;
}
 8001d36:	2001      	movs	r0, #1
 8001d38:	b004      	add	sp, #16
 8001d3a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001d3e:	bf00      	nop
 8001d40:	08002974 	.word	0x08002974
 8001d44:	2000137c 	.word	0x2000137c
 8001d48:	08002988 	.word	0x08002988
 8001d4c:	08002994 	.word	0x08002994

08001d50 <insert>:
	free(list->elements);
	list->elements = newArr;
}

int insert(DeviceList* const list, Element e, int index)
{
 8001d50:	b5f0      	push	{r4, r5, r6, r7, lr}
	if(index <= list->current && ++list->current < list->size)
 8001d52:	6804      	ldr	r4, [r0, #0]
 8001d54:	4294      	cmp	r4, r2
	free(list->elements);
	list->elements = newArr;
}

int insert(DeviceList* const list, Element e, int index)
{
 8001d56:	b085      	sub	sp, #20
	if(index <= list->current && ++list->current < list->size)
 8001d58:	db04      	blt.n	8001d64 <insert+0x14>
 8001d5a:	6843      	ldr	r3, [r0, #4]
 8001d5c:	3401      	adds	r4, #1
 8001d5e:	429c      	cmp	r4, r3
 8001d60:	6004      	str	r4, [r0, #0]
 8001d62:	db02      	blt.n	8001d6a <insert+0x1a>
	{
		shift(list, index, 1, RIGHT);
		list->elements[index] = e;
		return 1;
	}
	return 0;
 8001d64:	2000      	movs	r0, #0
}
 8001d66:	b005      	add	sp, #20
 8001d68:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001d6a:	4605      	mov	r5, r0
 8001d6c:	68c0      	ldr	r0, [r0, #12]

static void shift(DeviceList* const list, int index, int rooms, Shift dir)
{
	if(dir == RIGHT)
	{
		arrayCopy(list->elements, index + 1, list->elements, index, rooms, list->current, sizeof(Element));
 8001d6e:	9401      	str	r4, [sp, #4]
 8001d70:	4616      	mov	r6, r2
 8001d72:	2401      	movs	r4, #1
 8001d74:	2304      	movs	r3, #4
 8001d76:	460f      	mov	r7, r1
 8001d78:	4602      	mov	r2, r0
 8001d7a:	9302      	str	r3, [sp, #8]
 8001d7c:	9400      	str	r4, [sp, #0]
 8001d7e:	4633      	mov	r3, r6
 8001d80:	1931      	adds	r1, r6, r4
 8001d82:	f7ff ff1d 	bl	8001bc0 <arrayCopy>
int insert(DeviceList* const list, Element e, int index)
{
	if(index <= list->current && ++list->current < list->size)
	{
		shift(list, index, 1, RIGHT);
		list->elements[index] = e;
 8001d86:	68eb      	ldr	r3, [r5, #12]
		return 1;
 8001d88:	4620      	mov	r0, r4
int insert(DeviceList* const list, Element e, int index)
{
	if(index <= list->current && ++list->current < list->size)
	{
		shift(list, index, 1, RIGHT);
		list->elements[index] = e;
 8001d8a:	f843 7026 	str.w	r7, [r3, r6, lsl #2]
		return 1;
	}
	return 0;
}
 8001d8e:	b005      	add	sp, #20
 8001d90:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001d92:	bf00      	nop
 8001d94:	f3af 8000 	nop.w
 8001d98:	f3af 8000 	nop.w
 8001d9c:	f3af 8000 	nop.w

08001da0 <print>:
	}
	return NULL;
}

void print(const DeviceList* const list)
{
 8001da0:	b570      	push	{r4, r5, r6, lr}
 8001da2:	4605      	mov	r5, r0
	int i;
	chprintf((BaseSequentialStream *)&itm_port, "print list->current: %i\n", list->current);
 8001da4:	6802      	ldr	r2, [r0, #0]
 8001da6:	4914      	ldr	r1, [pc, #80]	; (8001df8 <print+0x58>)
 8001da8:	4814      	ldr	r0, [pc, #80]	; (8001dfc <print+0x5c>)
 8001daa:	f7ff ff51 	bl	8001c50 <chprintf.constprop.2>
	for(i = 0; i <= list->current; i++)
 8001dae:	682b      	ldr	r3, [r5, #0]
 8001db0:	2b00      	cmp	r3, #0
 8001db2:	bfa8      	it	ge
 8001db4:	2400      	movge	r4, #0
 8001db6:	db18      	blt.n	8001dea <print+0x4a>
	{
		chprintf((BaseSequentialStream *)&itm_port, "print list->elements[%d]: %i\n", i, list->elements[i]);
 8001db8:	68eb      	ldr	r3, [r5, #12]
 8001dba:	4911      	ldr	r1, [pc, #68]	; (8001e00 <print+0x60>)
 8001dbc:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8001dc0:	480e      	ldr	r0, [pc, #56]	; (8001dfc <print+0x5c>)
 8001dc2:	4622      	mov	r2, r4
 8001dc4:	f7ff ff44 	bl	8001c50 <chprintf.constprop.2>
		Element e = list->elements[i];
 8001dc8:	68eb      	ldr	r3, [r5, #12]
		chprintf((BaseSequentialStream *)&itm_port, "print e.data: %i\n", e.data);
 8001dca:	490e      	ldr	r1, [pc, #56]	; (8001e04 <print+0x64>)
	int i;
	chprintf((BaseSequentialStream *)&itm_port, "print list->current: %i\n", list->current);
	for(i = 0; i <= list->current; i++)
	{
		chprintf((BaseSequentialStream *)&itm_port, "print list->elements[%d]: %i\n", i, list->elements[i]);
		Element e = list->elements[i];
 8001dcc:	f853 6024 	ldr.w	r6, [r3, r4, lsl #2]
		chprintf((BaseSequentialStream *)&itm_port, "print e.data: %i\n", e.data);
 8001dd0:	480a      	ldr	r0, [pc, #40]	; (8001dfc <print+0x5c>)
 8001dd2:	4632      	mov	r2, r6
 8001dd4:	f7ff ff3c 	bl	8001c50 <chprintf.constprop.2>
	free(list->elements);
}

static void printElement(const Element* const e)
{
	chprintf((BaseSequentialStream *)&itm_port, "print e->data: %i ", e->data);
 8001dd8:	4632      	mov	r2, r6
 8001dda:	4808      	ldr	r0, [pc, #32]	; (8001dfc <print+0x5c>)
 8001ddc:	490a      	ldr	r1, [pc, #40]	; (8001e08 <print+0x68>)
 8001dde:	f7ff ff37 	bl	8001c50 <chprintf.constprop.2>

void print(const DeviceList* const list)
{
	int i;
	chprintf((BaseSequentialStream *)&itm_port, "print list->current: %i\n", list->current);
	for(i = 0; i <= list->current; i++)
 8001de2:	682b      	ldr	r3, [r5, #0]
 8001de4:	3401      	adds	r4, #1
 8001de6:	42a3      	cmp	r3, r4
 8001de8:	dae6      	bge.n	8001db8 <print+0x18>
		chprintf((BaseSequentialStream *)&itm_port, "print list->elements[%d]: %i\n", i, list->elements[i]);
		Element e = list->elements[i];
		chprintf((BaseSequentialStream *)&itm_port, "print e.data: %i\n", e.data);
		printElement(&e);
	}
	chprintf((BaseSequentialStream *)&itm_port, "\n");
 8001dea:	4804      	ldr	r0, [pc, #16]	; (8001dfc <print+0x5c>)
 8001dec:	4907      	ldr	r1, [pc, #28]	; (8001e0c <print+0x6c>)
}
 8001dee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		chprintf((BaseSequentialStream *)&itm_port, "print list->elements[%d]: %i\n", i, list->elements[i]);
		Element e = list->elements[i];
		chprintf((BaseSequentialStream *)&itm_port, "print e.data: %i\n", e.data);
		printElement(&e);
	}
	chprintf((BaseSequentialStream *)&itm_port, "\n");
 8001df2:	f7ff bf2d 	b.w	8001c50 <chprintf.constprop.2>
 8001df6:	bf00      	nop
 8001df8:	080029b8 	.word	0x080029b8
 8001dfc:	2000137c 	.word	0x2000137c
 8001e00:	080029d4 	.word	0x080029d4
 8001e04:	080029f4 	.word	0x080029f4
 8001e08:	08002a08 	.word	0x08002a08
 8001e0c:	08002a48 	.word	0x08002a48

08001e10 <Thread1>:

/*
 * Red LED blinker thread, times are in milliseconds.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8001e10:	b508      	push	{r3, lr}

  (void)arg;
  chRegSetThreadName("blinker");
 8001e12:	4b09      	ldr	r3, [pc, #36]	; (8001e38 <Thread1+0x28>)
 8001e14:	4a09      	ldr	r2, [pc, #36]	; (8001e3c <Thread1+0x2c>)
 8001e16:	699b      	ldr	r3, [r3, #24]
  while (TRUE) {
    palClearPad(GPIOA, GPIOA_LED_GREEN);
 8001e18:	4c09      	ldr	r4, [pc, #36]	; (8001e40 <Thread1+0x30>)
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {

  (void)arg;
  chRegSetThreadName("blinker");
 8001e1a:	619a      	str	r2, [r3, #24]
  while (TRUE) {
    palClearPad(GPIOA, GPIOA_LED_GREEN);
 8001e1c:	2520      	movs	r5, #32
 8001e1e:	462e      	mov	r6, r5
 8001e20:	8366      	strh	r6, [r4, #26]
    chThdSleepMilliseconds(500);
 8001e22:	f241 3088 	movw	r0, #5000	; 0x1388
 8001e26:	f7fe fe73 	bl	8000b10 <chThdSleep>
    palSetPad(GPIOA, GPIOA_LED_GREEN);
 8001e2a:	8325      	strh	r5, [r4, #24]
    chThdSleepMilliseconds(500);
 8001e2c:	f241 3088 	movw	r0, #5000	; 0x1388
 8001e30:	f7fe fe6e 	bl	8000b10 <chThdSleep>
  }
 8001e34:	e7f4      	b.n	8001e20 <Thread1+0x10>
 8001e36:	bf00      	nop
 8001e38:	20001040 	.word	0x20001040
 8001e3c:	08002a20 	.word	0x08002a20
 8001e40:	40020000 	.word	0x40020000
 8001e44:	f3af 8000 	nop.w
 8001e48:	f3af 8000 	nop.w
 8001e4c:	f3af 8000 	nop.w

08001e50 <chprintf.constprop.3>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8001e50:	b40e      	push	{r1, r2, r3}
 8001e52:	b500      	push	{lr}
 8001e54:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8001e56:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 8001e58:	461a      	mov	r2, r3
 8001e5a:	4905      	ldr	r1, [pc, #20]	; (8001e70 <chprintf.constprop.3+0x20>)
 8001e5c:	4805      	ldr	r0, [pc, #20]	; (8001e74 <chprintf.constprop.3+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8001e5e:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8001e60:	f7ff fcf6 	bl	8001850 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8001e64:	b002      	add	sp, #8
 8001e66:	f85d eb04 	ldr.w	lr, [sp], #4
 8001e6a:	b003      	add	sp, #12
 8001e6c:	4770      	bx	lr
 8001e6e:	bf00      	nop
 8001e70:	08002a28 	.word	0x08002a28
 8001e74:	2000137c 	.word	0x2000137c
 8001e78:	f3af 8000 	nop.w
 8001e7c:	f3af 8000 	nop.w

08001e80 <Debug_ITMDebugEnable>:
void Debug_ITMDebugEnable(void){
	volatile unsigned int *ITM_TER      = (volatile unsigned int *)0xE0000E00;
	volatile unsigned int *SCB_DHCSR 		= (volatile unsigned int *)0xE000EDF0;
	volatile unsigned int *DBGMCU_CR 		= (volatile unsigned int *)0xE0042004;

	*DBGMCU_CR |= 0x27; // DBGMCU_CR
 8001e80:	4a08      	ldr	r2, [pc, #32]	; (8001ea4 <Debug_ITMDebugEnable+0x24>)

if ((*SCB_DHCSR & 1) && (*ITM_TER & 1)) // Enabled?
 8001e82:	4909      	ldr	r1, [pc, #36]	; (8001ea8 <Debug_ITMDebugEnable+0x28>)
void Debug_ITMDebugEnable(void){
	volatile unsigned int *ITM_TER      = (volatile unsigned int *)0xE0000E00;
	volatile unsigned int *SCB_DHCSR 		= (volatile unsigned int *)0xE000EDF0;
	volatile unsigned int *DBGMCU_CR 		= (volatile unsigned int *)0xE0042004;

	*DBGMCU_CR |= 0x27; // DBGMCU_CR
 8001e84:	6813      	ldr	r3, [r2, #0]
 8001e86:	f043 0327 	orr.w	r3, r3, #39	; 0x27
 8001e8a:	6013      	str	r3, [r2, #0]

if ((*SCB_DHCSR & 1) && (*ITM_TER & 1)) // Enabled?
 8001e8c:	680b      	ldr	r3, [r1, #0]
 8001e8e:	07da      	lsls	r2, r3, #31
 8001e90:	d506      	bpl.n	8001ea0 <Debug_ITMDebugEnable+0x20>
 8001e92:	4b06      	ldr	r3, [pc, #24]	; (8001eac <Debug_ITMDebugEnable+0x2c>)
 8001e94:	681b      	ldr	r3, [r3, #0]
 8001e96:	07db      	lsls	r3, r3, #31
 8001e98:	d502      	bpl.n	8001ea0 <Debug_ITMDebugEnable+0x20>
    Debug_ITMDebug = 1;
 8001e9a:	4b05      	ldr	r3, [pc, #20]	; (8001eb0 <Debug_ITMDebugEnable+0x30>)
 8001e9c:	2201      	movs	r2, #1
 8001e9e:	601a      	str	r2, [r3, #0]
 8001ea0:	4770      	bx	lr
 8001ea2:	bf00      	nop
 8001ea4:	e0042004 	.word	0xe0042004
 8001ea8:	e000edf0 	.word	0xe000edf0
 8001eac:	e0000e00 	.word	0xe0000e00
 8001eb0:	20001378 	.word	0x20001378
 8001eb4:	f3af 8000 	nop.w
 8001eb8:	f3af 8000 	nop.w
 8001ebc:	f3af 8000 	nop.w

08001ec0 <Debug_ITMDebugOutputChar>:

void Debug_ITMDebugOutputChar(char ch){
	static volatile unsigned int *ITM_STIM0 = (volatile unsigned int *)0xE0000000; // ITM Port 0
	static volatile unsigned int *SCB_DEMCR = (volatile unsigned int *)0xE000EDFC;

	if (Debug_ITMDebug && (*SCB_DEMCR & 0x01000000))
 8001ec0:	4b07      	ldr	r3, [pc, #28]	; (8001ee0 <Debug_ITMDebugOutputChar+0x20>)
 8001ec2:	681b      	ldr	r3, [r3, #0]
 8001ec4:	b15b      	cbz	r3, 8001ede <Debug_ITMDebugOutputChar+0x1e>
 8001ec6:	4b07      	ldr	r3, [pc, #28]	; (8001ee4 <Debug_ITMDebugOutputChar+0x24>)
 8001ec8:	681b      	ldr	r3, [r3, #0]
 8001eca:	01db      	lsls	r3, r3, #7
 8001ecc:	d507      	bpl.n	8001ede <Debug_ITMDebugOutputChar+0x1e>
	{
		while(*ITM_STIM0 == 0);
 8001ece:	f04f 4160 	mov.w	r1, #3758096384	; 0xe0000000
 8001ed2:	680b      	ldr	r3, [r1, #0]
 8001ed4:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 8001ed8:	2b00      	cmp	r3, #0
 8001eda:	d0fa      	beq.n	8001ed2 <Debug_ITMDebugOutputChar+0x12>
  	*((volatile char *)ITM_STIM0) = ch;
 8001edc:	7010      	strb	r0, [r2, #0]
 8001ede:	4770      	bx	lr
 8001ee0:	20001378 	.word	0x20001378
 8001ee4:	e000edfc 	.word	0xe000edfc
 8001ee8:	f3af 8000 	nop.w
 8001eec:	f3af 8000 	nop.w

08001ef0 <calloc>:
 8001ef0:	4b02      	ldr	r3, [pc, #8]	; (8001efc <calloc+0xc>)
 8001ef2:	460a      	mov	r2, r1
 8001ef4:	4601      	mov	r1, r0
 8001ef6:	6818      	ldr	r0, [r3, #0]
 8001ef8:	f000 b802 	b.w	8001f00 <_calloc_r>
 8001efc:	20000c28 	.word	0x20000c28

08001f00 <_calloc_r>:
 8001f00:	b510      	push	{r4, lr}
 8001f02:	fb02 f101 	mul.w	r1, r2, r1
 8001f06:	f000 f833 	bl	8001f70 <_malloc_r>
 8001f0a:	4604      	mov	r4, r0
 8001f0c:	b168      	cbz	r0, 8001f2a <_calloc_r+0x2a>
 8001f0e:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8001f12:	f022 0203 	bic.w	r2, r2, #3
 8001f16:	3a04      	subs	r2, #4
 8001f18:	2a24      	cmp	r2, #36	; 0x24
 8001f1a:	d818      	bhi.n	8001f4e <_calloc_r+0x4e>
 8001f1c:	2a13      	cmp	r2, #19
 8001f1e:	d806      	bhi.n	8001f2e <_calloc_r+0x2e>
 8001f20:	4603      	mov	r3, r0
 8001f22:	2200      	movs	r2, #0
 8001f24:	601a      	str	r2, [r3, #0]
 8001f26:	605a      	str	r2, [r3, #4]
 8001f28:	609a      	str	r2, [r3, #8]
 8001f2a:	4620      	mov	r0, r4
 8001f2c:	bd10      	pop	{r4, pc}
 8001f2e:	2300      	movs	r3, #0
 8001f30:	2a1b      	cmp	r2, #27
 8001f32:	6003      	str	r3, [r0, #0]
 8001f34:	6043      	str	r3, [r0, #4]
 8001f36:	d90f      	bls.n	8001f58 <_calloc_r+0x58>
 8001f38:	2a24      	cmp	r2, #36	; 0x24
 8001f3a:	6083      	str	r3, [r0, #8]
 8001f3c:	60c3      	str	r3, [r0, #12]
 8001f3e:	bf05      	ittet	eq
 8001f40:	6103      	streq	r3, [r0, #16]
 8001f42:	6143      	streq	r3, [r0, #20]
 8001f44:	f100 0310 	addne.w	r3, r0, #16
 8001f48:	f100 0318 	addeq.w	r3, r0, #24
 8001f4c:	e7e9      	b.n	8001f22 <_calloc_r+0x22>
 8001f4e:	2100      	movs	r1, #0
 8001f50:	f000 fa9e 	bl	8002490 <memset>
 8001f54:	4620      	mov	r0, r4
 8001f56:	bd10      	pop	{r4, pc}
 8001f58:	f100 0308 	add.w	r3, r0, #8
 8001f5c:	e7e1      	b.n	8001f22 <_calloc_r+0x22>
 8001f5e:	bf00      	nop

08001f60 <free>:
 8001f60:	4b02      	ldr	r3, [pc, #8]	; (8001f6c <free+0xc>)
 8001f62:	4601      	mov	r1, r0
 8001f64:	6818      	ldr	r0, [r3, #0]
 8001f66:	f000 bb43 	b.w	80025f0 <_free_r>
 8001f6a:	bf00      	nop
 8001f6c:	20000c28 	.word	0x20000c28

08001f70 <_malloc_r>:
 8001f70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001f74:	f101 050b 	add.w	r5, r1, #11
 8001f78:	2d16      	cmp	r5, #22
 8001f7a:	b083      	sub	sp, #12
 8001f7c:	4606      	mov	r6, r0
 8001f7e:	d927      	bls.n	8001fd0 <_malloc_r+0x60>
 8001f80:	f035 0507 	bics.w	r5, r5, #7
 8001f84:	f100 80b6 	bmi.w	80020f4 <_malloc_r+0x184>
 8001f88:	42a9      	cmp	r1, r5
 8001f8a:	f200 80b3 	bhi.w	80020f4 <_malloc_r+0x184>
 8001f8e:	f000 facf 	bl	8002530 <__malloc_lock>
 8001f92:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
 8001f96:	d222      	bcs.n	8001fde <_malloc_r+0x6e>
 8001f98:	4fc2      	ldr	r7, [pc, #776]	; (80022a4 <_malloc_r+0x334>)
 8001f9a:	08e8      	lsrs	r0, r5, #3
 8001f9c:	eb07 03c0 	add.w	r3, r7, r0, lsl #3
 8001fa0:	68dc      	ldr	r4, [r3, #12]
 8001fa2:	429c      	cmp	r4, r3
 8001fa4:	f000 81c9 	beq.w	800233a <_malloc_r+0x3ca>
 8001fa8:	6863      	ldr	r3, [r4, #4]
 8001faa:	68e1      	ldr	r1, [r4, #12]
 8001fac:	68a5      	ldr	r5, [r4, #8]
 8001fae:	f023 0303 	bic.w	r3, r3, #3
 8001fb2:	4423      	add	r3, r4
 8001fb4:	4630      	mov	r0, r6
 8001fb6:	685a      	ldr	r2, [r3, #4]
 8001fb8:	60e9      	str	r1, [r5, #12]
 8001fba:	f042 0201 	orr.w	r2, r2, #1
 8001fbe:	608d      	str	r5, [r1, #8]
 8001fc0:	605a      	str	r2, [r3, #4]
 8001fc2:	f000 fabd 	bl	8002540 <__malloc_unlock>
 8001fc6:	3408      	adds	r4, #8
 8001fc8:	4620      	mov	r0, r4
 8001fca:	b003      	add	sp, #12
 8001fcc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001fd0:	2910      	cmp	r1, #16
 8001fd2:	f200 808f 	bhi.w	80020f4 <_malloc_r+0x184>
 8001fd6:	f000 faab 	bl	8002530 <__malloc_lock>
 8001fda:	2510      	movs	r5, #16
 8001fdc:	e7dc      	b.n	8001f98 <_malloc_r+0x28>
 8001fde:	0a68      	lsrs	r0, r5, #9
 8001fe0:	f000 808f 	beq.w	8002102 <_malloc_r+0x192>
 8001fe4:	2804      	cmp	r0, #4
 8001fe6:	f200 8154 	bhi.w	8002292 <_malloc_r+0x322>
 8001fea:	09a8      	lsrs	r0, r5, #6
 8001fec:	3038      	adds	r0, #56	; 0x38
 8001fee:	0041      	lsls	r1, r0, #1
 8001ff0:	4fac      	ldr	r7, [pc, #688]	; (80022a4 <_malloc_r+0x334>)
 8001ff2:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 8001ff6:	68cc      	ldr	r4, [r1, #12]
 8001ff8:	42a1      	cmp	r1, r4
 8001ffa:	d106      	bne.n	800200a <_malloc_r+0x9a>
 8001ffc:	e00c      	b.n	8002018 <_malloc_r+0xa8>
 8001ffe:	2a00      	cmp	r2, #0
 8002000:	f280 8082 	bge.w	8002108 <_malloc_r+0x198>
 8002004:	68e4      	ldr	r4, [r4, #12]
 8002006:	42a1      	cmp	r1, r4
 8002008:	d006      	beq.n	8002018 <_malloc_r+0xa8>
 800200a:	6863      	ldr	r3, [r4, #4]
 800200c:	f023 0303 	bic.w	r3, r3, #3
 8002010:	1b5a      	subs	r2, r3, r5
 8002012:	2a0f      	cmp	r2, #15
 8002014:	ddf3      	ble.n	8001ffe <_malloc_r+0x8e>
 8002016:	3801      	subs	r0, #1
 8002018:	3001      	adds	r0, #1
 800201a:	49a2      	ldr	r1, [pc, #648]	; (80022a4 <_malloc_r+0x334>)
 800201c:	693c      	ldr	r4, [r7, #16]
 800201e:	f101 0e08 	add.w	lr, r1, #8
 8002022:	4574      	cmp	r4, lr
 8002024:	f000 817e 	beq.w	8002324 <_malloc_r+0x3b4>
 8002028:	6863      	ldr	r3, [r4, #4]
 800202a:	f023 0303 	bic.w	r3, r3, #3
 800202e:	1b5a      	subs	r2, r3, r5
 8002030:	2a0f      	cmp	r2, #15
 8002032:	f300 8164 	bgt.w	80022fe <_malloc_r+0x38e>
 8002036:	2a00      	cmp	r2, #0
 8002038:	f8c1 e014 	str.w	lr, [r1, #20]
 800203c:	f8c1 e010 	str.w	lr, [r1, #16]
 8002040:	da73      	bge.n	800212a <_malloc_r+0x1ba>
 8002042:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8002046:	f080 8139 	bcs.w	80022bc <_malloc_r+0x34c>
 800204a:	08db      	lsrs	r3, r3, #3
 800204c:	eb01 08c3 	add.w	r8, r1, r3, lsl #3
 8002050:	ea4f 0ca3 	mov.w	ip, r3, asr #2
 8002054:	684a      	ldr	r2, [r1, #4]
 8002056:	f8d8 9008 	ldr.w	r9, [r8, #8]
 800205a:	f8c4 9008 	str.w	r9, [r4, #8]
 800205e:	2301      	movs	r3, #1
 8002060:	fa03 f30c 	lsl.w	r3, r3, ip
 8002064:	4313      	orrs	r3, r2
 8002066:	f8c4 800c 	str.w	r8, [r4, #12]
 800206a:	604b      	str	r3, [r1, #4]
 800206c:	f8c8 4008 	str.w	r4, [r8, #8]
 8002070:	f8c9 400c 	str.w	r4, [r9, #12]
 8002074:	1082      	asrs	r2, r0, #2
 8002076:	2401      	movs	r4, #1
 8002078:	4094      	lsls	r4, r2
 800207a:	429c      	cmp	r4, r3
 800207c:	d862      	bhi.n	8002144 <_malloc_r+0x1d4>
 800207e:	4223      	tst	r3, r4
 8002080:	d106      	bne.n	8002090 <_malloc_r+0x120>
 8002082:	f020 0003 	bic.w	r0, r0, #3
 8002086:	0064      	lsls	r4, r4, #1
 8002088:	4223      	tst	r3, r4
 800208a:	f100 0004 	add.w	r0, r0, #4
 800208e:	d0fa      	beq.n	8002086 <_malloc_r+0x116>
 8002090:	eb07 08c0 	add.w	r8, r7, r0, lsl #3
 8002094:	46c4      	mov	ip, r8
 8002096:	4681      	mov	r9, r0
 8002098:	f8dc 300c 	ldr.w	r3, [ip, #12]
 800209c:	459c      	cmp	ip, r3
 800209e:	d107      	bne.n	80020b0 <_malloc_r+0x140>
 80020a0:	e142      	b.n	8002328 <_malloc_r+0x3b8>
 80020a2:	2900      	cmp	r1, #0
 80020a4:	f280 8152 	bge.w	800234c <_malloc_r+0x3dc>
 80020a8:	68db      	ldr	r3, [r3, #12]
 80020aa:	459c      	cmp	ip, r3
 80020ac:	f000 813c 	beq.w	8002328 <_malloc_r+0x3b8>
 80020b0:	685a      	ldr	r2, [r3, #4]
 80020b2:	f022 0203 	bic.w	r2, r2, #3
 80020b6:	1b51      	subs	r1, r2, r5
 80020b8:	290f      	cmp	r1, #15
 80020ba:	ddf2      	ble.n	80020a2 <_malloc_r+0x132>
 80020bc:	461c      	mov	r4, r3
 80020be:	f8d3 c00c 	ldr.w	ip, [r3, #12]
 80020c2:	f854 8f08 	ldr.w	r8, [r4, #8]!
 80020c6:	195a      	adds	r2, r3, r5
 80020c8:	f045 0901 	orr.w	r9, r5, #1
 80020cc:	f041 0501 	orr.w	r5, r1, #1
 80020d0:	f8c3 9004 	str.w	r9, [r3, #4]
 80020d4:	4630      	mov	r0, r6
 80020d6:	f8c8 c00c 	str.w	ip, [r8, #12]
 80020da:	f8cc 8008 	str.w	r8, [ip, #8]
 80020de:	617a      	str	r2, [r7, #20]
 80020e0:	613a      	str	r2, [r7, #16]
 80020e2:	f8c2 e00c 	str.w	lr, [r2, #12]
 80020e6:	f8c2 e008 	str.w	lr, [r2, #8]
 80020ea:	6055      	str	r5, [r2, #4]
 80020ec:	5051      	str	r1, [r2, r1]
 80020ee:	f000 fa27 	bl	8002540 <__malloc_unlock>
 80020f2:	e769      	b.n	8001fc8 <_malloc_r+0x58>
 80020f4:	2400      	movs	r4, #0
 80020f6:	230c      	movs	r3, #12
 80020f8:	4620      	mov	r0, r4
 80020fa:	6033      	str	r3, [r6, #0]
 80020fc:	b003      	add	sp, #12
 80020fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002102:	217e      	movs	r1, #126	; 0x7e
 8002104:	203f      	movs	r0, #63	; 0x3f
 8002106:	e773      	b.n	8001ff0 <_malloc_r+0x80>
 8002108:	4423      	add	r3, r4
 800210a:	68e1      	ldr	r1, [r4, #12]
 800210c:	685a      	ldr	r2, [r3, #4]
 800210e:	68a5      	ldr	r5, [r4, #8]
 8002110:	f042 0201 	orr.w	r2, r2, #1
 8002114:	60e9      	str	r1, [r5, #12]
 8002116:	4630      	mov	r0, r6
 8002118:	608d      	str	r5, [r1, #8]
 800211a:	605a      	str	r2, [r3, #4]
 800211c:	f000 fa10 	bl	8002540 <__malloc_unlock>
 8002120:	3408      	adds	r4, #8
 8002122:	4620      	mov	r0, r4
 8002124:	b003      	add	sp, #12
 8002126:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800212a:	4423      	add	r3, r4
 800212c:	4630      	mov	r0, r6
 800212e:	685a      	ldr	r2, [r3, #4]
 8002130:	f042 0201 	orr.w	r2, r2, #1
 8002134:	605a      	str	r2, [r3, #4]
 8002136:	f000 fa03 	bl	8002540 <__malloc_unlock>
 800213a:	3408      	adds	r4, #8
 800213c:	4620      	mov	r0, r4
 800213e:	b003      	add	sp, #12
 8002140:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002144:	68bc      	ldr	r4, [r7, #8]
 8002146:	6863      	ldr	r3, [r4, #4]
 8002148:	f023 0803 	bic.w	r8, r3, #3
 800214c:	4545      	cmp	r5, r8
 800214e:	d804      	bhi.n	800215a <_malloc_r+0x1ea>
 8002150:	ebc5 0308 	rsb	r3, r5, r8
 8002154:	2b0f      	cmp	r3, #15
 8002156:	f300 808c 	bgt.w	8002272 <_malloc_r+0x302>
 800215a:	4b53      	ldr	r3, [pc, #332]	; (80022a8 <_malloc_r+0x338>)
 800215c:	f8df a158 	ldr.w	sl, [pc, #344]	; 80022b8 <_malloc_r+0x348>
 8002160:	681a      	ldr	r2, [r3, #0]
 8002162:	f8da 3000 	ldr.w	r3, [sl]
 8002166:	3301      	adds	r3, #1
 8002168:	442a      	add	r2, r5
 800216a:	eb04 0b08 	add.w	fp, r4, r8
 800216e:	f000 8150 	beq.w	8002412 <_malloc_r+0x4a2>
 8002172:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8002176:	320f      	adds	r2, #15
 8002178:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 800217c:	f022 020f 	bic.w	r2, r2, #15
 8002180:	4611      	mov	r1, r2
 8002182:	4630      	mov	r0, r6
 8002184:	9201      	str	r2, [sp, #4]
 8002186:	f7ff fb2b 	bl	80017e0 <_sbrk_r>
 800218a:	f1b0 3fff 	cmp.w	r0, #4294967295
 800218e:	4681      	mov	r9, r0
 8002190:	9a01      	ldr	r2, [sp, #4]
 8002192:	f000 80f5 	beq.w	8002380 <_malloc_r+0x410>
 8002196:	4583      	cmp	fp, r0
 8002198:	f200 80ef 	bhi.w	800237a <_malloc_r+0x40a>
 800219c:	4b43      	ldr	r3, [pc, #268]	; (80022ac <_malloc_r+0x33c>)
 800219e:	6819      	ldr	r1, [r3, #0]
 80021a0:	45cb      	cmp	fp, r9
 80021a2:	4411      	add	r1, r2
 80021a4:	6019      	str	r1, [r3, #0]
 80021a6:	f000 813d 	beq.w	8002424 <_malloc_r+0x4b4>
 80021aa:	f8da 0000 	ldr.w	r0, [sl]
 80021ae:	f8df e108 	ldr.w	lr, [pc, #264]	; 80022b8 <_malloc_r+0x348>
 80021b2:	3001      	adds	r0, #1
 80021b4:	bf1b      	ittet	ne
 80021b6:	ebcb 0b09 	rsbne	fp, fp, r9
 80021ba:	4459      	addne	r1, fp
 80021bc:	f8ce 9000 	streq.w	r9, [lr]
 80021c0:	6019      	strne	r1, [r3, #0]
 80021c2:	f019 0107 	ands.w	r1, r9, #7
 80021c6:	f000 8107 	beq.w	80023d8 <_malloc_r+0x468>
 80021ca:	f1c1 0008 	rsb	r0, r1, #8
 80021ce:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
 80021d2:	4481      	add	r9, r0
 80021d4:	3108      	adds	r1, #8
 80021d6:	444a      	add	r2, r9
 80021d8:	f3c2 020b 	ubfx	r2, r2, #0, #12
 80021dc:	ebc2 0a01 	rsb	sl, r2, r1
 80021e0:	4651      	mov	r1, sl
 80021e2:	4630      	mov	r0, r6
 80021e4:	9301      	str	r3, [sp, #4]
 80021e6:	f7ff fafb 	bl	80017e0 <_sbrk_r>
 80021ea:	1c43      	adds	r3, r0, #1
 80021ec:	9b01      	ldr	r3, [sp, #4]
 80021ee:	f000 8127 	beq.w	8002440 <_malloc_r+0x4d0>
 80021f2:	ebc9 0200 	rsb	r2, r9, r0
 80021f6:	4452      	add	r2, sl
 80021f8:	f042 0201 	orr.w	r2, r2, #1
 80021fc:	6819      	ldr	r1, [r3, #0]
 80021fe:	f8c7 9008 	str.w	r9, [r7, #8]
 8002202:	4451      	add	r1, sl
 8002204:	42bc      	cmp	r4, r7
 8002206:	f8c9 2004 	str.w	r2, [r9, #4]
 800220a:	6019      	str	r1, [r3, #0]
 800220c:	f8df a09c 	ldr.w	sl, [pc, #156]	; 80022ac <_malloc_r+0x33c>
 8002210:	d016      	beq.n	8002240 <_malloc_r+0x2d0>
 8002212:	f1b8 0f0f 	cmp.w	r8, #15
 8002216:	f240 80e2 	bls.w	80023de <_malloc_r+0x46e>
 800221a:	6862      	ldr	r2, [r4, #4]
 800221c:	f1a8 030c 	sub.w	r3, r8, #12
 8002220:	f023 0307 	bic.w	r3, r3, #7
 8002224:	18e0      	adds	r0, r4, r3
 8002226:	f002 0201 	and.w	r2, r2, #1
 800222a:	f04f 0e05 	mov.w	lr, #5
 800222e:	431a      	orrs	r2, r3
 8002230:	2b0f      	cmp	r3, #15
 8002232:	6062      	str	r2, [r4, #4]
 8002234:	f8c0 e004 	str.w	lr, [r0, #4]
 8002238:	f8c0 e008 	str.w	lr, [r0, #8]
 800223c:	f200 8104 	bhi.w	8002448 <_malloc_r+0x4d8>
 8002240:	4b1b      	ldr	r3, [pc, #108]	; (80022b0 <_malloc_r+0x340>)
 8002242:	68bc      	ldr	r4, [r7, #8]
 8002244:	681a      	ldr	r2, [r3, #0]
 8002246:	4291      	cmp	r1, r2
 8002248:	bf88      	it	hi
 800224a:	6019      	strhi	r1, [r3, #0]
 800224c:	4b19      	ldr	r3, [pc, #100]	; (80022b4 <_malloc_r+0x344>)
 800224e:	681a      	ldr	r2, [r3, #0]
 8002250:	4291      	cmp	r1, r2
 8002252:	6862      	ldr	r2, [r4, #4]
 8002254:	bf88      	it	hi
 8002256:	6019      	strhi	r1, [r3, #0]
 8002258:	f022 0203 	bic.w	r2, r2, #3
 800225c:	4295      	cmp	r5, r2
 800225e:	eba2 0305 	sub.w	r3, r2, r5
 8002262:	d801      	bhi.n	8002268 <_malloc_r+0x2f8>
 8002264:	2b0f      	cmp	r3, #15
 8002266:	dc04      	bgt.n	8002272 <_malloc_r+0x302>
 8002268:	4630      	mov	r0, r6
 800226a:	f000 f969 	bl	8002540 <__malloc_unlock>
 800226e:	2400      	movs	r4, #0
 8002270:	e6aa      	b.n	8001fc8 <_malloc_r+0x58>
 8002272:	1962      	adds	r2, r4, r5
 8002274:	f043 0301 	orr.w	r3, r3, #1
 8002278:	f045 0501 	orr.w	r5, r5, #1
 800227c:	6065      	str	r5, [r4, #4]
 800227e:	4630      	mov	r0, r6
 8002280:	60ba      	str	r2, [r7, #8]
 8002282:	6053      	str	r3, [r2, #4]
 8002284:	f000 f95c 	bl	8002540 <__malloc_unlock>
 8002288:	3408      	adds	r4, #8
 800228a:	4620      	mov	r0, r4
 800228c:	b003      	add	sp, #12
 800228e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002292:	2814      	cmp	r0, #20
 8002294:	d969      	bls.n	800236a <_malloc_r+0x3fa>
 8002296:	2854      	cmp	r0, #84	; 0x54
 8002298:	f200 8097 	bhi.w	80023ca <_malloc_r+0x45a>
 800229c:	0b28      	lsrs	r0, r5, #12
 800229e:	306e      	adds	r0, #110	; 0x6e
 80022a0:	0041      	lsls	r1, r0, #1
 80022a2:	e6a5      	b.n	8001ff0 <_malloc_r+0x80>
 80022a4:	20000c2c 	.word	0x20000c2c
 80022a8:	20001388 	.word	0x20001388
 80022ac:	2000138c 	.word	0x2000138c
 80022b0:	20001384 	.word	0x20001384
 80022b4:	20001380 	.word	0x20001380
 80022b8:	20001038 	.word	0x20001038
 80022bc:	0a5a      	lsrs	r2, r3, #9
 80022be:	2a04      	cmp	r2, #4
 80022c0:	d956      	bls.n	8002370 <_malloc_r+0x400>
 80022c2:	2a14      	cmp	r2, #20
 80022c4:	f200 80a7 	bhi.w	8002416 <_malloc_r+0x4a6>
 80022c8:	325b      	adds	r2, #91	; 0x5b
 80022ca:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 80022ce:	eb07 0c8c 	add.w	ip, r7, ip, lsl #2
 80022d2:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 8002488 <_malloc_r+0x518>
 80022d6:	f8dc 1008 	ldr.w	r1, [ip, #8]
 80022da:	4561      	cmp	r1, ip
 80022dc:	f000 8085 	beq.w	80023ea <_malloc_r+0x47a>
 80022e0:	684a      	ldr	r2, [r1, #4]
 80022e2:	f022 0203 	bic.w	r2, r2, #3
 80022e6:	4293      	cmp	r3, r2
 80022e8:	d202      	bcs.n	80022f0 <_malloc_r+0x380>
 80022ea:	6889      	ldr	r1, [r1, #8]
 80022ec:	458c      	cmp	ip, r1
 80022ee:	d1f7      	bne.n	80022e0 <_malloc_r+0x370>
 80022f0:	68ca      	ldr	r2, [r1, #12]
 80022f2:	687b      	ldr	r3, [r7, #4]
 80022f4:	60e2      	str	r2, [r4, #12]
 80022f6:	60a1      	str	r1, [r4, #8]
 80022f8:	6094      	str	r4, [r2, #8]
 80022fa:	60cc      	str	r4, [r1, #12]
 80022fc:	e6ba      	b.n	8002074 <_malloc_r+0x104>
 80022fe:	1963      	adds	r3, r4, r5
 8002300:	f042 0701 	orr.w	r7, r2, #1
 8002304:	f045 0501 	orr.w	r5, r5, #1
 8002308:	6065      	str	r5, [r4, #4]
 800230a:	4630      	mov	r0, r6
 800230c:	614b      	str	r3, [r1, #20]
 800230e:	610b      	str	r3, [r1, #16]
 8002310:	f8c3 e00c 	str.w	lr, [r3, #12]
 8002314:	f8c3 e008 	str.w	lr, [r3, #8]
 8002318:	605f      	str	r7, [r3, #4]
 800231a:	509a      	str	r2, [r3, r2]
 800231c:	3408      	adds	r4, #8
 800231e:	f000 f90f 	bl	8002540 <__malloc_unlock>
 8002322:	e651      	b.n	8001fc8 <_malloc_r+0x58>
 8002324:	684b      	ldr	r3, [r1, #4]
 8002326:	e6a5      	b.n	8002074 <_malloc_r+0x104>
 8002328:	f109 0901 	add.w	r9, r9, #1
 800232c:	f019 0f03 	tst.w	r9, #3
 8002330:	f10c 0c08 	add.w	ip, ip, #8
 8002334:	f47f aeb0 	bne.w	8002098 <_malloc_r+0x128>
 8002338:	e02b      	b.n	8002392 <_malloc_r+0x422>
 800233a:	f104 0308 	add.w	r3, r4, #8
 800233e:	6964      	ldr	r4, [r4, #20]
 8002340:	42a3      	cmp	r3, r4
 8002342:	bf08      	it	eq
 8002344:	3002      	addeq	r0, #2
 8002346:	f43f ae68 	beq.w	800201a <_malloc_r+0xaa>
 800234a:	e62d      	b.n	8001fa8 <_malloc_r+0x38>
 800234c:	441a      	add	r2, r3
 800234e:	461c      	mov	r4, r3
 8002350:	6851      	ldr	r1, [r2, #4]
 8002352:	68db      	ldr	r3, [r3, #12]
 8002354:	f854 5f08 	ldr.w	r5, [r4, #8]!
 8002358:	f041 0101 	orr.w	r1, r1, #1
 800235c:	6051      	str	r1, [r2, #4]
 800235e:	4630      	mov	r0, r6
 8002360:	60eb      	str	r3, [r5, #12]
 8002362:	609d      	str	r5, [r3, #8]
 8002364:	f000 f8ec 	bl	8002540 <__malloc_unlock>
 8002368:	e62e      	b.n	8001fc8 <_malloc_r+0x58>
 800236a:	305b      	adds	r0, #91	; 0x5b
 800236c:	0041      	lsls	r1, r0, #1
 800236e:	e63f      	b.n	8001ff0 <_malloc_r+0x80>
 8002370:	099a      	lsrs	r2, r3, #6
 8002372:	3238      	adds	r2, #56	; 0x38
 8002374:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 8002378:	e7a9      	b.n	80022ce <_malloc_r+0x35e>
 800237a:	42bc      	cmp	r4, r7
 800237c:	f43f af0e 	beq.w	800219c <_malloc_r+0x22c>
 8002380:	68bc      	ldr	r4, [r7, #8]
 8002382:	6862      	ldr	r2, [r4, #4]
 8002384:	f022 0203 	bic.w	r2, r2, #3
 8002388:	e768      	b.n	800225c <_malloc_r+0x2ec>
 800238a:	f8d8 8000 	ldr.w	r8, [r8]
 800238e:	4598      	cmp	r8, r3
 8002390:	d177      	bne.n	8002482 <_malloc_r+0x512>
 8002392:	f010 0f03 	tst.w	r0, #3
 8002396:	f1a8 0308 	sub.w	r3, r8, #8
 800239a:	f100 30ff 	add.w	r0, r0, #4294967295
 800239e:	d1f4      	bne.n	800238a <_malloc_r+0x41a>
 80023a0:	687b      	ldr	r3, [r7, #4]
 80023a2:	ea23 0304 	bic.w	r3, r3, r4
 80023a6:	607b      	str	r3, [r7, #4]
 80023a8:	0064      	lsls	r4, r4, #1
 80023aa:	429c      	cmp	r4, r3
 80023ac:	f63f aeca 	bhi.w	8002144 <_malloc_r+0x1d4>
 80023b0:	2c00      	cmp	r4, #0
 80023b2:	f43f aec7 	beq.w	8002144 <_malloc_r+0x1d4>
 80023b6:	4223      	tst	r3, r4
 80023b8:	4648      	mov	r0, r9
 80023ba:	f47f ae69 	bne.w	8002090 <_malloc_r+0x120>
 80023be:	0064      	lsls	r4, r4, #1
 80023c0:	4223      	tst	r3, r4
 80023c2:	f100 0004 	add.w	r0, r0, #4
 80023c6:	d0fa      	beq.n	80023be <_malloc_r+0x44e>
 80023c8:	e662      	b.n	8002090 <_malloc_r+0x120>
 80023ca:	f5b0 7faa 	cmp.w	r0, #340	; 0x154
 80023ce:	d818      	bhi.n	8002402 <_malloc_r+0x492>
 80023d0:	0be8      	lsrs	r0, r5, #15
 80023d2:	3077      	adds	r0, #119	; 0x77
 80023d4:	0041      	lsls	r1, r0, #1
 80023d6:	e60b      	b.n	8001ff0 <_malloc_r+0x80>
 80023d8:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80023dc:	e6fb      	b.n	80021d6 <_malloc_r+0x266>
 80023de:	2301      	movs	r3, #1
 80023e0:	f8c9 3004 	str.w	r3, [r9, #4]
 80023e4:	464c      	mov	r4, r9
 80023e6:	2200      	movs	r2, #0
 80023e8:	e738      	b.n	800225c <_malloc_r+0x2ec>
 80023ea:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80023ee:	1092      	asrs	r2, r2, #2
 80023f0:	f04f 0c01 	mov.w	ip, #1
 80023f4:	fa0c f202 	lsl.w	r2, ip, r2
 80023f8:	4313      	orrs	r3, r2
 80023fa:	f8c8 3004 	str.w	r3, [r8, #4]
 80023fe:	460a      	mov	r2, r1
 8002400:	e778      	b.n	80022f4 <_malloc_r+0x384>
 8002402:	f240 5354 	movw	r3, #1364	; 0x554
 8002406:	4298      	cmp	r0, r3
 8002408:	d817      	bhi.n	800243a <_malloc_r+0x4ca>
 800240a:	0ca8      	lsrs	r0, r5, #18
 800240c:	307c      	adds	r0, #124	; 0x7c
 800240e:	0041      	lsls	r1, r0, #1
 8002410:	e5ee      	b.n	8001ff0 <_malloc_r+0x80>
 8002412:	3210      	adds	r2, #16
 8002414:	e6b4      	b.n	8002180 <_malloc_r+0x210>
 8002416:	2a54      	cmp	r2, #84	; 0x54
 8002418:	d81e      	bhi.n	8002458 <_malloc_r+0x4e8>
 800241a:	0b1a      	lsrs	r2, r3, #12
 800241c:	326e      	adds	r2, #110	; 0x6e
 800241e:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 8002422:	e754      	b.n	80022ce <_malloc_r+0x35e>
 8002424:	f3cb 000b 	ubfx	r0, fp, #0, #12
 8002428:	2800      	cmp	r0, #0
 800242a:	f47f aebe 	bne.w	80021aa <_malloc_r+0x23a>
 800242e:	4442      	add	r2, r8
 8002430:	68bb      	ldr	r3, [r7, #8]
 8002432:	f042 0201 	orr.w	r2, r2, #1
 8002436:	605a      	str	r2, [r3, #4]
 8002438:	e702      	b.n	8002240 <_malloc_r+0x2d0>
 800243a:	21fc      	movs	r1, #252	; 0xfc
 800243c:	207e      	movs	r0, #126	; 0x7e
 800243e:	e5d7      	b.n	8001ff0 <_malloc_r+0x80>
 8002440:	2201      	movs	r2, #1
 8002442:	f04f 0a00 	mov.w	sl, #0
 8002446:	e6d9      	b.n	80021fc <_malloc_r+0x28c>
 8002448:	f104 0108 	add.w	r1, r4, #8
 800244c:	4630      	mov	r0, r6
 800244e:	f000 f8cf 	bl	80025f0 <_free_r>
 8002452:	f8da 1000 	ldr.w	r1, [sl]
 8002456:	e6f3      	b.n	8002240 <_malloc_r+0x2d0>
 8002458:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 800245c:	d804      	bhi.n	8002468 <_malloc_r+0x4f8>
 800245e:	0bda      	lsrs	r2, r3, #15
 8002460:	3277      	adds	r2, #119	; 0x77
 8002462:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 8002466:	e732      	b.n	80022ce <_malloc_r+0x35e>
 8002468:	f240 5154 	movw	r1, #1364	; 0x554
 800246c:	428a      	cmp	r2, r1
 800246e:	d804      	bhi.n	800247a <_malloc_r+0x50a>
 8002470:	0c9a      	lsrs	r2, r3, #18
 8002472:	327c      	adds	r2, #124	; 0x7c
 8002474:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 8002478:	e729      	b.n	80022ce <_malloc_r+0x35e>
 800247a:	f04f 0cfc 	mov.w	ip, #252	; 0xfc
 800247e:	227e      	movs	r2, #126	; 0x7e
 8002480:	e725      	b.n	80022ce <_malloc_r+0x35e>
 8002482:	687b      	ldr	r3, [r7, #4]
 8002484:	e790      	b.n	80023a8 <_malloc_r+0x438>
 8002486:	bf00      	nop
 8002488:	20000c2c 	.word	0x20000c2c
 800248c:	00000000 	.word	0x00000000

08002490 <memset>:
 8002490:	b470      	push	{r4, r5, r6}
 8002492:	0784      	lsls	r4, r0, #30
 8002494:	d046      	beq.n	8002524 <memset+0x94>
 8002496:	1e54      	subs	r4, r2, #1
 8002498:	2a00      	cmp	r2, #0
 800249a:	d041      	beq.n	8002520 <memset+0x90>
 800249c:	b2cd      	uxtb	r5, r1
 800249e:	4603      	mov	r3, r0
 80024a0:	e002      	b.n	80024a8 <memset+0x18>
 80024a2:	1e62      	subs	r2, r4, #1
 80024a4:	b3e4      	cbz	r4, 8002520 <memset+0x90>
 80024a6:	4614      	mov	r4, r2
 80024a8:	f803 5b01 	strb.w	r5, [r3], #1
 80024ac:	079a      	lsls	r2, r3, #30
 80024ae:	d1f8      	bne.n	80024a2 <memset+0x12>
 80024b0:	2c03      	cmp	r4, #3
 80024b2:	d92e      	bls.n	8002512 <memset+0x82>
 80024b4:	b2cd      	uxtb	r5, r1
 80024b6:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 80024ba:	2c0f      	cmp	r4, #15
 80024bc:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 80024c0:	d919      	bls.n	80024f6 <memset+0x66>
 80024c2:	f103 0210 	add.w	r2, r3, #16
 80024c6:	4626      	mov	r6, r4
 80024c8:	3e10      	subs	r6, #16
 80024ca:	2e0f      	cmp	r6, #15
 80024cc:	f842 5c10 	str.w	r5, [r2, #-16]
 80024d0:	f842 5c0c 	str.w	r5, [r2, #-12]
 80024d4:	f842 5c08 	str.w	r5, [r2, #-8]
 80024d8:	f842 5c04 	str.w	r5, [r2, #-4]
 80024dc:	f102 0210 	add.w	r2, r2, #16
 80024e0:	d8f2      	bhi.n	80024c8 <memset+0x38>
 80024e2:	f1a4 0210 	sub.w	r2, r4, #16
 80024e6:	f022 020f 	bic.w	r2, r2, #15
 80024ea:	f004 040f 	and.w	r4, r4, #15
 80024ee:	3210      	adds	r2, #16
 80024f0:	2c03      	cmp	r4, #3
 80024f2:	4413      	add	r3, r2
 80024f4:	d90d      	bls.n	8002512 <memset+0x82>
 80024f6:	461e      	mov	r6, r3
 80024f8:	4622      	mov	r2, r4
 80024fa:	3a04      	subs	r2, #4
 80024fc:	2a03      	cmp	r2, #3
 80024fe:	f846 5b04 	str.w	r5, [r6], #4
 8002502:	d8fa      	bhi.n	80024fa <memset+0x6a>
 8002504:	1f22      	subs	r2, r4, #4
 8002506:	f022 0203 	bic.w	r2, r2, #3
 800250a:	3204      	adds	r2, #4
 800250c:	4413      	add	r3, r2
 800250e:	f004 0403 	and.w	r4, r4, #3
 8002512:	b12c      	cbz	r4, 8002520 <memset+0x90>
 8002514:	b2c9      	uxtb	r1, r1
 8002516:	441c      	add	r4, r3
 8002518:	f803 1b01 	strb.w	r1, [r3], #1
 800251c:	42a3      	cmp	r3, r4
 800251e:	d1fb      	bne.n	8002518 <memset+0x88>
 8002520:	bc70      	pop	{r4, r5, r6}
 8002522:	4770      	bx	lr
 8002524:	4614      	mov	r4, r2
 8002526:	4603      	mov	r3, r0
 8002528:	e7c2      	b.n	80024b0 <memset+0x20>
 800252a:	bf00      	nop
 800252c:	0000      	movs	r0, r0
	...

08002530 <__malloc_lock>:
 8002530:	4770      	bx	lr
 8002532:	bf00      	nop
	...

08002540 <__malloc_unlock>:
 8002540:	4770      	bx	lr
 8002542:	bf00      	nop
	...

08002550 <_malloc_trim_r>:
 8002550:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002552:	4f23      	ldr	r7, [pc, #140]	; (80025e0 <_malloc_trim_r+0x90>)
 8002554:	460c      	mov	r4, r1
 8002556:	4606      	mov	r6, r0
 8002558:	f7ff ffea 	bl	8002530 <__malloc_lock>
 800255c:	68bb      	ldr	r3, [r7, #8]
 800255e:	685d      	ldr	r5, [r3, #4]
 8002560:	f025 0503 	bic.w	r5, r5, #3
 8002564:	1b29      	subs	r1, r5, r4
 8002566:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
 800256a:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
 800256e:	f021 010f 	bic.w	r1, r1, #15
 8002572:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
 8002576:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 800257a:	db07      	blt.n	800258c <_malloc_trim_r+0x3c>
 800257c:	4630      	mov	r0, r6
 800257e:	2100      	movs	r1, #0
 8002580:	f7ff f92e 	bl	80017e0 <_sbrk_r>
 8002584:	68bb      	ldr	r3, [r7, #8]
 8002586:	442b      	add	r3, r5
 8002588:	4298      	cmp	r0, r3
 800258a:	d004      	beq.n	8002596 <_malloc_trim_r+0x46>
 800258c:	4630      	mov	r0, r6
 800258e:	f7ff ffd7 	bl	8002540 <__malloc_unlock>
 8002592:	2000      	movs	r0, #0
 8002594:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002596:	4630      	mov	r0, r6
 8002598:	4261      	negs	r1, r4
 800259a:	f7ff f921 	bl	80017e0 <_sbrk_r>
 800259e:	3001      	adds	r0, #1
 80025a0:	d00d      	beq.n	80025be <_malloc_trim_r+0x6e>
 80025a2:	4b10      	ldr	r3, [pc, #64]	; (80025e4 <_malloc_trim_r+0x94>)
 80025a4:	68ba      	ldr	r2, [r7, #8]
 80025a6:	6819      	ldr	r1, [r3, #0]
 80025a8:	1b2d      	subs	r5, r5, r4
 80025aa:	f045 0501 	orr.w	r5, r5, #1
 80025ae:	4630      	mov	r0, r6
 80025b0:	1b09      	subs	r1, r1, r4
 80025b2:	6055      	str	r5, [r2, #4]
 80025b4:	6019      	str	r1, [r3, #0]
 80025b6:	f7ff ffc3 	bl	8002540 <__malloc_unlock>
 80025ba:	2001      	movs	r0, #1
 80025bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80025be:	4630      	mov	r0, r6
 80025c0:	2100      	movs	r1, #0
 80025c2:	f7ff f90d 	bl	80017e0 <_sbrk_r>
 80025c6:	68ba      	ldr	r2, [r7, #8]
 80025c8:	1a83      	subs	r3, r0, r2
 80025ca:	2b0f      	cmp	r3, #15
 80025cc:	ddde      	ble.n	800258c <_malloc_trim_r+0x3c>
 80025ce:	4c06      	ldr	r4, [pc, #24]	; (80025e8 <_malloc_trim_r+0x98>)
 80025d0:	4904      	ldr	r1, [pc, #16]	; (80025e4 <_malloc_trim_r+0x94>)
 80025d2:	6824      	ldr	r4, [r4, #0]
 80025d4:	f043 0301 	orr.w	r3, r3, #1
 80025d8:	1b00      	subs	r0, r0, r4
 80025da:	6053      	str	r3, [r2, #4]
 80025dc:	6008      	str	r0, [r1, #0]
 80025de:	e7d5      	b.n	800258c <_malloc_trim_r+0x3c>
 80025e0:	20000c2c 	.word	0x20000c2c
 80025e4:	2000138c 	.word	0x2000138c
 80025e8:	20001038 	.word	0x20001038
 80025ec:	00000000 	.word	0x00000000

080025f0 <_free_r>:
 80025f0:	2900      	cmp	r1, #0
 80025f2:	d04e      	beq.n	8002692 <_free_r+0xa2>
 80025f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80025f8:	460c      	mov	r4, r1
 80025fa:	4680      	mov	r8, r0
 80025fc:	f7ff ff98 	bl	8002530 <__malloc_lock>
 8002600:	f854 7c04 	ldr.w	r7, [r4, #-4]
 8002604:	4962      	ldr	r1, [pc, #392]	; (8002790 <_free_r+0x1a0>)
 8002606:	f027 0201 	bic.w	r2, r7, #1
 800260a:	f1a4 0508 	sub.w	r5, r4, #8
 800260e:	18ab      	adds	r3, r5, r2
 8002610:	688e      	ldr	r6, [r1, #8]
 8002612:	6858      	ldr	r0, [r3, #4]
 8002614:	429e      	cmp	r6, r3
 8002616:	f020 0003 	bic.w	r0, r0, #3
 800261a:	d05a      	beq.n	80026d2 <_free_r+0xe2>
 800261c:	07fe      	lsls	r6, r7, #31
 800261e:	6058      	str	r0, [r3, #4]
 8002620:	d40b      	bmi.n	800263a <_free_r+0x4a>
 8002622:	f854 7c08 	ldr.w	r7, [r4, #-8]
 8002626:	1bed      	subs	r5, r5, r7
 8002628:	f101 0e08 	add.w	lr, r1, #8
 800262c:	68ac      	ldr	r4, [r5, #8]
 800262e:	4574      	cmp	r4, lr
 8002630:	443a      	add	r2, r7
 8002632:	d067      	beq.n	8002704 <_free_r+0x114>
 8002634:	68ef      	ldr	r7, [r5, #12]
 8002636:	60e7      	str	r7, [r4, #12]
 8002638:	60bc      	str	r4, [r7, #8]
 800263a:	181c      	adds	r4, r3, r0
 800263c:	6864      	ldr	r4, [r4, #4]
 800263e:	07e4      	lsls	r4, r4, #31
 8002640:	d40c      	bmi.n	800265c <_free_r+0x6c>
 8002642:	4f54      	ldr	r7, [pc, #336]	; (8002794 <_free_r+0x1a4>)
 8002644:	689c      	ldr	r4, [r3, #8]
 8002646:	42bc      	cmp	r4, r7
 8002648:	4402      	add	r2, r0
 800264a:	d07c      	beq.n	8002746 <_free_r+0x156>
 800264c:	68d8      	ldr	r0, [r3, #12]
 800264e:	60e0      	str	r0, [r4, #12]
 8002650:	f042 0301 	orr.w	r3, r2, #1
 8002654:	6084      	str	r4, [r0, #8]
 8002656:	606b      	str	r3, [r5, #4]
 8002658:	50aa      	str	r2, [r5, r2]
 800265a:	e003      	b.n	8002664 <_free_r+0x74>
 800265c:	f042 0301 	orr.w	r3, r2, #1
 8002660:	606b      	str	r3, [r5, #4]
 8002662:	50aa      	str	r2, [r5, r2]
 8002664:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8002668:	d214      	bcs.n	8002694 <_free_r+0xa4>
 800266a:	08d2      	lsrs	r2, r2, #3
 800266c:	eb01 03c2 	add.w	r3, r1, r2, lsl #3
 8002670:	6848      	ldr	r0, [r1, #4]
 8002672:	689f      	ldr	r7, [r3, #8]
 8002674:	60af      	str	r7, [r5, #8]
 8002676:	1092      	asrs	r2, r2, #2
 8002678:	2401      	movs	r4, #1
 800267a:	fa04 f202 	lsl.w	r2, r4, r2
 800267e:	4310      	orrs	r0, r2
 8002680:	60eb      	str	r3, [r5, #12]
 8002682:	6048      	str	r0, [r1, #4]
 8002684:	609d      	str	r5, [r3, #8]
 8002686:	60fd      	str	r5, [r7, #12]
 8002688:	4640      	mov	r0, r8
 800268a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800268e:	f7ff bf57 	b.w	8002540 <__malloc_unlock>
 8002692:	4770      	bx	lr
 8002694:	0a53      	lsrs	r3, r2, #9
 8002696:	2b04      	cmp	r3, #4
 8002698:	d847      	bhi.n	800272a <_free_r+0x13a>
 800269a:	0993      	lsrs	r3, r2, #6
 800269c:	f103 0438 	add.w	r4, r3, #56	; 0x38
 80026a0:	0060      	lsls	r0, r4, #1
 80026a2:	eb01 0080 	add.w	r0, r1, r0, lsl #2
 80026a6:	493a      	ldr	r1, [pc, #232]	; (8002790 <_free_r+0x1a0>)
 80026a8:	6883      	ldr	r3, [r0, #8]
 80026aa:	4283      	cmp	r3, r0
 80026ac:	d043      	beq.n	8002736 <_free_r+0x146>
 80026ae:	6859      	ldr	r1, [r3, #4]
 80026b0:	f021 0103 	bic.w	r1, r1, #3
 80026b4:	4291      	cmp	r1, r2
 80026b6:	d902      	bls.n	80026be <_free_r+0xce>
 80026b8:	689b      	ldr	r3, [r3, #8]
 80026ba:	4298      	cmp	r0, r3
 80026bc:	d1f7      	bne.n	80026ae <_free_r+0xbe>
 80026be:	68da      	ldr	r2, [r3, #12]
 80026c0:	60ea      	str	r2, [r5, #12]
 80026c2:	60ab      	str	r3, [r5, #8]
 80026c4:	4640      	mov	r0, r8
 80026c6:	6095      	str	r5, [r2, #8]
 80026c8:	60dd      	str	r5, [r3, #12]
 80026ca:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80026ce:	f7ff bf37 	b.w	8002540 <__malloc_unlock>
 80026d2:	07ff      	lsls	r7, r7, #31
 80026d4:	4402      	add	r2, r0
 80026d6:	d407      	bmi.n	80026e8 <_free_r+0xf8>
 80026d8:	f854 3c08 	ldr.w	r3, [r4, #-8]
 80026dc:	1aed      	subs	r5, r5, r3
 80026de:	441a      	add	r2, r3
 80026e0:	68a8      	ldr	r0, [r5, #8]
 80026e2:	68eb      	ldr	r3, [r5, #12]
 80026e4:	60c3      	str	r3, [r0, #12]
 80026e6:	6098      	str	r0, [r3, #8]
 80026e8:	4b2b      	ldr	r3, [pc, #172]	; (8002798 <_free_r+0x1a8>)
 80026ea:	681b      	ldr	r3, [r3, #0]
 80026ec:	f042 0001 	orr.w	r0, r2, #1
 80026f0:	429a      	cmp	r2, r3
 80026f2:	6068      	str	r0, [r5, #4]
 80026f4:	608d      	str	r5, [r1, #8]
 80026f6:	d3c7      	bcc.n	8002688 <_free_r+0x98>
 80026f8:	4b28      	ldr	r3, [pc, #160]	; (800279c <_free_r+0x1ac>)
 80026fa:	4640      	mov	r0, r8
 80026fc:	6819      	ldr	r1, [r3, #0]
 80026fe:	f7ff ff27 	bl	8002550 <_malloc_trim_r>
 8002702:	e7c1      	b.n	8002688 <_free_r+0x98>
 8002704:	1819      	adds	r1, r3, r0
 8002706:	6849      	ldr	r1, [r1, #4]
 8002708:	07c9      	lsls	r1, r1, #31
 800270a:	d409      	bmi.n	8002720 <_free_r+0x130>
 800270c:	68d9      	ldr	r1, [r3, #12]
 800270e:	689b      	ldr	r3, [r3, #8]
 8002710:	4402      	add	r2, r0
 8002712:	f042 0001 	orr.w	r0, r2, #1
 8002716:	60d9      	str	r1, [r3, #12]
 8002718:	608b      	str	r3, [r1, #8]
 800271a:	6068      	str	r0, [r5, #4]
 800271c:	50aa      	str	r2, [r5, r2]
 800271e:	e7b3      	b.n	8002688 <_free_r+0x98>
 8002720:	f042 0301 	orr.w	r3, r2, #1
 8002724:	606b      	str	r3, [r5, #4]
 8002726:	50aa      	str	r2, [r5, r2]
 8002728:	e7ae      	b.n	8002688 <_free_r+0x98>
 800272a:	2b14      	cmp	r3, #20
 800272c:	d814      	bhi.n	8002758 <_free_r+0x168>
 800272e:	f103 045b 	add.w	r4, r3, #91	; 0x5b
 8002732:	0060      	lsls	r0, r4, #1
 8002734:	e7b5      	b.n	80026a2 <_free_r+0xb2>
 8002736:	684a      	ldr	r2, [r1, #4]
 8002738:	10a4      	asrs	r4, r4, #2
 800273a:	2001      	movs	r0, #1
 800273c:	40a0      	lsls	r0, r4
 800273e:	4302      	orrs	r2, r0
 8002740:	604a      	str	r2, [r1, #4]
 8002742:	461a      	mov	r2, r3
 8002744:	e7bc      	b.n	80026c0 <_free_r+0xd0>
 8002746:	f042 0301 	orr.w	r3, r2, #1
 800274a:	614d      	str	r5, [r1, #20]
 800274c:	610d      	str	r5, [r1, #16]
 800274e:	60ec      	str	r4, [r5, #12]
 8002750:	60ac      	str	r4, [r5, #8]
 8002752:	606b      	str	r3, [r5, #4]
 8002754:	50aa      	str	r2, [r5, r2]
 8002756:	e797      	b.n	8002688 <_free_r+0x98>
 8002758:	2b54      	cmp	r3, #84	; 0x54
 800275a:	d804      	bhi.n	8002766 <_free_r+0x176>
 800275c:	0b13      	lsrs	r3, r2, #12
 800275e:	f103 046e 	add.w	r4, r3, #110	; 0x6e
 8002762:	0060      	lsls	r0, r4, #1
 8002764:	e79d      	b.n	80026a2 <_free_r+0xb2>
 8002766:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 800276a:	d804      	bhi.n	8002776 <_free_r+0x186>
 800276c:	0bd3      	lsrs	r3, r2, #15
 800276e:	f103 0477 	add.w	r4, r3, #119	; 0x77
 8002772:	0060      	lsls	r0, r4, #1
 8002774:	e795      	b.n	80026a2 <_free_r+0xb2>
 8002776:	f240 5054 	movw	r0, #1364	; 0x554
 800277a:	4283      	cmp	r3, r0
 800277c:	d804      	bhi.n	8002788 <_free_r+0x198>
 800277e:	0c93      	lsrs	r3, r2, #18
 8002780:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8002784:	0060      	lsls	r0, r4, #1
 8002786:	e78c      	b.n	80026a2 <_free_r+0xb2>
 8002788:	20fc      	movs	r0, #252	; 0xfc
 800278a:	247e      	movs	r4, #126	; 0x7e
 800278c:	e789      	b.n	80026a2 <_free_r+0xb2>
 800278e:	bf00      	nop
 8002790:	20000c2c 	.word	0x20000c2c
 8002794:	20000c34 	.word	0x20000c34
 8002798:	20001034 	.word	0x20001034
 800279c:	20001388 	.word	0x20001388
 80027a0:	656c6469 	.word	0x656c6469
	...

080027b0 <ch_debug>:
 80027b0:	6e69616d 18001600 08440404 1814100c     main......D.....
 80027c0:	1e1d1c00 00000000 00000000 00000000     ................
 80027d0:	65486863 6c417061 3a636f6c 0a732520     chHeapAlloc: %s.
 80027e0:	00000000 6f6d656d 61207972 67696c6c     ....memory allig
 80027f0:	0000006e 6f6d656d 61207972 67696c6c     n...memory allig
 8002800:	0064656e 4f4c5f48 00004b43 4f4c5f48     ned.H_LOCK..H_LO
 8002810:	64204b43 00656e6f 3e2d7071 2e752e68     CK done.qp->h.u.
 8002820:	7478656e 6925203a 0000000a 4e555f48     next: %i....H_UN
 8002830:	4b434f4c 00000000 4e555f48 4b434f4c     LOCK....H_UNLOCK
 8002840:	6e6f6420 00000065 00000000 00000000      done...........
 8002850:	000a7325 5f6c6168 5f646c6c 74696e69     %s..hal_lld_init
 8002860:	00000000 496c6170 0074696e 00000000     ....palInit.....

08002870 <vmt>:
 8002870:	08001271 08001251 080012b1 08001291     q...Q...........
 8002880:	080012a1 08001281 08001261 08001241     ........a...A...

08002890 <pal_default_config>:
 8002890:	2a8004a0 00000000 fffffbaf 64155105     ...*.........Q.d
 80028a0:	0000ffdf 00007700 000aa000 00000080     .....w..........
 80028b0:	00000000 ffffffff 55555555 0000ffff     ........UUUU....
	...
 80028d0:	ffffffff 51555555 0000ffff 00000000     ....UUUQ........
	...
 80028ec:	ffffffff 55555555 0000ffff 00000000     ....UUUU........
	...
 8002908:	ffffffff 00000045 0000ffff 00000000     ....E...........
	...
 8002924:	ffffffff 00000000 0000ffff 00000000     ................
	...
 8002940:	6c756e28 0000296c 00000000 00000000     (null)..........

08002950 <vmt>:
 8002950:	08001b91 08001b71 08001b81 08001b61     ....q.......a...
 8002960:	7473696c 6c653e2d 6e656d65 203a7374     list->elements: 
 8002970:	000a6925 7473696c 75633e2d 6e657272     %i..list->curren
 8002980:	25203a74 00000a69 61642e65 203a6174     t: %i...e.data: 
 8002990:	000a6925 7473696c 6c653e2d 6e656d65     %i..list->elemen
 80029a0:	6c5b7374 2d747369 7275633e 746e6572     ts[list->current
 80029b0:	25203a5d 00000a69 6e697270 696c2074     ]: %i...print li
 80029c0:	3e2d7473 72727563 3a746e65 0a692520     st->current: %i.
 80029d0:	00000000 6e697270 696c2074 3e2d7473     ....print list->
 80029e0:	6d656c65 73746e65 5d64255b 6925203a     elements[%d]: %i
 80029f0:	0000000a 6e697270 2e652074 61746164     ....print e.data
 8002a00:	6925203a 0000000a 6e697270 2d652074     : %i....print e-
 8002a10:	7461643e 25203a61 00002069 00000000     >data: %i ......
 8002a20:	6e696c62 0072656b 00007325 20565753     blinker.%s..SWV 
 8002a30:	62616e45 0a64656c 00000000 62696843     Enabled.....Chib
 8002a40:	20534f69 302e3356 0000000a 00000000     iOS V3.0........
 8002a50:	00000043                                C...

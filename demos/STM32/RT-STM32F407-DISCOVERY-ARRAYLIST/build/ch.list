
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c0 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 80001c0:	b500      	push	{lr}
 80001c2:	b083      	sub	sp, #12
  /* Enable TRACE debug -----------------------------------------------*/
  Debug_ITMDebugEnable();
 80001c4:	f002 fadc 	bl	8002780 <Debug_ITMDebugEnable>
}

//****************************************************************************

void Debug_ITMDebugOutputString(char *Buffer){
	if (Debug_ITMDebug)
 80001c8:	4b1a      	ldr	r3, [pc, #104]	; (8000234 <__fini_array_end+0x74>)
 80001ca:	681b      	ldr	r3, [r3, #0]
 80001cc:	bb4b      	cbnz	r3, 8000222 <main+0x62>
int main(void) {
  /* Enable TRACE debug -----------------------------------------------*/
  Debug_ITMDebugEnable();
  Debug_ITMDebugOutputString("SWV Enabled\n");
  
  itmObjectInit(&itm_port);
 80001ce:	481a      	ldr	r0, [pc, #104]	; (8000238 <__fini_array_end+0x78>)
 80001d0:	f002 f9f6 	bl	80025c0 <itmObjectInit>
  //sdStart(&SD2, NULL);

  /*
   * Creates the blinker thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 80001d4:	2400      	movs	r4, #0
  Debug_ITMDebugEnable();
  Debug_ITMDebugOutputString("SWV Enabled\n");
  
  itmObjectInit(&itm_port);

  chprintf((BaseSequentialStream *)&itm_port, "%s", "ChibiOS V3.0\n");
 80001d6:	4919      	ldr	r1, [pc, #100]	; (800023c <__fini_array_end+0x7c>)
 80001d8:	4a19      	ldr	r2, [pc, #100]	; (8000240 <__fini_array_end+0x80>)
 80001da:	4817      	ldr	r0, [pc, #92]	; (8000238 <__fini_array_end+0x78>)
 80001dc:	f002 fa98 	bl	8002710 <chprintf.constprop.3>
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 80001e0:	f001 f9a6 	bl	8001530 <halInit>
  chSysInit();
 80001e4:	f000 f93c 	bl	8000460 <chSysInit>
  //sdStart(&SD2, NULL);

  /*
   * Creates the blinker thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 80001e8:	4b16      	ldr	r3, [pc, #88]	; (8000244 <__fini_array_end+0x84>)
 80001ea:	9400      	str	r4, [sp, #0]
 80001ec:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80001f0:	2240      	movs	r2, #64	; 0x40
 80001f2:	4815      	ldr	r0, [pc, #84]	; (8000248 <__fini_array_end+0x88>)
 80001f4:	f000 fdf4 	bl	8000de0 <chThdCreateStatic>
  
  /*
   * Creates the Producer thread.
   */
  chThdCreateStatic(wa_producer, sizeof(wa_producer), NORMALPRIO, producer_thread, NULL);
 80001f8:	4b14      	ldr	r3, [pc, #80]	; (800024c <__fini_array_end+0x8c>)
 80001fa:	9400      	str	r4, [sp, #0]
 80001fc:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8000200:	2240      	movs	r2, #64	; 0x40
 8000202:	4813      	ldr	r0, [pc, #76]	; (8000250 <__fini_array_end+0x90>)
 8000204:	f000 fdec 	bl	8000de0 <chThdCreateStatic>
  
  /*
   * Creates the Consumer thread.
   */
  chThdCreateStatic(wa_consumer, sizeof(wa_consumer), NORMALPRIO, consumer_thread, NULL);
 8000208:	9400      	str	r4, [sp, #0]
 800020a:	4812      	ldr	r0, [pc, #72]	; (8000254 <__fini_array_end+0x94>)
 800020c:	4b12      	ldr	r3, [pc, #72]	; (8000258 <__fini_array_end+0x98>)
 800020e:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8000212:	2240      	movs	r2, #64	; 0x40
 8000214:	f000 fde4 	bl	8000de0 <chThdCreateStatic>
   * sleeping in a loop and check the button state.
   */
  while (TRUE) {
    //if (!palReadPad(GPIOC, GPIOC_BUTTON))
      //TestThread(&SD2);
    chThdSleepMilliseconds(500);
 8000218:	f241 3088 	movw	r0, #5000	; 0x1388
 800021c:	f000 fe28 	bl	8000e70 <chThdSleep>
  }
 8000220:	e7fa      	b.n	8000218 <main+0x58>
}

//****************************************************************************

void Debug_ITMDebugOutputString(char *Buffer){
	if (Debug_ITMDebug)
 8000222:	4c0e      	ldr	r4, [pc, #56]	; (800025c <__fini_array_end+0x9c>)
 8000224:	2053      	movs	r0, #83	; 0x53
		while(*Buffer)
			Debug_ITMDebugOutputChar(*Buffer++);
 8000226:	f002 facb 	bl	80027c0 <Debug_ITMDebugOutputChar>

//****************************************************************************

void Debug_ITMDebugOutputString(char *Buffer){
	if (Debug_ITMDebug)
		while(*Buffer)
 800022a:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 800022e:	2800      	cmp	r0, #0
 8000230:	d1f9      	bne.n	8000226 <main+0x66>
 8000232:	e7cc      	b.n	80001ce <main+0xe>
 8000234:	20001210 	.word	0x20001210
 8000238:	20001214 	.word	0x20001214
 800023c:	08002c60 	.word	0x08002c60
 8000240:	08002c64 	.word	0x08002c64
 8000244:	080026a1 	.word	0x080026a1
 8000248:	200010a8 	.word	0x200010a8
 800024c:	080026e1 	.word	0x080026e1
 8000250:	20000f40 	.word	0x20000f40
 8000254:	20001218 	.word	0x20001218
 8000258:	08002741 	.word	0x08002741
 800025c:	08002c50 	.word	0x08002c50

08000260 <_port_switch>:
 8000260:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000264:	f8c1 d00c 	str.w	sp, [r1, #12]
 8000268:	f8d0 d00c 	ldr.w	sp, [r0, #12]
 800026c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000270 <_port_thread_start>:
 8000270:	f000 f9be 	bl	80005f0 <_dbg_check_unlock>
 8000274:	f000 fb44 	bl	8000900 <_stats_stop_measure_crit_thd>
 8000278:	2300      	movs	r3, #0
 800027a:	f383 8811 	msr	BASEPRI, r3
 800027e:	4628      	mov	r0, r5
 8000280:	47a0      	blx	r4
 8000282:	f000 fe4d 	bl	8000f20 <chThdExit>

08000286 <_port_switch_from_isr>:
 8000286:	f000 fb33 	bl	80008f0 <_stats_start_measure_crit_thd>
 800028a:	f000 f9a1 	bl	80005d0 <_dbg_check_lock>
 800028e:	f000 fc9f 	bl	8000bd0 <chSchDoReschedule>
 8000292:	f000 f9ad 	bl	80005f0 <_dbg_check_unlock>
 8000296:	f000 fb33 	bl	8000900 <_stats_stop_measure_crit_thd>

0800029a <_port_exit_from_isr>:
 800029a:	df00      	svc	0
 800029c:	e7fe      	b.n	800029c <_port_exit_from_isr+0x2>
	...

080002a0 <__late_init>:
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void __late_init(void) {}
 80002a0:	4770      	bx	lr
 80002a2:	bf00      	nop
 80002a4:	f3af 8000 	nop.w
 80002a8:	f3af 8000 	nop.w
 80002ac:	f3af 8000 	nop.w

080002b0 <_default_exit>:
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
void _default_exit(void) {
  while (1)
    ;
 80002b0:	e7fe      	b.n	80002b0 <_default_exit>
 80002b2:	bf00      	nop
 80002b4:	f3af 8000 	nop.w
 80002b8:	f3af 8000 	nop.w
 80002bc:	f3af 8000 	nop.w

080002c0 <Reset_Handler>:
  uint32_t psp, reg;

  /* Process Stack initialization, it is allocated starting from the
     symbol __process_stack_end__ and its lower limit is the symbol
     __process_stack_base__.*/
  asm volatile ("cpsid   i");
 80002c0:	b672      	cpsid	i
  psp = SYMVAL(__process_stack_end__);
 80002c2:	4c31      	ldr	r4, [pc, #196]	; (8000388 <Reset_Handler+0xc8>)
  asm volatile ("msr     PSP, %0" : : "r" (psp));
 80002c4:	f384 8809 	msr	PSP, r4
  reg = CRT0_CONTROL_INIT | 4;
#else
  /* CPU mode initialization.*/
  reg = CRT0_CONTROL_INIT;
#endif
  asm volatile ("msr     CONTROL, %0" : : "r" (reg));
 80002c8:	2302      	movs	r3, #2
 80002ca:	f383 8814 	msr	CONTROL, r3
  asm volatile ("isb");
 80002ce:	f3bf 8f6f 	isb	sy

  /* Early initialization hook invocation.*/
  __early_init();
 80002d2:	f001 ff8d 	bl	80021f0 <__early_init>

#if CRT0_INIT_STACKS
  /* Main and Process stacks initialization.*/
  fill32(&__main_stack_base__,
 80002d6:	4b2d      	ldr	r3, [pc, #180]	; (800038c <Reset_Handler+0xcc>)
 80002d8:	4a2d      	ldr	r2, [pc, #180]	; (8000390 <Reset_Handler+0xd0>)
 80002da:	4293      	cmp	r3, r2
 80002dc:	d20b      	bcs.n	80002f6 <Reset_Handler+0x36>
 80002de:	43d9      	mvns	r1, r3
 80002e0:	440a      	add	r2, r1
 80002e2:	f022 0203 	bic.w	r2, r2, #3
 80002e6:	3204      	adds	r2, #4
 80002e8:	441a      	add	r2, r3
 80002ea:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 80002ee:	f843 1b04 	str.w	r1, [r3], #4
 80002f2:	4293      	cmp	r3, r2
 80002f4:	d1fb      	bne.n	80002ee <Reset_Handler+0x2e>
         &__main_stack_end__,
         CRT0_STACKS_FILL_PATTERN);
  fill32(&__process_stack_base__,
 80002f6:	4b27      	ldr	r3, [pc, #156]	; (8000394 <Reset_Handler+0xd4>)
 80002f8:	42a3      	cmp	r3, r4
 80002fa:	d20c      	bcs.n	8000316 <Reset_Handler+0x56>
 80002fc:	4a26      	ldr	r2, [pc, #152]	; (8000398 <Reset_Handler+0xd8>)
 80002fe:	1d19      	adds	r1, r3, #4
 8000300:	1a52      	subs	r2, r2, r1
 8000302:	f022 0203 	bic.w	r2, r2, #3
 8000306:	3204      	adds	r2, #4
 8000308:	441a      	add	r2, r3
 800030a:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 800030e:	f843 1b04 	str.w	r1, [r3], #4
 8000312:	4293      	cmp	r3, r2
 8000314:	d1fb      	bne.n	800030e <Reset_Handler+0x4e>
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 8000316:	4a21      	ldr	r2, [pc, #132]	; (800039c <Reset_Handler+0xdc>)
 8000318:	4b21      	ldr	r3, [pc, #132]	; (80003a0 <Reset_Handler+0xe0>)
 800031a:	429a      	cmp	r2, r3
 800031c:	d20c      	bcs.n	8000338 <Reset_Handler+0x78>
 800031e:	43d0      	mvns	r0, r2
 8000320:	4418      	add	r0, r3
 8000322:	f020 0003 	bic.w	r0, r0, #3
 8000326:	4b1f      	ldr	r3, [pc, #124]	; (80003a4 <Reset_Handler+0xe4>)
 8000328:	3004      	adds	r0, #4
 800032a:	4418      	add	r0, r3
      *dp++ = *tp++;
 800032c:	f853 1b04 	ldr.w	r1, [r3], #4
 8000330:	f842 1b04 	str.w	r1, [r2], #4
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 8000334:	4283      	cmp	r3, r0
 8000336:	d1f9      	bne.n	800032c <Reset_Handler+0x6c>
  }
#endif

#if CRT0_INIT_BSS
  /* BSS segment initialization.*/
  fill32(&_bss_start, &_bss_end, 0);
 8000338:	4b1b      	ldr	r3, [pc, #108]	; (80003a8 <Reset_Handler+0xe8>)
 800033a:	4a1c      	ldr	r2, [pc, #112]	; (80003ac <Reset_Handler+0xec>)
 800033c:	4293      	cmp	r3, r2
 800033e:	d20a      	bcs.n	8000356 <Reset_Handler+0x96>
 8000340:	43d9      	mvns	r1, r3
 8000342:	440a      	add	r2, r1
 8000344:	f022 0203 	bic.w	r2, r2, #3
 8000348:	3204      	adds	r2, #4
 800034a:	441a      	add	r2, r3
 800034c:	2100      	movs	r1, #0
 800034e:	f843 1b04 	str.w	r1, [r3], #4
 8000352:	4293      	cmp	r3, r2
 8000354:	d1fb      	bne.n	800034e <Reset_Handler+0x8e>

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
    while (fpp < &__init_array_end) {
 8000356:	4d16      	ldr	r5, [pc, #88]	; (80003b0 <Reset_Handler+0xf0>)
 8000358:	4c16      	ldr	r4, [pc, #88]	; (80003b4 <Reset_Handler+0xf4>)
  /* BSS segment initialization.*/
  fill32(&_bss_start, &_bss_end, 0);
#endif

  /* Late initialization hook invocation.*/
  __late_init();
 800035a:	f7ff ffa1 	bl	80002a0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
    while (fpp < &__init_array_end) {
 800035e:	42ac      	cmp	r4, r5
 8000360:	d204      	bcs.n	800036c <Reset_Handler+0xac>
      (*fpp)();
 8000362:	f854 3b04 	ldr.w	r3, [r4], #4
 8000366:	4798      	blx	r3

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
    while (fpp < &__init_array_end) {
 8000368:	42ac      	cmp	r4, r5
 800036a:	d3fa      	bcc.n	8000362 <Reset_Handler+0xa2>

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
    while (fpp < &__fini_array_end) {
 800036c:	4d12      	ldr	r5, [pc, #72]	; (80003b8 <Reset_Handler+0xf8>)
 800036e:	4c13      	ldr	r4, [pc, #76]	; (80003bc <Reset_Handler+0xfc>)
    }
  }
#endif

  /* Invoking application main() function.*/
  main();
 8000370:	f7ff ff26 	bl	80001c0 <main>

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
    while (fpp < &__fini_array_end) {
 8000374:	42ac      	cmp	r4, r5
 8000376:	d204      	bcs.n	8000382 <Reset_Handler+0xc2>
      (*fpp)();
 8000378:	f854 3b04 	ldr.w	r3, [r4], #4
 800037c:	4798      	blx	r3

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
    while (fpp < &__fini_array_end) {
 800037e:	42ac      	cmp	r4, r5
 8000380:	d3fa      	bcc.n	8000378 <Reset_Handler+0xb8>
    }
  }
#endif

  /* Invoking the exit handler.*/
  _default_exit();
 8000382:	f7ff ff95 	bl	80002b0 <_default_exit>
 8000386:	bf00      	nop
 8000388:	20000800 	.word	0x20000800
 800038c:	20000000 	.word	0x20000000
 8000390:	20000400 	.word	0x20000400
 8000394:	20000400 	.word	0x20000400
 8000398:	20000803 	.word	0x20000803
 800039c:	20000800 	.word	0x20000800
 80003a0:	20000800 	.word	0x20000800
 80003a4:	08002c78 	.word	0x08002c78
 80003a8:	20000800 	.word	0x20000800
 80003ac:	20001380 	.word	0x20001380
 80003b0:	080001c0 	.word	0x080001c0
 80003b4:	080001c0 	.word	0x080001c0
 80003b8:	080001c0 	.word	0x080001c0
 80003bc:	080001c0 	.word	0x080001c0

080003c0 <_unhandled_exception>:
 * @notapi
 */
void _unhandled_exception(void) {

  while (true)
    ;
 80003c0:	e7fe      	b.n	80003c0 <_unhandled_exception>
 80003c2:	bf00      	nop
 80003c4:	f3af 8000 	nop.w
 80003c8:	f3af 8000 	nop.w
 80003cc:	f3af 8000 	nop.w

080003d0 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80003d0:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 80003d4:	3320      	adds	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80003d6:	f383 8809 	msr	PSP, r3

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80003da:	2300      	movs	r3, #0
 80003dc:	f383 8811 	msr	BASEPRI, r3
 80003e0:	4770      	bx	lr
 80003e2:	bf00      	nop
 80003e4:	f3af 8000 	nop.w
 80003e8:	f3af 8000 	nop.w
 80003ec:	f3af 8000 	nop.w

080003f0 <_port_irq_epilogue>:
 80003f0:	2320      	movs	r3, #32
 80003f2:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0) {
 80003f6:	4b0f      	ldr	r3, [pc, #60]	; (8000434 <_port_irq_epilogue+0x44>)
 80003f8:	685b      	ldr	r3, [r3, #4]
 80003fa:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 80003fe:	d102      	bne.n	8000406 <_port_irq_epilogue+0x16>
 8000400:	f383 8811 	msr	BASEPRI, r3
 8000404:	4770      	bx	lr
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8000406:	b510      	push	{r4, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000408:	f3ef 8409 	mrs	r4, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800040c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8000410:	f844 3c04 	str.w	r3, [r4, #-4]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8000414:	f1a4 0320 	sub.w	r3, r4, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000418:	f383 8809 	msr	PSP, r3
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800041c:	f000 fb90 	bl	8000b40 <chSchIsPreemptionRequired>
 8000420:	b118      	cbz	r0, 800042a <_port_irq_epilogue+0x3a>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8000422:	4b05      	ldr	r3, [pc, #20]	; (8000438 <_port_irq_epilogue+0x48>)
 8000424:	f844 3c08 	str.w	r3, [r4, #-8]
 8000428:	bd10      	pop	{r4, pc}
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 800042a:	4b04      	ldr	r3, [pc, #16]	; (800043c <_port_irq_epilogue+0x4c>)
 800042c:	f844 3c08 	str.w	r3, [r4, #-8]
 8000430:	bd10      	pop	{r4, pc}
 8000432:	bf00      	nop
 8000434:	e000ed00 	.word	0xe000ed00
 8000438:	08000287 	.word	0x08000287
 800043c:	0800029a 	.word	0x0800029a

08000440 <_idle_thread>:
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {

  (void)p;
  chRegSetThreadName("idle");
 8000440:	4b02      	ldr	r3, [pc, #8]	; (800044c <_idle_thread+0xc>)
 8000442:	4a03      	ldr	r2, [pc, #12]	; (8000450 <_idle_thread+0x10>)
 8000444:	699b      	ldr	r3, [r3, #24]
 8000446:	619a      	str	r2, [r3, #24]
 8000448:	e7fe      	b.n	8000448 <_idle_thread+0x8>
 800044a:	bf00      	nop
 800044c:	20000800 	.word	0x20000800
 8000450:	080027f0 	.word	0x080027f0
 8000454:	f3af 8000 	nop.w
 8000458:	f3af 8000 	nop.w
 800045c:	f3af 8000 	nop.w

08000460 <chSysInit>:
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8000460:	4b23      	ldr	r3, [pc, #140]	; (80004f0 <chSysInit+0x90>)
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
 8000462:	4a24      	ldr	r2, [pc, #144]	; (80004f4 <chSysInit+0x94>)
  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8000464:	4824      	ldr	r0, [pc, #144]	; (80004f8 <chSysInit+0x98>)
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8000466:	b5f0      	push	{r4, r5, r6, r7, lr}
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8000468:	2400      	movs	r4, #0
 800046a:	609c      	str	r4, [r3, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800046c:	68df      	ldr	r7, [r3, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800046e:	4e23      	ldr	r6, [pc, #140]	; (80004fc <chSysInit+0x9c>)
  _dbg_trace_init();
#endif

#if !CH_CFG_NO_IDLE_THREAD
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8000470:	4d23      	ldr	r5, [pc, #140]	; (8000500 <chSysInit+0xa0>)
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 8000472:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 8000476:	4039      	ands	r1, r7
  reg_value  =  (reg_value                                 |
 8000478:	430a      	orrs	r2, r1
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800047a:	60da      	str	r2, [r3, #12]
 800047c:	68f2      	ldr	r2, [r6, #12]
 800047e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000482:	60f2      	str	r2, [r6, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8000484:	6802      	ldr	r2, [r0, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8000486:	2120      	movs	r1, #32
 8000488:	f042 0201 	orr.w	r2, r2, #1
 800048c:	2610      	movs	r6, #16
 800048e:	6002      	str	r2, [r0, #0]
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8000490:	b083      	sub	sp, #12
 8000492:	77de      	strb	r6, [r3, #31]
 8000494:	f883 1022 	strb.w	r1, [r3, #34]	; 0x22
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
  _scheduler_init();
 8000498:	f000 fa4a 	bl	8000930 <_scheduler_init>
  _vt_init();
 800049c:	f000 fba0 	bl	8000be0 <_vt_init>
#if CH_CFG_USE_TM
  _tm_init();
 80004a0:	f000 f9a6 	bl	80007f0 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE
  _core_init();
 80004a4:	f000 ffc4 	bl	8001430 <_core_init>
#endif
#if CH_CFG_USE_HEAP
  _heap_init();
 80004a8:	f001 f81a 	bl	80014e0 <_heap_init>
#endif
#if CH_DBG_STATISTICS
  _stats_init();
 80004ac:	f000 f9e0 	bl	8000870 <_stats_init>
#endif
#if CH_DBG_ENABLE_TRACE
  _dbg_trace_init();
 80004b0:	f000 f936 	bl	8000720 <_dbg_trace_init>
#endif

#if !CH_CFG_NO_IDLE_THREAD
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80004b4:	2140      	movs	r1, #64	; 0x40
 80004b6:	4628      	mov	r0, r5
 80004b8:	f000 fc32 	bl	8000d20 <_thread_init>
 80004bc:	f5a5 6788 	sub.w	r7, r5, #1088	; 0x440

  currp->p_state = CH_STATE_CURRENT;
#if CH_DBG_ENABLE_STACK_CHECK
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
 80004c0:	4b10      	ldr	r3, [pc, #64]	; (8000504 <chSysInit+0xa4>)
 80004c2:	61c3      	str	r3, [r0, #28]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 80004c4:	2601      	movs	r6, #1
 80004c6:	f880 6020 	strb.w	r6, [r0, #32]
  _dbg_trace_init();
#endif

#if !CH_CFG_NO_IDLE_THREAD
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80004ca:	61b8      	str	r0, [r7, #24]
 *
 * @special
 */
static inline void chSysEnable(void) {

  _dbg_check_enable();
 80004cc:	f000 f870 	bl	80005b0 <_dbg_check_enable>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80004d0:	f384 8811 	msr	BASEPRI, r4
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80004d4:	b662      	cpsie	i
#endif
  chSysEnable();

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 80004d6:	69bb      	ldr	r3, [r7, #24]
 80004d8:	4a0b      	ldr	r2, [pc, #44]	; (8000508 <chSysInit+0xa8>)
 80004da:	619a      	str	r2, [r3, #24]

#if !CH_CFG_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(ch.idle_thread_wa, sizeof(ch.idle_thread_wa), IDLEPRIO,
 80004dc:	f105 00a0 	add.w	r0, r5, #160	; 0xa0
 80004e0:	4632      	mov	r2, r6
 80004e2:	9400      	str	r4, [sp, #0]
 80004e4:	21f8      	movs	r1, #248	; 0xf8
 80004e6:	4b09      	ldr	r3, [pc, #36]	; (800050c <chSysInit+0xac>)
 80004e8:	f000 fc7a 	bl	8000de0 <chThdCreateStatic>
                    (tfunc_t)_idle_thread, NULL);
#endif
}
 80004ec:	b003      	add	sp, #12
 80004ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80004f0:	e000ed00 	.word	0xe000ed00
 80004f4:	05fa0300 	.word	0x05fa0300
 80004f8:	e0001000 	.word	0xe0001000
 80004fc:	e000edf0 	.word	0xe000edf0
 8000500:	20000c40 	.word	0x20000c40
 8000504:	20000400 	.word	0x20000400
 8000508:	08002900 	.word	0x08002900
 800050c:	08000441 	.word	0x08000441

08000510 <chSysHalt>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000510:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8000512:	4b01      	ldr	r3, [pc, #4]	; (8000518 <chSysHalt+0x8>)
 8000514:	62d8      	str	r0, [r3, #44]	; 0x2c

  /* Harmless infinite loop.*/
  while (true) {
  }
 8000516:	e7fe      	b.n	8000516 <chSysHalt+0x6>
 8000518:	20000800 	.word	0x20000800
 800051c:	f3af 8000 	nop.w

08000520 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8000520:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8000524:	4d21      	ldr	r5, [pc, #132]	; (80005ac <chSysTimerHandlerI+0x8c>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000526:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000

  chDbgCheckClassI();
 800052a:	f000 f8d9 	bl	80006e0 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();
 800052e:	f000 f8d7 	bl	80006e0 <chDbgCheckClassI>
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8000532:	69ec      	ldr	r4, [r5, #28]
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8000534:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8000536:	6a7a      	ldr	r2, [r7, #36]	; 0x24

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8000538:	68a0      	ldr	r0, [r4, #8]
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 800053a:	1ad1      	subs	r1, r2, r3

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 800053c:	4281      	cmp	r1, r0
 800053e:	f105 081c 	add.w	r8, r5, #28
 8000542:	d320      	bcc.n	8000586 <chSysTimerHandlerI+0x66>

    /* The timer is removed from the list and marked as non-armed.*/
    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = (vtfunc_t)NULL;
 8000544:	2600      	movs	r6, #0

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000546:	f04f 0920 	mov.w	r9, #32
    /* The "last time" becomes this timer's expiration time.*/
    delta -= vtp->vt_delta;
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    /* The timer is removed from the list and marked as non-armed.*/
    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800054a:	6822      	ldr	r2, [r4, #0]
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 800054c:	f8d4 a00c 	ldr.w	sl, [r4, #12]
      break;
    }

    /* The "last time" becomes this timer's expiration time.*/
    delta -= vtp->vt_delta;
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8000550:	4403      	add	r3, r0
 8000552:	62ab      	str	r3, [r5, #40]	; 0x28

    /* The timer is removed from the list and marked as non-armed.*/
    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000554:	f8c2 8004 	str.w	r8, [r2, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 8000558:	61ea      	str	r2, [r5, #28]
    fn = vtp->vt_func;
    vtp->vt_func = (vtfunc_t)NULL;
 800055a:	60e6      	str	r6, [r4, #12]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800055c:	f000 f878 	bl	8000650 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8000560:	f000 f9de 	bl	8000920 <_stats_stop_measure_crit_isr>
 8000564:	f386 8811 	msr	BASEPRI, r6

    /* The callback is invoked outside the kernel critical zone.*/
    chSysUnlockFromISR();
    fn(vtp->vt_par);
 8000568:	6920      	ldr	r0, [r4, #16]
 800056a:	47d0      	blx	sl
 800056c:	f389 8811 	msr	BASEPRI, r9
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 8000570:	f000 f9ce 	bl	8000910 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8000574:	f000 f854 	bl	8000620 <_dbg_check_lock_from_isr>
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8000578:	69ec      	ldr	r4, [r5, #28]
 800057a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 800057c:	6aab      	ldr	r3, [r5, #40]	; 0x28

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 800057e:	68a0      	ldr	r0, [r4, #8]
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8000580:	1ad1      	subs	r1, r2, r3

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8000582:	4281      	cmp	r1, r0
 8000584:	d2e1      	bcs.n	800054a <chSysTimerHandlerI+0x2a>
    /* The callback is invoked outside the kernel critical zone.*/
    chSysUnlockFromISR();
    fn(vtp->vt_par);
    chSysLockFromISR();
  }
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000586:	4544      	cmp	r4, r8
 8000588:	d00b      	beq.n	80005a2 <chSysTimerHandlerI+0x82>
    port_timer_stop_alarm();
  }
  else {
    /* Updating the alarm to the next deadline, deadline that must not be
       closer in time than the minimum time delta.*/
    if (vtp->vt_delta >= CH_CFG_ST_TIMEDELTA) {
 800058a:	2801      	cmp	r0, #1
 800058c:	d004      	beq.n	8000598 <chSysTimerHandlerI+0x78>
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 800058e:	4410      	add	r0, r2
#endif
  chVTDoTickI();
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 8000590:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000594:	f001 b8b4 	b.w	8001700 <stSetAlarm>
 8000598:	1c90      	adds	r0, r2, #2
 800059a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800059e:	f001 b8af 	b.w	8001700 <stSetAlarm>
 80005a2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 80005a6:	f001 b8a3 	b.w	80016f0 <stStopAlarm>
 80005aa:	bf00      	nop
 80005ac:	20000800 	.word	0x20000800

080005b0 <_dbg_check_enable>:
 *
 * @notapi
 */
void _dbg_check_enable(void) {

  if ((ch.dbg.isr_cnt != 0) || (ch.dbg.lock_cnt != 0)) {
 80005b0:	4b04      	ldr	r3, [pc, #16]	; (80005c4 <_dbg_check_enable+0x14>)
 80005b2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80005b4:	b90a      	cbnz	r2, 80005ba <_dbg_check_enable+0xa>
 80005b6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80005b8:	b113      	cbz	r3, 80005c0 <_dbg_check_enable+0x10>
    chSysHalt("SV#3");
 80005ba:	4803      	ldr	r0, [pc, #12]	; (80005c8 <_dbg_check_enable+0x18>)
 80005bc:	f7ff bfa8 	b.w	8000510 <chSysHalt>
 80005c0:	4770      	bx	lr
 80005c2:	bf00      	nop
 80005c4:	20000800 	.word	0x20000800
 80005c8:	08002810 	.word	0x08002810
 80005cc:	f3af 8000 	nop.w

080005d0 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
 80005d0:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt != 0) || (ch.dbg.lock_cnt != 0)) {
 80005d2:	4c05      	ldr	r4, [pc, #20]	; (80005e8 <_dbg_check_lock+0x18>)
 80005d4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80005d6:	b90b      	cbnz	r3, 80005dc <_dbg_check_lock+0xc>
 80005d8:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80005da:	b113      	cbz	r3, 80005e2 <_dbg_check_lock+0x12>
    chSysHalt("SV#4");
 80005dc:	4803      	ldr	r0, [pc, #12]	; (80005ec <_dbg_check_lock+0x1c>)
 80005de:	f7ff ff97 	bl	8000510 <chSysHalt>
  }
  _dbg_enter_lock();
 80005e2:	2301      	movs	r3, #1
 80005e4:	6363      	str	r3, [r4, #52]	; 0x34
 80005e6:	bd10      	pop	{r4, pc}
 80005e8:	20000800 	.word	0x20000800
 80005ec:	08002818 	.word	0x08002818

080005f0 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
 80005f0:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt != 0) || (ch.dbg.lock_cnt <= 0)) {
 80005f2:	4c07      	ldr	r4, [pc, #28]	; (8000610 <_dbg_check_unlock+0x20>)
 80005f4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80005f6:	b92b      	cbnz	r3, 8000604 <_dbg_check_unlock+0x14>
 80005f8:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80005fa:	2b00      	cmp	r3, #0
 80005fc:	dd02      	ble.n	8000604 <_dbg_check_unlock+0x14>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 80005fe:	2300      	movs	r3, #0
 8000600:	6363      	str	r3, [r4, #52]	; 0x34
 8000602:	bd10      	pop	{r4, pc}
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != 0) || (ch.dbg.lock_cnt <= 0)) {
    chSysHalt("SV#5");
 8000604:	4803      	ldr	r0, [pc, #12]	; (8000614 <_dbg_check_unlock+0x24>)
 8000606:	f7ff ff83 	bl	8000510 <chSysHalt>
  }
  _dbg_leave_lock();
 800060a:	2300      	movs	r3, #0
 800060c:	6363      	str	r3, [r4, #52]	; 0x34
 800060e:	bd10      	pop	{r4, pc}
 8000610:	20000800 	.word	0x20000800
 8000614:	08002820 	.word	0x08002820
 8000618:	f3af 8000 	nop.w
 800061c:	f3af 8000 	nop.w

08000620 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
 8000620:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt <= 0) || (ch.dbg.lock_cnt != 0)) {
 8000622:	4c06      	ldr	r4, [pc, #24]	; (800063c <_dbg_check_lock_from_isr+0x1c>)
 8000624:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000626:	2b00      	cmp	r3, #0
 8000628:	dd01      	ble.n	800062e <_dbg_check_lock_from_isr+0xe>
 800062a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800062c:	b113      	cbz	r3, 8000634 <_dbg_check_lock_from_isr+0x14>
    chSysHalt("SV#6");
 800062e:	4804      	ldr	r0, [pc, #16]	; (8000640 <_dbg_check_lock_from_isr+0x20>)
 8000630:	f7ff ff6e 	bl	8000510 <chSysHalt>
  }
  _dbg_enter_lock();
 8000634:	2301      	movs	r3, #1
 8000636:	6363      	str	r3, [r4, #52]	; 0x34
 8000638:	bd10      	pop	{r4, pc}
 800063a:	bf00      	nop
 800063c:	20000800 	.word	0x20000800
 8000640:	08002828 	.word	0x08002828
 8000644:	f3af 8000 	nop.w
 8000648:	f3af 8000 	nop.w
 800064c:	f3af 8000 	nop.w

08000650 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
 8000650:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt <= 0) || (ch.dbg.lock_cnt <= 0)) {
 8000652:	4c08      	ldr	r4, [pc, #32]	; (8000674 <_dbg_check_unlock_from_isr+0x24>)
 8000654:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000656:	2b00      	cmp	r3, #0
 8000658:	dd05      	ble.n	8000666 <_dbg_check_unlock_from_isr+0x16>
 800065a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800065c:	2b00      	cmp	r3, #0
 800065e:	dd02      	ble.n	8000666 <_dbg_check_unlock_from_isr+0x16>
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 8000660:	2300      	movs	r3, #0
 8000662:	6363      	str	r3, [r4, #52]	; 0x34
 8000664:	bd10      	pop	{r4, pc}
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= 0) || (ch.dbg.lock_cnt <= 0)) {
    chSysHalt("SV#7");
 8000666:	4804      	ldr	r0, [pc, #16]	; (8000678 <_dbg_check_unlock_from_isr+0x28>)
 8000668:	f7ff ff52 	bl	8000510 <chSysHalt>
  }
  _dbg_leave_lock();
 800066c:	2300      	movs	r3, #0
 800066e:	6363      	str	r3, [r4, #52]	; 0x34
 8000670:	bd10      	pop	{r4, pc}
 8000672:	bf00      	nop
 8000674:	20000800 	.word	0x20000800
 8000678:	08002830 	.word	0x08002830
 800067c:	f3af 8000 	nop.w

08000680 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
 8000680:	b510      	push	{r4, lr}
 8000682:	2320      	movs	r3, #32
 8000684:	f383 8811 	msr	BASEPRI, r3

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < 0) || (ch.dbg.lock_cnt != 0)) {
 8000688:	4c07      	ldr	r4, [pc, #28]	; (80006a8 <_dbg_check_enter_isr+0x28>)
 800068a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800068c:	2b00      	cmp	r3, #0
 800068e:	db01      	blt.n	8000694 <_dbg_check_enter_isr+0x14>
 8000690:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8000692:	b11a      	cbz	r2, 800069c <_dbg_check_enter_isr+0x1c>
    chSysHalt("SV#8");
 8000694:	4805      	ldr	r0, [pc, #20]	; (80006ac <_dbg_check_enter_isr+0x2c>)
 8000696:	f7ff ff3b 	bl	8000510 <chSysHalt>
 800069a:	6b23      	ldr	r3, [r4, #48]	; 0x30
  }
  ch.dbg.isr_cnt++;
 800069c:	3301      	adds	r3, #1
 800069e:	6323      	str	r3, [r4, #48]	; 0x30
 80006a0:	2300      	movs	r3, #0
 80006a2:	f383 8811 	msr	BASEPRI, r3
 80006a6:	bd10      	pop	{r4, pc}
 80006a8:	20000800 	.word	0x20000800
 80006ac:	08002838 	.word	0x08002838

080006b0 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
 80006b0:	b510      	push	{r4, lr}
 80006b2:	2320      	movs	r3, #32
 80006b4:	f383 8811 	msr	BASEPRI, r3

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= 0) || (ch.dbg.lock_cnt != 0)) {
 80006b8:	4c07      	ldr	r4, [pc, #28]	; (80006d8 <_dbg_check_leave_isr+0x28>)
 80006ba:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80006bc:	2b00      	cmp	r3, #0
 80006be:	dd01      	ble.n	80006c4 <_dbg_check_leave_isr+0x14>
 80006c0:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80006c2:	b11a      	cbz	r2, 80006cc <_dbg_check_leave_isr+0x1c>
    chSysHalt("SV#9");
 80006c4:	4805      	ldr	r0, [pc, #20]	; (80006dc <_dbg_check_leave_isr+0x2c>)
 80006c6:	f7ff ff23 	bl	8000510 <chSysHalt>
 80006ca:	6b23      	ldr	r3, [r4, #48]	; 0x30
  }
  ch.dbg.isr_cnt--;
 80006cc:	3b01      	subs	r3, #1
 80006ce:	6323      	str	r3, [r4, #48]	; 0x30
 80006d0:	2300      	movs	r3, #0
 80006d2:	f383 8811 	msr	BASEPRI, r3
 80006d6:	bd10      	pop	{r4, pc}
 80006d8:	20000800 	.word	0x20000800
 80006dc:	08002840 	.word	0x08002840

080006e0 <chDbgCheckClassI>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < 0) || (ch.dbg.lock_cnt <= 0)) {
 80006e0:	4b05      	ldr	r3, [pc, #20]	; (80006f8 <chDbgCheckClassI+0x18>)
 80006e2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80006e4:	2a00      	cmp	r2, #0
 80006e6:	db03      	blt.n	80006f0 <chDbgCheckClassI+0x10>
 80006e8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80006ea:	2b00      	cmp	r3, #0
 80006ec:	dd00      	ble.n	80006f0 <chDbgCheckClassI+0x10>
 80006ee:	4770      	bx	lr
    chSysHalt("SV#10");
 80006f0:	4802      	ldr	r0, [pc, #8]	; (80006fc <chDbgCheckClassI+0x1c>)
 80006f2:	f7ff bf0d 	b.w	8000510 <chSysHalt>
 80006f6:	bf00      	nop
 80006f8:	20000800 	.word	0x20000800
 80006fc:	08002848 	.word	0x08002848

08000700 <chDbgCheckClassS>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != 0) || (ch.dbg.lock_cnt <= 0)) {
 8000700:	4b04      	ldr	r3, [pc, #16]	; (8000714 <chDbgCheckClassS+0x14>)
 8000702:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000704:	b91a      	cbnz	r2, 800070e <chDbgCheckClassS+0xe>
 8000706:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8000708:	2b00      	cmp	r3, #0
 800070a:	dd00      	ble.n	800070e <chDbgCheckClassS+0xe>
 800070c:	4770      	bx	lr
    chSysHalt("SV#11");
 800070e:	4802      	ldr	r0, [pc, #8]	; (8000718 <chDbgCheckClassS+0x18>)
 8000710:	f7ff befe 	b.w	8000510 <chSysHalt>
 8000714:	20000800 	.word	0x20000800
 8000718:	08002850 	.word	0x08002850
 800071c:	f3af 8000 	nop.w

08000720 <_dbg_trace_init>:
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
 8000720:	4b02      	ldr	r3, [pc, #8]	; (800072c <_dbg_trace_init+0xc>)
 8000722:	2140      	movs	r1, #64	; 0x40
  ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 8000724:	185a      	adds	r2, r3, r1
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
 8000726:	6399      	str	r1, [r3, #56]	; 0x38
  ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 8000728:	63da      	str	r2, [r3, #60]	; 0x3c
 800072a:	4770      	bx	lr
 800072c:	20000800 	.word	0x20000800

08000730 <_dbg_trace>:
 *
 * @notapi
 */
void _dbg_trace(thread_t *otp) {

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
 8000730:	4a0c      	ldr	r2, [pc, #48]	; (8000764 <_dbg_trace+0x34>)
 8000732:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8000736:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 *
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _dbg_trace(thread_t *otp) {
 8000738:	b410      	push	{r4}
 800073a:	6a4c      	ldr	r4, [r1, #36]	; 0x24

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
 800073c:	6991      	ldr	r1, [r2, #24]
 800073e:	6059      	str	r1, [r3, #4]
 *
 * @notapi
 */
void _dbg_trace(thread_t *otp) {

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
 8000740:	601c      	str	r4, [r3, #0]
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
  ch.dbg.trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
 8000742:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8000744:	6099      	str	r1, [r3, #8]
  ch.dbg.trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
 8000746:	f890 1020 	ldrb.w	r1, [r0, #32]
 800074a:	7319      	strb	r1, [r3, #12]
  if (++ch.dbg.trace_buffer.tb_ptr >=
 800074c:	3310      	adds	r3, #16
 800074e:	f502 6188 	add.w	r1, r2, #1088	; 0x440
 8000752:	428b      	cmp	r3, r1
      &ch.dbg.trace_buffer.tb_buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 8000754:	bf28      	it	cs
 8000756:	f102 0340 	addcs.w	r3, r2, #64	; 0x40
 800075a:	63d3      	str	r3, [r2, #60]	; 0x3c
  }
}
 800075c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000760:	4770      	bx	lr
 8000762:	bf00      	nop
 8000764:	20000800 	.word	0x20000800
 8000768:	f3af 8000 	nop.w
 800076c:	f3af 8000 	nop.w

08000770 <chTMObjectInit>:

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8000770:	2200      	movs	r2, #0
 8000772:	2300      	movs	r3, #0
 8000774:	e9c0 2304 	strd	r2, r3, [r0, #16]
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 8000778:	2300      	movs	r3, #0
 800077a:	f04f 32ff 	mov.w	r2, #4294967295
 800077e:	e880 000c 	stmia.w	r0, {r2, r3}
  tmp->last       = (rtcnt_t)0;
 8000782:	6083      	str	r3, [r0, #8]
  tmp->n          = (ucnt_t)0;
 8000784:	60c3      	str	r3, [r0, #12]
 8000786:	4770      	bx	lr
 8000788:	f3af 8000 	nop.w
 800078c:	f3af 8000 	nop.w

08000790 <chTMStartMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8000790:	4b01      	ldr	r3, [pc, #4]	; (8000798 <chTMStartMeasurementX+0x8>)
 8000792:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8000794:	6083      	str	r3, [r0, #8]
 8000796:	4770      	bx	lr
 8000798:	e0001000 	.word	0xe0001000
 800079c:	f3af 8000 	nop.w

080007a0 <chTMStopMeasurementX>:
 80007a0:	4b0f      	ldr	r3, [pc, #60]	; (80007e0 <chTMStopMeasurementX+0x40>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80007a2:	4910      	ldr	r1, [pc, #64]	; (80007e4 <chTMStopMeasurementX+0x44>)
 80007a4:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = now - tmp->last - offset;
 80007a6:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80007a8:	b4f0      	push	{r4, r5, r6, r7}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80007aa:	f8d1 74a0 	ldr.w	r7, [r1, #1184]	; 0x4a0

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 80007ae:	68c6      	ldr	r6, [r0, #12]
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 80007b0:	6841      	ldr	r1, [r0, #4]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 80007b2:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = now - tmp->last - offset;
 80007b6:	1ad3      	subs	r3, r2, r3
 80007b8:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
 80007ba:	18e4      	adds	r4, r4, r3
 80007bc:	f145 0500 	adc.w	r5, r5, #0

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 80007c0:	3601      	adds	r6, #1
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 80007c2:	428b      	cmp	r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 80007c4:	60c6      	str	r6, [r0, #12]
  tmp->last = now - tmp->last - offset;
 80007c6:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 80007c8:	e9c0 4504 	strd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
 80007cc:	d805      	bhi.n	80007da <chTMStopMeasurementX+0x3a>
    tmp->worst = tmp->last;
  }
  else if (tmp->last < tmp->best) {
 80007ce:	6802      	ldr	r2, [r0, #0]
 80007d0:	4293      	cmp	r3, r2
    tmp->best = tmp->last;
 80007d2:	bf38      	it	cc
 80007d4:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 80007d6:	bcf0      	pop	{r4, r5, r6, r7}
 80007d8:	4770      	bx	lr

  tmp->n++;
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 80007da:	6043      	str	r3, [r0, #4]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 80007dc:	bcf0      	pop	{r4, r5, r6, r7}
 80007de:	4770      	bx	lr
 80007e0:	e0001000 	.word	0xe0001000
 80007e4:	20000800 	.word	0x20000800
 80007e8:	f3af 8000 	nop.w
 80007ec:	f3af 8000 	nop.w

080007f0 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 80007f0:	b5d0      	push	{r4, r6, r7, lr}
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
 80007f2:	4c0d      	ldr	r4, [pc, #52]	; (8000828 <_tm_init+0x38>)
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 80007f4:	b086      	sub	sp, #24
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
 80007f6:	2300      	movs	r3, #0
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 80007f8:	f04f 32ff 	mov.w	r2, #4294967295
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 80007fc:	4668      	mov	r0, sp

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 80007fe:	2600      	movs	r6, #0
 8000800:	2700      	movs	r7, #0
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
 8000802:	f8c4 34a0 	str.w	r3, [r4, #1184]	; 0x4a0
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 8000806:	9301      	str	r3, [sp, #4]
  tmp->last       = (rtcnt_t)0;
 8000808:	9302      	str	r3, [sp, #8]
  tmp->n          = (ucnt_t)0;
 800080a:	9303      	str	r3, [sp, #12]
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 800080c:	9200      	str	r2, [sp, #0]
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 800080e:	e9cd 6704 	strd	r6, r7, [sp, #16]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8000812:	f7ff ffbd 	bl	8000790 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 8000816:	4668      	mov	r0, sp
 8000818:	f7ff ffc2 	bl	80007a0 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 800081c:	9b02      	ldr	r3, [sp, #8]
 800081e:	f8c4 34a0 	str.w	r3, [r4, #1184]	; 0x4a0
}
 8000822:	b006      	add	sp, #24
 8000824:	bdd0      	pop	{r4, r6, r7, pc}
 8000826:	bf00      	nop
 8000828:	20000800 	.word	0x20000800
 800082c:	f3af 8000 	nop.w

08000830 <chTMChainMeasurementToX>:
 8000830:	4b0e      	ldr	r3, [pc, #56]	; (800086c <chTMChainMeasurementToX+0x3c>)
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 8000832:	6842      	ldr	r2, [r0, #4]
 8000834:	685b      	ldr	r3, [r3, #4]
 *
 *
 * @xclass
 */
NOINLINE void chTMChainMeasurementToX(time_measurement_t *tmp1,
                                      time_measurement_t *tmp2) {
 8000836:	b470      	push	{r4, r5, r6}

  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();
 8000838:	608b      	str	r3, [r1, #8]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 800083a:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = now - tmp->last - offset;
 800083e:	6886      	ldr	r6, [r0, #8]

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8000840:	68c1      	ldr	r1, [r0, #12]
  tmp->last = now - tmp->last - offset;
 8000842:	1b9b      	subs	r3, r3, r6
  tmp->cumulative += (rttime_t)tmp->last;
 8000844:	18e4      	adds	r4, r4, r3
 8000846:	f145 0500 	adc.w	r5, r5, #0

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800084a:	3101      	adds	r1, #1
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 800084c:	4293      	cmp	r3, r2

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800084e:	60c1      	str	r1, [r0, #12]
  tmp->last = now - tmp->last - offset;
 8000850:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8000852:	e9c0 4504 	strd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
 8000856:	d805      	bhi.n	8000864 <chTMChainMeasurementToX+0x34>
    tmp->worst = tmp->last;
  }
  else if (tmp->last < tmp->best) {
 8000858:	6802      	ldr	r2, [r0, #0]
 800085a:	4293      	cmp	r3, r2
    tmp->best = tmp->last;
 800085c:	bf38      	it	cc
 800085e:	6003      	strcc	r3, [r0, #0]
  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();

  /* Stops previous measurement using the same time stamp.*/
  tm_stop(tmp1, tmp2->last, 0);
}
 8000860:	bc70      	pop	{r4, r5, r6}
 8000862:	4770      	bx	lr

  tmp->n++;
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 8000864:	6043      	str	r3, [r0, #4]
  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();

  /* Stops previous measurement using the same time stamp.*/
  tm_stop(tmp1, tmp2->last, 0);
}
 8000866:	bc70      	pop	{r4, r5, r6}
 8000868:	4770      	bx	lr
 800086a:	bf00      	nop
 800086c:	e0001000 	.word	0xe0001000

08000870 <_stats_init>:
/**
 * @brief   Initializes the statistics module.
 *
 * @init
 */
void _stats_init(void) {
 8000870:	b510      	push	{r4, lr}

  ch.kernel_stats.n_irq = 0;
 8000872:	4c08      	ldr	r4, [pc, #32]	; (8000894 <_stats_init+0x24>)
 8000874:	2300      	movs	r3, #0
  ch.kernel_stats.n_ctxswc = 0;
  chTMObjectInit(&ch.kernel_stats.m_crit_thd);
 8000876:	f504 6096 	add.w	r0, r4, #1200	; 0x4b0
 *
 * @init
 */
void _stats_init(void) {

  ch.kernel_stats.n_irq = 0;
 800087a:	f8c4 34a8 	str.w	r3, [r4, #1192]	; 0x4a8
  ch.kernel_stats.n_ctxswc = 0;
 800087e:	f8c4 34ac 	str.w	r3, [r4, #1196]	; 0x4ac
  chTMObjectInit(&ch.kernel_stats.m_crit_thd);
 8000882:	f7ff ff75 	bl	8000770 <chTMObjectInit>
  chTMObjectInit(&ch.kernel_stats.m_crit_isr);
 8000886:	f504 6099 	add.w	r0, r4, #1224	; 0x4c8
}
 800088a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void _stats_init(void) {

  ch.kernel_stats.n_irq = 0;
  ch.kernel_stats.n_ctxswc = 0;
  chTMObjectInit(&ch.kernel_stats.m_crit_thd);
  chTMObjectInit(&ch.kernel_stats.m_crit_isr);
 800088e:	f7ff bf6f 	b.w	8000770 <chTMObjectInit>
 8000892:	bf00      	nop
 8000894:	20000800 	.word	0x20000800
 8000898:	f3af 8000 	nop.w
 800089c:	f3af 8000 	nop.w

080008a0 <_stats_increase_irq>:
/**
 * @brief   Increases the IRQ counter.
 */
void _stats_increase_irq(void) {

  ch.kernel_stats.n_irq++;
 80008a0:	4a03      	ldr	r2, [pc, #12]	; (80008b0 <_stats_increase_irq+0x10>)
 80008a2:	f8d2 34a8 	ldr.w	r3, [r2, #1192]	; 0x4a8
 80008a6:	3301      	adds	r3, #1
 80008a8:	f8c2 34a8 	str.w	r3, [r2, #1192]	; 0x4a8
 80008ac:	4770      	bx	lr
 80008ae:	bf00      	nop
 80008b0:	20000800 	.word	0x20000800
 80008b4:	f3af 8000 	nop.w
 80008b8:	f3af 8000 	nop.w
 80008bc:	f3af 8000 	nop.w

080008c0 <_stats_ctxswc>:
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {

  ch.kernel_stats.n_ctxswc++;
 80008c0:	4a07      	ldr	r2, [pc, #28]	; (80008e0 <_stats_ctxswc+0x20>)
 80008c2:	f8d2 34ac 	ldr.w	r3, [r2, #1196]	; 0x4ac
 * @brief   Updates context switch related statistics.
 *
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {
 80008c6:	b410      	push	{r4}

  ch.kernel_stats.n_ctxswc++;
  chTMChainMeasurementToX(&otp->p_stats, &ntp->p_stats);
 80008c8:	f100 0448 	add.w	r4, r0, #72	; 0x48
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {

  ch.kernel_stats.n_ctxswc++;
 80008cc:	3301      	adds	r3, #1
  chTMChainMeasurementToX(&otp->p_stats, &ntp->p_stats);
 80008ce:	f101 0048 	add.w	r0, r1, #72	; 0x48
 80008d2:	4621      	mov	r1, r4
}
 80008d4:	f85d 4b04 	ldr.w	r4, [sp], #4
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {

  ch.kernel_stats.n_ctxswc++;
 80008d8:	f8c2 34ac 	str.w	r3, [r2, #1196]	; 0x4ac
  chTMChainMeasurementToX(&otp->p_stats, &ntp->p_stats);
 80008dc:	f7ff bfa8 	b.w	8000830 <chTMChainMeasurementToX>
 80008e0:	20000800 	.word	0x20000800
 80008e4:	f3af 8000 	nop.w
 80008e8:	f3af 8000 	nop.w
 80008ec:	f3af 8000 	nop.w

080008f0 <_stats_start_measure_crit_thd>:
/**
 * @brief   Starts the measurement of a thread critical zone.
 */
void _stats_start_measure_crit_thd(void) {

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_thd);
 80008f0:	4801      	ldr	r0, [pc, #4]	; (80008f8 <_stats_start_measure_crit_thd+0x8>)
 80008f2:	f7ff bf4d 	b.w	8000790 <chTMStartMeasurementX>
 80008f6:	bf00      	nop
 80008f8:	20000cb0 	.word	0x20000cb0
 80008fc:	f3af 8000 	nop.w

08000900 <_stats_stop_measure_crit_thd>:
/**
 * @brief   Stops the measurement of a thread critical zone.
 */
void _stats_stop_measure_crit_thd(void) {

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_thd);
 8000900:	4801      	ldr	r0, [pc, #4]	; (8000908 <_stats_stop_measure_crit_thd+0x8>)
 8000902:	f7ff bf4d 	b.w	80007a0 <chTMStopMeasurementX>
 8000906:	bf00      	nop
 8000908:	20000cb0 	.word	0x20000cb0
 800090c:	f3af 8000 	nop.w

08000910 <_stats_start_measure_crit_isr>:
/**
 * @brief   Starts the measurement of an ISR critical zone.
 */
void _stats_start_measure_crit_isr(void) {

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_isr);
 8000910:	4801      	ldr	r0, [pc, #4]	; (8000918 <_stats_start_measure_crit_isr+0x8>)
 8000912:	f7ff bf3d 	b.w	8000790 <chTMStartMeasurementX>
 8000916:	bf00      	nop
 8000918:	20000cc8 	.word	0x20000cc8
 800091c:	f3af 8000 	nop.w

08000920 <_stats_stop_measure_crit_isr>:
/**
 * @brief   Stops the measurement of an ISR critical zone.
 */
void _stats_stop_measure_crit_isr(void) {

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_isr);
 8000920:	4801      	ldr	r0, [pc, #4]	; (8000928 <_stats_stop_measure_crit_isr+0x8>)
 8000922:	f7ff bf3d 	b.w	80007a0 <chTMStopMeasurementX>
 8000926:	bf00      	nop
 8000928:	20000cc8 	.word	0x20000cc8
 800092c:	f3af 8000 	nop.w

08000930 <_scheduler_init>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8000930:	4b03      	ldr	r3, [pc, #12]	; (8000940 <_scheduler_init+0x10>)
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 8000932:	2200      	movs	r2, #0
 8000934:	605b      	str	r3, [r3, #4]
 8000936:	601b      	str	r3, [r3, #0]
#if CH_CFG_USE_REGISTRY
  ch.rlist.r_newer = ch.rlist.r_older = (thread_t *)&ch.rlist;
 8000938:	615b      	str	r3, [r3, #20]
 800093a:	611b      	str	r3, [r3, #16]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 800093c:	609a      	str	r2, [r3, #8]
 800093e:	4770      	bx	lr
 8000940:	20000800 	.word	0x20000800
 8000944:	f3af 8000 	nop.w
 8000948:	f3af 8000 	nop.w
 800094c:	f3af 8000 	nop.w

08000950 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8000950:	b510      	push	{r4, lr}
 8000952:	4604      	mov	r4, r0
  thread_t *cp;

  chDbgCheckClassI();
 8000954:	f7ff fec4 	bl	80006e0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8000958:	b1c4      	cbz	r4, 800098c <chSchReadyI+0x3c>
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
 800095a:	f894 3020 	ldrb.w	r3, [r4, #32]
 800095e:	b18b      	cbz	r3, 8000984 <chSchReadyI+0x34>
 8000960:	2b0f      	cmp	r3, #15
 8000962:	d00f      	beq.n	8000984 <chSchReadyI+0x34>
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000964:	2200      	movs	r2, #0
 8000966:	68a1      	ldr	r1, [r4, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000968:	4b0a      	ldr	r3, [pc, #40]	; (8000994 <chSchReadyI+0x44>)
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800096a:	f884 2020 	strb.w	r2, [r4, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800096e:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8000970:	689a      	ldr	r2, [r3, #8]
 8000972:	428a      	cmp	r2, r1
 8000974:	d2fb      	bcs.n	800096e <chSchReadyI+0x1e>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000976:	685a      	ldr	r2, [r3, #4]
 8000978:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 800097a:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;

  return tp;
}
 800097c:	4620      	mov	r0, r4
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 800097e:	605c      	str	r4, [r3, #4]
 8000980:	6014      	str	r4, [r2, #0]

  return tp;
}
 8000982:	bd10      	pop	{r4, pc}
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
 8000984:	4804      	ldr	r0, [pc, #16]	; (8000998 <chSchReadyI+0x48>)
 8000986:	f7ff fdc3 	bl	8000510 <chSysHalt>
 800098a:	e7eb      	b.n	8000964 <chSchReadyI+0x14>
 */
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
 800098c:	4802      	ldr	r0, [pc, #8]	; (8000998 <chSchReadyI+0x48>)
 800098e:	f7ff fdbf 	bl	8000510 <chSysHalt>
 8000992:	e7e2      	b.n	800095a <chSchReadyI+0xa>
 8000994:	20000800 	.word	0x20000800
 8000998:	08002860 	.word	0x08002860
 800099c:	f3af 8000 	nop.w

080009a0 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 80009a0:	b538      	push	{r3, r4, r5, lr}
 80009a2:	4604      	mov	r4, r0
 80009a4:	2320      	movs	r3, #32
 80009a6:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 80009aa:	f7ff ffb1 	bl	8000910 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 80009ae:	f7ff fe37 	bl	8000620 <_dbg_check_lock_from_isr>
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 80009b2:	f894 3020 	ldrb.w	r3, [r4, #32]
 80009b6:	2b07      	cmp	r3, #7
 80009b8:	d810      	bhi.n	80009dc <wakeup+0x3c>
 80009ba:	e8df f003 	tbb	[pc, r3]
 80009be:	0f15      	.short	0x0f15
 80009c0:	040a1d0f 	.word	0x040a1d0f
 80009c4:	0a0f      	.short	0x0a0f
  case CH_STATE_SUSPENDED:
    *(thread_reference_t *)tp->p_u.wtobjp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES
  case CH_STATE_WTSEM:
    chSemFastSignalI((semaphore_t *)tp->p_u.wtobjp);
 80009c6:	6a65      	ldr	r5, [r4, #36]	; 0x24
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
 80009c8:	f7ff fe8a 	bl	80006e0 <chDbgCheckClassI>

  sp->s_cnt++;
 80009cc:	68ab      	ldr	r3, [r5, #8]
 80009ce:	3301      	adds	r3, #1
 80009d0:	60ab      	str	r3, [r5, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 80009d2:	e894 000c 	ldmia.w	r4, {r2, r3}
 80009d6:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 80009d8:	6822      	ldr	r2, [r4, #0]
 80009da:	6053      	str	r3, [r2, #4]
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    queue_dequeue(tp);
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 80009dc:	f04f 33ff 	mov.w	r3, #4294967295
 80009e0:	6263      	str	r3, [r4, #36]	; 0x24
  chSchReadyI(tp);
 80009e2:	4620      	mov	r0, r4
 80009e4:	f7ff ffb4 	bl	8000950 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80009e8:	f7ff fe32 	bl	8000650 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 80009ec:	f7ff ff98 	bl	8000920 <_stats_stop_measure_crit_isr>
 80009f0:	2300      	movs	r3, #0
 80009f2:	f383 8811 	msr	BASEPRI, r3
 80009f6:	bd38      	pop	{r3, r4, r5, pc}
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *(thread_reference_t *)tp->p_u.wtobjp = NULL;
 80009f8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80009fa:	2200      	movs	r2, #0
 80009fc:	601a      	str	r2, [r3, #0]
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    queue_dequeue(tp);
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 80009fe:	f04f 33ff 	mov.w	r3, #4294967295
 8000a02:	6263      	str	r3, [r4, #36]	; 0x24
  chSchReadyI(tp);
 8000a04:	4620      	mov	r0, r4
 8000a06:	f7ff ffa3 	bl	8000950 <chSchReadyI>
 8000a0a:	e7ed      	b.n	80009e8 <wakeup+0x48>
 8000a0c:	f3af 8000 	nop.w

08000a10 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000a10:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 8000a12:	4c12      	ldr	r4, [pc, #72]	; (8000a5c <chSchGoSleepS+0x4c>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000a14:	4606      	mov	r6, r0
  thread_t *otp;

  chDbgCheckClassS();
 8000a16:	f7ff fe73 	bl	8000700 <chDbgCheckClassS>
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8000a1a:	6823      	ldr	r3, [r4, #0]

  (otp = currp)->p_state = newstate;
 8000a1c:	69a5      	ldr	r5, [r4, #24]

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8000a1e:	681a      	ldr	r2, [r3, #0]
 8000a20:	f885 6020 	strb.w	r6, [r5, #32]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000a24:	2101      	movs	r1, #1
 8000a26:	6054      	str	r4, [r2, #4]
  chSysSwitch(currp, otp);
 8000a28:	4628      	mov	r0, r5
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000a2a:	f883 1020 	strb.w	r1, [r3, #32]
 8000a2e:	6022      	str	r2, [r4, #0]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000a30:	61a3      	str	r3, [r4, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 8000a32:	f7ff fe7d 	bl	8000730 <_dbg_trace>
 8000a36:	4629      	mov	r1, r5
 8000a38:	69a0      	ldr	r0, [r4, #24]
 8000a3a:	f7ff ff41 	bl	80008c0 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000a3e:	f3ef 8309 	mrs	r3, PSP
 8000a42:	69ea      	ldr	r2, [r5, #28]
 8000a44:	3b24      	subs	r3, #36	; 0x24
 8000a46:	429a      	cmp	r2, r3
 8000a48:	d902      	bls.n	8000a50 <chSchGoSleepS+0x40>
 8000a4a:	4805      	ldr	r0, [pc, #20]	; (8000a60 <chSchGoSleepS+0x50>)
 8000a4c:	f7ff fd60 	bl	8000510 <chSysHalt>
 8000a50:	69a0      	ldr	r0, [r4, #24]
 8000a52:	4629      	mov	r1, r5
}
 8000a54:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 8000a58:	f7ff bc02 	b.w	8000260 <_port_switch>
 8000a5c:	20000800 	.word	0x20000800
 8000a60:	08002870 	.word	0x08002870
 8000a64:	f3af 8000 	nop.w
 8000a68:	f3af 8000 	nop.w
 8000a6c:	f3af 8000 	nop.w

08000a70 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000a70:	b570      	push	{r4, r5, r6, lr}
 8000a72:	460c      	mov	r4, r1
 8000a74:	b086      	sub	sp, #24
 8000a76:	4606      	mov	r6, r0

  chDbgCheckClassS();
 8000a78:	f7ff fe42 	bl	8000700 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
 8000a7c:	1c63      	adds	r3, r4, #1
 8000a7e:	d014      	beq.n	8000aaa <chSchGoSleepTimeoutS+0x3a>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8000a80:	4d0e      	ldr	r5, [pc, #56]	; (8000abc <chSchGoSleepTimeoutS+0x4c>)
 8000a82:	4a0f      	ldr	r2, [pc, #60]	; (8000ac0 <chSchGoSleepTimeoutS+0x50>)
 8000a84:	69ab      	ldr	r3, [r5, #24]
 8000a86:	4621      	mov	r1, r4
 8000a88:	a801      	add	r0, sp, #4
 8000a8a:	f000 f8b9 	bl	8000c00 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8000a8e:	4630      	mov	r0, r6
 8000a90:	f7ff ffbe 	bl	8000a10 <chSchGoSleepS>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 8000a94:	f7ff fe24 	bl	80006e0 <chDbgCheckClassI>
    if (chVTIsArmedI(&vt))
 8000a98:	9b04      	ldr	r3, [sp, #16]
 8000a9a:	b113      	cbz	r3, 8000aa2 <chSchGoSleepTimeoutS+0x32>
      chVTDoResetI(&vt);
 8000a9c:	a801      	add	r0, sp, #4
 8000a9e:	f000 f8ff 	bl	8000ca0 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 8000aa2:	69ab      	ldr	r3, [r5, #24]
}
 8000aa4:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8000aa6:	b006      	add	sp, #24
 8000aa8:	bd70      	pop	{r4, r5, r6, pc}
 8000aaa:	4d04      	ldr	r5, [pc, #16]	; (8000abc <chSchGoSleepTimeoutS+0x4c>)
    chSchGoSleepS(newstate);
    if (chVTIsArmedI(&vt))
      chVTDoResetI(&vt);
  }
  else {
    chSchGoSleepS(newstate);
 8000aac:	4630      	mov	r0, r6
 8000aae:	f7ff ffaf 	bl	8000a10 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8000ab2:	69ab      	ldr	r3, [r5, #24]
}
 8000ab4:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8000ab6:	b006      	add	sp, #24
 8000ab8:	bd70      	pop	{r4, r5, r6, pc}
 8000aba:	bf00      	nop
 8000abc:	20000800 	.word	0x20000800
 8000ac0:	080009a1 	.word	0x080009a1
 8000ac4:	f3af 8000 	nop.w
 8000ac8:	f3af 8000 	nop.w
 8000acc:	f3af 8000 	nop.w

08000ad0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000ad0:	b570      	push	{r4, r5, r6, lr}

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000ad2:	4d19      	ldr	r5, [pc, #100]	; (8000b38 <chSchWakeupS+0x68>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000ad4:	4604      	mov	r4, r0
 8000ad6:	460e      	mov	r6, r1

  chDbgCheckClassS();
 8000ad8:	f7ff fe12 	bl	8000700 <chDbgCheckClassS>

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000adc:	69a8      	ldr	r0, [r5, #24]
 8000ade:	68a2      	ldr	r2, [r4, #8]
 8000ae0:	6883      	ldr	r3, [r0, #8]

  chDbgCheckClassS();

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8000ae2:	6266      	str	r6, [r4, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000ae4:	429a      	cmp	r2, r3
 8000ae6:	d918      	bls.n	8000b1a <chSchWakeupS+0x4a>
    chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8000ae8:	f7ff ff32 	bl	8000950 <chSchReadyI>
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8000aec:	2301      	movs	r3, #1
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
    chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8000aee:	4606      	mov	r6, r0
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8000af0:	f884 3020 	strb.w	r3, [r4, #32]
  if (ntp->p_prio <= currp->p_prio) {
    chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 8000af4:	61ac      	str	r4, [r5, #24]
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8000af6:	f7ff fe1b 	bl	8000730 <_dbg_trace>
 8000afa:	4620      	mov	r0, r4
 8000afc:	4631      	mov	r1, r6
 8000afe:	f7ff fedf 	bl	80008c0 <_stats_ctxswc>
 8000b02:	f3ef 8309 	mrs	r3, PSP
 8000b06:	69f2      	ldr	r2, [r6, #28]
 8000b08:	3b24      	subs	r3, #36	; 0x24
 8000b0a:	429a      	cmp	r2, r3
 8000b0c:	d80a      	bhi.n	8000b24 <chSchWakeupS+0x54>
 8000b0e:	4620      	mov	r0, r4
 8000b10:	4631      	mov	r1, r6
  }
}
 8000b12:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8000b16:	f7ff bba3 	b.w	8000260 <_port_switch>
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
    chSchReadyI(ntp);
 8000b1a:	4620      	mov	r0, r4
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 8000b1c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
    chSchReadyI(ntp);
 8000b20:	f7ff bf16 	b.w	8000950 <chSchReadyI>
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8000b24:	4805      	ldr	r0, [pc, #20]	; (8000b3c <chSchWakeupS+0x6c>)
 8000b26:	f7ff fcf3 	bl	8000510 <chSysHalt>
 8000b2a:	4620      	mov	r0, r4
 8000b2c:	4631      	mov	r1, r6
  }
}
 8000b2e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8000b32:	f7ff bb95 	b.w	8000260 <_port_switch>
 8000b36:	bf00      	nop
 8000b38:	20000800 	.word	0x20000800
 8000b3c:	08002870 	.word	0x08002870

08000b40 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8000b40:	4b04      	ldr	r3, [pc, #16]	; (8000b54 <chSchIsPreemptionRequired+0x14>)
 8000b42:	681a      	ldr	r2, [r3, #0]
  tprio_t p2 = currp->p_prio;
 8000b44:	699b      	ldr	r3, [r3, #24]
     if the first thread on the ready queue has equal or higher priority.*/
  return currp->p_preempt ? p1 > p2 : p1 >= p2;
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8000b46:	6890      	ldr	r0, [r2, #8]
 8000b48:	689b      	ldr	r3, [r3, #8]
#endif
}
 8000b4a:	4298      	cmp	r0, r3
 8000b4c:	bf94      	ite	ls
 8000b4e:	2000      	movls	r0, #0
 8000b50:	2001      	movhi	r0, #1
 8000b52:	4770      	bx	lr
 8000b54:	20000800 	.word	0x20000800
 8000b58:	f3af 8000 	nop.w
 8000b5c:	f3af 8000 	nop.w

08000b60 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8000b60:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp, *cp;

  otp = currp;
 8000b62:	4d17      	ldr	r5, [pc, #92]	; (8000bc0 <chSchDoRescheduleAhead+0x60>)
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8000b64:	682a      	ldr	r2, [r5, #0]
 8000b66:	69ac      	ldr	r4, [r5, #24]

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8000b68:	6813      	ldr	r3, [r2, #0]
 8000b6a:	68a1      	ldr	r1, [r4, #8]
 8000b6c:	602b      	str	r3, [r5, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000b6e:	2601      	movs	r6, #1

  otp->p_state = CH_STATE_READY;
 8000b70:	2000      	movs	r0, #0
 8000b72:	605d      	str	r5, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000b74:	f882 6020 	strb.w	r6, [r2, #32]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000b78:	61aa      	str	r2, [r5, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 8000b7a:	f884 0020 	strb.w	r0, [r4, #32]
 8000b7e:	e000      	b.n	8000b82 <chSchDoRescheduleAhead+0x22>
 8000b80:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 8000b82:	689a      	ldr	r2, [r3, #8]
 8000b84:	428a      	cmp	r2, r1
 8000b86:	d8fb      	bhi.n	8000b80 <chSchDoRescheduleAhead+0x20>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8000b88:	685a      	ldr	r2, [r3, #4]
 8000b8a:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8000b8c:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
 8000b8e:	4620      	mov	r0, r4
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;
 8000b90:	605c      	str	r4, [r3, #4]
 8000b92:	6014      	str	r4, [r2, #0]

  chSysSwitch(currp, otp);
 8000b94:	f7ff fdcc 	bl	8000730 <_dbg_trace>
 8000b98:	69a8      	ldr	r0, [r5, #24]
 8000b9a:	4621      	mov	r1, r4
 8000b9c:	f7ff fe90 	bl	80008c0 <_stats_ctxswc>
 8000ba0:	f3ef 8309 	mrs	r3, PSP
 8000ba4:	69e2      	ldr	r2, [r4, #28]
 8000ba6:	3b24      	subs	r3, #36	; 0x24
 8000ba8:	429a      	cmp	r2, r3
 8000baa:	d902      	bls.n	8000bb2 <chSchDoRescheduleAhead+0x52>
 8000bac:	4805      	ldr	r0, [pc, #20]	; (8000bc4 <chSchDoRescheduleAhead+0x64>)
 8000bae:	f7ff fcaf 	bl	8000510 <chSysHalt>
 8000bb2:	69a8      	ldr	r0, [r5, #24]
 8000bb4:	4621      	mov	r1, r4
}
 8000bb6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
 8000bba:	f7ff bb51 	b.w	8000260 <_port_switch>
 8000bbe:	bf00      	nop
 8000bc0:	20000800 	.word	0x20000800
 8000bc4:	08002870 	.word	0x08002870
 8000bc8:	f3af 8000 	nop.w
 8000bcc:	f3af 8000 	nop.w

08000bd0 <chSchDoReschedule>:
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8000bd0:	f7ff bfc6 	b.w	8000b60 <chSchDoRescheduleAhead>
 8000bd4:	f3af 8000 	nop.w
 8000bd8:	f3af 8000 	nop.w
 8000bdc:	f3af 8000 	nop.w

08000be0 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
 8000be0:	4b05      	ldr	r3, [pc, #20]	; (8000bf8 <_vt_init+0x18>)
  ch.vtlist.vt_delta = (systime_t)-1;
 8000be2:	f04f 30ff 	mov.w	r0, #4294967295
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
 8000be6:	f103 021c 	add.w	r2, r3, #28
  ch.vtlist.vt_delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = 0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = 0;
 8000bea:	2100      	movs	r1, #0
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 8000bec:	6258      	str	r0, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = 0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = 0;
 8000bee:	6299      	str	r1, [r3, #40]	; 0x28
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
 8000bf0:	621a      	str	r2, [r3, #32]
 8000bf2:	61da      	str	r2, [r3, #28]
 8000bf4:	4770      	bx	lr
 8000bf6:	bf00      	nop
 8000bf8:	20000800 	.word	0x20000800
 8000bfc:	f3af 8000 	nop.w

08000c00 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8000c00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000c04:	4606      	mov	r6, r0
 8000c06:	460c      	mov	r4, r1
 8000c08:	4690      	mov	r8, r2
 8000c0a:	461d      	mov	r5, r3
  virtual_timer_t *p;

  chDbgCheckClassI();
 8000c0c:	f7ff fd68 	bl	80006e0 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8000c10:	b366      	cbz	r6, 8000c6c <chVTDoSetI+0x6c>
 8000c12:	f1b8 0f00 	cmp.w	r8, #0
 8000c16:	d029      	beq.n	8000c6c <chVTDoSetI+0x6c>
 8000c18:	b344      	cbz	r4, 8000c6c <chVTDoSetI+0x6c>

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = ch.vtlist.vt_next;
 8000c1a:	4f1c      	ldr	r7, [pc, #112]	; (8000c8c <chVTDoSetI+0x8c>)
  virtual_timer_t *p;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8000c1c:	6135      	str	r5, [r6, #16]
  vtp->vt_func = vtfunc;
  p = ch.vtlist.vt_next;
 8000c1e:	463b      	mov	r3, r7
    systime_t now = port_timer_get_time();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < CH_CFG_ST_TIMEDELTA) {
      delay = CH_CFG_ST_TIMEDELTA;
 8000c20:	2c01      	cmp	r4, #1
  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = ch.vtlist.vt_next;
 8000c22:	f853 5f1c 	ldr.w	r5, [r3, #28]!

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 8000c26:	f8c6 800c 	str.w	r8, [r6, #12]
 8000c2a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    systime_t now = port_timer_get_time();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < CH_CFG_ST_TIMEDELTA) {
      delay = CH_CFG_ST_TIMEDELTA;
 8000c2e:	bf98      	it	ls
 8000c30:	2402      	movls	r4, #2
    }

    if (&ch.vtlist == (virtual_timers_list_t *)p) {
 8000c32:	429d      	cmp	r5, r3
 8000c34:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8000c36:	d022      	beq.n	8000c7e <chVTDoSetI+0x7e>
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
    }
    else {
      /* Now the delay is calculated as delta from the last tick interrupt
         time.*/
      delay += now - ch.vtlist.vt_lasttime;
 8000c38:	6ab8      	ldr	r0, [r7, #40]	; 0x28

      /* If the specified delay is closer in time than the first element
         in the delta list then it becomes the next alarm event in time.*/
      if (delay < p->vt_delta) {
 8000c3a:	68ab      	ldr	r3, [r5, #8]
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
    }
    else {
      /* Now the delay is calculated as delta from the last tick interrupt
         time.*/
      delay += now - ch.vtlist.vt_lasttime;
 8000c3c:	1a12      	subs	r2, r2, r0
 8000c3e:	4414      	add	r4, r2

      /* If the specified delay is closer in time than the first element
         in the delta list then it becomes the next alarm event in time.*/
      if (delay < p->vt_delta) {
 8000c40:	429c      	cmp	r4, r3
 8000c42:	d203      	bcs.n	8000c4c <chVTDoSetI+0x4c>
 8000c44:	e016      	b.n	8000c74 <chVTDoSetI+0x74>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delay) {
    delay -= p->vt_delta;
    p = p->vt_next;
 8000c46:	682d      	ldr	r5, [r5, #0]
#endif /* CH_CFG_ST_TIMEDELTA > 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delay) {
    delay -= p->vt_delta;
 8000c48:	1ae4      	subs	r4, r4, r3
  }
#endif /* CH_CFG_ST_TIMEDELTA > 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delay) {
 8000c4a:	68ab      	ldr	r3, [r5, #8]
 8000c4c:	42a3      	cmp	r3, r4
 8000c4e:	d3fa      	bcc.n	8000c46 <chVTDoSetI+0x46>
    delay -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
 8000c50:	686b      	ldr	r3, [r5, #4]
 8000c52:	6073      	str	r3, [r6, #4]
 8000c54:	6035      	str	r5, [r6, #0]
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
 8000c56:	606e      	str	r6, [r5, #4]
 8000c58:	601e      	str	r6, [r3, #0]
  vtp->vt_delta = delay
 8000c5a:	60b4      	str	r4, [r6, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delay;
 8000c5c:	68a9      	ldr	r1, [r5, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8000c5e:	f04f 33ff 	mov.w	r3, #4294967295
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
  vtp->vt_delta = delay

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delay;
 8000c62:	1b09      	subs	r1, r1, r4
 8000c64:	60a9      	str	r1, [r5, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8000c66:	627b      	str	r3, [r7, #36]	; 0x24
 8000c68:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
  virtual_timer_t *p;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8000c6c:	4808      	ldr	r0, [pc, #32]	; (8000c90 <chVTDoSetI+0x90>)
 8000c6e:	f7ff fc4f 	bl	8000510 <chSysHalt>
 8000c72:	e7d2      	b.n	8000c1a <chVTDoSetI+0x1a>
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8000c74:	4420      	add	r0, r4
 8000c76:	f000 fd43 	bl	8001700 <stSetAlarm>
 8000c7a:	68ab      	ldr	r3, [r5, #8]
 8000c7c:	e7e6      	b.n	8000c4c <chVTDoSetI+0x4c>
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {

  stStartAlarm(time);
 8000c7e:	18a0      	adds	r0, r4, r2
    }

    if (&ch.vtlist == (virtual_timers_list_t *)p) {
      /* The delta list is empty, the current time becomes the new
         delta list base time.*/
      ch.vtlist.vt_lasttime = now;
 8000c80:	62ba      	str	r2, [r7, #40]	; 0x28
 8000c82:	f000 fd1d 	bl	80016c0 <stStartAlarm>
 8000c86:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000c88:	e7e0      	b.n	8000c4c <chVTDoSetI+0x4c>
 8000c8a:	bf00      	nop
 8000c8c:	20000800 	.word	0x20000800
 8000c90:	08002880 	.word	0x08002880
 8000c94:	f3af 8000 	nop.w
 8000c98:	f3af 8000 	nop.w
 8000c9c:	f3af 8000 	nop.w

08000ca0 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8000ca0:	b538      	push	{r3, r4, r5, lr}
 8000ca2:	4604      	mov	r4, r0

  chDbgCheckClassI();
 8000ca4:	f7ff fd1c 	bl	80006e0 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 8000ca8:	b344      	cbz	r4, 8000cfc <chVTDoResetI+0x5c>
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");
 8000caa:	68e3      	ldr	r3, [r4, #12]
 8000cac:	b313      	cbz	r3, 8000cf4 <chVTDoResetI+0x54>

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8000cae:	6822      	ldr	r2, [r4, #0]
 8000cb0:	68a3      	ldr	r3, [r4, #8]
 8000cb2:	6891      	ldr	r1, [r2, #8]
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = (vtfunc_t)NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8000cb4:	4d15      	ldr	r5, [pc, #84]	; (8000d0c <chVTDoResetI+0x6c>)
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
 8000cb6:	6860      	ldr	r0, [r4, #4]
  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8000cb8:	4419      	add	r1, r3
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000cba:	462b      	mov	r3, r5
  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8000cbc:	6091      	str	r1, [r2, #8]
  vtp->vt_prev->vt_next = vtp->vt_next;
 8000cbe:	6002      	str	r2, [r0, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
 8000cc0:	6821      	ldr	r1, [r4, #0]
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000cc2:	f853 2f1c 	ldr.w	r2, [r3, #28]!
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
 8000cc6:	6048      	str	r0, [r1, #4]
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000cc8:	429a      	cmp	r2, r3

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = (vtfunc_t)NULL;
 8000cca:	f04f 0000 	mov.w	r0, #0

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8000cce:	f04f 31ff 	mov.w	r1, #4294967295

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = (vtfunc_t)NULL;
 8000cd2:	60e0      	str	r0, [r4, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8000cd4:	6269      	str	r1, [r5, #36]	; 0x24

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000cd6:	d015      	beq.n	8000d04 <chVTDoResetI+0x64>
      port_timer_stop_alarm();
    }
    else {
      /* Updating the alarm to the next deadline, deadline that must not be
         closer in time than the minimum time delta.*/
      if (ch.vtlist.vt_next->vt_delta >= CH_CFG_ST_TIMEDELTA) {
 8000cd8:	6893      	ldr	r3, [r2, #8]
        port_timer_set_alarm(ch.vtlist.vt_lasttime +
 8000cda:	6aa8      	ldr	r0, [r5, #40]	; 0x28
      port_timer_stop_alarm();
    }
    else {
      /* Updating the alarm to the next deadline, deadline that must not be
         closer in time than the minimum time delta.*/
      if (ch.vtlist.vt_next->vt_delta >= CH_CFG_ST_TIMEDELTA) {
 8000cdc:	2b01      	cmp	r3, #1
 8000cde:	d904      	bls.n	8000cea <chVTDoResetI+0x4a>
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8000ce0:	4418      	add	r0, r3
                             CH_CFG_ST_TIMEDELTA);
      }
    }
  }
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000ce2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8000ce6:	f000 bd0b 	b.w	8001700 <stSetAlarm>
 8000cea:	3002      	adds	r0, #2
 8000cec:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8000cf0:	f000 bd06 	b.w	8001700 <stSetAlarm>
 */
void chVTDoResetI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");
 8000cf4:	4806      	ldr	r0, [pc, #24]	; (8000d10 <chVTDoResetI+0x70>)
 8000cf6:	f7ff fc0b 	bl	8000510 <chSysHalt>
 8000cfa:	e7d8      	b.n	8000cae <chVTDoResetI+0xe>
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
 8000cfc:	4804      	ldr	r0, [pc, #16]	; (8000d10 <chVTDoResetI+0x70>)
 8000cfe:	f7ff fc07 	bl	8000510 <chSysHalt>
 8000d02:	e7d2      	b.n	8000caa <chVTDoResetI+0xa>
                             CH_CFG_ST_TIMEDELTA);
      }
    }
  }
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000d04:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 8000d08:	f000 bcf2 	b.w	80016f0 <stStopAlarm>
 8000d0c:	20000800 	.word	0x20000800
 8000d10:	08002890 	.word	0x08002890
 8000d14:	f3af 8000 	nop.w
 8000d18:	f3af 8000 	nop.w
 8000d1c:	f3af 8000 	nop.w

08000d20 <_thread_init>:
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000d20:	4a17      	ldr	r2, [pc, #92]	; (8000d80 <_thread_init+0x60>)
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8000d22:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000d26:	4604      	mov	r4, r0
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000d28:	6957      	ldr	r7, [r2, #20]
 8000d2a:	6102      	str	r2, [r0, #16]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8000d2c:	2300      	movs	r3, #0
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
 8000d2e:	f104 0c28 	add.w	ip, r4, #40	; 0x28
#endif
#if CH_CFG_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
#endif
#if CH_DBG_ENABLE_STACK_CHECK
  tp->p_stklimit = (stkalign_t *)(tp + 1);
 8000d32:	f104 0e60 	add.w	lr, r4, #96	; 0x60
#endif
#if CH_DBG_STATISTICS || defined(__DOXYGEN__)
  chTMObjectInit(&tp->p_stats);
 8000d36:	f104 0548 	add.w	r5, r4, #72	; 0x48
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
 8000d3a:	f104 062c 	add.w	r6, r4, #44	; 0x2c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8000d3e:	f04f 0802 	mov.w	r8, #2
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 8000d42:	2001      	movs	r0, #1
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8000d44:	60a1      	str	r1, [r4, #8]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
 8000d46:	6421      	str	r1, [r4, #64]	; 0x40
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 8000d48:	f884 0022 	strb.w	r0, [r4, #34]	; 0x22
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000d4c:	6167      	str	r7, [r4, #20]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8000d4e:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000d52:	6154      	str	r4, [r2, #20]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8000d54:	63e3      	str	r3, [r4, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS
  tp->p_epending = 0;
 8000d56:	63a3      	str	r3, [r4, #56]	; 0x38
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
 8000d58:	61a3      	str	r3, [r4, #24]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8000d5a:	f884 8020 	strb.w	r8, [r4, #32]
#endif
#if CH_DBG_ENABLE_STACK_CHECK
  tp->p_stklimit = (stkalign_t *)(tp + 1);
#endif
#if CH_DBG_STATISTICS || defined(__DOXYGEN__)
  chTMObjectInit(&tp->p_stats);
 8000d5e:	4628      	mov	r0, r5
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000d60:	613c      	str	r4, [r7, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8000d62:	f8c4 c028 	str.w	ip, [r4, #40]	; 0x28
#endif
#if CH_CFG_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
#endif
#if CH_DBG_ENABLE_STACK_CHECK
  tp->p_stklimit = (stkalign_t *)(tp + 1);
 8000d66:	f8c4 e01c 	str.w	lr, [r4, #28]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8000d6a:	6326      	str	r6, [r4, #48]	; 0x30
 8000d6c:	62e6      	str	r6, [r4, #44]	; 0x2c
#endif
#if CH_DBG_STATISTICS || defined(__DOXYGEN__)
  chTMObjectInit(&tp->p_stats);
 8000d6e:	f7ff fcff 	bl	8000770 <chTMObjectInit>
  chTMStartMeasurementX(&tp->p_stats);
 8000d72:	4628      	mov	r0, r5
 8000d74:	f7ff fd0c 	bl	8000790 <chTMStartMeasurementX>
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
}
 8000d78:	4620      	mov	r0, r4
 8000d7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000d7e:	bf00      	nop
 8000d80:	20000800 	.word	0x20000800
 8000d84:	f3af 8000 	nop.w
 8000d88:	f3af 8000 	nop.w
 8000d8c:	f3af 8000 	nop.w

08000d90 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 8000d90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000d94:	4604      	mov	r4, r0
 8000d96:	460d      	mov	r5, r1
 8000d98:	4616      	mov	r6, r2
 8000d9a:	461f      	mov	r7, r3
 8000d9c:	f8dd 8018 	ldr.w	r8, [sp, #24]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;

  chDbgCheckClassI();
 8000da0:	f7ff fc9e 	bl	80006e0 <chDbgCheckClassI>
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
 8000da4:	b10c      	cbz	r4, 8000daa <chThdCreateI+0x1a>
 8000da6:	2de7      	cmp	r5, #231	; 0xe7
 8000da8:	d811      	bhi.n	8000dce <chThdCreateI+0x3e>
 8000daa:	480b      	ldr	r0, [pc, #44]	; (8000dd8 <chThdCreateI+0x48>)
 8000dac:	f7ff fbb0 	bl	8000510 <chSysHalt>
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000db0:	f1a5 0324 	sub.w	r3, r5, #36	; 0x24
 8000db4:	18e2      	adds	r2, r4, r3
 8000db6:	4d09      	ldr	r5, [pc, #36]	; (8000ddc <chThdCreateI+0x4c>)
 8000db8:	60e2      	str	r2, [r4, #12]

  return _thread_init(tp, prio);
 8000dba:	4631      	mov	r1, r6

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000dbc:	50e7      	str	r7, [r4, r3]

  return _thread_init(tp, prio);
 8000dbe:	4620      	mov	r0, r4

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000dc0:	f8c2 8004 	str.w	r8, [r2, #4]
 8000dc4:	6215      	str	r5, [r2, #32]

  return _thread_init(tp, prio);
}
 8000dc6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);

  return _thread_init(tp, prio);
 8000dca:	f7ff bfa9 	b.w	8000d20 <_thread_init>
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
 8000dce:	2e7f      	cmp	r6, #127	; 0x7f
 8000dd0:	d8eb      	bhi.n	8000daa <chThdCreateI+0x1a>
 8000dd2:	2f00      	cmp	r7, #0
 8000dd4:	d1ec      	bne.n	8000db0 <chThdCreateI+0x20>
 8000dd6:	e7e8      	b.n	8000daa <chThdCreateI+0x1a>
 8000dd8:	080028d0 	.word	0x080028d0
 8000ddc:	08000271 	.word	0x08000271

08000de0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8000de0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000de4:	b083      	sub	sp, #12
 8000de6:	4680      	mov	r8, r0
 8000de8:	9f0c      	ldr	r7, [sp, #48]	; 0x30
 8000dea:	4689      	mov	r9, r1
 8000dec:	4692      	mov	sl, r2
 8000dee:	469b      	mov	fp, r3
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS
  _thread_memfill((uint8_t *)wsp,
 8000df0:	f100 0560 	add.w	r5, r0, #96	; 0x60
 8000df4:	4604      	mov	r4, r0
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 8000df6:	26ff      	movs	r6, #255	; 0xff
 8000df8:	f804 6b01 	strb.w	r6, [r4], #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000dfc:	42a5      	cmp	r5, r4
 8000dfe:	d1fb      	bne.n	8000df8 <chThdCreateStatic+0x18>
  
#if CH_DBG_FILL_THREADS
  _thread_memfill((uint8_t *)wsp,
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 8000e00:	eb08 0409 	add.w	r4, r8, r9
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000e04:	42a5      	cmp	r5, r4
    *startp++ = v;
 8000e06:	bf38      	it	cc
 8000e08:	2655      	movcc	r6, #85	; 0x55
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000e0a:	d203      	bcs.n	8000e14 <chThdCreateStatic+0x34>
    *startp++ = v;
 8000e0c:	f805 6b01 	strb.w	r6, [r5], #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000e10:	42a5      	cmp	r5, r4
 8000e12:	d1fb      	bne.n	8000e0c <chThdCreateStatic+0x2c>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000e14:	2320      	movs	r3, #32
 8000e16:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void)  {

  port_lock();
  _stats_start_measure_crit_thd();
 8000e1a:	f7ff fd69 	bl	80008f0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8000e1e:	f7ff fbd7 	bl	80005d0 <_dbg_check_lock>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), MSG_OK);
 8000e22:	4652      	mov	r2, sl
 8000e24:	465b      	mov	r3, fp
 8000e26:	4649      	mov	r1, r9
 8000e28:	9700      	str	r7, [sp, #0]
 8000e2a:	4640      	mov	r0, r8
 8000e2c:	f7ff ffb0 	bl	8000d90 <chThdCreateI>
 8000e30:	2100      	movs	r1, #0
 8000e32:	4604      	mov	r4, r0
 8000e34:	f7ff fe4c 	bl	8000ad0 <chSchWakeupS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000e38:	f7ff fbda 	bl	80005f0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8000e3c:	f7ff fd60 	bl	8000900 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert(ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio,
 8000e40:	4b08      	ldr	r3, [pc, #32]	; (8000e64 <chThdCreateStatic+0x84>)
 8000e42:	699a      	ldr	r2, [r3, #24]
 8000e44:	681b      	ldr	r3, [r3, #0]
 8000e46:	6892      	ldr	r2, [r2, #8]
 8000e48:	689b      	ldr	r3, [r3, #8]
 8000e4a:	429a      	cmp	r2, r3
 8000e4c:	d202      	bcs.n	8000e54 <chThdCreateStatic+0x74>
 8000e4e:	4806      	ldr	r0, [pc, #24]	; (8000e68 <chThdCreateStatic+0x88>)
 8000e50:	f7ff fb5e 	bl	8000510 <chSysHalt>
 8000e54:	2300      	movs	r3, #0
 8000e56:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 8000e5a:	4620      	mov	r0, r4
 8000e5c:	b003      	add	sp, #12
 8000e5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000e62:	bf00      	nop
 8000e64:	20000800 	.word	0x20000800
 8000e68:	080028e0 	.word	0x080028e0
 8000e6c:	f3af 8000 	nop.w

08000e70 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8000e70:	b510      	push	{r4, lr}
 8000e72:	2320      	movs	r3, #32
 8000e74:	4604      	mov	r4, r0
 8000e76:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void)  {

  port_lock();
  _stats_start_measure_crit_thd();
 8000e7a:	f7ff fd39 	bl	80008f0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8000e7e:	f7ff fba7 	bl	80005d0 <_dbg_check_lock>
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);
 8000e82:	b914      	cbnz	r4, 8000e8a <chThdSleep+0x1a>
 8000e84:	480c      	ldr	r0, [pc, #48]	; (8000eb8 <chThdSleep+0x48>)
 8000e86:	f7ff fb43 	bl	8000510 <chSysHalt>

  chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8000e8a:	4621      	mov	r1, r4
 8000e8c:	2008      	movs	r0, #8
 8000e8e:	f7ff fdef 	bl	8000a70 <chSchGoSleepTimeoutS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000e92:	f7ff fbad 	bl	80005f0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8000e96:	f7ff fd33 	bl	8000900 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert(ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio,
 8000e9a:	4b08      	ldr	r3, [pc, #32]	; (8000ebc <chThdSleep+0x4c>)
 8000e9c:	699a      	ldr	r2, [r3, #24]
 8000e9e:	681b      	ldr	r3, [r3, #0]
 8000ea0:	6892      	ldr	r2, [r2, #8]
 8000ea2:	689b      	ldr	r3, [r3, #8]
 8000ea4:	429a      	cmp	r2, r3
 8000ea6:	d202      	bcs.n	8000eae <chThdSleep+0x3e>
 8000ea8:	4805      	ldr	r0, [pc, #20]	; (8000ec0 <chThdSleep+0x50>)
 8000eaa:	f7ff fb31 	bl	8000510 <chSysHalt>
 8000eae:	2300      	movs	r3, #0
 8000eb0:	f383 8811 	msr	BASEPRI, r3
 8000eb4:	bd10      	pop	{r4, pc}
 8000eb6:	bf00      	nop
 8000eb8:	080028f0 	.word	0x080028f0
 8000ebc:	20000800 	.word	0x20000800
 8000ec0:	080028e0 	.word	0x080028e0
 8000ec4:	f3af 8000 	nop.w
 8000ec8:	f3af 8000 	nop.w
 8000ecc:	f3af 8000 	nop.w

08000ed0 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8000ed0:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
 8000ed2:	4b10      	ldr	r3, [pc, #64]	; (8000f14 <chThdExitS+0x44>)
 8000ed4:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8000ed6:	6aa3      	ldr	r3, [r4, #40]	; 0x28

  tp->p_u.exitcode = msg;
 8000ed8:	6260      	str	r0, [r4, #36]	; 0x24
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  while (list_notempty(&tp->p_waiting)) {
 8000eda:	f104 0528 	add.w	r5, r4, #40	; 0x28
 8000ede:	429d      	cmp	r5, r3
 8000ee0:	d007      	beq.n	8000ef2 <chThdExitS+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 8000ee2:	681a      	ldr	r2, [r3, #0]
 8000ee4:	62a2      	str	r2, [r4, #40]	; 0x28
    chSchReadyI(list_remove(&tp->p_waiting));
 8000ee6:	4618      	mov	r0, r3
 8000ee8:	f7ff fd32 	bl	8000950 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8000eec:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  while (list_notempty(&tp->p_waiting)) {
 8000eee:	42ab      	cmp	r3, r5
 8000ef0:	d1f7      	bne.n	8000ee2 <chThdExitS+0x12>
  }
#endif
#if CH_CFG_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8000ef2:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8000ef6:	079b      	lsls	r3, r3, #30
 8000ef8:	d104      	bne.n	8000f04 <chThdExitS+0x34>
    REG_REMOVE(tp);
 8000efa:	6963      	ldr	r3, [r4, #20]
 8000efc:	6922      	ldr	r2, [r4, #16]
 8000efe:	611a      	str	r2, [r3, #16]
 8000f00:	6922      	ldr	r2, [r4, #16]
 8000f02:	6153      	str	r3, [r2, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8000f04:	200f      	movs	r0, #15
 8000f06:	f7ff fd83 	bl	8000a10 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 8000f0a:	4803      	ldr	r0, [pc, #12]	; (8000f18 <chThdExitS+0x48>)
}
 8000f0c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 8000f10:	f7ff bafe 	b.w	8000510 <chSysHalt>
 8000f14:	20000800 	.word	0x20000800
 8000f18:	080028c0 	.word	0x080028c0
 8000f1c:	f3af 8000 	nop.w

08000f20 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8000f20:	b510      	push	{r4, lr}
 8000f22:	2320      	movs	r3, #32
 8000f24:	4604      	mov	r4, r0
 8000f26:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void)  {

  port_lock();
  _stats_start_measure_crit_thd();
 8000f2a:	f7ff fce1 	bl	80008f0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8000f2e:	f7ff fb4f 	bl	80005d0 <_dbg_check_lock>

  chSysLock();
  chThdExitS(msg);
 8000f32:	4620      	mov	r0, r4
  /* The thread never returns here.*/
}
 8000f34:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
 8000f38:	f7ff bfca 	b.w	8000ed0 <chThdExitS>
 8000f3c:	f3af 8000 	nop.w

08000f40 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 8000f40:	b169      	cbz	r1, 8000f5e <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000f42:	4b08      	ldr	r3, [pc, #32]	; (8000f64 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8000f44:	b410      	push	{r4}
 8000f46:	4602      	mov	r2, r0
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8000f48:	6844      	ldr	r4, [r0, #4]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000f4a:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000f4c:	2004      	movs	r0, #4
 8000f4e:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->p_prev->p_next = tqp->p_prev = tp;
 8000f52:	6053      	str	r3, [r2, #4]
 8000f54:	6023      	str	r3, [r4, #0]
}
 8000f56:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000f5a:	f7ff bd89 	b.w	8000a70 <chSchGoSleepTimeoutS>
}
 8000f5e:	f04f 30ff 	mov.w	r0, #4294967295
 8000f62:	4770      	bx	lr
 8000f64:	20000800 	.word	0x20000800
 8000f68:	f3af 8000 	nop.w
 8000f6c:	f3af 8000 	nop.w

08000f70 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8000f70:	b538      	push	{r3, r4, r5, lr}
 *
 * @notapi
 */
static inline bool queue_notempty(threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (thread_t *)tqp);
 8000f72:	6804      	ldr	r4, [r0, #0]

  if (queue_notempty(tqp)) {
 8000f74:	42a0      	cmp	r0, r4
 8000f76:	d010      	beq.n	8000f9a <chThdDequeueNextI+0x2a>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8000f78:	6823      	ldr	r3, [r4, #0]
 8000f7a:	6003      	str	r3, [r0, #0]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 8000f7c:	f894 2020 	ldrb.w	r2, [r4, #32]
 8000f80:	6058      	str	r0, [r3, #4]
 8000f82:	2a04      	cmp	r2, #4
 8000f84:	460d      	mov	r5, r1
 8000f86:	d002      	beq.n	8000f8e <chThdDequeueNextI+0x1e>
 8000f88:	4804      	ldr	r0, [pc, #16]	; (8000f9c <chThdDequeueNextI+0x2c>)
 8000f8a:	f7ff fac1 	bl	8000510 <chSysHalt>

  tp->p_u.rdymsg = msg;
 8000f8e:	6265      	str	r5, [r4, #36]	; 0x24
  chSchReadyI(tp);
 8000f90:	4620      	mov	r0, r4
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8000f92:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8000f96:	f7ff bcdb 	b.w	8000950 <chSchReadyI>
 8000f9a:	bd38      	pop	{r3, r4, r5, pc}
 8000f9c:	080028a0 	.word	0x080028a0

08000fa0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8000fa0:	b510      	push	{r4, lr}

  chDbgCheck(mp != NULL);
 8000fa2:	4604      	mov	r4, r0
 8000fa4:	b120      	cbz	r0, 8000fb0 <chMtxObjectInit+0x10>

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 8000fa6:	2300      	movs	r3, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8000fa8:	6064      	str	r4, [r4, #4]
 8000faa:	6024      	str	r4, [r4, #0]
 8000fac:	60a3      	str	r3, [r4, #8]
 8000fae:	bd10      	pop	{r4, pc}
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);
 8000fb0:	4801      	ldr	r0, [pc, #4]	; (8000fb8 <chMtxObjectInit+0x18>)
 8000fb2:	f7ff faad 	bl	8000510 <chSysHalt>
 8000fb6:	e7f6      	b.n	8000fa6 <chMtxObjectInit+0x6>
 8000fb8:	08002920 	.word	0x08002920
 8000fbc:	f3af 8000 	nop.w

08000fc0 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8000fc0:	b538      	push	{r3, r4, r5, lr}
 8000fc2:	4604      	mov	r4, r0
 8000fc4:	460d      	mov	r5, r1

  chDbgCheckClassI();
 8000fc6:	f7ff fb8b 	bl	80006e0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8000fca:	b1cc      	cbz	r4, 8001000 <chEvtSignalI+0x40>

  tp->p_epending |= events;
 8000fcc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000fce:	f894 2020 	ldrb.w	r2, [r4, #32]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8000fd2:	ea45 0103 	orr.w	r1, r5, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000fd6:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8000fd8:	63a1      	str	r1, [r4, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000fda:	d00d      	beq.n	8000ff8 <chEvtSignalI+0x38>
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
 8000fdc:	2a0b      	cmp	r2, #11
 8000fde:	d000      	beq.n	8000fe2 <chEvtSignalI+0x22>
 8000fe0:	bd38      	pop	{r3, r4, r5, pc}
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8000fe2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000fe4:	4019      	ands	r1, r3

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8000fe6:	428b      	cmp	r3, r1
 8000fe8:	d1fa      	bne.n	8000fe0 <chEvtSignalI+0x20>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8000fea:	2300      	movs	r3, #0
 8000fec:	6263      	str	r3, [r4, #36]	; 0x24
    chSchReadyI(tp);
 8000fee:	4620      	mov	r0, r4
  }
}
 8000ff0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
    chSchReadyI(tp);
 8000ff4:	f7ff bcac 	b.w	8000950 <chSchReadyI>
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
 8000ff8:	6a63      	ldr	r3, [r4, #36]	; 0x24
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000ffa:	4219      	tst	r1, r3
 8000ffc:	d1f5      	bne.n	8000fea <chEvtSignalI+0x2a>
 8000ffe:	bd38      	pop	{r3, r4, r5, pc}
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
 8001000:	4801      	ldr	r0, [pc, #4]	; (8001008 <chEvtSignalI+0x48>)
 8001002:	f7ff fa85 	bl	8000510 <chSysHalt>
 8001006:	e7e1      	b.n	8000fcc <chEvtSignalI+0xc>
 8001008:	08002950 	.word	0x08002950
 800100c:	f3af 8000 	nop.w

08001010 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8001010:	b570      	push	{r4, r5, r6, lr}
 8001012:	4606      	mov	r6, r0
 8001014:	460d      	mov	r5, r1
  event_listener_t *elp;

  chDbgCheckClassI();
 8001016:	f7ff fb63 	bl	80006e0 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 800101a:	b18e      	cbz	r6, 8001040 <chEvtBroadcastFlagsI+0x30>

  elp = esp->es_next;
 800101c:	6834      	ldr	r4, [r6, #0]
  while (elp != (event_listener_t *)esp) {
 800101e:	42a6      	cmp	r6, r4
 8001020:	d00d      	beq.n	800103e <chEvtBroadcastFlagsI+0x2e>
    elp->el_flags |= flags;
 8001022:	68e3      	ldr	r3, [r4, #12]
 8001024:	432b      	orrs	r3, r5
 8001026:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == 0) || ((elp->el_flags & elp->el_wflags) != 0)) {
 8001028:	b115      	cbz	r5, 8001030 <chEvtBroadcastFlagsI+0x20>
 800102a:	6922      	ldr	r2, [r4, #16]
 800102c:	4213      	tst	r3, r2
 800102e:	d003      	beq.n	8001038 <chEvtBroadcastFlagsI+0x28>
      chEvtSignalI(elp->el_listener, elp->el_events);
 8001030:	6860      	ldr	r0, [r4, #4]
 8001032:	68a1      	ldr	r1, [r4, #8]
 8001034:	f7ff ffc4 	bl	8000fc0 <chEvtSignalI>
    }
    elp = elp->el_next;
 8001038:	6824      	ldr	r4, [r4, #0]

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  while (elp != (event_listener_t *)esp) {
 800103a:	42a6      	cmp	r6, r4
 800103c:	d1f1      	bne.n	8001022 <chEvtBroadcastFlagsI+0x12>
 800103e:	bd70      	pop	{r4, r5, r6, pc}
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);
 8001040:	4801      	ldr	r0, [pc, #4]	; (8001048 <chEvtBroadcastFlagsI+0x38>)
 8001042:	f7ff fa65 	bl	8000510 <chSysHalt>
 8001046:	e7e9      	b.n	800101c <chEvtBroadcastFlagsI+0xc>
 8001048:	08002930 	.word	0x08002930
 800104c:	f3af 8000 	nop.w

08001050 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 8001050:	b430      	push	{r4, r5}
 8001052:	9c02      	ldr	r4, [sp, #8]
  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
  iqp->q_top = bp + size;
  iqp->q_notify = infy;
  iqp->q_link = link;
 8001054:	6204      	str	r4, [r0, #32]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8001056:	2500      	movs	r5, #0
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
  iqp->q_top = bp + size;
 8001058:	440a      	add	r2, r1
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 800105a:	6085      	str	r5, [r0, #8]
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
  iqp->q_top = bp + size;
 800105c:	6102      	str	r2, [r0, #16]
 800105e:	6040      	str	r0, [r0, #4]
 8001060:	6000      	str	r0, [r0, #0]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
 8001062:	6141      	str	r1, [r0, #20]
 8001064:	6181      	str	r1, [r0, #24]
 8001066:	60c1      	str	r1, [r0, #12]
  iqp->q_top = bp + size;
  iqp->q_notify = infy;
 8001068:	61c3      	str	r3, [r0, #28]
  iqp->q_link = link;
}
 800106a:	bc30      	pop	{r4, r5}
 800106c:	4770      	bx	lr
 800106e:	bf00      	nop

08001070 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 8001070:	b538      	push	{r3, r4, r5, lr}
 8001072:	4604      	mov	r4, r0
 8001074:	460d      	mov	r5, r1

  chDbgCheckClassI();
 8001076:	f7ff fb33 	bl	80006e0 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();
 800107a:	f7ff fb31 	bl	80006e0 <chDbgCheckClassI>

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0));
 800107e:	69a3      	ldr	r3, [r4, #24]
 8001080:	6962      	ldr	r2, [r4, #20]
 8001082:	429a      	cmp	r2, r3
 8001084:	68a3      	ldr	r3, [r4, #8]
 8001086:	d010      	beq.n	80010aa <chIQPutI+0x3a>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8001088:	3301      	adds	r3, #1
  *iqp->q_wrptr++ = b;
 800108a:	1c51      	adds	r1, r2, #1

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 800108c:	60a3      	str	r3, [r4, #8]
  *iqp->q_wrptr++ = b;
 800108e:	6161      	str	r1, [r4, #20]
 8001090:	7015      	strb	r5, [r2, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8001092:	6962      	ldr	r2, [r4, #20]
 8001094:	6923      	ldr	r3, [r4, #16]
 8001096:	429a      	cmp	r2, r3
 8001098:	d301      	bcc.n	800109e <chIQPutI+0x2e>
    iqp->q_wrptr = iqp->q_buffer;
 800109a:	68e3      	ldr	r3, [r4, #12]
 800109c:	6163      	str	r3, [r4, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 800109e:	4620      	mov	r0, r4
 80010a0:	2100      	movs	r1, #0
 80010a2:	f7ff ff65 	bl	8000f70 <chThdDequeueNextI>

  return Q_OK;
 80010a6:	2000      	movs	r0, #0
 80010a8:	bd38      	pop	{r3, r4, r5, pc}
 80010aa:	2b00      	cmp	r3, #0
 80010ac:	d0ec      	beq.n	8001088 <chIQPutI+0x18>
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
 80010ae:	f06f 0003 	mvn.w	r0, #3
 80010b2:	bd38      	pop	{r3, r4, r5, pc}
 80010b4:	f3af 8000 	nop.w
 80010b8:	f3af 8000 	nop.w
 80010bc:	f3af 8000 	nop.w

080010c0 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t time) {
 80010c0:	b570      	push	{r4, r5, r6, lr}
 80010c2:	2320      	movs	r3, #32
 80010c4:	4604      	mov	r4, r0
 80010c6:	460e      	mov	r6, r1
 80010c8:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void)  {

  port_lock();
  _stats_start_measure_crit_thd();
 80010cc:	f7ff fc10 	bl	80008f0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 80010d0:	f7ff fa7e 	bl	80005d0 <_dbg_check_lock>
  uint8_t b;

  chSysLock();
  if (iqp->q_notify) {
 80010d4:	69e3      	ldr	r3, [r4, #28]
 80010d6:	b133      	cbz	r3, 80010e6 <chIQGetTimeout+0x26>
    iqp->q_notify(iqp);
 80010d8:	4620      	mov	r0, r4
 80010da:	4798      	blx	r3
 80010dc:	e003      	b.n	80010e6 <chIQGetTimeout+0x26>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg;
    if ((msg = chThdEnqueueTimeoutS(&iqp->q_waiting, time)) < Q_OK) {
 80010de:	f7ff ff2f 	bl	8000f40 <chThdEnqueueTimeoutS>
 80010e2:	1e05      	subs	r5, r0, #0
 80010e4:	db12      	blt.n	800110c <chIQGetTimeout+0x4c>
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 80010e6:	f7ff fafb 	bl	80006e0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) <= 0);
 80010ea:	68a3      	ldr	r3, [r4, #8]
 80010ec:	4620      	mov	r0, r4
 80010ee:	4631      	mov	r1, r6
  chSysLock();
  if (iqp->q_notify) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 80010f0:	2b00      	cmp	r3, #0
 80010f2:	d0f4      	beq.n	80010de <chIQGetTimeout+0x1e>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 80010f4:	69a1      	ldr	r1, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
 80010f6:	6920      	ldr	r0, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 80010f8:	1c4a      	adds	r2, r1, #1
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 80010fa:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 80010fc:	4282      	cmp	r2, r0
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 80010fe:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 8001100:	61a2      	str	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8001102:	bf28      	it	cs
 8001104:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8001106:	780d      	ldrb	r5, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8001108:	bf28      	it	cs
 800110a:	61a3      	strcs	r3, [r4, #24]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800110c:	f7ff fa70 	bl	80005f0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8001110:	f7ff fbf6 	bl	8000900 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert(ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio,
 8001114:	4b07      	ldr	r3, [pc, #28]	; (8001134 <chIQGetTimeout+0x74>)
 8001116:	699a      	ldr	r2, [r3, #24]
 8001118:	681b      	ldr	r3, [r3, #0]
 800111a:	6892      	ldr	r2, [r2, #8]
 800111c:	689b      	ldr	r3, [r3, #8]
 800111e:	429a      	cmp	r2, r3
 8001120:	d202      	bcs.n	8001128 <chIQGetTimeout+0x68>
 8001122:	4805      	ldr	r0, [pc, #20]	; (8001138 <chIQGetTimeout+0x78>)
 8001124:	f7ff f9f4 	bl	8000510 <chSysHalt>
 8001128:	2300      	movs	r3, #0
 800112a:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return b;
 800112e:	4628      	mov	r0, r5
}
 8001130:	bd70      	pop	{r4, r5, r6, pc}
 8001132:	bf00      	nop
 8001134:	20000800 	.word	0x20000800
 8001138:	08002990 	.word	0x08002990
 800113c:	f3af 8000 	nop.w

08001140 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t time) {
 8001140:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001144:	4604      	mov	r4, r0
 8001146:	b083      	sub	sp, #12
 8001148:	4689      	mov	r9, r1
 800114a:	461d      	mov	r5, r3
  qnotify_t nfy = iqp->q_notify;
 800114c:	f8d0 801c 	ldr.w	r8, [r0, #28]
  size_t r = 0;

  chDbgCheck(n > 0);
 8001150:	4692      	mov	sl, r2
 8001152:	2a00      	cmp	r2, #0
 8001154:	d059      	beq.n	800120a <chIQReadTimeout+0xca>
 8001156:	f04f 0b20 	mov.w	fp, #32
 800115a:	f38b 8811 	msr	BASEPRI, fp
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t time) {
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;
 800115e:	2600      	movs	r6, #0
 8001160:	4f2c      	ldr	r7, [pc, #176]	; (8001214 <chIQReadTimeout+0xd4>)
 * @special
 */
static inline void chSysLock(void)  {

  port_lock();
  _stats_start_measure_crit_thd();
 8001162:	f7ff fbc5 	bl	80008f0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8001166:	f7ff fa33 	bl	80005d0 <_dbg_check_lock>
 800116a:	f8cd b004 	str.w	fp, [sp, #4]
 800116e:	46b3      	mov	fp, r6

  chDbgCheck(n > 0);

  chSysLock();
  while (true) {
    if (nfy) {
 8001170:	f1b8 0f00 	cmp.w	r8, #0
 8001174:	d006      	beq.n	8001184 <chIQReadTimeout+0x44>
      nfy(iqp);
 8001176:	4620      	mov	r0, r4
 8001178:	47c0      	blx	r8
 800117a:	e003      	b.n	8001184 <chIQReadTimeout+0x44>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, time) != Q_OK) {
 800117c:	f7ff fee0 	bl	8000f40 <chThdEnqueueTimeoutS>
 8001180:	2800      	cmp	r0, #0
 8001182:	d12e      	bne.n	80011e2 <chIQReadTimeout+0xa2>
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8001184:	f7ff faac 	bl	80006e0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) <= 0);
 8001188:	68a3      	ldr	r3, [r4, #8]
 800118a:	4620      	mov	r0, r4
 800118c:	4629      	mov	r1, r5
  while (true) {
    if (nfy) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 800118e:	2b00      	cmp	r3, #0
 8001190:	d0f4      	beq.n	800117c <chIQReadTimeout+0x3c>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8001192:	69a2      	ldr	r2, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8001194:	3b01      	subs	r3, #1
    *bp++ = *iqp->q_rdptr++;
 8001196:	1c51      	adds	r1, r2, #1
 8001198:	61a1      	str	r1, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 800119a:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 800119c:	7813      	ldrb	r3, [r2, #0]
 800119e:	f809 3b01 	strb.w	r3, [r9], #1
    if (iqp->q_rdptr >= iqp->q_top)
 80011a2:	6923      	ldr	r3, [r4, #16]
 80011a4:	69a2      	ldr	r2, [r4, #24]
 80011a6:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 80011a8:	bf24      	itt	cs
 80011aa:	68e3      	ldrcs	r3, [r4, #12]
 80011ac:	61a3      	strcs	r3, [r4, #24]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80011ae:	f7ff fa1f 	bl	80005f0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80011b2:	f7ff fba5 	bl	8000900 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert(ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio,
 80011b6:	69ba      	ldr	r2, [r7, #24]
 80011b8:	683b      	ldr	r3, [r7, #0]
 80011ba:	6892      	ldr	r2, [r2, #8]
 80011bc:	689b      	ldr	r3, [r3, #8]
 80011be:	429a      	cmp	r2, r3
 80011c0:	d202      	bcs.n	80011c8 <chIQReadTimeout+0x88>
 80011c2:	4815      	ldr	r0, [pc, #84]	; (8001218 <chIQReadTimeout+0xd8>)
 80011c4:	f7ff f9a4 	bl	8000510 <chSysHalt>
 80011c8:	f38b 8811 	msr	BASEPRI, fp

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    r++;
 80011cc:	3601      	adds	r6, #1
    if (--n == 0) {
 80011ce:	45b2      	cmp	sl, r6
 80011d0:	d017      	beq.n	8001202 <chIQReadTimeout+0xc2>
 80011d2:	9b01      	ldr	r3, [sp, #4]
 80011d4:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void)  {

  port_lock();
  _stats_start_measure_crit_thd();
 80011d8:	f7ff fb8a 	bl	80008f0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 80011dc:	f7ff f9f8 	bl	80005d0 <_dbg_check_lock>
 80011e0:	e7c6      	b.n	8001170 <chIQReadTimeout+0x30>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80011e2:	f7ff fa05 	bl	80005f0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80011e6:	f7ff fb8b 	bl	8000900 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert(ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio,
 80011ea:	69ba      	ldr	r2, [r7, #24]
 80011ec:	683b      	ldr	r3, [r7, #0]
 80011ee:	6892      	ldr	r2, [r2, #8]
 80011f0:	689b      	ldr	r3, [r3, #8]
 80011f2:	429a      	cmp	r2, r3
 80011f4:	d202      	bcs.n	80011fc <chIQReadTimeout+0xbc>
 80011f6:	4808      	ldr	r0, [pc, #32]	; (8001218 <chIQReadTimeout+0xd8>)
 80011f8:	f7ff f98a 	bl	8000510 <chSysHalt>
 80011fc:	2300      	movs	r3, #0
 80011fe:	f383 8811 	msr	BASEPRI, r3
      return r;
    }

    chSysLock();
  }
}
 8001202:	4630      	mov	r0, r6
 8001204:	b003      	add	sp, #12
 8001206:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t time) {
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;

  chDbgCheck(n > 0);
 800120a:	4804      	ldr	r0, [pc, #16]	; (800121c <chIQReadTimeout+0xdc>)
 800120c:	f7ff f980 	bl	8000510 <chSysHalt>
 8001210:	e7a1      	b.n	8001156 <chIQReadTimeout+0x16>
 8001212:	bf00      	nop
 8001214:	20000800 	.word	0x20000800
 8001218:	08002990 	.word	0x08002990
 800121c:	08002980 	.word	0x08002980

08001220 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 8001220:	b430      	push	{r4, r5}
 8001222:	9c02      	ldr	r4, [sp, #8]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
  oqp->q_top = bp + size;
  oqp->q_notify = onfy;
  oqp->q_link = link;
 8001224:	6204      	str	r4, [r0, #32]
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
  oqp->q_top = bp + size;
 8001226:	188d      	adds	r5, r1, r2
 8001228:	6105      	str	r5, [r0, #16]
 800122a:	6040      	str	r0, [r0, #4]
 800122c:	6000      	str	r0, [r0, #0]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 800122e:	6082      	str	r2, [r0, #8]
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
 8001230:	6141      	str	r1, [r0, #20]
 8001232:	6181      	str	r1, [r0, #24]
 8001234:	60c1      	str	r1, [r0, #12]
  oqp->q_top = bp + size;
  oqp->q_notify = onfy;
 8001236:	61c3      	str	r3, [r0, #28]
  oqp->q_link = link;
}
 8001238:	bc30      	pop	{r4, r5}
 800123a:	4770      	bx	lr
 800123c:	f3af 8000 	nop.w

08001240 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t time) {
 8001240:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001242:	4604      	mov	r4, r0
 8001244:	460f      	mov	r7, r1
 8001246:	4616      	mov	r6, r2
 8001248:	2320      	movs	r3, #32
 800124a:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void)  {

  port_lock();
  _stats_start_measure_crit_thd();
 800124e:	f7ff fb4f 	bl	80008f0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8001252:	f7ff f9bd 	bl	80005d0 <_dbg_check_lock>
 8001256:	e003      	b.n	8001260 <chOQPutTimeout+0x20>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg;

    if ((msg = chThdEnqueueTimeoutS(&oqp->q_waiting, time)) < Q_OK) {
 8001258:	f7ff fe72 	bl	8000f40 <chThdEnqueueTimeoutS>
 800125c:	1e05      	subs	r5, r0, #0
 800125e:	db25      	blt.n	80012ac <chOQPutTimeout+0x6c>
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 8001260:	f7ff fa3e 	bl	80006e0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) <= 0);
 8001264:	68a3      	ldr	r3, [r4, #8]
 8001266:	4620      	mov	r0, r4
 8001268:	4631      	mov	r1, r6
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t time) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 800126a:	2b00      	cmp	r3, #0
 800126c:	d0f4      	beq.n	8001258 <chOQPutTimeout+0x18>
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 800126e:	6962      	ldr	r2, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8001270:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 8001272:	1c51      	adds	r1, r2, #1
 8001274:	6161      	str	r1, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8001276:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8001278:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 800127a:	6923      	ldr	r3, [r4, #16]
 800127c:	6962      	ldr	r2, [r4, #20]
 800127e:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8001280:	bf24      	itt	cs
 8001282:	68e3      	ldrcs	r3, [r4, #12]
 8001284:	6163      	strcs	r3, [r4, #20]
  }

  if (oqp->q_notify) {
 8001286:	69e3      	ldr	r3, [r4, #28]
 8001288:	b10b      	cbz	r3, 800128e <chOQPutTimeout+0x4e>
    oqp->q_notify(oqp);
 800128a:	4620      	mov	r0, r4
 800128c:	4798      	blx	r3
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800128e:	f7ff f9af 	bl	80005f0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8001292:	f7ff fb35 	bl	8000900 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert(ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio,
 8001296:	4b12      	ldr	r3, [pc, #72]	; (80012e0 <chOQPutTimeout+0xa0>)
 8001298:	699a      	ldr	r2, [r3, #24]
 800129a:	681b      	ldr	r3, [r3, #0]
 800129c:	6892      	ldr	r2, [r2, #8]
 800129e:	689b      	ldr	r3, [r3, #8]
 80012a0:	429a      	cmp	r2, r3
 80012a2:	d316      	bcc.n	80012d2 <chOQPutTimeout+0x92>
 80012a4:	2000      	movs	r0, #0
 80012a6:	f380 8811 	msr	BASEPRI, r0
  }
  chSysUnlock();

  return Q_OK;
}
 80012aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80012ac:	f7ff f9a0 	bl	80005f0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80012b0:	f7ff fb26 	bl	8000900 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert(ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio,
 80012b4:	4b0a      	ldr	r3, [pc, #40]	; (80012e0 <chOQPutTimeout+0xa0>)
 80012b6:	699a      	ldr	r2, [r3, #24]
 80012b8:	681b      	ldr	r3, [r3, #0]
 80012ba:	6892      	ldr	r2, [r2, #8]
 80012bc:	689b      	ldr	r3, [r3, #8]
 80012be:	429a      	cmp	r2, r3
 80012c0:	d202      	bcs.n	80012c8 <chOQPutTimeout+0x88>
 80012c2:	4808      	ldr	r0, [pc, #32]	; (80012e4 <chOQPutTimeout+0xa4>)
 80012c4:	f7ff f924 	bl	8000510 <chSysHalt>
 80012c8:	2300      	movs	r3, #0
 80012ca:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg;

    if ((msg = chThdEnqueueTimeoutS(&oqp->q_waiting, time)) < Q_OK) {
 80012ce:	4628      	mov	r0, r5
      chSysUnlock();
      return msg;
 80012d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80012d2:	4804      	ldr	r0, [pc, #16]	; (80012e4 <chOQPutTimeout+0xa4>)
 80012d4:	f7ff f91c 	bl	8000510 <chSysHalt>
 80012d8:	2000      	movs	r0, #0
 80012da:	f380 8811 	msr	BASEPRI, r0
    oqp->q_notify(oqp);
  }
  chSysUnlock();

  return Q_OK;
}
 80012de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80012e0:	20000800 	.word	0x20000800
 80012e4:	08002990 	.word	0x08002990
 80012e8:	f3af 8000 	nop.w
 80012ec:	f3af 8000 	nop.w

080012f0 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 80012f0:	b538      	push	{r3, r4, r5, lr}
 80012f2:	4604      	mov	r4, r0
  uint8_t b;

  chDbgCheckClassI();
 80012f4:	f7ff f9f4 	bl	80006e0 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();
 80012f8:	f7ff f9f2 	bl	80006e0 <chDbgCheckClassI>

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0));
 80012fc:	6963      	ldr	r3, [r4, #20]
 80012fe:	69a2      	ldr	r2, [r4, #24]
 8001300:	4293      	cmp	r3, r2
 8001302:	68a3      	ldr	r3, [r4, #8]
 8001304:	d00f      	beq.n	8001326 <chOQGetI+0x36>
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 8001306:	6920      	ldr	r0, [r4, #16]
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8001308:	1c51      	adds	r1, r2, #1

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 800130a:	3301      	adds	r3, #1
 800130c:	60a3      	str	r3, [r4, #8]
  b = *oqp->q_rdptr++;
 800130e:	61a1      	str	r1, [r4, #24]
  if (oqp->q_rdptr >= oqp->q_top) {
 8001310:	4281      	cmp	r1, r0
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8001312:	7815      	ldrb	r5, [r2, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 8001314:	d301      	bcc.n	800131a <chOQGetI+0x2a>
    oqp->q_rdptr = oqp->q_buffer;
 8001316:	68e3      	ldr	r3, [r4, #12]
 8001318:	61a3      	str	r3, [r4, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 800131a:	4620      	mov	r0, r4
 800131c:	2100      	movs	r1, #0
 800131e:	f7ff fe27 	bl	8000f70 <chThdDequeueNextI>

  return b;
 8001322:	4628      	mov	r0, r5
 8001324:	bd38      	pop	{r3, r4, r5, pc}
 8001326:	2b00      	cmp	r3, #0
 8001328:	d0ed      	beq.n	8001306 <chOQGetI+0x16>
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
 800132a:	f06f 0002 	mvn.w	r0, #2
 800132e:	bd38      	pop	{r3, r4, r5, pc}

08001330 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t time) {
 8001330:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001334:	b083      	sub	sp, #12
 8001336:	4683      	mov	fp, r0
 8001338:	460c      	mov	r4, r1
 800133a:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 800133c:	f8d0 901c 	ldr.w	r9, [r0, #28]
  size_t w = 0;

  chDbgCheck(n > 0);
 8001340:	4615      	mov	r5, r2
 8001342:	2a00      	cmp	r2, #0
 8001344:	d060      	beq.n	8001408 <chOQWriteTimeout+0xd8>
 8001346:	f04f 0a20 	mov.w	sl, #32
 800134a:	f38a 8811 	msr	BASEPRI, sl
 * @special
 */
static inline void chSysLock(void)  {

  port_lock();
  _stats_start_measure_crit_thd();
 800134e:	f7ff facf 	bl	80008f0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8001352:	f7ff f93d 	bl	80005d0 <_dbg_check_lock>
 8001356:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 8001428 <chOQWriteTimeout+0xf8>
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t time) {
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;
 800135a:	2700      	movs	r7, #0
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 800135c:	f7ff f9c0 	bl	80006e0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) <= 0);
 8001360:	f8db 3008 	ldr.w	r3, [fp, #8]
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8001364:	1c66      	adds	r6, r4, #1
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 8001366:	1e5a      	subs	r2, r3, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy) {
      nfy(oqp);
 8001368:	4658      	mov	r0, fp

  chDbgCheck(n > 0);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 800136a:	b3a3      	cbz	r3, 80013d6 <chOQWriteTimeout+0xa6>
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 800136c:	f8db 3014 	ldr.w	r3, [fp, #20]
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 8001370:	f8cb 2008 	str.w	r2, [fp, #8]
    *oqp->q_wrptr++ = *bp++;
 8001374:	1c5a      	adds	r2, r3, #1
 8001376:	f8cb 2014 	str.w	r2, [fp, #20]
 800137a:	7822      	ldrb	r2, [r4, #0]
 800137c:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 800137e:	f8db 3010 	ldr.w	r3, [fp, #16]
 8001382:	f8db 2014 	ldr.w	r2, [fp, #20]
 8001386:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 8001388:	bf24      	itt	cs
 800138a:	f8db 300c 	ldrcs.w	r3, [fp, #12]
 800138e:	f8cb 3014 	strcs.w	r3, [fp, #20]
    }

    if (nfy) {
 8001392:	f1b9 0f00 	cmp.w	r9, #0
 8001396:	d000      	beq.n	800139a <chOQWriteTimeout+0x6a>
      nfy(oqp);
 8001398:	47c8      	blx	r9
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800139a:	f7ff f929 	bl	80005f0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800139e:	f7ff faaf 	bl	8000900 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert(ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio,
 80013a2:	f8d8 2018 	ldr.w	r2, [r8, #24]
 80013a6:	f8d8 3000 	ldr.w	r3, [r8]
 80013aa:	6892      	ldr	r2, [r2, #8]
 80013ac:	689b      	ldr	r3, [r3, #8]
 80013ae:	429a      	cmp	r2, r3
 80013b0:	d202      	bcs.n	80013b8 <chOQWriteTimeout+0x88>
 80013b2:	481b      	ldr	r0, [pc, #108]	; (8001420 <chOQWriteTimeout+0xf0>)
 80013b4:	f7ff f8ac 	bl	8000510 <chSysHalt>
 80013b8:	2300      	movs	r3, #0
 80013ba:	f383 8811 	msr	BASEPRI, r3
    }

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    w++;
    if (--n == 0) {
 80013be:	3d01      	subs	r5, #1
    if (nfy) {
      nfy(oqp);
    }

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    w++;
 80013c0:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0) {
 80013c4:	d01c      	beq.n	8001400 <chOQWriteTimeout+0xd0>
 80013c6:	f38a 8811 	msr	BASEPRI, sl
 * @special
 */
static inline void chSysLock(void)  {

  port_lock();
  _stats_start_measure_crit_thd();
 80013ca:	f7ff fa91 	bl	80008f0 <_stats_start_measure_crit_thd>
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 80013ce:	4634      	mov	r4, r6
  _dbg_check_lock();
 80013d0:	f7ff f8fe 	bl	80005d0 <_dbg_check_lock>
 80013d4:	e7c2      	b.n	800135c <chOQWriteTimeout+0x2c>
  chDbgCheck(n > 0);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
 80013d6:	4658      	mov	r0, fp
 80013d8:	9901      	ldr	r1, [sp, #4]
 80013da:	f7ff fdb1 	bl	8000f40 <chThdEnqueueTimeoutS>
 80013de:	2800      	cmp	r0, #0
 80013e0:	d0bc      	beq.n	800135c <chOQWriteTimeout+0x2c>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80013e2:	f7ff f905 	bl	80005f0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80013e6:	f7ff fa8b 	bl	8000900 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert(ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio,
 80013ea:	f8d8 2018 	ldr.w	r2, [r8, #24]
 80013ee:	f8d8 3000 	ldr.w	r3, [r8]
 80013f2:	6892      	ldr	r2, [r2, #8]
 80013f4:	689b      	ldr	r3, [r3, #8]
 80013f6:	429a      	cmp	r2, r3
 80013f8:	d30a      	bcc.n	8001410 <chOQWriteTimeout+0xe0>
 80013fa:	2300      	movs	r3, #0
 80013fc:	f383 8811 	msr	BASEPRI, r3
    if (--n == 0) {
      return w;
    }
    chSysLock();
  }
}
 8001400:	4638      	mov	r0, r7
 8001402:	b003      	add	sp, #12
 8001404:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t time) {
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;

  chDbgCheck(n > 0);
 8001408:	4806      	ldr	r0, [pc, #24]	; (8001424 <chOQWriteTimeout+0xf4>)
 800140a:	f7ff f881 	bl	8000510 <chSysHalt>
 800140e:	e79a      	b.n	8001346 <chOQWriteTimeout+0x16>
 8001410:	4803      	ldr	r0, [pc, #12]	; (8001420 <chOQWriteTimeout+0xf0>)
 8001412:	f7ff f87d 	bl	8000510 <chSysHalt>
 8001416:	2300      	movs	r3, #0
 8001418:	f383 8811 	msr	BASEPRI, r3
 800141c:	e7f0      	b.n	8001400 <chOQWriteTimeout+0xd0>
 800141e:	bf00      	nop
 8001420:	08002990 	.word	0x08002990
 8001424:	08002960 	.word	0x08002960
 8001428:	20000800 	.word	0x20000800
 800142c:	f3af 8000 	nop.w

08001430 <_core_init>:
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001430:	4a05      	ldr	r2, [pc, #20]	; (8001448 <_core_init+0x18>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001432:	4b06      	ldr	r3, [pc, #24]	; (800144c <_core_init+0x1c>)
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001434:	4806      	ldr	r0, [pc, #24]	; (8001450 <_core_init+0x20>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001436:	4907      	ldr	r1, [pc, #28]	; (8001454 <_core_init+0x24>)
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001438:	f022 0207 	bic.w	r2, r2, #7
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800143c:	f023 0307 	bic.w	r3, r3, #7
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001440:	6002      	str	r2, [r0, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001442:	600b      	str	r3, [r1, #0]
 8001444:	4770      	bx	lr
 8001446:	bf00      	nop
 8001448:	20001387 	.word	0x20001387
 800144c:	2001c000 	.word	0x2001c000
 8001450:	20000ddc 	.word	0x20000ddc
 8001454:	20000dd8 	.word	0x20000dd8
 8001458:	f3af 8000 	nop.w
 800145c:	f3af 8000 	nop.w

08001460 <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
 8001460:	b510      	push	{r4, lr}
 8001462:	4604      	mov	r4, r0
  void *p;

  chDbgCheckClassI();
 8001464:	f7ff f93c 	bl	80006e0 <chDbgCheckClassI>

  size = MEM_ALIGN_NEXT(size);
  if ((size_t)(endmem - nextmem) < size) {
 8001468:	4906      	ldr	r1, [pc, #24]	; (8001484 <chCoreAllocI+0x24>)
 800146a:	4b07      	ldr	r3, [pc, #28]	; (8001488 <chCoreAllocI+0x28>)
 800146c:	6808      	ldr	r0, [r1, #0]
 800146e:	681a      	ldr	r2, [r3, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8001470:	1de3      	adds	r3, r4, #7
 8001472:	f023 0307 	bic.w	r3, r3, #7
  if ((size_t)(endmem - nextmem) < size) {
 8001476:	1a12      	subs	r2, r2, r0
 8001478:	4293      	cmp	r3, r2
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 800147a:	bf9a      	itte	ls
 800147c:	181b      	addls	r3, r3, r0
 800147e:	600b      	strls	r3, [r1, #0]

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  if ((size_t)(endmem - nextmem) < size) {
    return NULL;
 8001480:	2000      	movhi	r0, #0
  }
  p = nextmem;
  nextmem += size;

  return p;
}
 8001482:	bd10      	pop	{r4, pc}
 8001484:	20000ddc 	.word	0x20000ddc
 8001488:	20000dd8 	.word	0x20000dd8
 800148c:	f3af 8000 	nop.w

08001490 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8001490:	b510      	push	{r4, lr}
 8001492:	2320      	movs	r3, #32
 8001494:	4604      	mov	r4, r0
 8001496:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void)  {

  port_lock();
  _stats_start_measure_crit_thd();
 800149a:	f7ff fa29 	bl	80008f0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800149e:	f7ff f897 	bl	80005d0 <_dbg_check_lock>
  void *p;

  chSysLock();
  p = chCoreAllocI(size);
 80014a2:	4620      	mov	r0, r4
 80014a4:	f7ff ffdc 	bl	8001460 <chCoreAllocI>
 80014a8:	4604      	mov	r4, r0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80014aa:	f7ff f8a1 	bl	80005f0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80014ae:	f7ff fa27 	bl	8000900 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert(ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio,
 80014b2:	4b07      	ldr	r3, [pc, #28]	; (80014d0 <chCoreAlloc+0x40>)
 80014b4:	699a      	ldr	r2, [r3, #24]
 80014b6:	681b      	ldr	r3, [r3, #0]
 80014b8:	6892      	ldr	r2, [r2, #8]
 80014ba:	689b      	ldr	r3, [r3, #8]
 80014bc:	429a      	cmp	r2, r3
 80014be:	d202      	bcs.n	80014c6 <chCoreAlloc+0x36>
 80014c0:	4804      	ldr	r0, [pc, #16]	; (80014d4 <chCoreAlloc+0x44>)
 80014c2:	f7ff f825 	bl	8000510 <chSysHalt>
 80014c6:	2300      	movs	r3, #0
 80014c8:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return p;
}
 80014cc:	4620      	mov	r0, r4
 80014ce:	bd10      	pop	{r4, pc}
 80014d0:	20000800 	.word	0x20000800
 80014d4:	080029a0 	.word	0x080029a0
 80014d8:	f3af 8000 	nop.w
 80014dc:	f3af 8000 	nop.w

080014e0 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 80014e0:	4b04      	ldr	r3, [pc, #16]	; (80014f4 <_heap_init+0x14>)
 80014e2:	4a05      	ldr	r2, [pc, #20]	; (80014f8 <_heap_init+0x18>)
 80014e4:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = (union heap_header *)NULL;
  default_heap.h_free.h.size = 0;
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 80014e6:	f103 0010 	add.w	r0, r3, #16
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
  default_heap.h_free.h.u.next = (union heap_header *)NULL;
 80014ea:	2200      	movs	r2, #0
 80014ec:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 80014ee:	60da      	str	r2, [r3, #12]
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 80014f0:	f7ff bd56 	b.w	8000fa0 <chMtxObjectInit>
 80014f4:	20000de0 	.word	0x20000de0
 80014f8:	08001491 	.word	0x08001491
 80014fc:	f3af 8000 	nop.w

08001500 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8001500:	b40e      	push	{r1, r2, r3}
 8001502:	b500      	push	{lr}
 8001504:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8001506:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 8001508:	461a      	mov	r2, r3
 800150a:	4905      	ldr	r1, [pc, #20]	; (8001520 <chprintf.constprop.0+0x20>)
 800150c:	4805      	ldr	r0, [pc, #20]	; (8001524 <chprintf.constprop.0+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800150e:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8001510:	f000 fea6 	bl	8002260 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8001514:	b002      	add	sp, #8
 8001516:	f85d eb04 	ldr.w	lr, [sp], #4
 800151a:	b003      	add	sp, #12
 800151c:	4770      	bx	lr
 800151e:	bf00      	nop
 8001520:	080029b0 	.word	0x080029b0
 8001524:	20001214 	.word	0x20001214
 8001528:	f3af 8000 	nop.w
 800152c:	f3af 8000 	nop.w

08001530 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8001530:	b538      	push	{r3, r4, r5, lr}
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
  
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "hal_lld_init");
 8001532:	4d0d      	ldr	r5, [pc, #52]	; (8001568 <halInit+0x38>)
 8001534:	4c0d      	ldr	r4, [pc, #52]	; (800156c <halInit+0x3c>)

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 8001536:	f000 fb4b 	bl	8001bd0 <hal_lld_init>
  
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "hal_lld_init");
 800153a:	4621      	mov	r1, r4
 800153c:	4a0c      	ldr	r2, [pc, #48]	; (8001570 <halInit+0x40>)
 800153e:	4628      	mov	r0, r5
 8001540:	f7ff ffde 	bl	8001500 <chprintf.constprop.0>

#if HAL_USE_PAL || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8001544:	480b      	ldr	r0, [pc, #44]	; (8001574 <halInit+0x44>)
 8001546:	f000 fbe3 	bl	8001d10 <_pal_lld_init>
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "palInit");
 800154a:	4621      	mov	r1, r4
 800154c:	4a0a      	ldr	r2, [pc, #40]	; (8001578 <halInit+0x48>)
 800154e:	4628      	mov	r0, r5
 8001550:	f7ff ffd6 	bl	8001500 <chprintf.constprop.0>
#endif
#if HAL_USE_PWM || defined(__DOXYGEN__)
  pwmInit();
#endif
#if HAL_USE_SERIAL || defined(__DOXYGEN__)
  sdInit();
 8001554:	f000 f854 	bl	8001600 <sdInit>
#endif
#if HAL_USE_SPI || defined(__DOXYGEN__)
  spiInit();
#endif
#if HAL_USE_UART || defined(__DOXYGEN__)
  uartInit();
 8001558:	f000 f8e2 	bl	8001720 <uartInit>
#if HAL_USE_COMMUNITY || defined(__DOXYGEN__)
  halCommunityInit();
#endif

  /* Board specific initialization.*/
  boardInit();
 800155c:	f000 fe50 	bl	8002200 <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
 8001560:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8001564:	f000 b8a4 	b.w	80016b0 <stInit>
 8001568:	20001214 	.word	0x20001214
 800156c:	080029b0 	.word	0x080029b0
 8001570:	080029b4 	.word	0x080029b4
 8001574:	08002ae0 	.word	0x08002ae0
 8001578:	080029c4 	.word	0x080029c4
 800157c:	f3af 8000 	nop.w

08001580 <readt>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t time) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, time);
 8001580:	300c      	adds	r0, #12
 8001582:	f7ff bddd 	b.w	8001140 <chIQReadTimeout>
 8001586:	bf00      	nop
 8001588:	f3af 8000 	nop.w
 800158c:	f3af 8000 	nop.w

08001590 <read>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8001590:	300c      	adds	r0, #12
 8001592:	f04f 33ff 	mov.w	r3, #4294967295
 8001596:	f7ff bdd3 	b.w	8001140 <chIQReadTimeout>
 800159a:	bf00      	nop
 800159c:	f3af 8000 	nop.w

080015a0 <writet>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t time) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
 80015a0:	3030      	adds	r0, #48	; 0x30
 80015a2:	f7ff bec5 	b.w	8001330 <chOQWriteTimeout>
 80015a6:	bf00      	nop
 80015a8:	f3af 8000 	nop.w
 80015ac:	f3af 8000 	nop.w

080015b0 <write>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80015b0:	3030      	adds	r0, #48	; 0x30
 80015b2:	f04f 33ff 	mov.w	r3, #4294967295
 80015b6:	f7ff bebb 	b.w	8001330 <chOQWriteTimeout>
 80015ba:	bf00      	nop
 80015bc:	f3af 8000 	nop.w

080015c0 <gett>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80015c0:	300c      	adds	r0, #12
 80015c2:	f7ff bd7d 	b.w	80010c0 <chIQGetTimeout>
 80015c6:	bf00      	nop
 80015c8:	f3af 8000 	nop.w
 80015cc:	f3af 8000 	nop.w

080015d0 <get>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80015d0:	300c      	adds	r0, #12
 80015d2:	f04f 31ff 	mov.w	r1, #4294967295
 80015d6:	f7ff bd73 	b.w	80010c0 <chIQGetTimeout>
 80015da:	bf00      	nop
 80015dc:	f3af 8000 	nop.w

080015e0 <putt>:
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80015e0:	3030      	adds	r0, #48	; 0x30
 80015e2:	f7ff be2d 	b.w	8001240 <chOQPutTimeout>
 80015e6:	bf00      	nop
 80015e8:	f3af 8000 	nop.w
 80015ec:	f3af 8000 	nop.w

080015f0 <put>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80015f0:	3030      	adds	r0, #48	; 0x30
 80015f2:	f04f 32ff 	mov.w	r2, #4294967295
 80015f6:	f7ff be23 	b.w	8001240 <chOQPutTimeout>
 80015fa:	bf00      	nop
 80015fc:	f3af 8000 	nop.w

08001600 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
 8001600:	f000 bd76 	b.w	80020f0 <sd_lld_init>
 8001604:	f3af 8000 	nop.w
 8001608:	f3af 8000 	nop.w
 800160c:	f3af 8000 	nop.w

08001610 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8001610:	b570      	push	{r4, r5, r6, lr}

  sdp->vmt = &vmt;
 8001612:	4b0e      	ldr	r3, [pc, #56]	; (800164c <sdObjectInit+0x3c>)
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8001614:	4604      	mov	r4, r0
 8001616:	b082      	sub	sp, #8

  sdp->vmt = &vmt;
 8001618:	f840 3b04 	str.w	r3, [r0], #4
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 800161c:	2601      	movs	r6, #1
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 800161e:	9400      	str	r4, [sp, #0]
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8001620:	460b      	mov	r3, r1
 8001622:	4615      	mov	r5, r2
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)(void *)esp;
 8001624:	6060      	str	r0, [r4, #4]

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8001626:	f104 0154 	add.w	r1, r4, #84	; 0x54
 800162a:	f104 000c 	add.w	r0, r4, #12
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 800162e:	7226      	strb	r6, [r4, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8001630:	2210      	movs	r2, #16
 8001632:	f7ff fd0d 	bl	8001050 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8001636:	9400      	str	r4, [sp, #0]
 8001638:	462b      	mov	r3, r5
 800163a:	f104 0030 	add.w	r0, r4, #48	; 0x30
 800163e:	f104 0164 	add.w	r1, r4, #100	; 0x64
 8001642:	2210      	movs	r2, #16
 8001644:	f7ff fdec 	bl	8001220 <chOQObjectInit>
}
 8001648:	b002      	add	sp, #8
 800164a:	bd70      	pop	{r4, r5, r6, pc}
 800164c:	080029e0 	.word	0x080029e0

08001650 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8001650:	b538      	push	{r3, r4, r5, lr}
 8001652:	4604      	mov	r4, r0
 8001654:	460d      	mov	r5, r1

  osalDbgCheckClassI();
 8001656:	f7ff f843 	bl	80006e0 <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);
 800165a:	b1e4      	cbz	r4, 8001696 <sdIncomingDataI+0x46>
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 800165c:	f7ff f840 	bl	80006e0 <chDbgCheckClassI>

  if (iqIsEmptyI(&sdp->iqueue))
 8001660:	6963      	ldr	r3, [r4, #20]
 8001662:	b13b      	cbz	r3, 8001674 <sdIncomingDataI+0x24>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 8001664:	4629      	mov	r1, r5
 8001666:	f104 000c 	add.w	r0, r4, #12
 800166a:	f7ff fd01 	bl	8001070 <chIQPutI>
 800166e:	2800      	cmp	r0, #0
 8001670:	db0b      	blt.n	800168a <sdIncomingDataI+0x3a>
 8001672:	bd38      	pop	{r3, r4, r5, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8001674:	1d20      	adds	r0, r4, #4
 8001676:	2104      	movs	r1, #4
 8001678:	f7ff fcca 	bl	8001010 <chEvtBroadcastFlagsI>
 800167c:	4629      	mov	r1, r5
 800167e:	f104 000c 	add.w	r0, r4, #12
 8001682:	f7ff fcf5 	bl	8001070 <chIQPutI>
 8001686:	2800      	cmp	r0, #0
 8001688:	daf3      	bge.n	8001672 <sdIncomingDataI+0x22>
 800168a:	1d20      	adds	r0, r4, #4
 800168c:	2180      	movs	r1, #128	; 0x80
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
}
 800168e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8001692:	f7ff bcbd 	b.w	8001010 <chEvtBroadcastFlagsI>
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);
 8001696:	4802      	ldr	r0, [pc, #8]	; (80016a0 <sdIncomingDataI+0x50>)
 8001698:	f7fe ff3a 	bl	8000510 <chSysHalt>
 800169c:	e7de      	b.n	800165c <sdIncomingDataI+0xc>
 800169e:	bf00      	nop
 80016a0:	080029d0 	.word	0x080029d0
 80016a4:	f3af 8000 	nop.w
 80016a8:	f3af 8000 	nop.w
 80016ac:	f3af 8000 	nop.w

080016b0 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
 80016b0:	f000 bc36 	b.w	8001f20 <st_lld_init>
 80016b4:	f3af 8000 	nop.w
 80016b8:	f3af 8000 	nop.w
 80016bc:	f3af 8000 	nop.w

080016c0 <stStartAlarm>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80016c0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t time) {
 80016c4:	b510      	push	{r4, lr}
 80016c6:	68db      	ldr	r3, [r3, #12]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 80016c8:	079b      	lsls	r3, r3, #30
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t time) {
 80016ca:	4604      	mov	r4, r0

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 80016cc:	d502      	bpl.n	80016d4 <stStartAlarm+0x14>
 80016ce:	4805      	ldr	r0, [pc, #20]	; (80016e4 <stStartAlarm+0x24>)
 80016d0:	f7fe ff1e 	bl	8000510 <chSysHalt>
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80016d4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->SR     = 0;
 80016d8:	2100      	movs	r1, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80016da:	2202      	movs	r2, #2
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80016dc:	635c      	str	r4, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80016de:	6119      	str	r1, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80016e0:	60da      	str	r2, [r3, #12]
 80016e2:	bd10      	pop	{r4, pc}
 80016e4:	08002a00 	.word	0x08002a00
 80016e8:	f3af 8000 	nop.w
 80016ec:	f3af 8000 	nop.w

080016f0 <stStopAlarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 80016f0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80016f4:	2200      	movs	r2, #0
 80016f6:	60da      	str	r2, [r3, #12]
 80016f8:	4770      	bx	lr
 80016fa:	bf00      	nop
 80016fc:	f3af 8000 	nop.w

08001700 <stSetAlarm>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8001700:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t time) {
 8001704:	b510      	push	{r4, lr}
 8001706:	68db      	ldr	r3, [r3, #12]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8001708:	079b      	lsls	r3, r3, #30
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t time) {
 800170a:	4604      	mov	r4, r0

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 800170c:	d402      	bmi.n	8001714 <stSetAlarm+0x14>
 800170e:	4803      	ldr	r0, [pc, #12]	; (800171c <stSetAlarm+0x1c>)
 8001710:	f7fe fefe 	bl	8000510 <chSysHalt>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001714:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001718:	635c      	str	r4, [r3, #52]	; 0x34
 800171a:	bd10      	pop	{r4, pc}
 800171c:	08002a10 	.word	0x08002a10

08001720 <uartInit>:
 *
 * @init
 */
void uartInit(void) {

  uart_lld_init();
 8001720:	f000 bd56 	b.w	80021d0 <uart_lld_init>
 8001724:	f3af 8000 	nop.w
 8001728:	f3af 8000 	nop.w
 800172c:	f3af 8000 	nop.w

08001730 <uartObjectInit>:
 * @init
 */
void uartObjectInit(UARTDriver *uartp) {

  uartp->state   = UART_STOP;
  uartp->txstate = UART_TX_IDLE;
 8001730:	2300      	movs	r3, #0
 *
 * @init
 */
void uartObjectInit(UARTDriver *uartp) {

  uartp->state   = UART_STOP;
 8001732:	2201      	movs	r2, #1
 8001734:	7002      	strb	r2, [r0, #0]
  uartp->txstate = UART_TX_IDLE;
 8001736:	7043      	strb	r3, [r0, #1]
  uartp->rxstate = UART_RX_IDLE;
 8001738:	7083      	strb	r3, [r0, #2]
  uartp->config  = NULL;
 800173a:	6043      	str	r3, [r0, #4]
 800173c:	4770      	bx	lr
 800173e:	bf00      	nop

08001740 <nvicEnableVector>:
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8001740:	0943      	lsrs	r3, r0, #5
 8001742:	009b      	lsls	r3, r3, #2
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8001744:	b410      	push	{r4}
 8001746:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 800174a:	f100 4460 	add.w	r4, r0, #3758096384	; 0xe0000000
 800174e:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
 8001752:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 8001756:	0109      	lsls	r1, r1, #4
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8001758:	f000 001f 	and.w	r0, r0, #31
 800175c:	2201      	movs	r2, #1
 800175e:	4082      	lsls	r2, r0
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 8001760:	b2c9      	uxtb	r1, r1
 8001762:	f884 1300 	strb.w	r1, [r4, #768]	; 0x300
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8001766:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 800176a:	601a      	str	r2, [r3, #0]
}
 800176c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001770:	4770      	bx	lr
 8001772:	bf00      	nop
 8001774:	f3af 8000 	nop.w
 8001778:	f3af 8000 	nop.w
 800177c:	f3af 8000 	nop.w

08001780 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector6C) {
 8001780:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001782:	f7ff f88d 	bl	80008a0 <_stats_increase_irq>
 8001786:	f7fe ff7b 	bl	8000680 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
 800178a:	4b08      	ldr	r3, [pc, #32]	; (80017ac <Vector6C+0x2c>)
  DMA1->LIFCR = flags << 0;
  if (dma_isr_redir[0].dma_func)
 800178c:	4a08      	ldr	r2, [pc, #32]	; (80017b0 <Vector6C+0x30>)
OSAL_IRQ_HANDLER(Vector6C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
 800178e:	6819      	ldr	r1, [r3, #0]
 8001790:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0;
 8001794:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[0].dma_func)
 8001796:	6813      	ldr	r3, [r2, #0]
 8001798:	b10b      	cbz	r3, 800179e <Vector6C+0x1e>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 800179a:	6850      	ldr	r0, [r2, #4]
 800179c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800179e:	f7fe ff87 	bl	80006b0 <_dbg_check_leave_isr>
}
 80017a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 0;
  if (dma_isr_redir[0].dma_func)
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80017a6:	f7fe be23 	b.w	80003f0 <_port_irq_epilogue>
 80017aa:	bf00      	nop
 80017ac:	40026000 	.word	0x40026000
 80017b0:	20000e00 	.word	0x20000e00
 80017b4:	f3af 8000 	nop.w
 80017b8:	f3af 8000 	nop.w
 80017bc:	f3af 8000 	nop.w

080017c0 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector70) {
 80017c0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80017c2:	f7ff f86d 	bl	80008a0 <_stats_increase_irq>
 80017c6:	f7fe ff5b 	bl	8000680 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 80017ca:	4b09      	ldr	r3, [pc, #36]	; (80017f0 <Vector70+0x30>)
  DMA1->LIFCR = flags << 6;
  if (dma_isr_redir[1].dma_func)
 80017cc:	4809      	ldr	r0, [pc, #36]	; (80017f4 <Vector70+0x34>)
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 80017ce:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 6;
  if (dma_isr_redir[1].dma_func)
 80017d0:	6882      	ldr	r2, [r0, #8]
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 80017d2:	0989      	lsrs	r1, r1, #6
 80017d4:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 6;
 80017d8:	018c      	lsls	r4, r1, #6
 80017da:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[1].dma_func)
 80017dc:	b10a      	cbz	r2, 80017e2 <Vector70+0x22>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 80017de:	68c0      	ldr	r0, [r0, #12]
 80017e0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80017e2:	f7fe ff65 	bl	80006b0 <_dbg_check_leave_isr>
}
 80017e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 6;
  if (dma_isr_redir[1].dma_func)
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80017ea:	f7fe be01 	b.w	80003f0 <_port_irq_epilogue>
 80017ee:	bf00      	nop
 80017f0:	40026000 	.word	0x40026000
 80017f4:	20000e00 	.word	0x20000e00
 80017f8:	f3af 8000 	nop.w
 80017fc:	f3af 8000 	nop.w

08001800 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector74) {
 8001800:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001802:	f7ff f84d 	bl	80008a0 <_stats_increase_irq>
 8001806:	f7fe ff3b 	bl	8000680 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 800180a:	4b09      	ldr	r3, [pc, #36]	; (8001830 <Vector74+0x30>)
  DMA1->LIFCR = flags << 16;
  if (dma_isr_redir[2].dma_func)
 800180c:	4809      	ldr	r0, [pc, #36]	; (8001834 <Vector74+0x34>)
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 800180e:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 16;
  if (dma_isr_redir[2].dma_func)
 8001810:	6902      	ldr	r2, [r0, #16]
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 8001812:	0c09      	lsrs	r1, r1, #16
 8001814:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 16;
 8001818:	040c      	lsls	r4, r1, #16
 800181a:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[2].dma_func)
 800181c:	b10a      	cbz	r2, 8001822 <Vector74+0x22>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 800181e:	6940      	ldr	r0, [r0, #20]
 8001820:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001822:	f7fe ff45 	bl	80006b0 <_dbg_check_leave_isr>
}
 8001826:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 16;
  if (dma_isr_redir[2].dma_func)
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800182a:	f7fe bde1 	b.w	80003f0 <_port_irq_epilogue>
 800182e:	bf00      	nop
 8001830:	40026000 	.word	0x40026000
 8001834:	20000e00 	.word	0x20000e00
 8001838:	f3af 8000 	nop.w
 800183c:	f3af 8000 	nop.w

08001840 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector78) {
 8001840:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001842:	f7ff f82d 	bl	80008a0 <_stats_increase_irq>
 8001846:	f7fe ff1b 	bl	8000680 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 800184a:	4b09      	ldr	r3, [pc, #36]	; (8001870 <Vector78+0x30>)
  DMA1->LIFCR = flags << 22;
  if (dma_isr_redir[3].dma_func)
 800184c:	4809      	ldr	r0, [pc, #36]	; (8001874 <Vector78+0x34>)
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 800184e:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 22;
  if (dma_isr_redir[3].dma_func)
 8001850:	6982      	ldr	r2, [r0, #24]
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 8001852:	0d89      	lsrs	r1, r1, #22
 8001854:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 22;
 8001858:	058c      	lsls	r4, r1, #22
 800185a:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[3].dma_func)
 800185c:	b10a      	cbz	r2, 8001862 <Vector78+0x22>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 800185e:	69c0      	ldr	r0, [r0, #28]
 8001860:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001862:	f7fe ff25 	bl	80006b0 <_dbg_check_leave_isr>
}
 8001866:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 22;
  if (dma_isr_redir[3].dma_func)
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800186a:	f7fe bdc1 	b.w	80003f0 <_port_irq_epilogue>
 800186e:	bf00      	nop
 8001870:	40026000 	.word	0x40026000
 8001874:	20000e00 	.word	0x20000e00
 8001878:	f3af 8000 	nop.w
 800187c:	f3af 8000 	nop.w

08001880 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector7C) {
 8001880:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001882:	f7ff f80d 	bl	80008a0 <_stats_increase_irq>
 8001886:	f7fe fefb 	bl	8000680 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 800188a:	4b08      	ldr	r3, [pc, #32]	; (80018ac <Vector7C+0x2c>)
  DMA1->HIFCR = flags << 0;
  if (dma_isr_redir[4].dma_func)
 800188c:	4808      	ldr	r0, [pc, #32]	; (80018b0 <Vector7C+0x30>)
OSAL_IRQ_HANDLER(Vector7C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 800188e:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 0;
  if (dma_isr_redir[4].dma_func)
 8001890:	6a02      	ldr	r2, [r0, #32]
OSAL_IRQ_HANDLER(Vector7C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 8001892:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0;
 8001896:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[4].dma_func)
 8001898:	b10a      	cbz	r2, 800189e <Vector7C+0x1e>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 800189a:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800189c:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800189e:	f7fe ff07 	bl	80006b0 <_dbg_check_leave_isr>
}
 80018a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 0;
  if (dma_isr_redir[4].dma_func)
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80018a6:	f7fe bda3 	b.w	80003f0 <_port_irq_epilogue>
 80018aa:	bf00      	nop
 80018ac:	40026000 	.word	0x40026000
 80018b0:	20000e00 	.word	0x20000e00
 80018b4:	f3af 8000 	nop.w
 80018b8:	f3af 8000 	nop.w
 80018bc:	f3af 8000 	nop.w

080018c0 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector80) {
 80018c0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80018c2:	f7fe ffed 	bl	80008a0 <_stats_increase_irq>
 80018c6:	f7fe fedb 	bl	8000680 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 80018ca:	4b09      	ldr	r3, [pc, #36]	; (80018f0 <Vector80+0x30>)
  DMA1->HIFCR = flags << 6;
  if (dma_isr_redir[5].dma_func)
 80018cc:	4809      	ldr	r0, [pc, #36]	; (80018f4 <Vector80+0x34>)
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 80018ce:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 6;
  if (dma_isr_redir[5].dma_func)
 80018d0:	6a82      	ldr	r2, [r0, #40]	; 0x28
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 80018d2:	0989      	lsrs	r1, r1, #6
 80018d4:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 6;
 80018d8:	018c      	lsls	r4, r1, #6
 80018da:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[5].dma_func)
 80018dc:	b10a      	cbz	r2, 80018e2 <Vector80+0x22>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 80018de:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 80018e0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80018e2:	f7fe fee5 	bl	80006b0 <_dbg_check_leave_isr>
}
 80018e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 6;
  if (dma_isr_redir[5].dma_func)
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80018ea:	f7fe bd81 	b.w	80003f0 <_port_irq_epilogue>
 80018ee:	bf00      	nop
 80018f0:	40026000 	.word	0x40026000
 80018f4:	20000e00 	.word	0x20000e00
 80018f8:	f3af 8000 	nop.w
 80018fc:	f3af 8000 	nop.w

08001900 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector84) {
 8001900:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001902:	f7fe ffcd 	bl	80008a0 <_stats_increase_irq>
 8001906:	f7fe febb 	bl	8000680 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 800190a:	4b09      	ldr	r3, [pc, #36]	; (8001930 <Vector84+0x30>)
  DMA1->HIFCR = flags << 16;
  if (dma_isr_redir[6].dma_func)
 800190c:	4809      	ldr	r0, [pc, #36]	; (8001934 <Vector84+0x34>)
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 800190e:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 16;
  if (dma_isr_redir[6].dma_func)
 8001910:	6b02      	ldr	r2, [r0, #48]	; 0x30
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 8001912:	0c09      	lsrs	r1, r1, #16
 8001914:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 16;
 8001918:	040c      	lsls	r4, r1, #16
 800191a:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[6].dma_func)
 800191c:	b10a      	cbz	r2, 8001922 <Vector84+0x22>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 800191e:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8001920:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001922:	f7fe fec5 	bl	80006b0 <_dbg_check_leave_isr>
}
 8001926:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 16;
  if (dma_isr_redir[6].dma_func)
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800192a:	f7fe bd61 	b.w	80003f0 <_port_irq_epilogue>
 800192e:	bf00      	nop
 8001930:	40026000 	.word	0x40026000
 8001934:	20000e00 	.word	0x20000e00
 8001938:	f3af 8000 	nop.w
 800193c:	f3af 8000 	nop.w

08001940 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorFC) {
 8001940:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001942:	f7fe ffad 	bl	80008a0 <_stats_increase_irq>
 8001946:	f7fe fe9b 	bl	8000680 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 800194a:	4b09      	ldr	r3, [pc, #36]	; (8001970 <VectorFC+0x30>)
  DMA1->HIFCR = flags << 22;
  if (dma_isr_redir[7].dma_func)
 800194c:	4809      	ldr	r0, [pc, #36]	; (8001974 <VectorFC+0x34>)
OSAL_IRQ_HANDLER(VectorFC) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 800194e:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 22;
  if (dma_isr_redir[7].dma_func)
 8001950:	6b82      	ldr	r2, [r0, #56]	; 0x38
OSAL_IRQ_HANDLER(VectorFC) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 8001952:	0d89      	lsrs	r1, r1, #22
 8001954:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 22;
 8001958:	058c      	lsls	r4, r1, #22
 800195a:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[7].dma_func)
 800195c:	b10a      	cbz	r2, 8001962 <VectorFC+0x22>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 800195e:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 8001960:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001962:	f7fe fea5 	bl	80006b0 <_dbg_check_leave_isr>
}
 8001966:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 22;
  if (dma_isr_redir[7].dma_func)
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800196a:	f7fe bd41 	b.w	80003f0 <_port_irq_epilogue>
 800196e:	bf00      	nop
 8001970:	40026000 	.word	0x40026000
 8001974:	20000e00 	.word	0x20000e00
 8001978:	f3af 8000 	nop.w
 800197c:	f3af 8000 	nop.w

08001980 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector120) {
 8001980:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001982:	f7fe ff8d 	bl	80008a0 <_stats_increase_irq>
 8001986:	f7fe fe7b 	bl	8000680 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 800198a:	4b08      	ldr	r3, [pc, #32]	; (80019ac <Vector120+0x2c>)
  DMA2->LIFCR = flags << 0;
  if (dma_isr_redir[8].dma_func)
 800198c:	4808      	ldr	r0, [pc, #32]	; (80019b0 <Vector120+0x30>)
OSAL_IRQ_HANDLER(Vector120) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 800198e:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 0;
  if (dma_isr_redir[8].dma_func)
 8001990:	6c02      	ldr	r2, [r0, #64]	; 0x40
OSAL_IRQ_HANDLER(Vector120) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 8001992:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0;
 8001996:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[8].dma_func)
 8001998:	b10a      	cbz	r2, 800199e <Vector120+0x1e>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 800199a:	6c40      	ldr	r0, [r0, #68]	; 0x44
 800199c:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800199e:	f7fe fe87 	bl	80006b0 <_dbg_check_leave_isr>
}
 80019a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 0;
  if (dma_isr_redir[8].dma_func)
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80019a6:	f7fe bd23 	b.w	80003f0 <_port_irq_epilogue>
 80019aa:	bf00      	nop
 80019ac:	40026400 	.word	0x40026400
 80019b0:	20000e00 	.word	0x20000e00
 80019b4:	f3af 8000 	nop.w
 80019b8:	f3af 8000 	nop.w
 80019bc:	f3af 8000 	nop.w

080019c0 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector124) {
 80019c0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80019c2:	f7fe ff6d 	bl	80008a0 <_stats_increase_irq>
 80019c6:	f7fe fe5b 	bl	8000680 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 80019ca:	4b09      	ldr	r3, [pc, #36]	; (80019f0 <Vector124+0x30>)
  DMA2->LIFCR = flags << 6;
  if (dma_isr_redir[9].dma_func)
 80019cc:	4809      	ldr	r0, [pc, #36]	; (80019f4 <Vector124+0x34>)
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 80019ce:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 6;
  if (dma_isr_redir[9].dma_func)
 80019d0:	6c82      	ldr	r2, [r0, #72]	; 0x48
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 80019d2:	0989      	lsrs	r1, r1, #6
 80019d4:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 6;
 80019d8:	018c      	lsls	r4, r1, #6
 80019da:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[9].dma_func)
 80019dc:	b10a      	cbz	r2, 80019e2 <Vector124+0x22>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 80019de:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 80019e0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80019e2:	f7fe fe65 	bl	80006b0 <_dbg_check_leave_isr>
}
 80019e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 6;
  if (dma_isr_redir[9].dma_func)
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80019ea:	f7fe bd01 	b.w	80003f0 <_port_irq_epilogue>
 80019ee:	bf00      	nop
 80019f0:	40026400 	.word	0x40026400
 80019f4:	20000e00 	.word	0x20000e00
 80019f8:	f3af 8000 	nop.w
 80019fc:	f3af 8000 	nop.w

08001a00 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector128) {
 8001a00:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001a02:	f7fe ff4d 	bl	80008a0 <_stats_increase_irq>
 8001a06:	f7fe fe3b 	bl	8000680 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 8001a0a:	4b09      	ldr	r3, [pc, #36]	; (8001a30 <Vector128+0x30>)
  DMA2->LIFCR = flags << 16;
  if (dma_isr_redir[10].dma_func)
 8001a0c:	4809      	ldr	r0, [pc, #36]	; (8001a34 <Vector128+0x34>)
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 8001a0e:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 16;
  if (dma_isr_redir[10].dma_func)
 8001a10:	6d02      	ldr	r2, [r0, #80]	; 0x50
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 8001a12:	0c09      	lsrs	r1, r1, #16
 8001a14:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 16;
 8001a18:	040c      	lsls	r4, r1, #16
 8001a1a:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[10].dma_func)
 8001a1c:	b10a      	cbz	r2, 8001a22 <Vector128+0x22>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 8001a1e:	6d40      	ldr	r0, [r0, #84]	; 0x54
 8001a20:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001a22:	f7fe fe45 	bl	80006b0 <_dbg_check_leave_isr>
}
 8001a26:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 16;
  if (dma_isr_redir[10].dma_func)
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001a2a:	f7fe bce1 	b.w	80003f0 <_port_irq_epilogue>
 8001a2e:	bf00      	nop
 8001a30:	40026400 	.word	0x40026400
 8001a34:	20000e00 	.word	0x20000e00
 8001a38:	f3af 8000 	nop.w
 8001a3c:	f3af 8000 	nop.w

08001a40 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector12C) {
 8001a40:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001a42:	f7fe ff2d 	bl	80008a0 <_stats_increase_irq>
 8001a46:	f7fe fe1b 	bl	8000680 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 8001a4a:	4b09      	ldr	r3, [pc, #36]	; (8001a70 <Vector12C+0x30>)
  DMA2->LIFCR = flags << 22;
  if (dma_isr_redir[11].dma_func)
 8001a4c:	4809      	ldr	r0, [pc, #36]	; (8001a74 <Vector12C+0x34>)
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 8001a4e:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 22;
  if (dma_isr_redir[11].dma_func)
 8001a50:	6d82      	ldr	r2, [r0, #88]	; 0x58
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 8001a52:	0d89      	lsrs	r1, r1, #22
 8001a54:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 22;
 8001a58:	058c      	lsls	r4, r1, #22
 8001a5a:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[11].dma_func)
 8001a5c:	b10a      	cbz	r2, 8001a62 <Vector12C+0x22>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 8001a5e:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 8001a60:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001a62:	f7fe fe25 	bl	80006b0 <_dbg_check_leave_isr>
}
 8001a66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 22;
  if (dma_isr_redir[11].dma_func)
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001a6a:	f7fe bcc1 	b.w	80003f0 <_port_irq_epilogue>
 8001a6e:	bf00      	nop
 8001a70:	40026400 	.word	0x40026400
 8001a74:	20000e00 	.word	0x20000e00
 8001a78:	f3af 8000 	nop.w
 8001a7c:	f3af 8000 	nop.w

08001a80 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector130) {
 8001a80:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001a82:	f7fe ff0d 	bl	80008a0 <_stats_increase_irq>
 8001a86:	f7fe fdfb 	bl	8000680 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 8001a8a:	4b08      	ldr	r3, [pc, #32]	; (8001aac <Vector130+0x2c>)
  DMA2->HIFCR = flags << 0;
  if (dma_isr_redir[12].dma_func)
 8001a8c:	4808      	ldr	r0, [pc, #32]	; (8001ab0 <Vector130+0x30>)
OSAL_IRQ_HANDLER(Vector130) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 8001a8e:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 0;
  if (dma_isr_redir[12].dma_func)
 8001a90:	6e02      	ldr	r2, [r0, #96]	; 0x60
OSAL_IRQ_HANDLER(Vector130) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 8001a92:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0;
 8001a96:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[12].dma_func)
 8001a98:	b10a      	cbz	r2, 8001a9e <Vector130+0x1e>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 8001a9a:	6e40      	ldr	r0, [r0, #100]	; 0x64
 8001a9c:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001a9e:	f7fe fe07 	bl	80006b0 <_dbg_check_leave_isr>
}
 8001aa2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 0;
  if (dma_isr_redir[12].dma_func)
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001aa6:	f7fe bca3 	b.w	80003f0 <_port_irq_epilogue>
 8001aaa:	bf00      	nop
 8001aac:	40026400 	.word	0x40026400
 8001ab0:	20000e00 	.word	0x20000e00
 8001ab4:	f3af 8000 	nop.w
 8001ab8:	f3af 8000 	nop.w
 8001abc:	f3af 8000 	nop.w

08001ac0 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector150) {
 8001ac0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001ac2:	f7fe feed 	bl	80008a0 <_stats_increase_irq>
 8001ac6:	f7fe fddb 	bl	8000680 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 8001aca:	4b09      	ldr	r3, [pc, #36]	; (8001af0 <Vector150+0x30>)
  DMA2->HIFCR = flags << 6;
  if (dma_isr_redir[13].dma_func)
 8001acc:	4809      	ldr	r0, [pc, #36]	; (8001af4 <Vector150+0x34>)
OSAL_IRQ_HANDLER(Vector150) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 8001ace:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 6;
  if (dma_isr_redir[13].dma_func)
 8001ad0:	6e82      	ldr	r2, [r0, #104]	; 0x68
OSAL_IRQ_HANDLER(Vector150) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 8001ad2:	0989      	lsrs	r1, r1, #6
 8001ad4:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 6;
 8001ad8:	018c      	lsls	r4, r1, #6
 8001ada:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[13].dma_func)
 8001adc:	b10a      	cbz	r2, 8001ae2 <Vector150+0x22>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 8001ade:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 8001ae0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001ae2:	f7fe fde5 	bl	80006b0 <_dbg_check_leave_isr>
}
 8001ae6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 6;
  if (dma_isr_redir[13].dma_func)
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001aea:	f7fe bc81 	b.w	80003f0 <_port_irq_epilogue>
 8001aee:	bf00      	nop
 8001af0:	40026400 	.word	0x40026400
 8001af4:	20000e00 	.word	0x20000e00
 8001af8:	f3af 8000 	nop.w
 8001afc:	f3af 8000 	nop.w

08001b00 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector154) {
 8001b00:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001b02:	f7fe fecd 	bl	80008a0 <_stats_increase_irq>
 8001b06:	f7fe fdbb 	bl	8000680 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 8001b0a:	4b09      	ldr	r3, [pc, #36]	; (8001b30 <Vector154+0x30>)
  DMA2->HIFCR = flags << 16;
  if (dma_isr_redir[14].dma_func)
 8001b0c:	4809      	ldr	r0, [pc, #36]	; (8001b34 <Vector154+0x34>)
OSAL_IRQ_HANDLER(Vector154) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 8001b0e:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 16;
  if (dma_isr_redir[14].dma_func)
 8001b10:	6f02      	ldr	r2, [r0, #112]	; 0x70
OSAL_IRQ_HANDLER(Vector154) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 8001b12:	0c09      	lsrs	r1, r1, #16
 8001b14:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 16;
 8001b18:	040c      	lsls	r4, r1, #16
 8001b1a:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[14].dma_func)
 8001b1c:	b10a      	cbz	r2, 8001b22 <Vector154+0x22>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 8001b1e:	6f40      	ldr	r0, [r0, #116]	; 0x74
 8001b20:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001b22:	f7fe fdc5 	bl	80006b0 <_dbg_check_leave_isr>
}
 8001b26:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 16;
  if (dma_isr_redir[14].dma_func)
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001b2a:	f7fe bc61 	b.w	80003f0 <_port_irq_epilogue>
 8001b2e:	bf00      	nop
 8001b30:	40026400 	.word	0x40026400
 8001b34:	20000e00 	.word	0x20000e00
 8001b38:	f3af 8000 	nop.w
 8001b3c:	f3af 8000 	nop.w

08001b40 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector158) {
 8001b40:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001b42:	f7fe fead 	bl	80008a0 <_stats_increase_irq>
 8001b46:	f7fe fd9b 	bl	8000680 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 8001b4a:	4b09      	ldr	r3, [pc, #36]	; (8001b70 <Vector158+0x30>)
  DMA2->HIFCR = flags << 22;
  if (dma_isr_redir[15].dma_func)
 8001b4c:	4809      	ldr	r0, [pc, #36]	; (8001b74 <Vector158+0x34>)
OSAL_IRQ_HANDLER(Vector158) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 8001b4e:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 22;
  if (dma_isr_redir[15].dma_func)
 8001b50:	6f82      	ldr	r2, [r0, #120]	; 0x78
OSAL_IRQ_HANDLER(Vector158) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 8001b52:	0d89      	lsrs	r1, r1, #22
 8001b54:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 22;
 8001b58:	058c      	lsls	r4, r1, #22
 8001b5a:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[15].dma_func)
 8001b5c:	b10a      	cbz	r2, 8001b62 <Vector158+0x22>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 8001b5e:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 8001b60:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001b62:	f7fe fda5 	bl	80006b0 <_dbg_check_leave_isr>
}
 8001b66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 22;
  if (dma_isr_redir[15].dma_func)
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001b6a:	f7fe bc41 	b.w	80003f0 <_port_irq_epilogue>
 8001b6e:	bf00      	nop
 8001b70:	40026400 	.word	0x40026400
 8001b74:	20000e00 	.word	0x20000e00
 8001b78:	f3af 8000 	nop.w
 8001b7c:	f3af 8000 	nop.w

08001b80 <dmaInit>:
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
 8001b80:	4b0d      	ldr	r3, [pc, #52]	; (8001bb8 <dmaInit+0x38>)
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8001b82:	b430      	push	{r4, r5}
  int i;

  dma_streams_mask = 0;
 8001b84:	2200      	movs	r2, #0
 8001b86:	4d0d      	ldr	r5, [pc, #52]	; (8001bbc <dmaInit+0x3c>)
 8001b88:	4c0d      	ldr	r4, [pc, #52]	; (8001bc0 <dmaInit+0x40>)
 8001b8a:	601a      	str	r2, [r3, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0;
 8001b8c:	4611      	mov	r1, r2
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8001b8e:	4613      	mov	r3, r2
    _stm32_dma_streams[i].stream->CR = 0;
 8001b90:	58a8      	ldr	r0, [r5, r2]
 8001b92:	6001      	str	r1, [r0, #0]
    dma_isr_redir[i].dma_func = NULL;
 8001b94:	f844 1033 	str.w	r1, [r4, r3, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8001b98:	3301      	adds	r3, #1
 8001b9a:	2b10      	cmp	r3, #16
 8001b9c:	f102 020c 	add.w	r2, r2, #12
 8001ba0:	d1f6      	bne.n	8001b90 <dmaInit+0x10>
    _stm32_dma_streams[i].stream->CR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFF;
 8001ba2:	4908      	ldr	r1, [pc, #32]	; (8001bc4 <dmaInit+0x44>)
  DMA1->HIFCR = 0xFFFFFFFF;
  DMA2->LIFCR = 0xFFFFFFFF;
 8001ba4:	4a08      	ldr	r2, [pc, #32]	; (8001bc8 <dmaInit+0x48>)
  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFF;
 8001ba6:	f04f 33ff 	mov.w	r3, #4294967295
 8001baa:	608b      	str	r3, [r1, #8]
  DMA1->HIFCR = 0xFFFFFFFF;
  DMA2->LIFCR = 0xFFFFFFFF;
  DMA2->HIFCR = 0xFFFFFFFF;
}
 8001bac:	bc30      	pop	{r4, r5}
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFF;
  DMA1->HIFCR = 0xFFFFFFFF;
 8001bae:	60cb      	str	r3, [r1, #12]
  DMA2->LIFCR = 0xFFFFFFFF;
 8001bb0:	6093      	str	r3, [r2, #8]
  DMA2->HIFCR = 0xFFFFFFFF;
 8001bb2:	60d3      	str	r3, [r2, #12]
}
 8001bb4:	4770      	bx	lr
 8001bb6:	bf00      	nop
 8001bb8:	20000e80 	.word	0x20000e80
 8001bbc:	08002a20 	.word	0x08002a20
 8001bc0:	20000e00 	.word	0x20000e00
 8001bc4:	40026000 	.word	0x40026000
 8001bc8:	40026400 	.word	0x40026400
 8001bcc:	f3af 8000 	nop.w

08001bd0 <hal_lld_init>:
 */
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 8001bd0:	4b17      	ldr	r3, [pc, #92]	; (8001c30 <hal_lld_init+0x60>)
 8001bd2:	f04f 31ff 	mov.w	r1, #4294967295
 8001bd6:	691a      	ldr	r2, [r3, #16]
 8001bd8:	2200      	movs	r2, #0
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8001bda:	b410      	push	{r4}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 8001bdc:	6119      	str	r1, [r3, #16]
 8001bde:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 8001be0:	6958      	ldr	r0, [r3, #20]
 8001be2:	6159      	str	r1, [r3, #20]
 8001be4:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8001be6:	6a18      	ldr	r0, [r3, #32]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001be8:	4c12      	ldr	r4, [pc, #72]	; (8001c34 <hal_lld_init+0x64>)

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
  rccResetAHB2(~0);
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8001bea:	f060 5080 	orn	r0, r0, #268435456	; 0x10000000
 8001bee:	6218      	str	r0, [r3, #32]
 8001bf0:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 8001bf2:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8001bf4:	6259      	str	r1, [r3, #36]	; 0x24
 8001bf6:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8001bf8:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8001bfa:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8001bfe:	6419      	str	r1, [r3, #64]	; 0x40
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001c00:	6821      	ldr	r1, [r4, #0]
 8001c02:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8001c06:	6021      	str	r1, [r4, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8001c08:	6f19      	ldr	r1, [r3, #112]	; 0x70
 8001c0a:	f401 7140 	and.w	r1, r1, #768	; 0x300
 8001c0e:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8001c12:	d003      	beq.n	8001c1c <hal_lld_init+0x4c>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8001c14:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8001c18:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8001c1a:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8001c1c:	4a05      	ldr	r2, [pc, #20]	; (8001c34 <hal_lld_init+0x64>)

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 8001c1e:	f85d 4b04 	ldr.w	r4, [sp], #4

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8001c22:	6853      	ldr	r3, [r2, #4]
 8001c24:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8001c28:	6053      	str	r3, [r2, #4]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8001c2a:	f7ff bfa9 	b.w	8001b80 <dmaInit>
 8001c2e:	bf00      	nop
 8001c30:	40023800 	.word	0x40023800
 8001c34:	40007000 	.word	0x40007000
 8001c38:	f3af 8000 	nop.w
 8001c3c:	f3af 8000 	nop.w

08001c40 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001c40:	492c      	ldr	r1, [pc, #176]	; (8001cf4 <stm32_clock_init+0xb4>)

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8001c42:	4b2d      	ldr	r3, [pc, #180]	; (8001cf8 <stm32_clock_init+0xb8>)
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001c44:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8001c48:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001c4c:	6408      	str	r0, [r1, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8001c4e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001c50:	680b      	ldr	r3, [r1, #0]
 8001c52:	f043 0301 	orr.w	r3, r3, #1
 8001c56:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001c58:	680a      	ldr	r2, [r1, #0]
 8001c5a:	4b26      	ldr	r3, [pc, #152]	; (8001cf4 <stm32_clock_init+0xb4>)
 8001c5c:	0790      	lsls	r0, r2, #30
 8001c5e:	d5fb      	bpl.n	8001c58 <stm32_clock_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8001c60:	689a      	ldr	r2, [r3, #8]
 8001c62:	f022 0203 	bic.w	r2, r2, #3
 8001c66:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001c68:	689a      	ldr	r2, [r3, #8]
 8001c6a:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001c6c:	4619      	mov	r1, r3
 8001c6e:	688b      	ldr	r3, [r1, #8]
 8001c70:	4a20      	ldr	r2, [pc, #128]	; (8001cf4 <stm32_clock_init+0xb4>)
 8001c72:	f013 030c 	ands.w	r3, r3, #12
 8001c76:	d1fa      	bne.n	8001c6e <stm32_clock_init+0x2e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001c78:	6811      	ldr	r1, [r2, #0]
 8001c7a:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 8001c7e:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001c80:	6093      	str	r3, [r2, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 8001c82:	6813      	ldr	r3, [r2, #0]
 8001c84:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001c88:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8001c8a:	6811      	ldr	r1, [r2, #0]
 8001c8c:	4b19      	ldr	r3, [pc, #100]	; (8001cf4 <stm32_clock_init+0xb4>)
 8001c8e:	0389      	lsls	r1, r1, #14
 8001c90:	d5fb      	bpl.n	8001c8a <stm32_clock_init+0x4a>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001c92:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8001c94:	f042 0201 	orr.w	r2, r2, #1
 8001c98:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001c9a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8001c9c:	4915      	ldr	r1, [pc, #84]	; (8001cf4 <stm32_clock_init+0xb4>)
 8001c9e:	0790      	lsls	r0, r2, #30
 8001ca0:	d5fb      	bpl.n	8001c9a <stm32_clock_init+0x5a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8001ca2:	4b16      	ldr	r3, [pc, #88]	; (8001cfc <stm32_clock_init+0xbc>)
 8001ca4:	604b      	str	r3, [r1, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8001ca6:	680b      	ldr	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8001ca8:	4a13      	ldr	r2, [pc, #76]	; (8001cf8 <stm32_clock_init+0xb8>)

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8001caa:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001cae:	600b      	str	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8001cb0:	6853      	ldr	r3, [r2, #4]
 8001cb2:	0459      	lsls	r1, r3, #17
 8001cb4:	d5fc      	bpl.n	8001cb0 <stm32_clock_init+0x70>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001cb6:	490f      	ldr	r1, [pc, #60]	; (8001cf4 <stm32_clock_init+0xb4>)
 8001cb8:	680a      	ldr	r2, [r1, #0]
 8001cba:	4b0e      	ldr	r3, [pc, #56]	; (8001cf4 <stm32_clock_init+0xb4>)
 8001cbc:	0192      	lsls	r2, r2, #6
 8001cbe:	d5fb      	bpl.n	8001cb8 <stm32_clock_init+0x78>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8001cc0:	4a0f      	ldr	r2, [pc, #60]	; (8001d00 <stm32_clock_init+0xc0>)
  while (!(RCC->CR & RCC_CR_PLLI2SRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8001cc2:	4910      	ldr	r1, [pc, #64]	; (8001d04 <stm32_clock_init+0xc4>)
 8001cc4:	6099      	str	r1, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8001cc6:	f240 7104 	movw	r1, #1796	; 0x704
 8001cca:	6011      	str	r1, [r2, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8001ccc:	689a      	ldr	r2, [r3, #8]
 8001cce:	f042 0202 	orr.w	r2, r2, #2
 8001cd2:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001cd4:	461a      	mov	r2, r3
 8001cd6:	6893      	ldr	r3, [r2, #8]
 8001cd8:	4906      	ldr	r1, [pc, #24]	; (8001cf4 <stm32_clock_init+0xb4>)
 8001cda:	f003 030c 	and.w	r3, r3, #12
 8001cde:	2b08      	cmp	r3, #8
 8001ce0:	d1f9      	bne.n	8001cd6 <stm32_clock_init+0x96>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8001ce2:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 8001ce4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001ce8:	644b      	str	r3, [r1, #68]	; 0x44
 8001cea:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 8001cec:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001cf0:	664b      	str	r3, [r1, #100]	; 0x64
 8001cf2:	4770      	bx	lr
 8001cf4:	40023800 	.word	0x40023800
 8001cf8:	40007000 	.word	0x40007000
 8001cfc:	07404b19 	.word	0x07404b19
 8001d00:	40023c00 	.word	0x40023c00
 8001d04:	3d689400 	.word	0x3d689400
 8001d08:	f3af 8000 	nop.w
 8001d0c:	f3af 8000 	nop.w

08001d10 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8001d10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8001d14:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 8001ecc <_pal_lld_init+0x1bc>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001d18:	f8df c1b4 	ldr.w	ip, [pc, #436]	; 8001ed0 <_pal_lld_init+0x1c0>
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8001d1c:	f8d8 a030 	ldr.w	sl, [r8, #48]	; 0x30
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001d20:	f8df e1b0 	ldr.w	lr, [pc, #432]	; 8001ed4 <_pal_lld_init+0x1c4>
 8001d24:	4f63      	ldr	r7, [pc, #396]	; (8001eb4 <_pal_lld_init+0x1a4>)
 8001d26:	4e64      	ldr	r6, [pc, #400]	; (8001eb8 <_pal_lld_init+0x1a8>)
 8001d28:	4d64      	ldr	r5, [pc, #400]	; (8001ebc <_pal_lld_init+0x1ac>)
 8001d2a:	4c65      	ldr	r4, [pc, #404]	; (8001ec0 <_pal_lld_init+0x1b0>)
 8001d2c:	4965      	ldr	r1, [pc, #404]	; (8001ec4 <_pal_lld_init+0x1b4>)
 8001d2e:	4a66      	ldr	r2, [pc, #408]	; (8001ec8 <_pal_lld_init+0x1b8>)
 8001d30:	f8df b1a4 	ldr.w	fp, [pc, #420]	; 8001ed8 <_pal_lld_init+0x1c8>
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8001d34:	f240 19ff 	movw	r9, #511	; 0x1ff
 8001d38:	ea4a 0a09 	orr.w	sl, sl, r9
 8001d3c:	f8c8 a030 	str.w	sl, [r8, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 8001d40:	f8d8 a050 	ldr.w	sl, [r8, #80]	; 0x50
 8001d44:	ea4a 0909 	orr.w	r9, sl, r9
 8001d48:	f8c8 9050 	str.w	r9, [r8, #80]	; 0x50
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001d4c:	6843      	ldr	r3, [r0, #4]
 8001d4e:	f8cc 3004 	str.w	r3, [ip, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001d52:	6883      	ldr	r3, [r0, #8]
 8001d54:	f8cc 3008 	str.w	r3, [ip, #8]
  gpiop->PUPDR   = config->pupdr;
 8001d58:	68c3      	ldr	r3, [r0, #12]
 8001d5a:	f8cc 300c 	str.w	r3, [ip, #12]
  gpiop->ODR     = config->odr;
 8001d5e:	6903      	ldr	r3, [r0, #16]
 8001d60:	f8cc 3014 	str.w	r3, [ip, #20]
  gpiop->AFRL    = config->afrl;
 8001d64:	6943      	ldr	r3, [r0, #20]
 8001d66:	f8cc 3020 	str.w	r3, [ip, #32]
  gpiop->AFRH    = config->afrh;
 8001d6a:	6983      	ldr	r3, [r0, #24]
 8001d6c:	f8cc 3024 	str.w	r3, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001d70:	6803      	ldr	r3, [r0, #0]
 8001d72:	f8cc 3000 	str.w	r3, [ip]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001d76:	6a03      	ldr	r3, [r0, #32]
 8001d78:	f8ce 3004 	str.w	r3, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001d7c:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001d7e:	f8ce 3008 	str.w	r3, [lr, #8]
  gpiop->PUPDR   = config->pupdr;
 8001d82:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001d84:	f8ce 300c 	str.w	r3, [lr, #12]
  gpiop->ODR     = config->odr;
 8001d88:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8001d8a:	f8ce 3014 	str.w	r3, [lr, #20]
  gpiop->AFRL    = config->afrl;
 8001d8e:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8001d90:	f8ce 3020 	str.w	r3, [lr, #32]
  gpiop->AFRH    = config->afrh;
 8001d94:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001d96:	f8ce 3024 	str.w	r3, [lr, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001d9a:	69c3      	ldr	r3, [r0, #28]
 8001d9c:	f8ce 3000 	str.w	r3, [lr]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001da0:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8001da2:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001da4:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001da6:	60bb      	str	r3, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 8001da8:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8001daa:	60fb      	str	r3, [r7, #12]
  gpiop->ODR     = config->odr;
 8001dac:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8001dae:	617b      	str	r3, [r7, #20]
  gpiop->AFRL    = config->afrl;
 8001db0:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8001db2:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 8001db4:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8001db6:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001db8:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8001dba:	603b      	str	r3, [r7, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001dbc:	6d87      	ldr	r7, [r0, #88]	; 0x58
 8001dbe:	6077      	str	r7, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001dc0:	6dc7      	ldr	r7, [r0, #92]	; 0x5c
 8001dc2:	60b7      	str	r7, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 8001dc4:	6e07      	ldr	r7, [r0, #96]	; 0x60
 8001dc6:	60f7      	str	r7, [r6, #12]
  gpiop->ODR     = config->odr;
 8001dc8:	6e47      	ldr	r7, [r0, #100]	; 0x64
 8001dca:	6177      	str	r7, [r6, #20]
  gpiop->AFRL    = config->afrl;
 8001dcc:	6e87      	ldr	r7, [r0, #104]	; 0x68
 8001dce:	6237      	str	r7, [r6, #32]
  gpiop->AFRH    = config->afrh;
 8001dd0:	6ec7      	ldr	r7, [r0, #108]	; 0x6c
 8001dd2:	6277      	str	r7, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001dd4:	6d47      	ldr	r7, [r0, #84]	; 0x54
 8001dd6:	6037      	str	r7, [r6, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001dd8:	6f46      	ldr	r6, [r0, #116]	; 0x74
 8001dda:	606e      	str	r6, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001ddc:	6f86      	ldr	r6, [r0, #120]	; 0x78
 8001dde:	60ae      	str	r6, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 8001de0:	6fc6      	ldr	r6, [r0, #124]	; 0x7c
 8001de2:	60ee      	str	r6, [r5, #12]
  gpiop->ODR     = config->odr;
 8001de4:	f8d0 6080 	ldr.w	r6, [r0, #128]	; 0x80
 8001de8:	616e      	str	r6, [r5, #20]
  gpiop->AFRL    = config->afrl;
 8001dea:	f8d0 6084 	ldr.w	r6, [r0, #132]	; 0x84
 8001dee:	622e      	str	r6, [r5, #32]
  gpiop->AFRH    = config->afrh;
 8001df0:	f8d0 6088 	ldr.w	r6, [r0, #136]	; 0x88
 8001df4:	626e      	str	r6, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001df6:	6f06      	ldr	r6, [r0, #112]	; 0x70
 8001df8:	602e      	str	r6, [r5, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001dfa:	f8d0 5090 	ldr.w	r5, [r0, #144]	; 0x90
 8001dfe:	6065      	str	r5, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001e00:	f8d0 5094 	ldr.w	r5, [r0, #148]	; 0x94
 8001e04:	60a5      	str	r5, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8001e06:	f8d0 5098 	ldr.w	r5, [r0, #152]	; 0x98
 8001e0a:	60e5      	str	r5, [r4, #12]
  gpiop->ODR     = config->odr;
 8001e0c:	f8d0 509c 	ldr.w	r5, [r0, #156]	; 0x9c
 8001e10:	6165      	str	r5, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8001e12:	f8d0 50a0 	ldr.w	r5, [r0, #160]	; 0xa0
 8001e16:	6225      	str	r5, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8001e18:	f8d0 50a4 	ldr.w	r5, [r0, #164]	; 0xa4
 8001e1c:	6265      	str	r5, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001e1e:	f8d0 508c 	ldr.w	r5, [r0, #140]	; 0x8c
 8001e22:	6025      	str	r5, [r4, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001e24:	f8d0 40ac 	ldr.w	r4, [r0, #172]	; 0xac
 8001e28:	604c      	str	r4, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001e2a:	f8d0 40b0 	ldr.w	r4, [r0, #176]	; 0xb0
 8001e2e:	608c      	str	r4, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8001e30:	f8d0 40b4 	ldr.w	r4, [r0, #180]	; 0xb4
 8001e34:	60cc      	str	r4, [r1, #12]
  gpiop->ODR     = config->odr;
 8001e36:	f8d0 40b8 	ldr.w	r4, [r0, #184]	; 0xb8
 8001e3a:	614c      	str	r4, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8001e3c:	f8d0 40bc 	ldr.w	r4, [r0, #188]	; 0xbc
 8001e40:	620c      	str	r4, [r1, #32]
  gpiop->AFRH    = config->afrh;
 8001e42:	f8d0 40c0 	ldr.w	r4, [r0, #192]	; 0xc0
 8001e46:	624c      	str	r4, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001e48:	f8d0 40a8 	ldr.w	r4, [r0, #168]	; 0xa8
 8001e4c:	600c      	str	r4, [r1, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001e4e:	f8d0 10c8 	ldr.w	r1, [r0, #200]	; 0xc8
 8001e52:	6051      	str	r1, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001e54:	f8d0 10cc 	ldr.w	r1, [r0, #204]	; 0xcc
 8001e58:	6091      	str	r1, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8001e5a:	f8d0 10d0 	ldr.w	r1, [r0, #208]	; 0xd0
 8001e5e:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 8001e60:	f8d0 10d4 	ldr.w	r1, [r0, #212]	; 0xd4
 8001e64:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8001e66:	f8d0 10d8 	ldr.w	r1, [r0, #216]	; 0xd8
 8001e6a:	6211      	str	r1, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8001e6c:	f8d0 10dc 	ldr.w	r1, [r0, #220]	; 0xdc
 8001e70:	6251      	str	r1, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001e72:	f8d0 10c4 	ldr.w	r1, [r0, #196]	; 0xc4
 8001e76:	6011      	str	r1, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001e78:	f8d0 20e4 	ldr.w	r2, [r0, #228]	; 0xe4
 8001e7c:	f8cb 2004 	str.w	r2, [fp, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001e80:	f8d0 20e8 	ldr.w	r2, [r0, #232]	; 0xe8
 8001e84:	f8cb 2008 	str.w	r2, [fp, #8]
  gpiop->PUPDR   = config->pupdr;
 8001e88:	f8d0 20ec 	ldr.w	r2, [r0, #236]	; 0xec
 8001e8c:	f8cb 200c 	str.w	r2, [fp, #12]
  gpiop->ODR     = config->odr;
 8001e90:	f8d0 20f0 	ldr.w	r2, [r0, #240]	; 0xf0
 8001e94:	f8cb 2014 	str.w	r2, [fp, #20]
  gpiop->AFRL    = config->afrl;
 8001e98:	f8d0 20f4 	ldr.w	r2, [r0, #244]	; 0xf4
 8001e9c:	f8cb 2020 	str.w	r2, [fp, #32]
  gpiop->AFRH    = config->afrh;
 8001ea0:	f8d0 20f8 	ldr.w	r2, [r0, #248]	; 0xf8
 8001ea4:	f8cb 2024 	str.w	r2, [fp, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001ea8:	f8d0 20e0 	ldr.w	r2, [r0, #224]	; 0xe0
 8001eac:	f8cb 2000 	str.w	r2, [fp]
 8001eb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001eb4:	40020800 	.word	0x40020800
 8001eb8:	40020c00 	.word	0x40020c00
 8001ebc:	40021000 	.word	0x40021000
 8001ec0:	40021400 	.word	0x40021400
 8001ec4:	40021800 	.word	0x40021800
 8001ec8:	40021c00 	.word	0x40021c00
 8001ecc:	40023800 	.word	0x40023800
 8001ed0:	40020000 	.word	0x40020000
 8001ed4:	40020400 	.word	0x40020400
 8001ed8:	40022000 	.word	0x40022000
 8001edc:	f3af 8000 	nop.w

08001ee0 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8001ee0:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();
 8001ee2:	f7fe fcdd 	bl	80008a0 <_stats_increase_irq>
 8001ee6:	f7fe fbcb 	bl	8000680 <_dbg_check_enter_isr>

  STM32_ST_TIM->SR = 0;
 8001eea:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001eee:	2400      	movs	r4, #0
 8001ef0:	611c      	str	r4, [r3, #16]
 8001ef2:	2320      	movs	r3, #32
 8001ef4:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 8001ef8:	f7fe fd0a 	bl	8000910 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8001efc:	f7fe fb90 	bl	8000620 <_dbg_check_lock_from_isr>
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
 8001f00:	f7fe fb0e 	bl	8000520 <chSysTimerHandlerI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8001f04:	f7fe fba4 	bl	8000650 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8001f08:	f7fe fd0a 	bl	8000920 <_stats_stop_measure_crit_isr>
 8001f0c:	f384 8811 	msr	BASEPRI, r4

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
 8001f10:	f7fe fbce 	bl	80006b0 <_dbg_check_leave_isr>
}
 8001f14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
 8001f18:	f7fe ba6a 	b.w	80003f0 <_port_irq_epilogue>
 8001f1c:	f3af 8000 	nop.w

08001f20 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8001f20:	b470      	push	{r4, r5, r6}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001f22:	480d      	ldr	r0, [pc, #52]	; (8001f58 <st_lld_init+0x38>)
 8001f24:	6c01      	ldr	r1, [r0, #64]	; 0x40

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001f26:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 8001f2a:	2200      	movs	r2, #0
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8001f2c:	2401      	movs	r4, #1

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001f2e:	f041 0101 	orr.w	r1, r1, #1

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001f32:	f641 564b 	movw	r6, #7499	; 0x1d4b
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001f36:	f04f 35ff 	mov.w	r5, #4294967295

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001f3a:	6401      	str	r1, [r0, #64]	; 0x40

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001f3c:	629e      	str	r6, [r3, #40]	; 0x28
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8001f3e:	201c      	movs	r0, #28
  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001f40:	62dd      	str	r5, [r3, #44]	; 0x2c
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8001f42:	2108      	movs	r1, #8
  ST_ENABLE_CLOCK();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 8001f44:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8001f46:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8001f48:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8001f4a:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8001f4c:	615c      	str	r4, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8001f4e:	601c      	str	r4, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8001f50:	bc70      	pop	{r4, r5, r6}
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8001f52:	f7ff bbf5 	b.w	8001740 <nvicEnableVector>
 8001f56:	bf00      	nop
 8001f58:	40023800 	.word	0x40023800
 8001f5c:	f3af 8000 	nop.w

08001f60 <notify2>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 8001f60:	4a02      	ldr	r2, [pc, #8]	; (8001f6c <notify2+0xc>)
 8001f62:	68d3      	ldr	r3, [r2, #12]
 8001f64:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001f68:	60d3      	str	r3, [r2, #12]
 8001f6a:	4770      	bx	lr
 8001f6c:	40004400 	.word	0x40004400

08001f70 <VectorD8>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8001f70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8001f72:	4e5a      	ldr	r6, [pc, #360]	; (80020dc <VectorD8+0x16c>)
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 8001f74:	f7fe fc94 	bl	80008a0 <_stats_increase_irq>
 8001f78:	f7fe fb82 	bl	8000680 <_dbg_check_enter_isr>
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8001f7c:	6f75      	ldr	r5, [r6, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 8001f7e:	68ef      	ldr	r7, [r5, #12]
  uint16_t sr = u->SR;
 8001f80:	682b      	ldr	r3, [r5, #0]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8001f82:	05da      	lsls	r2, r3, #23
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
  uint16_t sr = u->SR;
 8001f84:	b29c      	uxth	r4, r3

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8001f86:	d469      	bmi.n	800205c <VectorD8+0xec>
 8001f88:	2320      	movs	r3, #32
 8001f8a:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 8001f8e:	f7fe fcbf 	bl	8000910 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8001f92:	f7fe fb45 	bl	8000620 <_dbg_check_lock_from_isr>
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8001f96:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8001f9a:	d108      	bne.n	8001fae <VectorD8+0x3e>
 8001f9c:	e029      	b.n	8001ff2 <VectorD8+0x82>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 8001f9e:	06a0      	lsls	r0, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 8001fa0:	6869      	ldr	r1, [r5, #4]
    if (sr & USART_SR_RXNE)
 8001fa2:	d41d      	bmi.n	8001fe0 <VectorD8+0x70>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 8001fa4:	682c      	ldr	r4, [r5, #0]
 8001fa6:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8001fa8:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8001fac:	d021      	beq.n	8001ff2 <VectorD8+0x82>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8001fae:	0723      	lsls	r3, r4, #28
 8001fb0:	d0f5      	beq.n	8001f9e <VectorD8+0x2e>
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
  eventflags_t sts = 0;

  if (sr & USART_SR_ORE)
    sts |= SD_OVERRUN_ERROR;
 8001fb2:	f014 0f08 	tst.w	r4, #8
 8001fb6:	bf0c      	ite	eq
 8001fb8:	2100      	moveq	r1, #0
 8001fba:	2180      	movne	r1, #128	; 0x80
  if (sr & USART_SR_PE)
 8001fbc:	07e0      	lsls	r0, r4, #31
    sts |= SD_PARITY_ERROR;
 8001fbe:	bf48      	it	mi
 8001fc0:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 8001fc4:	07a2      	lsls	r2, r4, #30
    sts |= SD_FRAMING_ERROR;
 8001fc6:	bf48      	it	mi
 8001fc8:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 8001fcc:	0763      	lsls	r3, r4, #29
    sts |= SD_NOISE_ERROR;
 8001fce:	bf48      	it	mi
 8001fd0:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8001fd4:	4842      	ldr	r0, [pc, #264]	; (80020e0 <VectorD8+0x170>)
 8001fd6:	f7ff f81b 	bl	8001010 <chEvtBroadcastFlagsI>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 8001fda:	06a0      	lsls	r0, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 8001fdc:	6869      	ldr	r1, [r5, #4]
    if (sr & USART_SR_RXNE)
 8001fde:	d5e1      	bpl.n	8001fa4 <VectorD8+0x34>
      sdIncomingDataI(sdp, b);
 8001fe0:	b2c9      	uxtb	r1, r1
 8001fe2:	483e      	ldr	r0, [pc, #248]	; (80020dc <VectorD8+0x16c>)
 8001fe4:	f7ff fb34 	bl	8001650 <sdIncomingDataI>
    sr = u->SR;
 8001fe8:	682c      	ldr	r4, [r5, #0]
 8001fea:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8001fec:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8001ff0:	d1dd      	bne.n	8001fae <VectorD8+0x3e>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8001ff2:	f7fe fb2d 	bl	8000650 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8001ff6:	f7fe fc93 	bl	8000920 <_stats_stop_measure_crit_isr>
 8001ffa:	2300      	movs	r3, #0
 8001ffc:	f383 8811 	msr	BASEPRI, r3
    sr = u->SR;
  }
  osalSysUnlockFromISR();

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8002000:	0639      	lsls	r1, r7, #24
 8002002:	d501      	bpl.n	8002008 <VectorD8+0x98>
 8002004:	0622      	lsls	r2, r4, #24
 8002006:	d440      	bmi.n	800208a <VectorD8+0x11a>
      u->DR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 8002008:	0663      	lsls	r3, r4, #25
 800200a:	d405      	bmi.n	8002018 <VectorD8+0xa8>

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
 800200c:	f7fe fb50 	bl	80006b0 <_dbg_check_leave_isr>
}
 8002010:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
 8002014:	f7fe b9ec 	b.w	80003f0 <_port_irq_epilogue>
 8002018:	2320      	movs	r3, #32
 800201a:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 800201e:	f7fe fc77 	bl	8000910 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8002022:	f7fe fafd 	bl	8000620 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();
 8002026:	f7fe fb5b 	bl	80006e0 <chDbgCheckClassI>

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0));
 800202a:	6c72      	ldr	r2, [r6, #68]	; 0x44
 800202c:	6cb3      	ldr	r3, [r6, #72]	; 0x48
 800202e:	482b      	ldr	r0, [pc, #172]	; (80020dc <VectorD8+0x16c>)
 8002030:	429a      	cmp	r2, r3
 8002032:	d03f      	beq.n	80020b4 <VectorD8+0x144>
  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8002034:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 8002038:	403b      	ands	r3, r7
    u->SR = ~USART_SR_TC;
 800203a:	f06f 0240 	mvn.w	r2, #64	; 0x40
  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 800203e:	60eb      	str	r3, [r5, #12]
    u->SR = ~USART_SR_TC;
 8002040:	602a      	str	r2, [r5, #0]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8002042:	f7fe fb05 	bl	8000650 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8002046:	f7fe fc6b 	bl	8000920 <_stats_stop_measure_crit_isr>
 800204a:	2300      	movs	r3, #0
 800204c:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
 8002050:	f7fe fb2e 	bl	80006b0 <_dbg_check_leave_isr>
}
 8002054:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
 8002058:	f7fe b9ca 	b.w	80003f0 <_port_irq_epilogue>
 800205c:	2320      	movs	r3, #32
 800205e:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 8002062:	f7fe fc55 	bl	8000910 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8002066:	f7fe fadb 	bl	8000620 <_dbg_check_lock_from_isr>
 800206a:	1d30      	adds	r0, r6, #4
 800206c:	f44f 7100 	mov.w	r1, #512	; 0x200
 8002070:	f7fe ffce 	bl	8001010 <chEvtBroadcastFlagsI>

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    u->SR = ~USART_SR_LBD;
 8002074:	f46f 7380 	mvn.w	r3, #256	; 0x100
 8002078:	602b      	str	r3, [r5, #0]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800207a:	f7fe fae9 	bl	8000650 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 800207e:	f7fe fc4f 	bl	8000920 <_stats_stop_measure_crit_isr>
 8002082:	2300      	movs	r3, #0
 8002084:	f383 8811 	msr	BASEPRI, r3
 8002088:	e77e      	b.n	8001f88 <VectorD8+0x18>
 800208a:	2320      	movs	r3, #32
 800208c:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 8002090:	f7fe fc3e 	bl	8000910 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8002094:	f7fe fac4 	bl	8000620 <_dbg_check_lock_from_isr>

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
 8002098:	4812      	ldr	r0, [pc, #72]	; (80020e4 <VectorD8+0x174>)
 800209a:	f7ff f929 	bl	80012f0 <chOQGetI>
    if (b < Q_OK) {
 800209e:	2800      	cmp	r0, #0
 80020a0:	db10      	blt.n	80020c4 <VectorD8+0x154>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->DR = b;
 80020a2:	6068      	str	r0, [r5, #4]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80020a4:	f7fe fad4 	bl	8000650 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 80020a8:	f7fe fc3a 	bl	8000920 <_stats_stop_measure_crit_isr>
 80020ac:	2300      	movs	r3, #0
 80020ae:	f383 8811 	msr	BASEPRI, r3
 80020b2:	e7a9      	b.n	8002008 <VectorD8+0x98>
 80020b4:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80020b6:	2b00      	cmp	r3, #0
 80020b8:	d0bc      	beq.n	8002034 <VectorD8+0xc4>
 80020ba:	3004      	adds	r0, #4
 80020bc:	2110      	movs	r1, #16
 80020be:	f7fe ffa7 	bl	8001010 <chEvtBroadcastFlagsI>
 80020c2:	e7b7      	b.n	8002034 <VectorD8+0xc4>
 80020c4:	4806      	ldr	r0, [pc, #24]	; (80020e0 <VectorD8+0x170>)
 80020c6:	2108      	movs	r1, #8
 80020c8:	f7fe ffa2 	bl	8001010 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 80020cc:	f64f 733f 	movw	r3, #65343	; 0xff3f
 80020d0:	403b      	ands	r3, r7
 80020d2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80020d6:	60eb      	str	r3, [r5, #12]
 80020d8:	e7e4      	b.n	80020a4 <VectorD8+0x134>
 80020da:	bf00      	nop
 80020dc:	20000e84 	.word	0x20000e84
 80020e0:	20000e88 	.word	0x20000e88
 80020e4:	20000eb4 	.word	0x20000eb4
 80020e8:	f3af 8000 	nop.w
 80020ec:	f3af 8000 	nop.w

080020f0 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 80020f0:	b510      	push	{r4, lr}
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 80020f2:	4c04      	ldr	r4, [pc, #16]	; (8002104 <sd_lld_init+0x14>)
 80020f4:	4a04      	ldr	r2, [pc, #16]	; (8002108 <sd_lld_init+0x18>)
 80020f6:	4620      	mov	r0, r4
 80020f8:	2100      	movs	r1, #0
 80020fa:	f7ff fa89 	bl	8001610 <sdObjectInit>
  SD2.usart = USART2;
 80020fe:	4b03      	ldr	r3, [pc, #12]	; (800210c <sd_lld_init+0x1c>)
 8002100:	6763      	str	r3, [r4, #116]	; 0x74
 8002102:	bd10      	pop	{r4, pc}
 8002104:	20000e84 	.word	0x20000e84
 8002108:	08001f61 	.word	0x08001f61
 800210c:	40004400 	.word	0x40004400

08002110 <VectorDC>:
/**
 * @brief   USART3 IRQ handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
 8002110:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void serve_usart_irq(UARTDriver *uartp) {

  uint32_t isr;
  USART_TypeDef *u = uartp->usart;
 8002112:	4e2b      	ldr	r6, [pc, #172]	; (80021c0 <VectorDC+0xb0>)
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 8002114:	f7fe fbc4 	bl	80008a0 <_stats_increase_irq>
 8002118:	f7fe fab2 	bl	8000680 <_dbg_check_enter_isr>
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void serve_usart_irq(UARTDriver *uartp) {

  uint32_t isr;
  USART_TypeDef *u = uartp->usart;
 800211c:	68b7      	ldr	r7, [r6, #8]

  /* Reading and clearing status.*/
  isr = u->SR;
 800211e:	683c      	ldr	r4, [r7, #0]
  //u->ICR = isr;

  /* Error condition detection.*/
  if (isr & (/*USART_SR_LBD |*/ USART_SR_ORE | USART_SR_NE |
 8002120:	0725      	lsls	r5, r4, #28
 8002122:	d019      	beq.n	8002158 <VectorDC+0x48>
             USART_SR_FE  | USART_SR_PE)) {
    if (uartp->config->rxerr_cb != NULL)
 8002124:	6873      	ldr	r3, [r6, #4]
 8002126:	691b      	ldr	r3, [r3, #16]
 8002128:	b1b3      	cbz	r3, 8002158 <VectorDC+0x48>
static uartflags_t translate_errors(uint32_t isr) 
{
  uartflags_t sts = 0;

  if (isr & USART_SR_ORE)
    sts |= UART_OVERRUN_ERROR;
 800212a:	f014 0f08 	tst.w	r4, #8
 800212e:	bf0c      	ite	eq
 8002130:	2100      	moveq	r1, #0
 8002132:	2110      	movne	r1, #16
  if (isr & USART_SR_PE)
 8002134:	07e0      	lsls	r0, r4, #31
    sts |= UART_PARITY_ERROR;
 8002136:	bf48      	it	mi
 8002138:	f041 0104 	orrmi.w	r1, r1, #4
  if (isr & USART_SR_FE)
 800213c:	07a2      	lsls	r2, r4, #30
    sts |= UART_FRAMING_ERROR;
 800213e:	bf48      	it	mi
 8002140:	f041 0108 	orrmi.w	r1, r1, #8
  if (isr & USART_SR_NE)
 8002144:	0765      	lsls	r5, r4, #29
    sts |= UART_NOISE_ERROR;
 8002146:	bf48      	it	mi
 8002148:	f041 0120 	orrmi.w	r1, r1, #32
  if (isr & USART_SR_LBD)
 800214c:	05e0      	lsls	r0, r4, #23
    sts |= UART_BREAK_DETECTED;
 800214e:	bf48      	it	mi
 8002150:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40

  /* Error condition detection.*/
  if (isr & (/*USART_SR_LBD |*/ USART_SR_ORE | USART_SR_NE |
             USART_SR_FE  | USART_SR_PE)) {
    if (uartp->config->rxerr_cb != NULL)
      uartp->config->rxerr_cb(uartp, translate_errors(isr));        // Receive error callback
 8002154:	481a      	ldr	r0, [pc, #104]	; (80021c0 <VectorDC+0xb0>)
 8002156:	4798      	blx	r3
  }

#if STM32_UART_USE_INTERRUPTS
  uint32_t cr1 = u->CR1;
 8002158:	68fd      	ldr	r5, [r7, #12]

  /* Data available (receive). */
  if ((cr1 & USART_CR1_RXNEIE) && (isr & USART_SR_RXNE))
 800215a:	06aa      	lsls	r2, r5, #26
 800215c:	d501      	bpl.n	8002162 <VectorDC+0x52>
 800215e:	06a3      	lsls	r3, r4, #26
 8002160:	d425      	bmi.n	80021ae <VectorDC+0x9e>
        uartp->config->rxchar_cb(uartp, uartp->rxbuf);				// Receive character callback
	//}
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_SR_TXE)) 
 8002162:	0628      	lsls	r0, r5, #24
 8002164:	d501      	bpl.n	800216a <VectorDC+0x5a>
 8002166:	0621      	lsls	r1, r4, #24
 8002168:	d415      	bmi.n	8002196 <VectorDC+0x86>
	    uartp->txstate = UART_TX_IDLE;
      //u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;       // Disable transmit data interrupt, enable TxBuffer empty
    //}
  }
  /* Physical transmission end.*/
  if ((cr1 & USART_CR1_TCIE) && (isr & USART_SR_TC))
 800216a:	066a      	lsls	r2, r5, #25
 800216c:	d50d      	bpl.n	800218a <VectorDC+0x7a>
 800216e:	0663      	lsls	r3, r4, #25
 8002170:	d50b      	bpl.n	800218a <VectorDC+0x7a>
  {
	palClearPad(GPIOG, GPIOG_PIN8);
 8002172:	4a14      	ldr	r2, [pc, #80]	; (80021c4 <VectorDC+0xb4>)
    if (uartp->config->txend2_cb != NULL)
 8002174:	6873      	ldr	r3, [r6, #4]
    //}
  }
  /* Physical transmission end.*/
  if ((cr1 & USART_CR1_TCIE) && (isr & USART_SR_TC))
  {
	palClearPad(GPIOG, GPIOG_PIN8);
 8002176:	f44f 7180 	mov.w	r1, #256	; 0x100
 800217a:	8351      	strh	r1, [r2, #26]
    if (uartp->config->txend2_cb != NULL)
 800217c:	685b      	ldr	r3, [r3, #4]
 800217e:	b10b      	cbz	r3, 8002184 <VectorDC+0x74>
      uartp->config->txend2_cb(uartp);      // Signal that whole transmit message gone
 8002180:	480f      	ldr	r0, [pc, #60]	; (80021c0 <VectorDC+0xb0>)
 8002182:	4798      	blx	r3
    u->CR1 = cr1 & ~USART_CR1_TCIE;         // Disable transmit buffer empty interrupt
 8002184:	f025 0540 	bic.w	r5, r5, #64	; 0x40
 8002188:	60fd      	str	r5, [r7, #12]

  OSAL_IRQ_PROLOGUE();

  serve_usart_irq(&UARTD3);

  OSAL_IRQ_EPILOGUE();
 800218a:	f7fe fa91 	bl	80006b0 <_dbg_check_leave_isr>
}
 800218e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  OSAL_IRQ_PROLOGUE();

  serve_usart_irq(&UARTD3);

  OSAL_IRQ_EPILOGUE();
 8002192:	f7fe b92d 	b.w	80003f0 <_port_irq_epilogue>
    //if (--(uartp->txCount) == 0)
    //{
      //uartp->txBuf = NULL;
      /* A callback is generated, if enabled, after a completed transfer.*/
      //uartp->txstate = UART_TX_COMPLETE;
	  if (uartp->config->txend1_cb != NULL)
 8002196:	6873      	ldr	r3, [r6, #4]
 8002198:	681b      	ldr	r3, [r3, #0]
 800219a:	b10b      	cbz	r3, 80021a0 <VectorDC+0x90>
		uartp->config->txend1_cb(uartp);            // Signal that Tx buffer finished with
 800219c:	4808      	ldr	r0, [pc, #32]	; (80021c0 <VectorDC+0xb0>)
 800219e:	4798      	blx	r3

	  /* If the callback didn't explicitly change state then the transmitter
	     automatically returns to the idle state.*/
	  if (uartp->txstate == UART_TX_COMPLETE)
 80021a0:	7873      	ldrb	r3, [r6, #1]
 80021a2:	4a07      	ldr	r2, [pc, #28]	; (80021c0 <VectorDC+0xb0>)
 80021a4:	2b02      	cmp	r3, #2
	    uartp->txstate = UART_TX_IDLE;
 80021a6:	bf04      	itt	eq
 80021a8:	2300      	moveq	r3, #0
 80021aa:	7053      	strbeq	r3, [r2, #1]
 80021ac:	e7dd      	b.n	800216a <VectorDC+0x5a>
	    }
	  }
	}*/
	//else
	//{   // Receive character while in UART_RX_IDLE mode
      if (uartp->config->rxchar_cb != NULL)
 80021ae:	6873      	ldr	r3, [r6, #4]
 80021b0:	4803      	ldr	r0, [pc, #12]	; (80021c0 <VectorDC+0xb0>)
 80021b2:	68db      	ldr	r3, [r3, #12]
 80021b4:	2b00      	cmp	r3, #0
 80021b6:	d0d4      	beq.n	8002162 <VectorDC+0x52>
        uartp->config->rxchar_cb(uartp, uartp->rxbuf);				// Receive character callback
 80021b8:	8981      	ldrh	r1, [r0, #12]
 80021ba:	b289      	uxth	r1, r1
 80021bc:	4798      	blx	r3
 80021be:	e7d0      	b.n	8002162 <VectorDC+0x52>
 80021c0:	20000efc 	.word	0x20000efc
 80021c4:	40021800 	.word	0x40021800
 80021c8:	f3af 8000 	nop.w
 80021cc:	f3af 8000 	nop.w

080021d0 <uart_lld_init>:
/**
 * @brief   Low level UART driver initialization.
 *
 * @notapi
 */
void uart_lld_init(void) {
 80021d0:	b510      	push	{r4, lr}
  UARTD2.dmatx   = STM32_DMA_STREAM(STM32_UART_USART2_TX_DMA_STREAM);
  #endif
#endif

#if STM32_UART_USE_USART3
  uartObjectInit(&UARTD3);
 80021d2:	4c03      	ldr	r4, [pc, #12]	; (80021e0 <uart_lld_init+0x10>)
 80021d4:	4620      	mov	r0, r4
 80021d6:	f7ff faab 	bl	8001730 <uartObjectInit>
  UARTD3.usart   = USART3;
 80021da:	4b02      	ldr	r3, [pc, #8]	; (80021e4 <uart_lld_init+0x14>)
 80021dc:	60a3      	str	r3, [r4, #8]
 80021de:	bd10      	pop	{r4, pc}
 80021e0:	20000efc 	.word	0x20000efc
 80021e4:	40004800 	.word	0x40004800
 80021e8:	f3af 8000 	nop.w
 80021ec:	f3af 8000 	nop.w

080021f0 <__early_init>:
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
 80021f0:	f7ff bd26 	b.w	8001c40 <stm32_clock_init>
 80021f4:	f3af 8000 	nop.w
 80021f8:	f3af 8000 	nop.w
 80021fc:	f3af 8000 	nop.w

08002200 <boardInit>:

/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
 8002200:	4770      	bx	lr
 8002202:	bf00      	nop
 8002204:	f3af 8000 	nop.w
 8002208:	f3af 8000 	nop.w
 800220c:	f3af 8000 	nop.w

08002210 <long_to_string_with_divisor.constprop.0>:
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
 8002210:	b4f0      	push	{r4, r5, r6, r7}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8002212:	f100 070b 	add.w	r7, r0, #11
 8002216:	463c      	mov	r4, r7
 8002218:	460d      	mov	r5, r1
  do {
    i = (int)(l % radix);
 800221a:	fbb1 f6f2 	udiv	r6, r1, r2
 800221e:	fb02 1116 	mls	r1, r2, r6, r1
    i += '0';
 8002222:	f101 0330 	add.w	r3, r1, #48	; 0x30
    if (i > '9')
 8002226:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
 8002228:	bfc8      	it	gt
 800222a:	f101 0337 	addgt.w	r3, r1, #55	; 0x37
    *--q = i;
 800222e:	b2db      	uxtb	r3, r3
 8002230:	f804 3d01 	strb.w	r3, [r4, #-1]!
    l /= radix;
  } while ((ll /= radix) != 0);
 8002234:	fbb5 f5f2 	udiv	r5, r5, r2
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
 8002238:	4631      	mov	r1, r6
  } while ((ll /= radix) != 0);
 800223a:	2d00      	cmp	r5, #0
 800223c:	d1ed      	bne.n	800221a <long_to_string_with_divisor.constprop.0+0xa>

  i = (int)(p + MAX_FILLER - q);
 800223e:	1b3a      	subs	r2, r7, r4
 8002240:	4402      	add	r2, r0
 8002242:	e001      	b.n	8002248 <long_to_string_with_divisor.constprop.0+0x38>
 8002244:	f814 3f01 	ldrb.w	r3, [r4, #1]!
  do
    *p++ = *q++;
 8002248:	f800 3b01 	strb.w	r3, [r0], #1
  while (--i);
 800224c:	4290      	cmp	r0, r2
 800224e:	d1f9      	bne.n	8002244 <long_to_string_with_divisor.constprop.0+0x34>

  return p;
}
 8002250:	bcf0      	pop	{r4, r5, r6, r7}
 8002252:	4770      	bx	lr
 8002254:	f3af 8000 	nop.w
 8002258:	f3af 8000 	nop.w
 800225c:	f3af 8000 	nop.w

08002260 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8002260:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002264:	b087      	sub	sp, #28
 8002266:	4615      	mov	r5, r2
 8002268:	f10d 030d 	add.w	r3, sp, #13
 800226c:	aa03      	add	r2, sp, #12
 800226e:	1a9b      	subs	r3, r3, r2
 8002270:	4681      	mov	r9, r0
 8002272:	468a      	mov	sl, r1
 8002274:	9301      	str	r3, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8002276:	f04f 0800 	mov.w	r8, #0
 800227a:	468b      	mov	fp, r1
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 800227c:	f89b 1000 	ldrb.w	r1, [fp]
 8002280:	f10b 0301 	add.w	r3, fp, #1
    if (c == 0)
 8002284:	b179      	cbz	r1, 80022a6 <chvprintf+0x46>
      return n;
    if (c != '%') {
 8002286:	2925      	cmp	r1, #37	; 0x25
 8002288:	d011      	beq.n	80022ae <chvprintf+0x4e>
      chSequentialStreamPut(chp, (uint8_t)c);
 800228a:	f8d9 2000 	ldr.w	r2, [r9]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 800228e:	469b      	mov	fp, r3
    if (c == 0)
      return n;
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
 8002290:	6892      	ldr	r2, [r2, #8]
 8002292:	4648      	mov	r0, r9
 8002294:	4790      	blx	r2
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 8002296:	f89b 1000 	ldrb.w	r1, [fp]
    if (c == 0)
      return n;
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
 800229a:	f108 0801 	add.w	r8, r8, #1
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 800229e:	f10b 0301 	add.w	r3, fp, #1
    if (c == 0)
 80022a2:	2900      	cmp	r1, #0
 80022a4:	d1ef      	bne.n	8002286 <chvprintf+0x26>
      chSequentialStreamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 80022a6:	4640      	mov	r0, r8
 80022a8:	b007      	add	sp, #28
 80022aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 80022ae:	f89b 2001 	ldrb.w	r2, [fp, #1]
 80022b2:	2a2d      	cmp	r2, #45	; 0x2d
 80022b4:	bf03      	ittte	eq
 80022b6:	f89b 2002 	ldrbeq.w	r2, [fp, #2]
      fmt++;
 80022ba:	f10b 0302 	addeq.w	r3, fp, #2
      left_align = TRUE;
 80022be:	f04f 0a01 	moveq.w	sl, #1
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
 80022c2:	f04f 0a00 	movne.w	sl, #0
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
 80022c6:	2a30      	cmp	r2, #48	; 0x30
 80022c8:	bf03      	ittte	eq
 80022ca:	785a      	ldrbeq	r2, [r3, #1]
      fmt++;
 80022cc:	3301      	addeq	r3, #1
      filler = '0';
 80022ce:	2730      	moveq	r7, #48	; 0x30
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
 80022d0:	2720      	movne	r7, #32
 80022d2:	1c59      	adds	r1, r3, #1
    if (*fmt == '0') {
      fmt++;
      filler = '0';
    }
    width = 0;
 80022d4:	2600      	movs	r6, #0
 80022d6:	e006      	b.n	80022e6 <chvprintf+0x86>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
 80022d8:	782b      	ldrb	r3, [r5, #0]
 80022da:	3504      	adds	r5, #4
 80022dc:	f89b 2000 	ldrb.w	r2, [fp]
      else
        break;
      width = width * 10 + c;
 80022e0:	eb03 0640 	add.w	r6, r3, r0, lsl #1
 80022e4:	3101      	adds	r1, #1
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 80022e6:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 80022ea:	b2db      	uxtb	r3, r3
 80022ec:	2b09      	cmp	r3, #9
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
 80022ee:	468b      	mov	fp, r1
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
 80022f0:	eb06 0086 	add.w	r0, r6, r6, lsl #2
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 80022f4:	d9f2      	bls.n	80022dc <chvprintf+0x7c>
        c -= '0';
      else if (c == '*')
 80022f6:	2a2a      	cmp	r2, #42	; 0x2a
 80022f8:	d0ee      	beq.n	80022d8 <chvprintf+0x78>
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
 80022fa:	2a2e      	cmp	r2, #46	; 0x2e
 80022fc:	f04f 0100 	mov.w	r1, #0
 8002300:	d043      	beq.n	800238a <chvprintf+0x12a>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8002302:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 8002306:	2b4c      	cmp	r3, #76	; 0x4c
 8002308:	d04e      	beq.n	80023a8 <chvprintf+0x148>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 800230a:	f1a2 0044 	sub.w	r0, r2, #68	; 0x44
 800230e:	2834      	cmp	r0, #52	; 0x34
 8002310:	f200 80f7 	bhi.w	8002502 <chvprintf+0x2a2>
 8002314:	e8df f010 	tbh	[pc, r0, lsl #1]
 8002318:	00f500ea 	.word	0x00f500ea
 800231c:	00f500f5 	.word	0x00f500f5
 8002320:	00ea00f5 	.word	0x00ea00f5
 8002324:	00f500f5 	.word	0x00f500f5
 8002328:	00f500f5 	.word	0x00f500f5
 800232c:	00e800f5 	.word	0x00e800f5
 8002330:	00f500f5 	.word	0x00f500f5
 8002334:	00f500f5 	.word	0x00f500f5
 8002338:	00dd00f5 	.word	0x00dd00f5
 800233c:	00f500f5 	.word	0x00f500f5
 8002340:	00f500f2 	.word	0x00f500f2
 8002344:	00f500f5 	.word	0x00f500f5
 8002348:	00f500f5 	.word	0x00f500f5
 800234c:	00f500f5 	.word	0x00f500f5
 8002350:	00f500f5 	.word	0x00f500f5
 8002354:	00a100f5 	.word	0x00a100f5
 8002358:	00f500ea 	.word	0x00f500ea
 800235c:	00f500f5 	.word	0x00f500f5
 8002360:	00ea00f5 	.word	0x00ea00f5
 8002364:	00f500f5 	.word	0x00f500f5
 8002368:	00f500f5 	.word	0x00f500f5
 800236c:	00e800f5 	.word	0x00e800f5
 8002370:	00f500f5 	.word	0x00f500f5
 8002374:	007100f5 	.word	0x007100f5
 8002378:	00dd00f5 	.word	0x00dd00f5
 800237c:	00f500f5 	.word	0x00f500f5
 8002380:	00f2      	.short	0x00f2
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
 8002382:	782b      	ldrb	r3, [r5, #0]
 8002384:	3504      	adds	r5, #4
        else
          break;
        precision *= 10;
        precision += c;
 8002386:	eb03 0140 	add.w	r1, r3, r0, lsl #1
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 800238a:	f81b 2b01 	ldrb.w	r2, [fp], #1
        if (c >= '0' && c <= '9')
 800238e:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8002392:	b2db      	uxtb	r3, r3
 8002394:	2b09      	cmp	r3, #9
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
        else
          break;
        precision *= 10;
 8002396:	eb01 0081 	add.w	r0, r1, r1, lsl #2
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
 800239a:	d9f4      	bls.n	8002386 <chvprintf+0x126>
          c -= '0';
        else if (c == '*')
 800239c:	2a2a      	cmp	r2, #42	; 0x2a
 800239e:	d0f0      	beq.n	8002382 <chvprintf+0x122>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 80023a0:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 80023a4:	2b4c      	cmp	r3, #76	; 0x4c
 80023a6:	d1b0      	bne.n	800230a <chvprintf+0xaa>
      is_long = TRUE;
      if (*fmt)
 80023a8:	f89b 3000 	ldrb.w	r3, [fp]
 80023ac:	2b00      	cmp	r3, #0
 80023ae:	f000 80a8 	beq.w	8002502 <chvprintf+0x2a2>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80023b2:	f1a3 0244 	sub.w	r2, r3, #68	; 0x44
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 80023b6:	f10b 0b01 	add.w	fp, fp, #1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80023ba:	2a34      	cmp	r2, #52	; 0x34
 80023bc:	f200 80a0 	bhi.w	8002500 <chvprintf+0x2a0>
 80023c0:	e8df f002 	tbb	[pc, r2]
 80023c4:	9e9e9e94 	.word	0x9e9e9e94
 80023c8:	9e9e949e 	.word	0x9e9e949e
 80023cc:	929e9e9e 	.word	0x929e9e9e
 80023d0:	9e9e9e9e 	.word	0x9e9e9e9e
 80023d4:	9e9e879e 	.word	0x9e9e879e
 80023d8:	9e9e9e9c 	.word	0x9e9e9e9c
 80023dc:	9e9e9e9e 	.word	0x9e9e9e9e
 80023e0:	4b9e9e9e 	.word	0x4b9e9e9e
 80023e4:	9e9e9e94 	.word	0x9e9e9e94
 80023e8:	9e9e949e 	.word	0x9e9e949e
 80023ec:	929e9e9e 	.word	0x929e9e9e
 80023f0:	1b9e9e9e 	.word	0x1b9e9e9e
 80023f4:	9e9e879e 	.word	0x9e9e879e
 80023f8:	9c          	.byte	0x9c
 80023f9:	00          	.byte	0x00
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 80023fa:	682c      	ldr	r4, [r5, #0]
        s = "(null)";
 80023fc:	4b5a      	ldr	r3, [pc, #360]	; (8002568 <chvprintf+0x308>)
 80023fe:	2c00      	cmp	r4, #0
 8002400:	bf08      	it	eq
 8002402:	461c      	moveq	r4, r3
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8002404:	3504      	adds	r5, #4
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8002406:	7823      	ldrb	r3, [r4, #0]
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
 8002408:	2900      	cmp	r1, #0
 800240a:	f000 8094 	beq.w	8002536 <chvprintf+0x2d6>
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 800240e:	2b00      	cmp	r3, #0
 8002410:	f000 8096 	beq.w	8002540 <chvprintf+0x2e0>
 8002414:	3901      	subs	r1, #1
 8002416:	4620      	mov	r0, r4
 8002418:	e001      	b.n	800241e <chvprintf+0x1be>
 800241a:	3901      	subs	r1, #1
 800241c:	d403      	bmi.n	8002426 <chvprintf+0x1c6>
 800241e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8002422:	2b00      	cmp	r3, #0
 8002424:	d1f9      	bne.n	800241a <chvprintf+0x1ba>
 8002426:	1b00      	subs	r0, r0, r4
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 8002428:	1a36      	subs	r6, r6, r0
 800242a:	1e43      	subs	r3, r0, #1
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 800242c:	2720      	movs	r7, #32
 800242e:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8002432:	f1ba 0f00 	cmp.w	sl, #0
 8002436:	d01f      	beq.n	8002478 <chvprintf+0x218>
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8002438:	2b00      	cmp	r3, #0
 800243a:	9300      	str	r3, [sp, #0]
 800243c:	da34      	bge.n	80024a8 <chvprintf+0x248>
      chSequentialStreamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 800243e:	2e00      	cmp	r6, #0
 8002440:	f43f af1c 	beq.w	800227c <chvprintf+0x1c>
 8002444:	4634      	mov	r4, r6
      chSequentialStreamPut(chp, (uint8_t)filler);
 8002446:	f8d9 3000 	ldr.w	r3, [r9]
 800244a:	4648      	mov	r0, r9
 800244c:	689b      	ldr	r3, [r3, #8]
 800244e:	4639      	mov	r1, r7
 8002450:	4798      	blx	r3
    while (--i >= 0) {
      chSequentialStreamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8002452:	3c01      	subs	r4, #1
 8002454:	d1f7      	bne.n	8002446 <chvprintf+0x1e6>
 8002456:	44b0      	add	r8, r6
 8002458:	e710      	b.n	800227c <chvprintf+0x1c>

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 800245a:	682b      	ldr	r3, [r5, #0]
 800245c:	f88d 300c 	strb.w	r3, [sp, #12]
 8002460:	9b01      	ldr	r3, [sp, #4]
 8002462:	3504      	adds	r5, #4
 8002464:	4618      	mov	r0, r3
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 8002466:	2720      	movs	r7, #32
 8002468:	3b01      	subs	r3, #1
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 800246a:	ac03      	add	r4, sp, #12
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 800246c:	1a36      	subs	r6, r6, r0
 800246e:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      width = 0;
    if (left_align == FALSE)
 8002472:	f1ba 0f00 	cmp.w	sl, #0
 8002476:	d1df      	bne.n	8002438 <chvprintf+0x1d8>
 8002478:	9300      	str	r3, [sp, #0]
      width = -width;
 800247a:	f1c6 0a00 	rsb	sl, r6, #0
    if (width < 0) {
 800247e:	f1ba 0f00 	cmp.w	sl, #0
 8002482:	d045      	beq.n	8002510 <chvprintf+0x2b0>
      if (*s == '-' && filler == '0') {
 8002484:	7821      	ldrb	r1, [r4, #0]
 8002486:	292d      	cmp	r1, #45	; 0x2d
 8002488:	d047      	beq.n	800251a <chvprintf+0x2ba>
        chSequentialStreamPut(chp, (uint8_t)*s++);
        n++;
 800248a:	4656      	mov	r6, sl
        i--;
      }
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
 800248c:	f8d9 3000 	ldr.w	r3, [r9]
 8002490:	4648      	mov	r0, r9
 8002492:	689b      	ldr	r3, [r3, #8]
 8002494:	4639      	mov	r1, r7
 8002496:	4798      	blx	r3
        n++;
      } while (++width != 0);
 8002498:	3601      	adds	r6, #1
 800249a:	d1f7      	bne.n	800248c <chvprintf+0x22c>
    }
    while (--i >= 0) {
 800249c:	9b00      	ldr	r3, [sp, #0]
 800249e:	2b00      	cmp	r3, #0
 80024a0:	ebca 0808 	rsb	r8, sl, r8
 80024a4:	f6ff aeea 	blt.w	800227c <chvprintf+0x1c>
 80024a8:	f8dd a000 	ldr.w	sl, [sp]
      chSequentialStreamPut(chp, (uint8_t)*s++);
 80024ac:	f8d9 3000 	ldr.w	r3, [r9]
 80024b0:	f814 1b01 	ldrb.w	r1, [r4], #1
 80024b4:	689b      	ldr	r3, [r3, #8]
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 80024b6:	f10a 3aff 	add.w	sl, sl, #4294967295
      chSequentialStreamPut(chp, (uint8_t)*s++);
 80024ba:	4648      	mov	r0, r9
 80024bc:	4798      	blx	r3
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 80024be:	f1ba 3fff 	cmp.w	sl, #4294967295
 80024c2:	d1f3      	bne.n	80024ac <chvprintf+0x24c>
 80024c4:	9b00      	ldr	r3, [sp, #0]
 80024c6:	f108 0801 	add.w	r8, r8, #1
 80024ca:	2b00      	cmp	r3, #0
 80024cc:	bfa8      	it	ge
 80024ce:	4498      	addge	r8, r3
 80024d0:	e7b5      	b.n	800243e <chvprintf+0x1de>
      c = 16;
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
      goto unsigned_common;
 80024d2:	220a      	movs	r2, #10
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 80024d4:	6829      	ldr	r1, [r5, #0]
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 80024d6:	a803      	add	r0, sp, #12
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 80024d8:	3504      	adds	r5, #4
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 80024da:	f7ff fe99 	bl	8002210 <long_to_string_with_divisor.constprop.0>
 80024de:	ab03      	add	r3, sp, #12
 80024e0:	1ac0      	subs	r0, r0, r3
 80024e2:	1e43      	subs	r3, r0, #1
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 80024e4:	ac03      	add	r4, sp, #12
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
 80024e6:	e7c1      	b.n	800246c <chvprintf+0x20c>
 80024e8:	2208      	movs	r2, #8
 80024ea:	e7f3      	b.n	80024d4 <chvprintf+0x274>
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 80024ec:	6829      	ldr	r1, [r5, #0]
      if (l < 0) {
 80024ee:	2900      	cmp	r1, #0
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 80024f0:	f105 0504 	add.w	r5, r5, #4
      if (l < 0) {
 80024f4:	db2e      	blt.n	8002554 <chvprintf+0x2f4>
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 80024f6:	a803      	add	r0, sp, #12
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 80024f8:	220a      	movs	r2, #10
 80024fa:	e7ee      	b.n	80024da <chvprintf+0x27a>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80024fc:	2210      	movs	r2, #16
 80024fe:	e7e9      	b.n	80024d4 <chvprintf+0x274>
 8002500:	461a      	mov	r2, r3
 8002502:	9b01      	ldr	r3, [sp, #4]
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8002504:	f88d 200c 	strb.w	r2, [sp, #12]
 8002508:	4618      	mov	r0, r3
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 800250a:	ac03      	add	r4, sp, #12
 800250c:	3b01      	subs	r3, #1
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
      break;
 800250e:	e7ad      	b.n	800246c <chvprintf+0x20c>
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8002510:	9b00      	ldr	r3, [sp, #0]
 8002512:	2b00      	cmp	r3, #0
 8002514:	4656      	mov	r6, sl
 8002516:	dac7      	bge.n	80024a8 <chvprintf+0x248>
 8002518:	e6b0      	b.n	800227c <chvprintf+0x1c>
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
 800251a:	2f30      	cmp	r7, #48	; 0x30
 800251c:	d1b5      	bne.n	800248a <chvprintf+0x22a>
        chSequentialStreamPut(chp, (uint8_t)*s++);
 800251e:	f8d9 3000 	ldr.w	r3, [r9]
 8002522:	4648      	mov	r0, r9
 8002524:	689b      	ldr	r3, [r3, #8]
 8002526:	4798      	blx	r3
 8002528:	9b00      	ldr	r3, [sp, #0]
 800252a:	3b01      	subs	r3, #1
 800252c:	3401      	adds	r4, #1
        n++;
 800252e:	f108 0801 	add.w	r8, r8, #1
 8002532:	9300      	str	r3, [sp, #0]
 8002534:	e7a9      	b.n	800248a <chvprintf+0x22a>
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8002536:	f647 71fe 	movw	r1, #32766	; 0x7ffe
 800253a:	2b00      	cmp	r3, #0
 800253c:	f47f af6b 	bne.w	8002416 <chvprintf+0x1b6>
 8002540:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8002544:	f1ba 0f00 	cmp.w	sl, #0
 8002548:	d10b      	bne.n	8002562 <chvprintf+0x302>
 800254a:	f04f 33ff 	mov.w	r3, #4294967295
 800254e:	9300      	str	r3, [sp, #0]
 8002550:	2720      	movs	r7, #32
 8002552:	e792      	b.n	800247a <chvprintf+0x21a>
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8002554:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 8002556:	4249      	negs	r1, r1
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8002558:	f88d 300c 	strb.w	r3, [sp, #12]
 800255c:	f10d 000d 	add.w	r0, sp, #13
 8002560:	e7ca      	b.n	80024f8 <chvprintf+0x298>
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8002562:	2720      	movs	r7, #32
 8002564:	e76b      	b.n	800243e <chvprintf+0x1de>
 8002566:	bf00      	nop
 8002568:	08002be0 	.word	0x08002be0
 800256c:	f3af 8000 	nop.w

08002570 <get>:
static msg_t get(void *ip) {

  (void)ip;

  return 4;
}
 8002570:	2004      	movs	r0, #4
 8002572:	4770      	bx	lr
 8002574:	f3af 8000 	nop.w
 8002578:	f3af 8000 	nop.w
 800257c:	f3af 8000 	nop.w

08002580 <reads>:
  (void)ip;
  (void)bp;
  (void)n;

  return 0;
}
 8002580:	2000      	movs	r0, #0
 8002582:	4770      	bx	lr
 8002584:	f3af 8000 	nop.w
 8002588:	f3af 8000 	nop.w
 800258c:	f3af 8000 	nop.w

08002590 <put>:
extern void Debug_ITMDebugOutputChar(char ch);

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static msg_t put(void *ip, uint8_t b) {
 8002590:	b508      	push	{r3, lr}

  (void)ip;
  
  Debug_ITMDebugOutputChar(b);
 8002592:	4608      	mov	r0, r1
 8002594:	f000 f914 	bl	80027c0 <Debug_ITMDebugOutputChar>

  return 1;
}
 8002598:	2001      	movs	r0, #1
 800259a:	bd08      	pop	{r3, pc}
 800259c:	f3af 8000 	nop.w

080025a0 <writes>:
  (void)ip;

  return 4;
}

static size_t writes(void *ip, const uint8_t *bp, size_t n) {
 80025a0:	b570      	push	{r4, r5, r6, lr}
  size_t cnt = n;

  while (cnt > 0) {
 80025a2:	4616      	mov	r6, r2
 80025a4:	b13a      	cbz	r2, 80025b6 <writes+0x16>
 80025a6:	460d      	mov	r5, r1
 80025a8:	4614      	mov	r4, r2
/*===========================================================================*/
static msg_t put(void *ip, uint8_t b) {

  (void)ip;
  
  Debug_ITMDebugOutputChar(b);
 80025aa:	f815 0b01 	ldrb.w	r0, [r5], #1
 80025ae:	f000 f907 	bl	80027c0 <Debug_ITMDebugOutputChar>
}

static size_t writes(void *ip, const uint8_t *bp, size_t n) {
  size_t cnt = n;

  while (cnt > 0) {
 80025b2:	3c01      	subs	r4, #1
 80025b4:	d1f9      	bne.n	80025aa <writes+0xa>
    bp++;
    cnt--;
  }

  return n;
}
 80025b6:	4630      	mov	r0, r6
 80025b8:	bd70      	pop	{r4, r5, r6, pc}
 80025ba:	bf00      	nop
 80025bc:	f3af 8000 	nop.w

080025c0 <itmObjectInit>:
 * @brief   ITM stream object initialization.
 *
 * @param[out] pitm      pointer to the @p ITMStream object to be initialized
 */
void itmObjectInit(ITMStream *pitm) {
   pitm->vmt = &vmt;
 80025c0:	4b01      	ldr	r3, [pc, #4]	; (80025c8 <itmObjectInit+0x8>)
 80025c2:	6003      	str	r3, [r0, #0]
 80025c4:	4770      	bx	lr
 80025c6:	bf00      	nop
 80025c8:	08002bf0 	.word	0x08002bf0
 80025cc:	f3af 8000 	nop.w

080025d0 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80025d0:	b40e      	push	{r1, r2, r3}
 80025d2:	b500      	push	{lr}
 80025d4:	b082      	sub	sp, #8
 80025d6:	aa03      	add	r2, sp, #12
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
 80025d8:	4805      	ldr	r0, [pc, #20]	; (80025f0 <chprintf.constprop.0+0x20>)
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80025da:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80025de:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80025e0:	f7ff fe3e 	bl	8002260 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 80025e4:	b002      	add	sp, #8
 80025e6:	f85d eb04 	ldr.w	lr, [sp], #4
 80025ea:	b003      	add	sp, #12
 80025ec:	4770      	bx	lr
 80025ee:	bf00      	nop
 80025f0:	20001214 	.word	0x20001214
 80025f4:	f3af 8000 	nop.w
 80025f8:	f3af 8000 	nop.w
 80025fc:	f3af 8000 	nop.w

08002600 <En_queue>:
	}
	
	return Element;
}

void En_queue(char Element){
 8002600:	b470      	push	{r4, r5, r6}
	if((Wrpos - Rdpos) <= SIZE_QUEUE){
 8002602:	4b0b      	ldr	r3, [pc, #44]	; (8002630 <En_queue+0x30>)
 8002604:	4c0b      	ldr	r4, [pc, #44]	; (8002634 <En_queue+0x34>)
 8002606:	781b      	ldrb	r3, [r3, #0]
 8002608:	7821      	ldrb	r1, [r4, #0]
 800260a:	1acb      	subs	r3, r1, r3
 800260c:	2b20      	cmp	r3, #32
 800260e:	dd01      	ble.n	8002614 <En_queue+0x14>
		Queue[Wrpos % SIZE_QUEUE] = Element;
		Wrpos++;
		chprintf((BaseSequentialStream *)&itm_port, "WritePos: %d\n", Wrpos);
	}
}
 8002610:	bc70      	pop	{r4, r5, r6}
 8002612:	4770      	bx	lr
}

void En_queue(char Element){
	if((Wrpos - Rdpos) <= SIZE_QUEUE){
		Queue[Wrpos % SIZE_QUEUE] = Element;
		Wrpos++;
 8002614:	1c4a      	adds	r2, r1, #1
	return Element;
}

void En_queue(char Element){
	if((Wrpos - Rdpos) <= SIZE_QUEUE){
		Queue[Wrpos % SIZE_QUEUE] = Element;
 8002616:	f001 031f 	and.w	r3, r1, #31
 800261a:	4e07      	ldr	r6, [pc, #28]	; (8002638 <En_queue+0x38>)
		Wrpos++;
		chprintf((BaseSequentialStream *)&itm_port, "WritePos: %d\n", Wrpos);
 800261c:	4907      	ldr	r1, [pc, #28]	; (800263c <En_queue+0x3c>)
 800261e:	4605      	mov	r5, r0
}

void En_queue(char Element){
	if((Wrpos - Rdpos) <= SIZE_QUEUE){
		Queue[Wrpos % SIZE_QUEUE] = Element;
		Wrpos++;
 8002620:	b2d2      	uxtb	r2, r2
 8002622:	7022      	strb	r2, [r4, #0]
	return Element;
}

void En_queue(char Element){
	if((Wrpos - Rdpos) <= SIZE_QUEUE){
		Queue[Wrpos % SIZE_QUEUE] = Element;
 8002624:	54f5      	strb	r5, [r6, r3]
		Wrpos++;
		chprintf((BaseSequentialStream *)&itm_port, "WritePos: %d\n", Wrpos);
 8002626:	4806      	ldr	r0, [pc, #24]	; (8002640 <En_queue+0x40>)
	}
}
 8002628:	bc70      	pop	{r4, r5, r6}

void En_queue(char Element){
	if((Wrpos - Rdpos) <= SIZE_QUEUE){
		Queue[Wrpos % SIZE_QUEUE] = Element;
		Wrpos++;
		chprintf((BaseSequentialStream *)&itm_port, "WritePos: %d\n", Wrpos);
 800262a:	f7ff bfd1 	b.w	80025d0 <chprintf.constprop.0>
 800262e:	bf00      	nop
 8002630:	20000f18 	.word	0x20000f18
 8002634:	20000f3c 	.word	0x20000f3c
 8002638:	20000f1c 	.word	0x20000f1c
 800263c:	08002c00 	.word	0x08002c00
 8002640:	20001214 	.word	0x20001214
 8002644:	f3af 8000 	nop.w
 8002648:	f3af 8000 	nop.w
 800264c:	f3af 8000 	nop.w

08002650 <De_queue>:
	}
}

char De_queue(void){
 8002650:	b538      	push	{r3, r4, r5, lr}
	char Element;

	if(Wrpos > Rdpos){
 8002652:	4d0b      	ldr	r5, [pc, #44]	; (8002680 <De_queue+0x30>)
 8002654:	4b0b      	ldr	r3, [pc, #44]	; (8002684 <De_queue+0x34>)
 8002656:	782a      	ldrb	r2, [r5, #0]
 8002658:	781b      	ldrb	r3, [r3, #0]
 800265a:	4293      	cmp	r3, r2
 800265c:	d801      	bhi.n	8002662 <De_queue+0x12>
		chprintf((BaseSequentialStream *)&itm_port, "ReadPos: %d\n", Rdpos);

		return Element;
	}

	return 0;
 800265e:	2000      	movs	r0, #0
}
 8002660:	bd38      	pop	{r3, r4, r5, pc}

char De_queue(void){
	char Element;

	if(Wrpos > Rdpos){
		Element = Queue[Rdpos % SIZE_QUEUE];
 8002662:	f002 031f 	and.w	r3, r2, #31
 8002666:	4908      	ldr	r1, [pc, #32]	; (8002688 <De_queue+0x38>)
		Rdpos++;
		chprintf((BaseSequentialStream *)&itm_port, "ReadPos: %d\n", Rdpos);
 8002668:	4808      	ldr	r0, [pc, #32]	; (800268c <De_queue+0x3c>)

char De_queue(void){
	char Element;

	if(Wrpos > Rdpos){
		Element = Queue[Rdpos % SIZE_QUEUE];
 800266a:	5ccc      	ldrb	r4, [r1, r3]
		Rdpos++;
		chprintf((BaseSequentialStream *)&itm_port, "ReadPos: %d\n", Rdpos);
 800266c:	4908      	ldr	r1, [pc, #32]	; (8002690 <De_queue+0x40>)
char De_queue(void){
	char Element;

	if(Wrpos > Rdpos){
		Element = Queue[Rdpos % SIZE_QUEUE];
		Rdpos++;
 800266e:	3201      	adds	r2, #1
 8002670:	b2d3      	uxtb	r3, r2
		chprintf((BaseSequentialStream *)&itm_port, "ReadPos: %d\n", Rdpos);
 8002672:	461a      	mov	r2, r3
char De_queue(void){
	char Element;

	if(Wrpos > Rdpos){
		Element = Queue[Rdpos % SIZE_QUEUE];
		Rdpos++;
 8002674:	702b      	strb	r3, [r5, #0]
		chprintf((BaseSequentialStream *)&itm_port, "ReadPos: %d\n", Rdpos);
 8002676:	f7ff ffab 	bl	80025d0 <chprintf.constprop.0>

		return Element;
 800267a:	4620      	mov	r0, r4
 800267c:	bd38      	pop	{r3, r4, r5, pc}
 800267e:	bf00      	nop
 8002680:	20000f18 	.word	0x20000f18
 8002684:	20000f3c 	.word	0x20000f3c
 8002688:	20000f1c 	.word	0x20000f1c
 800268c:	20001214 	.word	0x20001214
 8002690:	08002c10 	.word	0x08002c10
 8002694:	f3af 8000 	nop.w
 8002698:	f3af 8000 	nop.w
 800269c:	f3af 8000 	nop.w

080026a0 <Thread1>:

/*
 * Green LED blinker thread, times are in milliseconds.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 80026a0:	b508      	push	{r3, lr}

  (void)arg;
  chRegSetThreadName("blinker");
 80026a2:	4b09      	ldr	r3, [pc, #36]	; (80026c8 <Thread1+0x28>)
 80026a4:	4a09      	ldr	r2, [pc, #36]	; (80026cc <Thread1+0x2c>)
 80026a6:	699b      	ldr	r3, [r3, #24]
  while (TRUE) {
    palClearPad(GPIOG, GPIOG_PIN6);
 80026a8:	4c09      	ldr	r4, [pc, #36]	; (80026d0 <Thread1+0x30>)
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {

  (void)arg;
  chRegSetThreadName("blinker");
 80026aa:	619a      	str	r2, [r3, #24]
  while (TRUE) {
    palClearPad(GPIOG, GPIOG_PIN6);
 80026ac:	2540      	movs	r5, #64	; 0x40
 80026ae:	462e      	mov	r6, r5
 80026b0:	8366      	strh	r6, [r4, #26]
    chThdSleepMilliseconds(500);
 80026b2:	f241 3088 	movw	r0, #5000	; 0x1388
 80026b6:	f7fe fbdb 	bl	8000e70 <chThdSleep>
    palSetPad(GPIOG, GPIOG_PIN6);
 80026ba:	8325      	strh	r5, [r4, #24]
    chThdSleepMilliseconds(500);
 80026bc:	f241 3088 	movw	r0, #5000	; 0x1388
 80026c0:	f7fe fbd6 	bl	8000e70 <chThdSleep>
  }
 80026c4:	e7f4      	b.n	80026b0 <Thread1+0x10>
 80026c6:	bf00      	nop
 80026c8:	20000800 	.word	0x20000800
 80026cc:	08002c20 	.word	0x08002c20
 80026d0:	40021800 	.word	0x40021800
 80026d4:	f3af 8000 	nop.w
 80026d8:	f3af 8000 	nop.w
 80026dc:	f3af 8000 	nop.w

080026e0 <producer_thread>:
static THD_WORKING_AREA(wa_producer, 128);
static THD_FUNCTION(producer_thread, arg) {

  (void)arg;
  char e = 5;
  chRegSetThreadName("producer");
 80026e0:	4b07      	ldr	r3, [pc, #28]	; (8002700 <producer_thread+0x20>)
 80026e2:	4a08      	ldr	r2, [pc, #32]	; (8002704 <producer_thread+0x24>)
 80026e4:	699b      	ldr	r3, [r3, #24]

/*
 * Producer Thread
 */
static THD_WORKING_AREA(wa_producer, 128);
static THD_FUNCTION(producer_thread, arg) {
 80026e6:	b510      	push	{r4, lr}

  (void)arg;
  char e = 5;
 80026e8:	2005      	movs	r0, #5
  chRegSetThreadName("producer");
 80026ea:	619a      	str	r2, [r3, #24]
  while (TRUE) {
	En_queue(e++);
 80026ec:	1c44      	adds	r4, r0, #1
 80026ee:	b2e4      	uxtb	r4, r4
 80026f0:	f7ff ff86 	bl	8002600 <En_queue>
	chThdSleepMilliseconds(1000);
 80026f4:	f242 7010 	movw	r0, #10000	; 0x2710
 80026f8:	f7fe fbba 	bl	8000e70 <chThdSleep>

  (void)arg;
  char e = 5;
  chRegSetThreadName("producer");
  while (TRUE) {
	En_queue(e++);
 80026fc:	4620      	mov	r0, r4
	chThdSleepMilliseconds(1000);
  }
 80026fe:	e7f5      	b.n	80026ec <producer_thread+0xc>
 8002700:	20000800 	.word	0x20000800
 8002704:	08002c28 	.word	0x08002c28
 8002708:	f3af 8000 	nop.w
 800270c:	f3af 8000 	nop.w

08002710 <chprintf.constprop.3>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8002710:	b40e      	push	{r1, r2, r3}
 8002712:	b500      	push	{lr}
 8002714:	b082      	sub	sp, #8
 8002716:	aa03      	add	r2, sp, #12
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
 8002718:	4805      	ldr	r0, [pc, #20]	; (8002730 <chprintf.constprop.3+0x20>)
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 800271a:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800271e:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8002720:	f7ff fd9e 	bl	8002260 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8002724:	b002      	add	sp, #8
 8002726:	f85d eb04 	ldr.w	lr, [sp], #4
 800272a:	b003      	add	sp, #12
 800272c:	4770      	bx	lr
 800272e:	bf00      	nop
 8002730:	20001214 	.word	0x20001214
 8002734:	f3af 8000 	nop.w
 8002738:	f3af 8000 	nop.w
 800273c:	f3af 8000 	nop.w

08002740 <consumer_thread>:

/*
 * Consumer Thread
 */
static THD_WORKING_AREA(wa_consumer, 128);
static THD_FUNCTION(consumer_thread, arg) {
 8002740:	b508      	push	{r3, lr}

  (void)arg;
  char e;
  chRegSetThreadName("consumer");
 8002742:	4b08      	ldr	r3, [pc, #32]	; (8002764 <consumer_thread+0x24>)
 8002744:	4a08      	ldr	r2, [pc, #32]	; (8002768 <consumer_thread+0x28>)
 8002746:	699b      	ldr	r3, [r3, #24]
 8002748:	619a      	str	r2, [r3, #24]
  while (TRUE) {
    e = De_queue();
 800274a:	f7ff ff81 	bl	8002650 <De_queue>
	chprintf((BaseSequentialStream *)&itm_port, "Element: %d\n", e);
 800274e:	4907      	ldr	r1, [pc, #28]	; (800276c <consumer_thread+0x2c>)

  (void)arg;
  char e;
  chRegSetThreadName("consumer");
  while (TRUE) {
    e = De_queue();
 8002750:	4602      	mov	r2, r0
	chprintf((BaseSequentialStream *)&itm_port, "Element: %d\n", e);
 8002752:	4807      	ldr	r0, [pc, #28]	; (8002770 <consumer_thread+0x30>)
 8002754:	f7ff ffdc 	bl	8002710 <chprintf.constprop.3>
	chThdSleepMilliseconds(300);
 8002758:	f640 30b8 	movw	r0, #3000	; 0xbb8
 800275c:	f7fe fb88 	bl	8000e70 <chThdSleep>
  }
 8002760:	e7f3      	b.n	800274a <consumer_thread+0xa>
 8002762:	bf00      	nop
 8002764:	20000800 	.word	0x20000800
 8002768:	08002c34 	.word	0x08002c34
 800276c:	08002c40 	.word	0x08002c40
 8002770:	20001214 	.word	0x20001214
 8002774:	f3af 8000 	nop.w
 8002778:	f3af 8000 	nop.w
 800277c:	f3af 8000 	nop.w

08002780 <Debug_ITMDebugEnable>:
void Debug_ITMDebugEnable(void){
	volatile unsigned int *ITM_TER      = (volatile unsigned int *)0xE0000E00;
	volatile unsigned int *SCB_DHCSR 		= (volatile unsigned int *)0xE000EDF0;
	volatile unsigned int *DBGMCU_CR 		= (volatile unsigned int *)0xE0042004;

	*DBGMCU_CR |= 0x27; // DBGMCU_CR
 8002780:	4a08      	ldr	r2, [pc, #32]	; (80027a4 <Debug_ITMDebugEnable+0x24>)

if ((*SCB_DHCSR & 1) && (*ITM_TER & 1)) // Enabled?
 8002782:	4909      	ldr	r1, [pc, #36]	; (80027a8 <Debug_ITMDebugEnable+0x28>)
void Debug_ITMDebugEnable(void){
	volatile unsigned int *ITM_TER      = (volatile unsigned int *)0xE0000E00;
	volatile unsigned int *SCB_DHCSR 		= (volatile unsigned int *)0xE000EDF0;
	volatile unsigned int *DBGMCU_CR 		= (volatile unsigned int *)0xE0042004;

	*DBGMCU_CR |= 0x27; // DBGMCU_CR
 8002784:	6813      	ldr	r3, [r2, #0]
 8002786:	f043 0327 	orr.w	r3, r3, #39	; 0x27
 800278a:	6013      	str	r3, [r2, #0]

if ((*SCB_DHCSR & 1) && (*ITM_TER & 1)) // Enabled?
 800278c:	680b      	ldr	r3, [r1, #0]
 800278e:	07da      	lsls	r2, r3, #31
 8002790:	d506      	bpl.n	80027a0 <Debug_ITMDebugEnable+0x20>
 8002792:	4b06      	ldr	r3, [pc, #24]	; (80027ac <Debug_ITMDebugEnable+0x2c>)
 8002794:	681b      	ldr	r3, [r3, #0]
 8002796:	07db      	lsls	r3, r3, #31
 8002798:	d502      	bpl.n	80027a0 <Debug_ITMDebugEnable+0x20>
    Debug_ITMDebug = 1;
 800279a:	4b05      	ldr	r3, [pc, #20]	; (80027b0 <Debug_ITMDebugEnable+0x30>)
 800279c:	2201      	movs	r2, #1
 800279e:	601a      	str	r2, [r3, #0]
 80027a0:	4770      	bx	lr
 80027a2:	bf00      	nop
 80027a4:	e0042004 	.word	0xe0042004
 80027a8:	e000edf0 	.word	0xe000edf0
 80027ac:	e0000e00 	.word	0xe0000e00
 80027b0:	20001210 	.word	0x20001210
 80027b4:	f3af 8000 	nop.w
 80027b8:	f3af 8000 	nop.w
 80027bc:	f3af 8000 	nop.w

080027c0 <Debug_ITMDebugOutputChar>:

void Debug_ITMDebugOutputChar(char ch){
	static volatile unsigned int *ITM_STIM0 = (volatile unsigned int *)0xE0000000; // ITM Port 0
	static volatile unsigned int *SCB_DEMCR = (volatile unsigned int *)0xE000EDFC;

	if (Debug_ITMDebug && (*SCB_DEMCR & 0x01000000))
 80027c0:	4b07      	ldr	r3, [pc, #28]	; (80027e0 <Debug_ITMDebugOutputChar+0x20>)
 80027c2:	681b      	ldr	r3, [r3, #0]
 80027c4:	b15b      	cbz	r3, 80027de <Debug_ITMDebugOutputChar+0x1e>
 80027c6:	4b07      	ldr	r3, [pc, #28]	; (80027e4 <Debug_ITMDebugOutputChar+0x24>)
 80027c8:	681b      	ldr	r3, [r3, #0]
 80027ca:	01db      	lsls	r3, r3, #7
 80027cc:	d507      	bpl.n	80027de <Debug_ITMDebugOutputChar+0x1e>
	{
		while(*ITM_STIM0 == 0);
 80027ce:	f04f 4160 	mov.w	r1, #3758096384	; 0xe0000000
 80027d2:	680b      	ldr	r3, [r1, #0]
 80027d4:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 80027d8:	2b00      	cmp	r3, #0
 80027da:	d0fa      	beq.n	80027d2 <Debug_ITMDebugOutputChar+0x12>
  	*((volatile char *)ITM_STIM0) = ch;
 80027dc:	7010      	strb	r0, [r2, #0]
 80027de:	4770      	bx	lr
 80027e0:	20001210 	.word	0x20001210
 80027e4:	e000edfc 	.word	0xe000edfc
 80027e8:	f3af 8000 	nop.w
 80027ec:	f3af 8000 	nop.w
 80027f0:	656c6469 	.word	0x656c6469
	...
 8002800:	31235653 	.word	0x31235653
 8002804:	00000000 	.word	0x00000000
 8002808:	32235653 	.word	0x32235653
 800280c:	00000000 	.word	0x00000000
 8002810:	33235653 	.word	0x33235653
 8002814:	00000000 	.word	0x00000000
 8002818:	34235653 	.word	0x34235653
 800281c:	00000000 	.word	0x00000000
 8002820:	35235653 	.word	0x35235653
 8002824:	00000000 	.word	0x00000000
 8002828:	36235653 	.word	0x36235653
 800282c:	00000000 	.word	0x00000000
 8002830:	37235653 	.word	0x37235653
 8002834:	00000000 	.word	0x00000000
 8002838:	38235653 	.word	0x38235653
 800283c:	00000000 	.word	0x00000000
 8002840:	39235653 	.word	0x39235653
 8002844:	00000000 	.word	0x00000000
 8002848:	31235653 	.word	0x31235653
 800284c:	00000030 	.word	0x00000030
 8002850:	31235653 	.word	0x31235653
 8002854:	00000031 	.word	0x00000031
	...

08002860 <__func__.6559>:
 8002860:	63536863 61655268 00497964 00000000     chSchReadyI.....
 8002870:	63617473 766f206b 6c667265 0000776f     stack overflow..

08002880 <__func__.6561>:
 8002880:	54566863 65536f44 00004974 00000000     chVTDoSetI......

08002890 <__func__.6569>:
 8002890:	54566863 65526f44 49746573 00000000     chVTDoResetI....

080028a0 <__func__.6048>:
 80028a0:	68546863 446f4464 65757165 654e6575     chThdDoDequeueNe
 80028b0:	00497478 00000000 00000000 00000000     xtI.............

080028c0 <__func__.6615>:
 80028c0:	68546863 69784564 00005374 00000000     chThdExitS......

080028d0 <__func__.6571>:
 80028d0:	68546863 65724364 49657461 00000000     chThdCreateI....

080028e0 <__func__.5870>:
 80028e0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

080028f0 <__func__.6036>:
 80028f0:	68546863 656c5364 00537065 00000000     chThdSleepS.....

08002900 <ch_debug>:
 8002900:	6e69616d 18001600 08600404 1814100c     main......`.....
 8002910:	2221201c 00000000 00000000 00000000     . !"............

08002920 <__func__.6554>:
 8002920:	744d6863 6a624f78 49746365 0074696e     chMtxObjectInit.

08002930 <__func__.6579>:
 8002930:	76456863 6f724274 61636461 6c467473     chEvtBroadcastFl
 8002940:	49736761 00000000 00000000 00000000     agsI............

08002950 <__func__.6596>:
 8002950:	76456863 67695374 496c616e 00000000     chEvtSignalI....

08002960 <__func__.6618>:
 8002960:	514f6863 74697257 6d695465 74756f65     chOQWriteTimeout
	...

08002980 <__func__.6582>:
 8002980:	51496863 64616552 656d6954 0074756f     chIQReadTimeout.

08002990 <__func__.5870>:
 8002990:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

080029a0 <__func__.5870>:
 80029a0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....
 80029b0:	000a7325 5f6c6168 5f646c6c 74696e69     %s..hal_lld_init
 80029c0:	00000000 496c6170 0074696e 00000000     ....palInit.....

080029d0 <__func__.7120>:
 80029d0:	6e496473 696d6f63 6144676e 00496174     sdIncomingDataI.

080029e0 <vmt>:
 80029e0:	080015b1 08001591 080015f1 080015d1     ................
 80029f0:	080015e1 080015c1 080015a1 08001581     ................

08002a00 <__func__.7066>:
 8002a00:	74537473 41747261 6d72616c 00000000     stStartAlarm....

08002a10 <__func__.7073>:
 8002a10:	65537473 616c4174 00006d72 00000000     stSetAlarm......

08002a20 <_stm32_dma_streams>:
 8002a20:	40026010 40026008 000b0000 40026028     .`.@.`.@....(`.@
 8002a30:	40026008 000c0106 40026040 40026008     .`.@....@`.@.`.@
 8002a40:	000d0210 40026058 40026008 000e0316     ....X`.@.`.@....
 8002a50:	40026070 4002600c 000f0400 40026088     p`.@.`.@.....`.@
 8002a60:	4002600c 00100506 400260a0 4002600c     .`.@.....`.@.`.@
 8002a70:	00110610 400260b8 4002600c 002f0716     .....`.@.`.@../.
 8002a80:	40026410 40026408 00380800 40026428     .d.@.d.@..8.(d.@
 8002a90:	40026408 00390906 40026440 40026408     .d.@..9.@d.@.d.@
 8002aa0:	003a0a10 40026458 40026408 003b0b16     ..:.Xd.@.d.@..;.
 8002ab0:	40026470 4002640c 003c0c00 40026488     pd.@.d.@..<..d.@
 8002ac0:	4002640c 00440d06 400264a0 4002640c     .d.@..D..d.@.d.@
 8002ad0:	00450e10 400264b8 4002640c 00460f16     ..E..d.@.d.@..F.

08002ae0 <pal_default_config>:
 8002ae0:	2a82aa28 00280028 ffffffff 40000054     (..*(.(.....T..@
 8002af0:	0000ffff b5560bb0 00000000 00082080     ......V...... ..
 8002b00:	00000240 ffffffff 55514515 0000ffff     @........EQU....
 8002b10:	04000000 00000040 00a5aa09 00000000     ....@...........
 8002b20:	ffffffff 54000050 0000fcff 88bb00b0     ....P..T........
 8002b30:	00067700 55000100 00000000 ffffffff     .w.....U........
 8002b40:	00155055 00000fff 00000000 00000000     UP..............
 8002b50:	00000040 00000000 ffffffff 00000000     @...............
 8002b60:	0000ffff 00000000 00000000 00000000     ................
 8002b70:	00000000 ffffffff 00000000 0000ffff     ................
	...
 8002b88:	28811000 00000000 ffffffff 14400000     ...(..........@.
 8002b98:	0000febf 00000000 0bb0b000 00000000     ................
 8002ba8:	00000000 ffffffff 00000000 0000ffff     ................
	...
 8002bc0:	00040000 00000000 ffffffff 00000000     ................
 8002bd0:	0000fdff 00000000 00000000 00000000     ................
 8002be0:	6c756e28 0000296c 00000000 00000000     (null)..........

08002bf0 <vmt>:
 8002bf0:	080025a1 08002581 08002591 08002571     .%...%...%..q%..
 8002c00:	74697257 736f5065 6425203a 0000000a     WritePos: %d....
 8002c10:	64616552 3a736f50 0a642520 00000000     ReadPos: %d.....
 8002c20:	6e696c62 0072656b 646f7270 72656375     blinker.producer
 8002c30:	00000000 736e6f63 72656d75 00000000     ....consumer....
 8002c40:	6d656c45 3a746e65 0a642520 00000000     Element: %d.....
 8002c50:	20565753 62616e45 0a64656c 00000000     SWV Enabled.....
 8002c60:	00007325 62696843 20534f69 302e3356     %s..ChibiOS V3.0
 8002c70:	0000000a                                ....


build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c0 <main>:

/*
 * Application entry point.
 */
int main(void)
{
 80001c0:	b500      	push	{lr}
 80001c2:	b083      	sub	sp, #12
  /* Enable TRACE debug -----------------------------------------------*/
  Debug_ITMDebugEnable();
 80001c4:	f013 fa84 	bl	80136d0 <Debug_ITMDebugEnable>
}

//****************************************************************************

void Debug_ITMDebugOutputString(char *Buffer){
	if (Debug_ITMDebug)
 80001c8:	4b2e      	ldr	r3, [pc, #184]	; (8000284 <__fini_array_end+0xc4>)
 80001ca:	681b      	ldr	r3, [r3, #0]
 80001cc:	2b00      	cmp	r3, #0
 80001ce:	d14f      	bne.n	8000270 <main+0xb0>
{
  /* Enable TRACE debug -----------------------------------------------*/
  Debug_ITMDebugEnable();
  Debug_ITMDebugOutputString("SWV Enabled\n");
  
  itmObjectInit(&itm_port);
 80001d0:	482d      	ldr	r0, [pc, #180]	; (8000288 <__fini_array_end+0xc8>)
   * sleeping in a loop and check the button state.
   */
  while (TRUE)
  {
	
    if (palReadPad(GPIOA, GPIOA_BUTTON) == 1)
 80001d2:	4c2e      	ldr	r4, [pc, #184]	; (800028c <__fini_array_end+0xcc>)
{
  /* Enable TRACE debug -----------------------------------------------*/
  Debug_ITMDebugEnable();
  Debug_ITMDebugOutputString("SWV Enabled\n");
  
  itmObjectInit(&itm_port);
 80001d4:	f012 fb7c 	bl	80128d0 <itmObjectInit>

  chprintf((BaseSequentialStream *)&itm_port, "%s", "ChibiOS V3.0\n");
 80001d8:	4a2d      	ldr	r2, [pc, #180]	; (8000290 <__fini_array_end+0xd0>)
 80001da:	492e      	ldr	r1, [pc, #184]	; (8000294 <__fini_array_end+0xd4>)
 80001dc:	482a      	ldr	r0, [pc, #168]	; (8000288 <__fini_array_end+0xc8>)
 80001de:	f013 f9ff 	bl	80135e0 <chprintf.constprop.3>
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 80001e2:	f006 f84d 	bl	8006280 <halInit>
  chSysInit();
 80001e6:	f000 fe73 	bl	8000ed0 <chSysInit>
  
  /*
   * List of modbus slave devices - Web
   *
   */
  init(&list_RTC);
 80001ea:	482b      	ldr	r0, [pc, #172]	; (8000298 <__fini_array_end+0xd8>)
 80001ec:	f013 f910 	bl	8013410 <init>
  
  /*
   * List of requests to modbus devices on bus
   *
   */
  init(&list_mbDevices);
 80001f0:	482a      	ldr	r0, [pc, #168]	; (800029c <__fini_array_end+0xdc>)
  sdStart(&SD6, NULL);

  /*
   * Creates the blinker thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 80001f2:	2500      	movs	r5, #0
  
  /*
   * List of requests to modbus devices on bus
   *
   */
  init(&list_mbDevices);
 80001f4:	f013 f90c 	bl	8013410 <init>
  
  /*
   * Synchronize modbus
   */
  chSemObjectInit(&mbPoll, 1);
 80001f8:	4829      	ldr	r0, [pc, #164]	; (80002a0 <__fini_array_end+0xe0>)
 80001fa:	2101      	movs	r1, #1
 80001fc:	f001 fb58 	bl	80018b0 <chSemObjectInit>

  /*
   * Activates the serial driver 6 using the driver default configuration.
   */
  sdStart(&SD6, NULL);
 8000200:	4629      	mov	r1, r5
 8000202:	4828      	ldr	r0, [pc, #160]	; (80002a4 <__fini_array_end+0xe4>)
 8000204:	f006 f994 	bl	8006530 <sdStart>

  /*
   * Creates the blinker thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8000208:	9500      	str	r5, [sp, #0]
 800020a:	4b27      	ldr	r3, [pc, #156]	; (80002a8 <__fini_array_end+0xe8>)
 800020c:	4827      	ldr	r0, [pc, #156]	; (80002ac <__fini_array_end+0xec>)
 800020e:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8000212:	2240      	movs	r2, #64	; 0x40
 8000214:	f001 f96c 	bl	80014f0 <chThdCreateStatic>
  
  /*
   * Creates the modbus poll thread.
   */
  chThdCreateStatic(wa_freemodbus_thread, sizeof(wa_freemodbus_thread), NORMALPRIO,
 8000218:	9500      	str	r5, [sp, #0]
 800021a:	4b25      	ldr	r3, [pc, #148]	; (80002b0 <__fini_array_end+0xf0>)
 800021c:	4825      	ldr	r0, [pc, #148]	; (80002b4 <__fini_array_end+0xf4>)
 800021e:	f44f 7154 	mov.w	r1, #848	; 0x350
 8000222:	2240      	movs	r2, #64	; 0x40
 8000224:	f001 f964 	bl	80014f0 <chThdCreateStatic>
					modbus_thread, NULL);
					
  /*
   * Creates the modbus request thread.
   */
  chThdCreateStatic(wa_modbusreq_thread, sizeof(wa_modbusreq_thread), NORMALPRIO,
 8000228:	9500      	str	r5, [sp, #0]
 800022a:	4b23      	ldr	r3, [pc, #140]	; (80002b8 <__fini_array_end+0xf8>)
 800022c:	4823      	ldr	r0, [pc, #140]	; (80002bc <__fini_array_end+0xfc>)
 800022e:	f44f 7154 	mov.w	r1, #848	; 0x350
 8000232:	2240      	movs	r2, #64	; 0x40
 8000234:	f001 f95c 	bl	80014f0 <chThdCreateStatic>
					modbusreq_thread, NULL);

  /*
   * Creates the LWIP threads (it changes priority internally).
   */
  chThdCreateStatic(wa_lwip_thread, LWIP_THREAD_STACK_SIZE, HIGHPRIO + 1,
 8000238:	9500      	str	r5, [sp, #0]
 800023a:	4b21      	ldr	r3, [pc, #132]	; (80002c0 <__fini_array_end+0x100>)
 800023c:	4821      	ldr	r0, [pc, #132]	; (80002c4 <__fini_array_end+0x104>)
 800023e:	f44f 7110 	mov.w	r1, #576	; 0x240
 8000242:	2280      	movs	r2, #128	; 0x80
 8000244:	f001 f954 	bl	80014f0 <chThdCreateStatic>
					lwip_thread, NULL);
	
  /*
   * Creates the HTTP thread (it changes priority internally).
   */
  chThdCreateStatic(wa_http_server, sizeof(wa_http_server), NORMALPRIO + 1,
 8000248:	9500      	str	r5, [sp, #0]
 800024a:	4b1f      	ldr	r3, [pc, #124]	; (80002c8 <__fini_array_end+0x108>)
 800024c:	481f      	ldr	r0, [pc, #124]	; (80002cc <__fini_array_end+0x10c>)
 800024e:	f241 1150 	movw	r1, #4432	; 0x1150
 8000252:	2241      	movs	r2, #65	; 0x41
 8000254:	f001 f94c 	bl	80014f0 <chThdCreateStatic>
 8000258:	e003      	b.n	8000262 <main+0xa2>
  while (TRUE)
  {
	
    if (palReadPad(GPIOA, GPIOA_BUTTON) == 1)
	TestThread(&SD6);
    chThdSleepMilliseconds(1000);
 800025a:	f242 7010 	movw	r0, #10000	; 0x2710
 800025e:	f001 f9bf 	bl	80015e0 <chThdSleep>
   * sleeping in a loop and check the button state.
   */
  while (TRUE)
  {
	
    if (palReadPad(GPIOA, GPIOA_BUTTON) == 1)
 8000262:	6923      	ldr	r3, [r4, #16]
 8000264:	07db      	lsls	r3, r3, #31
 8000266:	d5f8      	bpl.n	800025a <main+0x9a>
	TestThread(&SD6);
 8000268:	480e      	ldr	r0, [pc, #56]	; (80002a4 <__fini_array_end+0xe4>)
 800026a:	f002 fd39 	bl	8002ce0 <TestThread>
 800026e:	e7f4      	b.n	800025a <main+0x9a>
}

//****************************************************************************

void Debug_ITMDebugOutputString(char *Buffer){
	if (Debug_ITMDebug)
 8000270:	4c17      	ldr	r4, [pc, #92]	; (80002d0 <__fini_array_end+0x110>)
 8000272:	2053      	movs	r0, #83	; 0x53
		while(*Buffer)
			Debug_ITMDebugOutputChar(*Buffer++);
 8000274:	f013 fa4c 	bl	8013710 <Debug_ITMDebugOutputChar>

//****************************************************************************

void Debug_ITMDebugOutputString(char *Buffer){
	if (Debug_ITMDebug)
		while(*Buffer)
 8000278:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 800027c:	2800      	cmp	r0, #0
 800027e:	d1f9      	bne.n	8000274 <main+0xb4>
 8000280:	e7a6      	b.n	80001d0 <main+0x10>
 8000282:	bf00      	nop
 8000284:	200180b4 	.word	0x200180b4
 8000288:	200180c8 	.word	0x200180c8
 800028c:	40020000 	.word	0x40020000
 8000290:	0801cd98 	.word	0x0801cd98
 8000294:	0801cd58 	.word	0x0801cd58
 8000298:	20018420 	.word	0x20018420
 800029c:	200180b8 	.word	0x200180b8
 80002a0:	200180a8 	.word	0x200180a8
 80002a4:	200042bc 	.word	0x200042bc
 80002a8:	08013681 	.word	0x08013681
 80002ac:	20017ed8 	.word	0x20017ed8
 80002b0:	08013611 	.word	0x08013611
 80002b4:	200180d0 	.word	0x200180d0
 80002b8:	08013581 	.word	0x08013581
 80002bc:	20018430 	.word	0x20018430
 80002c0:	080078c1 	.word	0x080078c1
 80002c4:	20004380 	.word	0x20004380
 80002c8:	08013221 	.word	0x08013221
 80002cc:	20016c98 	.word	0x20016c98
 80002d0:	0801cd88 	.word	0x0801cd88
 80002d4:	f3af 8000 	nop.w
 80002d8:	f3af 8000 	nop.w
 80002dc:	f3af 8000 	nop.w

080002e0 <_port_switch>:
 80002e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002e4:	ed2d 8a10 	vpush	{s16-s31}
 80002e8:	f8c1 d00c 	str.w	sp, [r1, #12]
 80002ec:	f8d0 d00c 	ldr.w	sp, [r0, #12]
 80002f0:	ecbd 8a10 	vpop	{s16-s31}
 80002f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002f8 <_port_thread_start>:
 80002f8:	2300      	movs	r3, #0
 80002fa:	f383 8811 	msr	BASEPRI, r3
 80002fe:	4628      	mov	r0, r5
 8000300:	47a0      	blx	r4
 8000302:	f001 f9c5 	bl	8001690 <chThdExit>

08000306 <_port_switch_from_isr>:
 8000306:	f001 f823 	bl	8001350 <chSchDoReschedule>

0800030a <_port_exit_from_isr>:
 800030a:	df00      	svc	0
 800030c:	e7fe      	b.n	800030c <_port_exit_from_isr+0x2>
	...

08000310 <__aeabi_uldivmod>:
 8000310:	b94b      	cbnz	r3, 8000326 <__aeabi_uldivmod+0x16>
 8000312:	b942      	cbnz	r2, 8000326 <__aeabi_uldivmod+0x16>
 8000314:	2900      	cmp	r1, #0
 8000316:	bf08      	it	eq
 8000318:	2800      	cmpeq	r0, #0
 800031a:	d002      	beq.n	8000322 <__aeabi_uldivmod+0x12>
 800031c:	f04f 31ff 	mov.w	r1, #4294967295
 8000320:	4608      	mov	r0, r1
 8000322:	f000 b83d 	b.w	80003a0 <__aeabi_idiv0>
 8000326:	b082      	sub	sp, #8
 8000328:	46ec      	mov	ip, sp
 800032a:	e92d 5000 	stmdb	sp!, {ip, lr}
 800032e:	f000 f81f 	bl	8000370 <__gnu_uldivmod_helper>
 8000332:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000336:	b002      	add	sp, #8
 8000338:	bc0c      	pop	{r2, r3}
 800033a:	4770      	bx	lr
 800033c:	0000      	movs	r0, r0
	...

08000340 <__gnu_ldivmod_helper>:
 8000340:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000344:	9c06      	ldr	r4, [sp, #24]
 8000346:	4615      	mov	r5, r2
 8000348:	4606      	mov	r6, r0
 800034a:	460f      	mov	r7, r1
 800034c:	4698      	mov	r8, r3
 800034e:	f000 f82f 	bl	80003b0 <__divdi3>
 8000352:	fb05 f301 	mul.w	r3, r5, r1
 8000356:	fb00 3808 	mla	r8, r0, r8, r3
 800035a:	fba5 2300 	umull	r2, r3, r5, r0
 800035e:	1ab2      	subs	r2, r6, r2
 8000360:	4443      	add	r3, r8
 8000362:	eb67 0303 	sbc.w	r3, r7, r3
 8000366:	e9c4 2300 	strd	r2, r3, [r4]
 800036a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800036e:	bf00      	nop

08000370 <__gnu_uldivmod_helper>:
 8000370:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000374:	9c06      	ldr	r4, [sp, #24]
 8000376:	4690      	mov	r8, r2
 8000378:	4606      	mov	r6, r0
 800037a:	460f      	mov	r7, r1
 800037c:	461d      	mov	r5, r3
 800037e:	f000 f967 	bl	8000650 <__udivdi3>
 8000382:	fb00 f505 	mul.w	r5, r0, r5
 8000386:	fba0 2308 	umull	r2, r3, r0, r8
 800038a:	fb08 5501 	mla	r5, r8, r1, r5
 800038e:	1ab2      	subs	r2, r6, r2
 8000390:	442b      	add	r3, r5
 8000392:	eb67 0303 	sbc.w	r3, r7, r3
 8000396:	e9c4 2300 	strd	r2, r3, [r4]
 800039a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800039e:	bf00      	nop

080003a0 <__aeabi_idiv0>:
 80003a0:	4770      	bx	lr
 80003a2:	bf00      	nop
	...

080003b0 <__divdi3>:
 80003b0:	2900      	cmp	r1, #0
 80003b2:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80003b6:	f2c0 80a6 	blt.w	8000506 <__divdi3+0x156>
 80003ba:	2600      	movs	r6, #0
 80003bc:	2b00      	cmp	r3, #0
 80003be:	f2c0 809c 	blt.w	80004fa <__divdi3+0x14a>
 80003c2:	4688      	mov	r8, r1
 80003c4:	4694      	mov	ip, r2
 80003c6:	469e      	mov	lr, r3
 80003c8:	4615      	mov	r5, r2
 80003ca:	4604      	mov	r4, r0
 80003cc:	460f      	mov	r7, r1
 80003ce:	2b00      	cmp	r3, #0
 80003d0:	d13d      	bne.n	800044e <__divdi3+0x9e>
 80003d2:	428a      	cmp	r2, r1
 80003d4:	d959      	bls.n	800048a <__divdi3+0xda>
 80003d6:	fab2 f382 	clz	r3, r2
 80003da:	b13b      	cbz	r3, 80003ec <__divdi3+0x3c>
 80003dc:	f1c3 0220 	rsb	r2, r3, #32
 80003e0:	409f      	lsls	r7, r3
 80003e2:	fa20 f202 	lsr.w	r2, r0, r2
 80003e6:	409d      	lsls	r5, r3
 80003e8:	4317      	orrs	r7, r2
 80003ea:	409c      	lsls	r4, r3
 80003ec:	0c29      	lsrs	r1, r5, #16
 80003ee:	0c22      	lsrs	r2, r4, #16
 80003f0:	fbb7 fef1 	udiv	lr, r7, r1
 80003f4:	b2a8      	uxth	r0, r5
 80003f6:	fb01 771e 	mls	r7, r1, lr, r7
 80003fa:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
 80003fe:	fb00 f30e 	mul.w	r3, r0, lr
 8000402:	42bb      	cmp	r3, r7
 8000404:	d90a      	bls.n	800041c <__divdi3+0x6c>
 8000406:	197f      	adds	r7, r7, r5
 8000408:	f10e 32ff 	add.w	r2, lr, #4294967295
 800040c:	f080 8105 	bcs.w	800061a <__divdi3+0x26a>
 8000410:	42bb      	cmp	r3, r7
 8000412:	f240 8102 	bls.w	800061a <__divdi3+0x26a>
 8000416:	f1ae 0e02 	sub.w	lr, lr, #2
 800041a:	442f      	add	r7, r5
 800041c:	1aff      	subs	r7, r7, r3
 800041e:	b2a4      	uxth	r4, r4
 8000420:	fbb7 f3f1 	udiv	r3, r7, r1
 8000424:	fb01 7713 	mls	r7, r1, r3, r7
 8000428:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 800042c:	fb00 f003 	mul.w	r0, r0, r3
 8000430:	42b8      	cmp	r0, r7
 8000432:	d908      	bls.n	8000446 <__divdi3+0x96>
 8000434:	197f      	adds	r7, r7, r5
 8000436:	f103 32ff 	add.w	r2, r3, #4294967295
 800043a:	f080 80f0 	bcs.w	800061e <__divdi3+0x26e>
 800043e:	42b8      	cmp	r0, r7
 8000440:	f240 80ed 	bls.w	800061e <__divdi3+0x26e>
 8000444:	3b02      	subs	r3, #2
 8000446:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 800044a:	2200      	movs	r2, #0
 800044c:	e003      	b.n	8000456 <__divdi3+0xa6>
 800044e:	428b      	cmp	r3, r1
 8000450:	d90f      	bls.n	8000472 <__divdi3+0xc2>
 8000452:	2200      	movs	r2, #0
 8000454:	4613      	mov	r3, r2
 8000456:	1c34      	adds	r4, r6, #0
 8000458:	bf18      	it	ne
 800045a:	2401      	movne	r4, #1
 800045c:	4260      	negs	r0, r4
 800045e:	f04f 0500 	mov.w	r5, #0
 8000462:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
 8000466:	4058      	eors	r0, r3
 8000468:	4051      	eors	r1, r2
 800046a:	1900      	adds	r0, r0, r4
 800046c:	4169      	adcs	r1, r5
 800046e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8000472:	fab3 f283 	clz	r2, r3
 8000476:	2a00      	cmp	r2, #0
 8000478:	f040 8086 	bne.w	8000588 <__divdi3+0x1d8>
 800047c:	428b      	cmp	r3, r1
 800047e:	d302      	bcc.n	8000486 <__divdi3+0xd6>
 8000480:	4584      	cmp	ip, r0
 8000482:	f200 80db 	bhi.w	800063c <__divdi3+0x28c>
 8000486:	2301      	movs	r3, #1
 8000488:	e7e5      	b.n	8000456 <__divdi3+0xa6>
 800048a:	b912      	cbnz	r2, 8000492 <__divdi3+0xe2>
 800048c:	2301      	movs	r3, #1
 800048e:	fbb3 f5f2 	udiv	r5, r3, r2
 8000492:	fab5 f085 	clz	r0, r5
 8000496:	2800      	cmp	r0, #0
 8000498:	d13b      	bne.n	8000512 <__divdi3+0x162>
 800049a:	1b78      	subs	r0, r7, r5
 800049c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80004a0:	fa1f fc85 	uxth.w	ip, r5
 80004a4:	2201      	movs	r2, #1
 80004a6:	fbb0 f8fe 	udiv	r8, r0, lr
 80004aa:	0c21      	lsrs	r1, r4, #16
 80004ac:	fb0e 0718 	mls	r7, lr, r8, r0
 80004b0:	ea41 4707 	orr.w	r7, r1, r7, lsl #16
 80004b4:	fb0c f308 	mul.w	r3, ip, r8
 80004b8:	42bb      	cmp	r3, r7
 80004ba:	d907      	bls.n	80004cc <__divdi3+0x11c>
 80004bc:	197f      	adds	r7, r7, r5
 80004be:	f108 31ff 	add.w	r1, r8, #4294967295
 80004c2:	d202      	bcs.n	80004ca <__divdi3+0x11a>
 80004c4:	42bb      	cmp	r3, r7
 80004c6:	f200 80bd 	bhi.w	8000644 <__divdi3+0x294>
 80004ca:	4688      	mov	r8, r1
 80004cc:	1aff      	subs	r7, r7, r3
 80004ce:	b2a4      	uxth	r4, r4
 80004d0:	fbb7 f3fe 	udiv	r3, r7, lr
 80004d4:	fb0e 7713 	mls	r7, lr, r3, r7
 80004d8:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 80004dc:	fb0c fc03 	mul.w	ip, ip, r3
 80004e0:	45bc      	cmp	ip, r7
 80004e2:	d907      	bls.n	80004f4 <__divdi3+0x144>
 80004e4:	197f      	adds	r7, r7, r5
 80004e6:	f103 31ff 	add.w	r1, r3, #4294967295
 80004ea:	d202      	bcs.n	80004f2 <__divdi3+0x142>
 80004ec:	45bc      	cmp	ip, r7
 80004ee:	f200 80a7 	bhi.w	8000640 <__divdi3+0x290>
 80004f2:	460b      	mov	r3, r1
 80004f4:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 80004f8:	e7ad      	b.n	8000456 <__divdi3+0xa6>
 80004fa:	4252      	negs	r2, r2
 80004fc:	ea6f 0606 	mvn.w	r6, r6
 8000500:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000504:	e75d      	b.n	80003c2 <__divdi3+0x12>
 8000506:	4240      	negs	r0, r0
 8000508:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800050c:	f04f 36ff 	mov.w	r6, #4294967295
 8000510:	e754      	b.n	80003bc <__divdi3+0xc>
 8000512:	f1c0 0220 	rsb	r2, r0, #32
 8000516:	fa24 f102 	lsr.w	r1, r4, r2
 800051a:	fa07 f300 	lsl.w	r3, r7, r0
 800051e:	4085      	lsls	r5, r0
 8000520:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000524:	40d7      	lsrs	r7, r2
 8000526:	4319      	orrs	r1, r3
 8000528:	fbb7 f2fe 	udiv	r2, r7, lr
 800052c:	0c0b      	lsrs	r3, r1, #16
 800052e:	fb0e 7712 	mls	r7, lr, r2, r7
 8000532:	fa1f fc85 	uxth.w	ip, r5
 8000536:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 800053a:	fb0c f702 	mul.w	r7, ip, r2
 800053e:	429f      	cmp	r7, r3
 8000540:	fa04 f400 	lsl.w	r4, r4, r0
 8000544:	d907      	bls.n	8000556 <__divdi3+0x1a6>
 8000546:	195b      	adds	r3, r3, r5
 8000548:	f102 30ff 	add.w	r0, r2, #4294967295
 800054c:	d274      	bcs.n	8000638 <__divdi3+0x288>
 800054e:	429f      	cmp	r7, r3
 8000550:	d972      	bls.n	8000638 <__divdi3+0x288>
 8000552:	3a02      	subs	r2, #2
 8000554:	442b      	add	r3, r5
 8000556:	1bdf      	subs	r7, r3, r7
 8000558:	b289      	uxth	r1, r1
 800055a:	fbb7 f8fe 	udiv	r8, r7, lr
 800055e:	fb0e 7318 	mls	r3, lr, r8, r7
 8000562:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 8000566:	fb0c f708 	mul.w	r7, ip, r8
 800056a:	429f      	cmp	r7, r3
 800056c:	d908      	bls.n	8000580 <__divdi3+0x1d0>
 800056e:	195b      	adds	r3, r3, r5
 8000570:	f108 31ff 	add.w	r1, r8, #4294967295
 8000574:	d25c      	bcs.n	8000630 <__divdi3+0x280>
 8000576:	429f      	cmp	r7, r3
 8000578:	d95a      	bls.n	8000630 <__divdi3+0x280>
 800057a:	f1a8 0802 	sub.w	r8, r8, #2
 800057e:	442b      	add	r3, r5
 8000580:	1bd8      	subs	r0, r3, r7
 8000582:	ea48 4202 	orr.w	r2, r8, r2, lsl #16
 8000586:	e78e      	b.n	80004a6 <__divdi3+0xf6>
 8000588:	f1c2 0320 	rsb	r3, r2, #32
 800058c:	fa2c f103 	lsr.w	r1, ip, r3
 8000590:	fa0e fe02 	lsl.w	lr, lr, r2
 8000594:	fa20 f703 	lsr.w	r7, r0, r3
 8000598:	ea41 0e0e 	orr.w	lr, r1, lr
 800059c:	fa08 f002 	lsl.w	r0, r8, r2
 80005a0:	fa28 f103 	lsr.w	r1, r8, r3
 80005a4:	ea4f 451e 	mov.w	r5, lr, lsr #16
 80005a8:	4338      	orrs	r0, r7
 80005aa:	fbb1 f8f5 	udiv	r8, r1, r5
 80005ae:	0c03      	lsrs	r3, r0, #16
 80005b0:	fb05 1118 	mls	r1, r5, r8, r1
 80005b4:	fa1f f78e 	uxth.w	r7, lr
 80005b8:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 80005bc:	fb07 f308 	mul.w	r3, r7, r8
 80005c0:	428b      	cmp	r3, r1
 80005c2:	fa0c fc02 	lsl.w	ip, ip, r2
 80005c6:	d909      	bls.n	80005dc <__divdi3+0x22c>
 80005c8:	eb11 010e 	adds.w	r1, r1, lr
 80005cc:	f108 39ff 	add.w	r9, r8, #4294967295
 80005d0:	d230      	bcs.n	8000634 <__divdi3+0x284>
 80005d2:	428b      	cmp	r3, r1
 80005d4:	d92e      	bls.n	8000634 <__divdi3+0x284>
 80005d6:	f1a8 0802 	sub.w	r8, r8, #2
 80005da:	4471      	add	r1, lr
 80005dc:	1ac9      	subs	r1, r1, r3
 80005de:	b280      	uxth	r0, r0
 80005e0:	fbb1 f3f5 	udiv	r3, r1, r5
 80005e4:	fb05 1113 	mls	r1, r5, r3, r1
 80005e8:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 80005ec:	fb07 f703 	mul.w	r7, r7, r3
 80005f0:	428f      	cmp	r7, r1
 80005f2:	d908      	bls.n	8000606 <__divdi3+0x256>
 80005f4:	eb11 010e 	adds.w	r1, r1, lr
 80005f8:	f103 30ff 	add.w	r0, r3, #4294967295
 80005fc:	d216      	bcs.n	800062c <__divdi3+0x27c>
 80005fe:	428f      	cmp	r7, r1
 8000600:	d914      	bls.n	800062c <__divdi3+0x27c>
 8000602:	3b02      	subs	r3, #2
 8000604:	4471      	add	r1, lr
 8000606:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 800060a:	1bc9      	subs	r1, r1, r7
 800060c:	fba3 890c 	umull	r8, r9, r3, ip
 8000610:	4549      	cmp	r1, r9
 8000612:	d309      	bcc.n	8000628 <__divdi3+0x278>
 8000614:	d005      	beq.n	8000622 <__divdi3+0x272>
 8000616:	2200      	movs	r2, #0
 8000618:	e71d      	b.n	8000456 <__divdi3+0xa6>
 800061a:	4696      	mov	lr, r2
 800061c:	e6fe      	b.n	800041c <__divdi3+0x6c>
 800061e:	4613      	mov	r3, r2
 8000620:	e711      	b.n	8000446 <__divdi3+0x96>
 8000622:	4094      	lsls	r4, r2
 8000624:	4544      	cmp	r4, r8
 8000626:	d2f6      	bcs.n	8000616 <__divdi3+0x266>
 8000628:	3b01      	subs	r3, #1
 800062a:	e7f4      	b.n	8000616 <__divdi3+0x266>
 800062c:	4603      	mov	r3, r0
 800062e:	e7ea      	b.n	8000606 <__divdi3+0x256>
 8000630:	4688      	mov	r8, r1
 8000632:	e7a5      	b.n	8000580 <__divdi3+0x1d0>
 8000634:	46c8      	mov	r8, r9
 8000636:	e7d1      	b.n	80005dc <__divdi3+0x22c>
 8000638:	4602      	mov	r2, r0
 800063a:	e78c      	b.n	8000556 <__divdi3+0x1a6>
 800063c:	4613      	mov	r3, r2
 800063e:	e70a      	b.n	8000456 <__divdi3+0xa6>
 8000640:	3b02      	subs	r3, #2
 8000642:	e757      	b.n	80004f4 <__divdi3+0x144>
 8000644:	f1a8 0802 	sub.w	r8, r8, #2
 8000648:	442f      	add	r7, r5
 800064a:	e73f      	b.n	80004cc <__divdi3+0x11c>
 800064c:	0000      	movs	r0, r0
	...

08000650 <__udivdi3>:
 8000650:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000654:	2b00      	cmp	r3, #0
 8000656:	d144      	bne.n	80006e2 <__udivdi3+0x92>
 8000658:	428a      	cmp	r2, r1
 800065a:	4615      	mov	r5, r2
 800065c:	4604      	mov	r4, r0
 800065e:	d94f      	bls.n	8000700 <__udivdi3+0xb0>
 8000660:	fab2 f782 	clz	r7, r2
 8000664:	460e      	mov	r6, r1
 8000666:	b14f      	cbz	r7, 800067c <__udivdi3+0x2c>
 8000668:	f1c7 0320 	rsb	r3, r7, #32
 800066c:	40b9      	lsls	r1, r7
 800066e:	fa20 f603 	lsr.w	r6, r0, r3
 8000672:	fa02 f507 	lsl.w	r5, r2, r7
 8000676:	430e      	orrs	r6, r1
 8000678:	fa00 f407 	lsl.w	r4, r0, r7
 800067c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000680:	0c23      	lsrs	r3, r4, #16
 8000682:	fbb6 f0fe 	udiv	r0, r6, lr
 8000686:	b2af      	uxth	r7, r5
 8000688:	fb0e 6110 	mls	r1, lr, r0, r6
 800068c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000690:	fb07 f100 	mul.w	r1, r7, r0
 8000694:	4299      	cmp	r1, r3
 8000696:	d909      	bls.n	80006ac <__udivdi3+0x5c>
 8000698:	195b      	adds	r3, r3, r5
 800069a:	f100 32ff 	add.w	r2, r0, #4294967295
 800069e:	f080 80ec 	bcs.w	800087a <__udivdi3+0x22a>
 80006a2:	4299      	cmp	r1, r3
 80006a4:	f240 80e9 	bls.w	800087a <__udivdi3+0x22a>
 80006a8:	3802      	subs	r0, #2
 80006aa:	442b      	add	r3, r5
 80006ac:	1a5a      	subs	r2, r3, r1
 80006ae:	b2a4      	uxth	r4, r4
 80006b0:	fbb2 f3fe 	udiv	r3, r2, lr
 80006b4:	fb0e 2213 	mls	r2, lr, r3, r2
 80006b8:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
 80006bc:	fb07 f703 	mul.w	r7, r7, r3
 80006c0:	4297      	cmp	r7, r2
 80006c2:	d908      	bls.n	80006d6 <__udivdi3+0x86>
 80006c4:	1952      	adds	r2, r2, r5
 80006c6:	f103 31ff 	add.w	r1, r3, #4294967295
 80006ca:	f080 80d8 	bcs.w	800087e <__udivdi3+0x22e>
 80006ce:	4297      	cmp	r7, r2
 80006d0:	f240 80d5 	bls.w	800087e <__udivdi3+0x22e>
 80006d4:	3b02      	subs	r3, #2
 80006d6:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80006da:	2600      	movs	r6, #0
 80006dc:	4631      	mov	r1, r6
 80006de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80006e2:	428b      	cmp	r3, r1
 80006e4:	d847      	bhi.n	8000776 <__udivdi3+0x126>
 80006e6:	fab3 f683 	clz	r6, r3
 80006ea:	2e00      	cmp	r6, #0
 80006ec:	d148      	bne.n	8000780 <__udivdi3+0x130>
 80006ee:	428b      	cmp	r3, r1
 80006f0:	d302      	bcc.n	80006f8 <__udivdi3+0xa8>
 80006f2:	4282      	cmp	r2, r0
 80006f4:	f200 80cd 	bhi.w	8000892 <__udivdi3+0x242>
 80006f8:	2001      	movs	r0, #1
 80006fa:	4631      	mov	r1, r6
 80006fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000700:	b912      	cbnz	r2, 8000708 <__udivdi3+0xb8>
 8000702:	2501      	movs	r5, #1
 8000704:	fbb5 f5f2 	udiv	r5, r5, r2
 8000708:	fab5 f885 	clz	r8, r5
 800070c:	f1b8 0f00 	cmp.w	r8, #0
 8000710:	d177      	bne.n	8000802 <__udivdi3+0x1b2>
 8000712:	1b4a      	subs	r2, r1, r5
 8000714:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000718:	b2af      	uxth	r7, r5
 800071a:	2601      	movs	r6, #1
 800071c:	fbb2 f0fe 	udiv	r0, r2, lr
 8000720:	0c23      	lsrs	r3, r4, #16
 8000722:	fb0e 2110 	mls	r1, lr, r0, r2
 8000726:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 800072a:	fb07 f300 	mul.w	r3, r7, r0
 800072e:	428b      	cmp	r3, r1
 8000730:	d907      	bls.n	8000742 <__udivdi3+0xf2>
 8000732:	1949      	adds	r1, r1, r5
 8000734:	f100 32ff 	add.w	r2, r0, #4294967295
 8000738:	d202      	bcs.n	8000740 <__udivdi3+0xf0>
 800073a:	428b      	cmp	r3, r1
 800073c:	f200 80ba 	bhi.w	80008b4 <__udivdi3+0x264>
 8000740:	4610      	mov	r0, r2
 8000742:	1ac9      	subs	r1, r1, r3
 8000744:	b2a4      	uxth	r4, r4
 8000746:	fbb1 f3fe 	udiv	r3, r1, lr
 800074a:	fb0e 1113 	mls	r1, lr, r3, r1
 800074e:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 8000752:	fb07 f703 	mul.w	r7, r7, r3
 8000756:	42a7      	cmp	r7, r4
 8000758:	d908      	bls.n	800076c <__udivdi3+0x11c>
 800075a:	1964      	adds	r4, r4, r5
 800075c:	f103 32ff 	add.w	r2, r3, #4294967295
 8000760:	f080 808f 	bcs.w	8000882 <__udivdi3+0x232>
 8000764:	42a7      	cmp	r7, r4
 8000766:	f240 808c 	bls.w	8000882 <__udivdi3+0x232>
 800076a:	3b02      	subs	r3, #2
 800076c:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8000770:	4631      	mov	r1, r6
 8000772:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000776:	2600      	movs	r6, #0
 8000778:	4630      	mov	r0, r6
 800077a:	4631      	mov	r1, r6
 800077c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000780:	f1c6 0420 	rsb	r4, r6, #32
 8000784:	fa22 f504 	lsr.w	r5, r2, r4
 8000788:	40b3      	lsls	r3, r6
 800078a:	432b      	orrs	r3, r5
 800078c:	fa20 fc04 	lsr.w	ip, r0, r4
 8000790:	fa01 f706 	lsl.w	r7, r1, r6
 8000794:	fa21 f504 	lsr.w	r5, r1, r4
 8000798:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 800079c:	ea4c 0707 	orr.w	r7, ip, r7
 80007a0:	fbb5 f8fe 	udiv	r8, r5, lr
 80007a4:	0c39      	lsrs	r1, r7, #16
 80007a6:	fb0e 5518 	mls	r5, lr, r8, r5
 80007aa:	fa1f fc83 	uxth.w	ip, r3
 80007ae:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
 80007b2:	fb0c f108 	mul.w	r1, ip, r8
 80007b6:	42a9      	cmp	r1, r5
 80007b8:	fa02 f206 	lsl.w	r2, r2, r6
 80007bc:	d904      	bls.n	80007c8 <__udivdi3+0x178>
 80007be:	18ed      	adds	r5, r5, r3
 80007c0:	f108 34ff 	add.w	r4, r8, #4294967295
 80007c4:	d367      	bcc.n	8000896 <__udivdi3+0x246>
 80007c6:	46a0      	mov	r8, r4
 80007c8:	1a6d      	subs	r5, r5, r1
 80007ca:	b2bf      	uxth	r7, r7
 80007cc:	fbb5 f4fe 	udiv	r4, r5, lr
 80007d0:	fb0e 5514 	mls	r5, lr, r4, r5
 80007d4:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
 80007d8:	fb0c fc04 	mul.w	ip, ip, r4
 80007dc:	458c      	cmp	ip, r1
 80007de:	d904      	bls.n	80007ea <__udivdi3+0x19a>
 80007e0:	18c9      	adds	r1, r1, r3
 80007e2:	f104 35ff 	add.w	r5, r4, #4294967295
 80007e6:	d35c      	bcc.n	80008a2 <__udivdi3+0x252>
 80007e8:	462c      	mov	r4, r5
 80007ea:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
 80007ee:	ebcc 0101 	rsb	r1, ip, r1
 80007f2:	fba4 2302 	umull	r2, r3, r4, r2
 80007f6:	4299      	cmp	r1, r3
 80007f8:	d348      	bcc.n	800088c <__udivdi3+0x23c>
 80007fa:	d044      	beq.n	8000886 <__udivdi3+0x236>
 80007fc:	4620      	mov	r0, r4
 80007fe:	2600      	movs	r6, #0
 8000800:	e76c      	b.n	80006dc <__udivdi3+0x8c>
 8000802:	f1c8 0420 	rsb	r4, r8, #32
 8000806:	fa01 f308 	lsl.w	r3, r1, r8
 800080a:	fa05 f508 	lsl.w	r5, r5, r8
 800080e:	fa20 f704 	lsr.w	r7, r0, r4
 8000812:	40e1      	lsrs	r1, r4
 8000814:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000818:	431f      	orrs	r7, r3
 800081a:	fbb1 f6fe 	udiv	r6, r1, lr
 800081e:	0c3a      	lsrs	r2, r7, #16
 8000820:	fb0e 1116 	mls	r1, lr, r6, r1
 8000824:	fa1f fc85 	uxth.w	ip, r5
 8000828:	ea42 4301 	orr.w	r3, r2, r1, lsl #16
 800082c:	fb0c f206 	mul.w	r2, ip, r6
 8000830:	429a      	cmp	r2, r3
 8000832:	fa00 f408 	lsl.w	r4, r0, r8
 8000836:	d907      	bls.n	8000848 <__udivdi3+0x1f8>
 8000838:	195b      	adds	r3, r3, r5
 800083a:	f106 31ff 	add.w	r1, r6, #4294967295
 800083e:	d237      	bcs.n	80008b0 <__udivdi3+0x260>
 8000840:	429a      	cmp	r2, r3
 8000842:	d935      	bls.n	80008b0 <__udivdi3+0x260>
 8000844:	3e02      	subs	r6, #2
 8000846:	442b      	add	r3, r5
 8000848:	1a9b      	subs	r3, r3, r2
 800084a:	b2bf      	uxth	r7, r7
 800084c:	fbb3 f0fe 	udiv	r0, r3, lr
 8000850:	fb0e 3310 	mls	r3, lr, r0, r3
 8000854:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
 8000858:	fb0c f100 	mul.w	r1, ip, r0
 800085c:	4299      	cmp	r1, r3
 800085e:	d907      	bls.n	8000870 <__udivdi3+0x220>
 8000860:	195b      	adds	r3, r3, r5
 8000862:	f100 32ff 	add.w	r2, r0, #4294967295
 8000866:	d221      	bcs.n	80008ac <__udivdi3+0x25c>
 8000868:	4299      	cmp	r1, r3
 800086a:	d91f      	bls.n	80008ac <__udivdi3+0x25c>
 800086c:	3802      	subs	r0, #2
 800086e:	442b      	add	r3, r5
 8000870:	1a5a      	subs	r2, r3, r1
 8000872:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 8000876:	4667      	mov	r7, ip
 8000878:	e750      	b.n	800071c <__udivdi3+0xcc>
 800087a:	4610      	mov	r0, r2
 800087c:	e716      	b.n	80006ac <__udivdi3+0x5c>
 800087e:	460b      	mov	r3, r1
 8000880:	e729      	b.n	80006d6 <__udivdi3+0x86>
 8000882:	4613      	mov	r3, r2
 8000884:	e772      	b.n	800076c <__udivdi3+0x11c>
 8000886:	40b0      	lsls	r0, r6
 8000888:	4290      	cmp	r0, r2
 800088a:	d2b7      	bcs.n	80007fc <__udivdi3+0x1ac>
 800088c:	1e60      	subs	r0, r4, #1
 800088e:	2600      	movs	r6, #0
 8000890:	e724      	b.n	80006dc <__udivdi3+0x8c>
 8000892:	4630      	mov	r0, r6
 8000894:	e722      	b.n	80006dc <__udivdi3+0x8c>
 8000896:	42a9      	cmp	r1, r5
 8000898:	d995      	bls.n	80007c6 <__udivdi3+0x176>
 800089a:	f1a8 0802 	sub.w	r8, r8, #2
 800089e:	441d      	add	r5, r3
 80008a0:	e792      	b.n	80007c8 <__udivdi3+0x178>
 80008a2:	458c      	cmp	ip, r1
 80008a4:	d9a0      	bls.n	80007e8 <__udivdi3+0x198>
 80008a6:	3c02      	subs	r4, #2
 80008a8:	4419      	add	r1, r3
 80008aa:	e79e      	b.n	80007ea <__udivdi3+0x19a>
 80008ac:	4610      	mov	r0, r2
 80008ae:	e7df      	b.n	8000870 <__udivdi3+0x220>
 80008b0:	460e      	mov	r6, r1
 80008b2:	e7c9      	b.n	8000848 <__udivdi3+0x1f8>
 80008b4:	3802      	subs	r0, #2
 80008b6:	4429      	add	r1, r5
 80008b8:	e743      	b.n	8000742 <__udivdi3+0xf2>
 80008ba:	bf00      	nop
 80008bc:	0000      	movs	r0, r0
	...

080008c0 <memcpy>:
 80008c0:	4684      	mov	ip, r0
 80008c2:	ea41 0300 	orr.w	r3, r1, r0
 80008c6:	f013 0303 	ands.w	r3, r3, #3
 80008ca:	d16d      	bne.n	80009a8 <memcpy+0xe8>
 80008cc:	3a40      	subs	r2, #64	; 0x40
 80008ce:	d341      	bcc.n	8000954 <memcpy+0x94>
 80008d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80008d4:	f840 3b04 	str.w	r3, [r0], #4
 80008d8:	f851 3b04 	ldr.w	r3, [r1], #4
 80008dc:	f840 3b04 	str.w	r3, [r0], #4
 80008e0:	f851 3b04 	ldr.w	r3, [r1], #4
 80008e4:	f840 3b04 	str.w	r3, [r0], #4
 80008e8:	f851 3b04 	ldr.w	r3, [r1], #4
 80008ec:	f840 3b04 	str.w	r3, [r0], #4
 80008f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80008f4:	f840 3b04 	str.w	r3, [r0], #4
 80008f8:	f851 3b04 	ldr.w	r3, [r1], #4
 80008fc:	f840 3b04 	str.w	r3, [r0], #4
 8000900:	f851 3b04 	ldr.w	r3, [r1], #4
 8000904:	f840 3b04 	str.w	r3, [r0], #4
 8000908:	f851 3b04 	ldr.w	r3, [r1], #4
 800090c:	f840 3b04 	str.w	r3, [r0], #4
 8000910:	f851 3b04 	ldr.w	r3, [r1], #4
 8000914:	f840 3b04 	str.w	r3, [r0], #4
 8000918:	f851 3b04 	ldr.w	r3, [r1], #4
 800091c:	f840 3b04 	str.w	r3, [r0], #4
 8000920:	f851 3b04 	ldr.w	r3, [r1], #4
 8000924:	f840 3b04 	str.w	r3, [r0], #4
 8000928:	f851 3b04 	ldr.w	r3, [r1], #4
 800092c:	f840 3b04 	str.w	r3, [r0], #4
 8000930:	f851 3b04 	ldr.w	r3, [r1], #4
 8000934:	f840 3b04 	str.w	r3, [r0], #4
 8000938:	f851 3b04 	ldr.w	r3, [r1], #4
 800093c:	f840 3b04 	str.w	r3, [r0], #4
 8000940:	f851 3b04 	ldr.w	r3, [r1], #4
 8000944:	f840 3b04 	str.w	r3, [r0], #4
 8000948:	f851 3b04 	ldr.w	r3, [r1], #4
 800094c:	f840 3b04 	str.w	r3, [r0], #4
 8000950:	3a40      	subs	r2, #64	; 0x40
 8000952:	d2bd      	bcs.n	80008d0 <memcpy+0x10>
 8000954:	3230      	adds	r2, #48	; 0x30
 8000956:	d311      	bcc.n	800097c <memcpy+0xbc>
 8000958:	f851 3b04 	ldr.w	r3, [r1], #4
 800095c:	f840 3b04 	str.w	r3, [r0], #4
 8000960:	f851 3b04 	ldr.w	r3, [r1], #4
 8000964:	f840 3b04 	str.w	r3, [r0], #4
 8000968:	f851 3b04 	ldr.w	r3, [r1], #4
 800096c:	f840 3b04 	str.w	r3, [r0], #4
 8000970:	f851 3b04 	ldr.w	r3, [r1], #4
 8000974:	f840 3b04 	str.w	r3, [r0], #4
 8000978:	3a10      	subs	r2, #16
 800097a:	d2ed      	bcs.n	8000958 <memcpy+0x98>
 800097c:	320c      	adds	r2, #12
 800097e:	d305      	bcc.n	800098c <memcpy+0xcc>
 8000980:	f851 3b04 	ldr.w	r3, [r1], #4
 8000984:	f840 3b04 	str.w	r3, [r0], #4
 8000988:	3a04      	subs	r2, #4
 800098a:	d2f9      	bcs.n	8000980 <memcpy+0xc0>
 800098c:	3204      	adds	r2, #4
 800098e:	d008      	beq.n	80009a2 <memcpy+0xe2>
 8000990:	07d2      	lsls	r2, r2, #31
 8000992:	bf1c      	itt	ne
 8000994:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000998:	f800 3b01 	strbne.w	r3, [r0], #1
 800099c:	d301      	bcc.n	80009a2 <memcpy+0xe2>
 800099e:	880b      	ldrh	r3, [r1, #0]
 80009a0:	8003      	strh	r3, [r0, #0]
 80009a2:	4660      	mov	r0, ip
 80009a4:	4770      	bx	lr
 80009a6:	bf00      	nop
 80009a8:	2a08      	cmp	r2, #8
 80009aa:	d313      	bcc.n	80009d4 <memcpy+0x114>
 80009ac:	078b      	lsls	r3, r1, #30
 80009ae:	d08d      	beq.n	80008cc <memcpy+0xc>
 80009b0:	f010 0303 	ands.w	r3, r0, #3
 80009b4:	d08a      	beq.n	80008cc <memcpy+0xc>
 80009b6:	f1c3 0304 	rsb	r3, r3, #4
 80009ba:	1ad2      	subs	r2, r2, r3
 80009bc:	07db      	lsls	r3, r3, #31
 80009be:	bf1c      	itt	ne
 80009c0:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80009c4:	f800 3b01 	strbne.w	r3, [r0], #1
 80009c8:	d380      	bcc.n	80008cc <memcpy+0xc>
 80009ca:	f831 3b02 	ldrh.w	r3, [r1], #2
 80009ce:	f820 3b02 	strh.w	r3, [r0], #2
 80009d2:	e77b      	b.n	80008cc <memcpy+0xc>
 80009d4:	3a04      	subs	r2, #4
 80009d6:	d3d9      	bcc.n	800098c <memcpy+0xcc>
 80009d8:	3a01      	subs	r2, #1
 80009da:	f811 3b01 	ldrb.w	r3, [r1], #1
 80009de:	f800 3b01 	strb.w	r3, [r0], #1
 80009e2:	d2f9      	bcs.n	80009d8 <memcpy+0x118>
 80009e4:	780b      	ldrb	r3, [r1, #0]
 80009e6:	7003      	strb	r3, [r0, #0]
 80009e8:	784b      	ldrb	r3, [r1, #1]
 80009ea:	7043      	strb	r3, [r0, #1]
 80009ec:	788b      	ldrb	r3, [r1, #2]
 80009ee:	7083      	strb	r3, [r0, #2]
 80009f0:	4660      	mov	r0, ip
 80009f2:	4770      	bx	lr
	...
 8000a00:	eba2 0003 	sub.w	r0, r2, r3
 8000a04:	4770      	bx	lr
 8000a06:	bf00      	nop

08000a08 <strcmp>:
 8000a08:	7802      	ldrb	r2, [r0, #0]
 8000a0a:	780b      	ldrb	r3, [r1, #0]
 8000a0c:	2a01      	cmp	r2, #1
 8000a0e:	bf28      	it	cs
 8000a10:	429a      	cmpcs	r2, r3
 8000a12:	d1f5      	bne.n	8000a00 <memcpy+0x140>
 8000a14:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 8000a18:	ea40 0401 	orr.w	r4, r0, r1
 8000a1c:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8000a20:	f06f 0c00 	mvn.w	ip, #0
 8000a24:	ea4f 7244 	mov.w	r2, r4, lsl #29
 8000a28:	b312      	cbz	r2, 8000a70 <strcmp+0x68>
 8000a2a:	ea80 0401 	eor.w	r4, r0, r1
 8000a2e:	f014 0f07 	tst.w	r4, #7
 8000a32:	d16a      	bne.n	8000b0a <strcmp+0x102>
 8000a34:	f000 0407 	and.w	r4, r0, #7
 8000a38:	f020 0007 	bic.w	r0, r0, #7
 8000a3c:	f004 0503 	and.w	r5, r4, #3
 8000a40:	f021 0107 	bic.w	r1, r1, #7
 8000a44:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 8000a48:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 8000a4c:	f014 0f04 	tst.w	r4, #4
 8000a50:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8000a54:	fa0c f405 	lsl.w	r4, ip, r5
 8000a58:	ea62 0204 	orn	r2, r2, r4
 8000a5c:	ea66 0604 	orn	r6, r6, r4
 8000a60:	d00a      	beq.n	8000a78 <strcmp+0x70>
 8000a62:	ea63 0304 	orn	r3, r3, r4
 8000a66:	4662      	mov	r2, ip
 8000a68:	ea67 0704 	orn	r7, r7, r4
 8000a6c:	4666      	mov	r6, ip
 8000a6e:	e003      	b.n	8000a78 <strcmp+0x70>
 8000a70:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 8000a74:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8000a78:	fa82 f54c 	uadd8	r5, r2, ip
 8000a7c:	ea82 0406 	eor.w	r4, r2, r6
 8000a80:	faa4 f48c 	sel	r4, r4, ip
 8000a84:	bb6c      	cbnz	r4, 8000ae2 <strcmp+0xda>
 8000a86:	fa83 f54c 	uadd8	r5, r3, ip
 8000a8a:	ea83 0507 	eor.w	r5, r3, r7
 8000a8e:	faa5 f58c 	sel	r5, r5, ip
 8000a92:	b995      	cbnz	r5, 8000aba <strcmp+0xb2>
 8000a94:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 8000a98:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 8000a9c:	fa82 f54c 	uadd8	r5, r2, ip
 8000aa0:	ea82 0406 	eor.w	r4, r2, r6
 8000aa4:	faa4 f48c 	sel	r4, r4, ip
 8000aa8:	fa83 f54c 	uadd8	r5, r3, ip
 8000aac:	ea83 0507 	eor.w	r5, r3, r7
 8000ab0:	faa5 f58c 	sel	r5, r5, ip
 8000ab4:	4325      	orrs	r5, r4
 8000ab6:	d0db      	beq.n	8000a70 <strcmp+0x68>
 8000ab8:	b99c      	cbnz	r4, 8000ae2 <strcmp+0xda>
 8000aba:	ba2d      	rev	r5, r5
 8000abc:	fab5 f485 	clz	r4, r5
 8000ac0:	f024 0407 	bic.w	r4, r4, #7
 8000ac4:	fa27 f104 	lsr.w	r1, r7, r4
 8000ac8:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8000acc:	fa23 f304 	lsr.w	r3, r3, r4
 8000ad0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8000ad4:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000ad8:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000adc:	eba0 0001 	sub.w	r0, r0, r1
 8000ae0:	4770      	bx	lr
 8000ae2:	ba24      	rev	r4, r4
 8000ae4:	fab4 f484 	clz	r4, r4
 8000ae8:	f024 0407 	bic.w	r4, r4, #7
 8000aec:	fa26 f104 	lsr.w	r1, r6, r4
 8000af0:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8000af4:	fa22 f204 	lsr.w	r2, r2, r4
 8000af8:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 8000afc:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000b00:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000b04:	eba0 0001 	sub.w	r0, r0, r1
 8000b08:	4770      	bx	lr
 8000b0a:	f014 0f03 	tst.w	r4, #3
 8000b0e:	d13c      	bne.n	8000b8a <strcmp+0x182>
 8000b10:	f010 0403 	ands.w	r4, r0, #3
 8000b14:	d128      	bne.n	8000b68 <strcmp+0x160>
 8000b16:	f850 2b08 	ldr.w	r2, [r0], #8
 8000b1a:	f851 3b08 	ldr.w	r3, [r1], #8
 8000b1e:	fa82 f54c 	uadd8	r5, r2, ip
 8000b22:	ea82 0503 	eor.w	r5, r2, r3
 8000b26:	faa5 f58c 	sel	r5, r5, ip
 8000b2a:	b95d      	cbnz	r5, 8000b44 <strcmp+0x13c>
 8000b2c:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8000b30:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8000b34:	fa82 f54c 	uadd8	r5, r2, ip
 8000b38:	ea82 0503 	eor.w	r5, r2, r3
 8000b3c:	faa5 f58c 	sel	r5, r5, ip
 8000b40:	2d00      	cmp	r5, #0
 8000b42:	d0e8      	beq.n	8000b16 <strcmp+0x10e>
 8000b44:	ba2d      	rev	r5, r5
 8000b46:	fab5 f485 	clz	r4, r5
 8000b4a:	f024 0407 	bic.w	r4, r4, #7
 8000b4e:	fa23 f104 	lsr.w	r1, r3, r4
 8000b52:	fa22 f204 	lsr.w	r2, r2, r4
 8000b56:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 8000b5a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000b5e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000b62:	eba0 0001 	sub.w	r0, r0, r1
 8000b66:	4770      	bx	lr
 8000b68:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 8000b6c:	f020 0003 	bic.w	r0, r0, #3
 8000b70:	f850 2b08 	ldr.w	r2, [r0], #8
 8000b74:	f021 0103 	bic.w	r1, r1, #3
 8000b78:	f851 3b08 	ldr.w	r3, [r1], #8
 8000b7c:	fa0c f404 	lsl.w	r4, ip, r4
 8000b80:	ea62 0204 	orn	r2, r2, r4
 8000b84:	ea63 0304 	orn	r3, r3, r4
 8000b88:	e7c9      	b.n	8000b1e <strcmp+0x116>
 8000b8a:	f010 0403 	ands.w	r4, r0, #3
 8000b8e:	d01a      	beq.n	8000bc6 <strcmp+0x1be>
 8000b90:	eba1 0104 	sub.w	r1, r1, r4
 8000b94:	f020 0003 	bic.w	r0, r0, #3
 8000b98:	07e4      	lsls	r4, r4, #31
 8000b9a:	f850 2b04 	ldr.w	r2, [r0], #4
 8000b9e:	d006      	beq.n	8000bae <strcmp+0x1a6>
 8000ba0:	d20f      	bcs.n	8000bc2 <strcmp+0x1ba>
 8000ba2:	788b      	ldrb	r3, [r1, #2]
 8000ba4:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 8000ba8:	1ae4      	subs	r4, r4, r3
 8000baa:	d106      	bne.n	8000bba <strcmp+0x1b2>
 8000bac:	b12b      	cbz	r3, 8000bba <strcmp+0x1b2>
 8000bae:	78cb      	ldrb	r3, [r1, #3]
 8000bb0:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 8000bb4:	1ae4      	subs	r4, r4, r3
 8000bb6:	d100      	bne.n	8000bba <strcmp+0x1b2>
 8000bb8:	b91b      	cbnz	r3, 8000bc2 <strcmp+0x1ba>
 8000bba:	4620      	mov	r0, r4
 8000bbc:	f85d 4b10 	ldr.w	r4, [sp], #16
 8000bc0:	4770      	bx	lr
 8000bc2:	f101 0104 	add.w	r1, r1, #4
 8000bc6:	f850 2b04 	ldr.w	r2, [r0], #4
 8000bca:	07cc      	lsls	r4, r1, #31
 8000bcc:	f021 0103 	bic.w	r1, r1, #3
 8000bd0:	f851 3b04 	ldr.w	r3, [r1], #4
 8000bd4:	d848      	bhi.n	8000c68 <strcmp+0x260>
 8000bd6:	d224      	bcs.n	8000c22 <strcmp+0x21a>
 8000bd8:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
 8000bdc:	fa82 f54c 	uadd8	r5, r2, ip
 8000be0:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 8000be4:	faa5 f58c 	sel	r5, r5, ip
 8000be8:	d10a      	bne.n	8000c00 <strcmp+0x1f8>
 8000bea:	b965      	cbnz	r5, 8000c06 <strcmp+0x1fe>
 8000bec:	f851 3b04 	ldr.w	r3, [r1], #4
 8000bf0:	ea84 0402 	eor.w	r4, r4, r2
 8000bf4:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 8000bf8:	d10e      	bne.n	8000c18 <strcmp+0x210>
 8000bfa:	f850 2b04 	ldr.w	r2, [r0], #4
 8000bfe:	e7eb      	b.n	8000bd8 <strcmp+0x1d0>
 8000c00:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8000c04:	e055      	b.n	8000cb2 <strcmp+0x2aa>
 8000c06:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
 8000c0a:	d14d      	bne.n	8000ca8 <strcmp+0x2a0>
 8000c0c:	7808      	ldrb	r0, [r1, #0]
 8000c0e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000c12:	f1c0 0000 	rsb	r0, r0, #0
 8000c16:	4770      	bx	lr
 8000c18:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8000c1c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8000c20:	e047      	b.n	8000cb2 <strcmp+0x2aa>
 8000c22:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 8000c26:	fa82 f54c 	uadd8	r5, r2, ip
 8000c2a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 8000c2e:	faa5 f58c 	sel	r5, r5, ip
 8000c32:	d10a      	bne.n	8000c4a <strcmp+0x242>
 8000c34:	b965      	cbnz	r5, 8000c50 <strcmp+0x248>
 8000c36:	f851 3b04 	ldr.w	r3, [r1], #4
 8000c3a:	ea84 0402 	eor.w	r4, r4, r2
 8000c3e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 8000c42:	d10c      	bne.n	8000c5e <strcmp+0x256>
 8000c44:	f850 2b04 	ldr.w	r2, [r0], #4
 8000c48:	e7eb      	b.n	8000c22 <strcmp+0x21a>
 8000c4a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8000c4e:	e030      	b.n	8000cb2 <strcmp+0x2aa>
 8000c50:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 8000c54:	d128      	bne.n	8000ca8 <strcmp+0x2a0>
 8000c56:	880b      	ldrh	r3, [r1, #0]
 8000c58:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8000c5c:	e029      	b.n	8000cb2 <strcmp+0x2aa>
 8000c5e:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8000c62:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 8000c66:	e024      	b.n	8000cb2 <strcmp+0x2aa>
 8000c68:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 8000c6c:	fa82 f54c 	uadd8	r5, r2, ip
 8000c70:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 8000c74:	faa5 f58c 	sel	r5, r5, ip
 8000c78:	d10a      	bne.n	8000c90 <strcmp+0x288>
 8000c7a:	b965      	cbnz	r5, 8000c96 <strcmp+0x28e>
 8000c7c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000c80:	ea84 0402 	eor.w	r4, r4, r2
 8000c84:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 8000c88:	d109      	bne.n	8000c9e <strcmp+0x296>
 8000c8a:	f850 2b04 	ldr.w	r2, [r0], #4
 8000c8e:	e7eb      	b.n	8000c68 <strcmp+0x260>
 8000c90:	ea4f 6313 	mov.w	r3, r3, lsr #24
 8000c94:	e00d      	b.n	8000cb2 <strcmp+0x2aa>
 8000c96:	f015 0fff 	tst.w	r5, #255	; 0xff
 8000c9a:	d105      	bne.n	8000ca8 <strcmp+0x2a0>
 8000c9c:	680b      	ldr	r3, [r1, #0]
 8000c9e:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8000ca2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8000ca6:	e004      	b.n	8000cb2 <strcmp+0x2aa>
 8000ca8:	f04f 0000 	mov.w	r0, #0
 8000cac:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000cb0:	4770      	bx	lr
 8000cb2:	ba12      	rev	r2, r2
 8000cb4:	ba1b      	rev	r3, r3
 8000cb6:	fa82 f44c 	uadd8	r4, r2, ip
 8000cba:	ea82 0403 	eor.w	r4, r2, r3
 8000cbe:	faa4 f58c 	sel	r5, r4, ip
 8000cc2:	fab5 f485 	clz	r4, r5
 8000cc6:	fa02 f204 	lsl.w	r2, r2, r4
 8000cca:	fa03 f304 	lsl.w	r3, r3, r4
 8000cce:	ea4f 6012 	mov.w	r0, r2, lsr #24
 8000cd2:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000cd6:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 8000cda:	4770      	bx	lr
 8000cdc:	f3af 8000 	nop.w

08000ce0 <__late_init>:
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void __late_init(void) {}
 8000ce0:	4770      	bx	lr
 8000ce2:	bf00      	nop
 8000ce4:	f3af 8000 	nop.w
 8000ce8:	f3af 8000 	nop.w
 8000cec:	f3af 8000 	nop.w

08000cf0 <_default_exit>:
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
void _default_exit(void) {
  while (1)
    ;
 8000cf0:	e7fe      	b.n	8000cf0 <_default_exit>
 8000cf2:	bf00      	nop
 8000cf4:	f3af 8000 	nop.w
 8000cf8:	f3af 8000 	nop.w
 8000cfc:	f3af 8000 	nop.w

08000d00 <Reset_Handler>:
  uint32_t psp, reg;

  /* Process Stack initialization, it is allocated starting from the
     symbol __process_stack_end__ and its lower limit is the symbol
     __process_stack_base__.*/
  asm volatile ("cpsid   i");
 8000d00:	b672      	cpsid	i
  psp = SYMVAL(__process_stack_end__);
 8000d02:	4c37      	ldr	r4, [pc, #220]	; (8000de0 <Reset_Handler+0xe0>)
  asm volatile ("msr     PSP, %0" : : "r" (psp));
 8000d04:	f384 8809 	msr	PSP, r4
#if CORTEX_USE_FPU
  /* Initializing the FPU context save in lazy mode.*/
  SCB_FPCCR = FPCCR_ASPEN | FPCCR_LSPEN;

  /* CP10 and CP11 set to full access.*/
  SCB_CPACR |= 0x00F00000;
 8000d08:	4a36      	ldr	r2, [pc, #216]	; (8000de4 <Reset_Handler+0xe4>)
  psp = SYMVAL(__process_stack_end__);
  asm volatile ("msr     PSP, %0" : : "r" (psp));

#if CORTEX_USE_FPU
  /* Initializing the FPU context save in lazy mode.*/
  SCB_FPCCR = FPCCR_ASPEN | FPCCR_LSPEN;
 8000d0a:	4937      	ldr	r1, [pc, #220]	; (8000de8 <Reset_Handler+0xe8>)

  /* CP10 and CP11 set to full access.*/
  SCB_CPACR |= 0x00F00000;
 8000d0c:	6813      	ldr	r3, [r2, #0]
  psp = SYMVAL(__process_stack_end__);
  asm volatile ("msr     PSP, %0" : : "r" (psp));

#if CORTEX_USE_FPU
  /* Initializing the FPU context save in lazy mode.*/
  SCB_FPCCR = FPCCR_ASPEN | FPCCR_LSPEN;
 8000d0e:	f04f 4040 	mov.w	r0, #3221225472	; 0xc0000000

  /* CP10 and CP11 set to full access.*/
  SCB_CPACR |= 0x00F00000;
 8000d12:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8000d16:	6013      	str	r3, [r2, #0]
  psp = SYMVAL(__process_stack_end__);
  asm volatile ("msr     PSP, %0" : : "r" (psp));

#if CORTEX_USE_FPU
  /* Initializing the FPU context save in lazy mode.*/
  SCB_FPCCR = FPCCR_ASPEN | FPCCR_LSPEN;
 8000d18:	6008      	str	r0, [r1, #0]
  /* CP10 and CP11 set to full access.*/
  SCB_CPACR |= 0x00F00000;

  /* FPSCR and FPDSCR initially zero.*/
  reg = 0;
  asm volatile ("vmsr    FPSCR, %0" : : "r" (reg) : "memory");
 8000d1a:	2300      	movs	r3, #0
 8000d1c:	eee1 3a10 	vmsr	fpscr, r3
  reg = CRT0_CONTROL_INIT | 4;
#else
  /* CPU mode initialization.*/
  reg = CRT0_CONTROL_INIT;
#endif
  asm volatile ("msr     CONTROL, %0" : : "r" (reg));
 8000d20:	2206      	movs	r2, #6
  SCB_CPACR |= 0x00F00000;

  /* FPSCR and FPDSCR initially zero.*/
  reg = 0;
  asm volatile ("vmsr    FPSCR, %0" : : "r" (reg) : "memory");
  SCB_FPDSCR = reg;
 8000d22:	608b      	str	r3, [r1, #8]
  reg = CRT0_CONTROL_INIT | 4;
#else
  /* CPU mode initialization.*/
  reg = CRT0_CONTROL_INIT;
#endif
  asm volatile ("msr     CONTROL, %0" : : "r" (reg));
 8000d24:	f382 8814 	msr	CONTROL, r2
  asm volatile ("isb");
 8000d28:	f3bf 8f6f 	isb	sy

  /* Early initialization hook invocation.*/
  __early_init();
 8000d2c:	f006 fd58 	bl	80077e0 <__early_init>

#if CRT0_INIT_STACKS
  /* Main and Process stacks initialization.*/
  fill32(&__main_stack_base__,
 8000d30:	4b2e      	ldr	r3, [pc, #184]	; (8000dec <Reset_Handler+0xec>)
 8000d32:	4a2f      	ldr	r2, [pc, #188]	; (8000df0 <Reset_Handler+0xf0>)
 8000d34:	4293      	cmp	r3, r2
 8000d36:	d20b      	bcs.n	8000d50 <Reset_Handler+0x50>
 8000d38:	43d9      	mvns	r1, r3
 8000d3a:	440a      	add	r2, r1
 8000d3c:	f022 0203 	bic.w	r2, r2, #3
 8000d40:	3204      	adds	r2, #4
 8000d42:	441a      	add	r2, r3
 8000d44:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 8000d48:	f843 1b04 	str.w	r1, [r3], #4
 8000d4c:	4293      	cmp	r3, r2
 8000d4e:	d1fb      	bne.n	8000d48 <Reset_Handler+0x48>
         &__main_stack_end__,
         CRT0_STACKS_FILL_PATTERN);
  fill32(&__process_stack_base__,
 8000d50:	4b28      	ldr	r3, [pc, #160]	; (8000df4 <Reset_Handler+0xf4>)
 8000d52:	42a3      	cmp	r3, r4
 8000d54:	d20c      	bcs.n	8000d70 <Reset_Handler+0x70>
 8000d56:	4a28      	ldr	r2, [pc, #160]	; (8000df8 <Reset_Handler+0xf8>)
 8000d58:	1d19      	adds	r1, r3, #4
 8000d5a:	1a52      	subs	r2, r2, r1
 8000d5c:	f022 0203 	bic.w	r2, r2, #3
 8000d60:	3204      	adds	r2, #4
 8000d62:	441a      	add	r2, r3
 8000d64:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 8000d68:	f843 1b04 	str.w	r1, [r3], #4
 8000d6c:	4293      	cmp	r3, r2
 8000d6e:	d1fb      	bne.n	8000d68 <Reset_Handler+0x68>
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 8000d70:	4a22      	ldr	r2, [pc, #136]	; (8000dfc <Reset_Handler+0xfc>)
 8000d72:	4b23      	ldr	r3, [pc, #140]	; (8000e00 <Reset_Handler+0x100>)
 8000d74:	429a      	cmp	r2, r3
 8000d76:	d20c      	bcs.n	8000d92 <Reset_Handler+0x92>
 8000d78:	43d0      	mvns	r0, r2
 8000d7a:	4418      	add	r0, r3
 8000d7c:	f020 0003 	bic.w	r0, r0, #3
 8000d80:	4b20      	ldr	r3, [pc, #128]	; (8000e04 <Reset_Handler+0x104>)
 8000d82:	3004      	adds	r0, #4
 8000d84:	4418      	add	r0, r3
      *dp++ = *tp++;
 8000d86:	f853 1b04 	ldr.w	r1, [r3], #4
 8000d8a:	f842 1b04 	str.w	r1, [r2], #4
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 8000d8e:	4283      	cmp	r3, r0
 8000d90:	d1f9      	bne.n	8000d86 <Reset_Handler+0x86>
  }
#endif

#if CRT0_INIT_BSS
  /* BSS segment initialization.*/
  fill32(&_bss_start, &_bss_end, 0);
 8000d92:	4b1d      	ldr	r3, [pc, #116]	; (8000e08 <Reset_Handler+0x108>)
 8000d94:	4a1d      	ldr	r2, [pc, #116]	; (8000e0c <Reset_Handler+0x10c>)
 8000d96:	4293      	cmp	r3, r2
 8000d98:	d20a      	bcs.n	8000db0 <Reset_Handler+0xb0>
 8000d9a:	43d9      	mvns	r1, r3
 8000d9c:	440a      	add	r2, r1
 8000d9e:	f022 0203 	bic.w	r2, r2, #3
 8000da2:	3204      	adds	r2, #4
 8000da4:	441a      	add	r2, r3
 8000da6:	2100      	movs	r1, #0
 8000da8:	f843 1b04 	str.w	r1, [r3], #4
 8000dac:	4293      	cmp	r3, r2
 8000dae:	d1fb      	bne.n	8000da8 <Reset_Handler+0xa8>

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
    while (fpp < &__init_array_end) {
 8000db0:	4d17      	ldr	r5, [pc, #92]	; (8000e10 <Reset_Handler+0x110>)
 8000db2:	4c18      	ldr	r4, [pc, #96]	; (8000e14 <Reset_Handler+0x114>)
  /* BSS segment initialization.*/
  fill32(&_bss_start, &_bss_end, 0);
#endif

  /* Late initialization hook invocation.*/
  __late_init();
 8000db4:	f7ff ff94 	bl	8000ce0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
    while (fpp < &__init_array_end) {
 8000db8:	42ac      	cmp	r4, r5
 8000dba:	d204      	bcs.n	8000dc6 <Reset_Handler+0xc6>
      (*fpp)();
 8000dbc:	f854 3b04 	ldr.w	r3, [r4], #4
 8000dc0:	4798      	blx	r3

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
    while (fpp < &__init_array_end) {
 8000dc2:	42ac      	cmp	r4, r5
 8000dc4:	d3fa      	bcc.n	8000dbc <Reset_Handler+0xbc>

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
    while (fpp < &__fini_array_end) {
 8000dc6:	4d14      	ldr	r5, [pc, #80]	; (8000e18 <Reset_Handler+0x118>)
 8000dc8:	4c14      	ldr	r4, [pc, #80]	; (8000e1c <Reset_Handler+0x11c>)
    }
  }
#endif

  /* Invoking application main() function.*/
  main();
 8000dca:	f7ff f9f9 	bl	80001c0 <main>

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
    while (fpp < &__fini_array_end) {
 8000dce:	42ac      	cmp	r4, r5
 8000dd0:	d204      	bcs.n	8000ddc <Reset_Handler+0xdc>
      (*fpp)();
 8000dd2:	f854 3b04 	ldr.w	r3, [r4], #4
 8000dd6:	4798      	blx	r3

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
    while (fpp < &__fini_array_end) {
 8000dd8:	42ac      	cmp	r4, r5
 8000dda:	d3fa      	bcc.n	8000dd2 <Reset_Handler+0xd2>
    }
  }
#endif

  /* Invoking the exit handler.*/
  _default_exit();
 8000ddc:	f7ff ff88 	bl	8000cf0 <_default_exit>
 8000de0:	20000800 	.word	0x20000800
 8000de4:	e000ed88 	.word	0xe000ed88
 8000de8:	e000ef34 	.word	0xe000ef34
 8000dec:	20000000 	.word	0x20000000
 8000df0:	20000400 	.word	0x20000400
 8000df4:	20000400 	.word	0x20000400
 8000df8:	20000803 	.word	0x20000803
 8000dfc:	20000800 	.word	0x20000800
 8000e00:	2000114c 	.word	0x2000114c
 8000e04:	0801ce40 	.word	0x0801ce40
 8000e08:	2000114c 	.word	0x2000114c
 8000e0c:	200187b8 	.word	0x200187b8
 8000e10:	080001c0 	.word	0x080001c0
 8000e14:	080001c0 	.word	0x080001c0
 8000e18:	080001c0 	.word	0x080001c0
 8000e1c:	080001c0 	.word	0x080001c0

08000e20 <_unhandled_exception>:
 * @notapi
 */
void _unhandled_exception(void) {

  while (true)
    ;
 8000e20:	e7fe      	b.n	8000e20 <_unhandled_exception>
 8000e22:	bf00      	nop
 8000e24:	f3af 8000 	nop.w
 8000e28:	f3af 8000 	nop.w
 8000e2c:	f3af 8000 	nop.w

08000e30 <SVC_Handler>:
void SVC_Handler(void) {
  struct port_extctx *ctxp;

#if CORTEX_USE_FPU
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8000e30:	4a06      	ldr	r2, [pc, #24]	; (8000e4c <SVC_Handler+0x1c>)
 8000e32:	6853      	ldr	r3, [r2, #4]
 8000e34:	f023 0301 	bic.w	r3, r3, #1
 8000e38:	6053      	str	r3, [r2, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000e3a:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000e3e:	3368      	adds	r3, #104	; 0x68

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000e40:	f383 8809 	msr	PSP, r3

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000e44:	2300      	movs	r3, #0
 8000e46:	f383 8811 	msr	BASEPRI, r3
 8000e4a:	4770      	bx	lr
 8000e4c:	e000ef30 	.word	0xe000ef30

08000e50 <_port_irq_epilogue>:
 8000e50:	2320      	movs	r3, #32
 8000e52:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0) {
 8000e56:	4b12      	ldr	r3, [pc, #72]	; (8000ea0 <_port_irq_epilogue+0x50>)
 8000e58:	685b      	ldr	r3, [r3, #4]
 8000e5a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8000e5e:	d102      	bne.n	8000e66 <_port_irq_epilogue+0x16>
 8000e60:	f383 8811 	msr	BASEPRI, r3
 8000e64:	4770      	bx	lr
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8000e66:	b510      	push	{r4, lr}
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  uint32_t result;

  /* Empty asm statement works as a scheduling barrier */
  __ASM volatile ("");
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 8000e68:	eef1 3a10 	vmrs	r3, fpscr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000e6c:	f3ef 8409 	mrs	r4, PSP
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
#if CORTEX_USE_FPU
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8000e70:	4b0c      	ldr	r3, [pc, #48]	; (8000ea4 <_port_irq_epilogue+0x54>)
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8000e72:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
#if CORTEX_USE_FPU
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8000e76:	68db      	ldr	r3, [r3, #12]
 8000e78:	f844 3c08 	str.w	r3, [r4, #-8]
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8000e7c:	f844 2c4c 	str.w	r2, [r4, #-76]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8000e80:	f1a4 0368 	sub.w	r3, r4, #104	; 0x68

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000e84:	f383 8809 	msr	PSP, r3
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8000e88:	f000 fa02 	bl	8001290 <chSchIsPreemptionRequired>
 8000e8c:	b118      	cbz	r0, 8000e96 <_port_irq_epilogue+0x46>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8000e8e:	4b06      	ldr	r3, [pc, #24]	; (8000ea8 <_port_irq_epilogue+0x58>)
 8000e90:	f844 3c50 	str.w	r3, [r4, #-80]
 8000e94:	bd10      	pop	{r4, pc}
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8000e96:	4b05      	ldr	r3, [pc, #20]	; (8000eac <_port_irq_epilogue+0x5c>)
 8000e98:	f844 3c50 	str.w	r3, [r4, #-80]
 8000e9c:	bd10      	pop	{r4, pc}
 8000e9e:	bf00      	nop
 8000ea0:	e000ed00 	.word	0xe000ed00
 8000ea4:	e000ef30 	.word	0xe000ef30
 8000ea8:	08000307 	.word	0x08000307
 8000eac:	0800030a 	.word	0x0800030a

08000eb0 <_idle_thread>:
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {

  (void)p;
  chRegSetThreadName("idle");
 8000eb0:	4b02      	ldr	r3, [pc, #8]	; (8000ebc <_idle_thread+0xc>)
 8000eb2:	4a03      	ldr	r2, [pc, #12]	; (8000ec0 <_idle_thread+0x10>)
 8000eb4:	699b      	ldr	r3, [r3, #24]
 8000eb6:	619a      	str	r2, [r3, #24]
 8000eb8:	e7fe      	b.n	8000eb8 <_idle_thread+0x8>
 8000eba:	bf00      	nop
 8000ebc:	20001150 	.word	0x20001150
 8000ec0:	080160a0 	.word	0x080160a0
 8000ec4:	f3af 8000 	nop.w
 8000ec8:	f3af 8000 	nop.w
 8000ecc:	f3af 8000 	nop.w

08000ed0 <chSysInit>:
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8000ed0:	4b1f      	ldr	r3, [pc, #124]	; (8000f50 <chSysInit+0x80>)
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
 8000ed2:	4a20      	ldr	r2, [pc, #128]	; (8000f54 <chSysInit+0x84>)
  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8000ed4:	4820      	ldr	r0, [pc, #128]	; (8000f58 <chSysInit+0x88>)
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8000ed6:	b5f0      	push	{r4, r5, r6, r7, lr}
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8000ed8:	2400      	movs	r4, #0
 8000eda:	609c      	str	r4, [r3, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000edc:	68df      	ldr	r7, [r3, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8000ede:	4e1f      	ldr	r6, [pc, #124]	; (8000f5c <chSysInit+0x8c>)
  _dbg_trace_init();
#endif

#if !CH_CFG_NO_IDLE_THREAD
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8000ee0:	4d1f      	ldr	r5, [pc, #124]	; (8000f60 <chSysInit+0x90>)
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 8000ee2:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 8000ee6:	4039      	ands	r1, r7
  reg_value  =  (reg_value                                 |
 8000ee8:	430a      	orrs	r2, r1
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8000eea:	60da      	str	r2, [r3, #12]
 8000eec:	68f2      	ldr	r2, [r6, #12]
 8000eee:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000ef2:	60f2      	str	r2, [r6, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8000ef4:	6802      	ldr	r2, [r0, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8000ef6:	2120      	movs	r1, #32
 8000ef8:	f042 0201 	orr.w	r2, r2, #1
 8000efc:	2610      	movs	r6, #16
 8000efe:	6002      	str	r2, [r0, #0]
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8000f00:	b083      	sub	sp, #12
 8000f02:	77de      	strb	r6, [r3, #31]
 8000f04:	f883 1022 	strb.w	r1, [r3, #34]	; 0x22
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
  _scheduler_init();
 8000f08:	f000 f92a 	bl	8001160 <_scheduler_init>
  _vt_init();
 8000f0c:	f000 fa28 	bl	8001360 <_vt_init>
#if CH_CFG_USE_TM
  _tm_init();
 8000f10:	f000 f8ce 	bl	80010b0 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE
  _core_init();
 8000f14:	f001 fc24 	bl	8002760 <_core_init>
#endif
#if CH_CFG_USE_HEAP
  _heap_init();
 8000f18:	f001 fc6a 	bl	80027f0 <_heap_init>
  _dbg_trace_init();
#endif

#if !CH_CFG_NO_IDLE_THREAD
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8000f1c:	4628      	mov	r0, r5
 8000f1e:	2140      	movs	r1, #64	; 0x40
 8000f20:	f000 fa8e 	bl	8001440 <_thread_init>
 8000f24:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8000f28:	2201      	movs	r2, #1
  _dbg_trace_init();
#endif

#if !CH_CFG_NO_IDLE_THREAD
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8000f2a:	6198      	str	r0, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8000f2c:	7702      	strb	r2, [r0, #28]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000f2e:	f384 8811 	msr	BASEPRI, r4
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000f32:	b662      	cpsie	i
#endif
  chSysEnable();

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 8000f34:	699b      	ldr	r3, [r3, #24]
 8000f36:	490b      	ldr	r1, [pc, #44]	; (8000f64 <chSysInit+0x94>)
 8000f38:	6199      	str	r1, [r3, #24]

#if !CH_CFG_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(ch.idle_thread_wa, sizeof(ch.idle_thread_wa), IDLEPRIO,
 8000f3a:	f105 0048 	add.w	r0, r5, #72	; 0x48
 8000f3e:	9400      	str	r4, [sp, #0]
 8000f40:	f44f 71b0 	mov.w	r1, #352	; 0x160
 8000f44:	4b08      	ldr	r3, [pc, #32]	; (8000f68 <chSysInit+0x98>)
 8000f46:	f000 fad3 	bl	80014f0 <chThdCreateStatic>
                    (tfunc_t)_idle_thread, NULL);
#endif
}
 8000f4a:	b003      	add	sp, #12
 8000f4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000f4e:	bf00      	nop
 8000f50:	e000ed00 	.word	0xe000ed00
 8000f54:	05fa0300 	.word	0x05fa0300
 8000f58:	e0001000 	.word	0xe0001000
 8000f5c:	e000edf0 	.word	0xe000edf0
 8000f60:	20001180 	.word	0x20001180
 8000f64:	080160b0 	.word	0x080160b0
 8000f68:	08000eb1 	.word	0x08000eb1
 8000f6c:	f3af 8000 	nop.w

08000f70 <chSysHalt>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000f70:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8000f72:	4b01      	ldr	r3, [pc, #4]	; (8000f78 <chSysHalt+0x8>)
 8000f74:	62d8      	str	r0, [r3, #44]	; 0x2c

  /* Harmless infinite loop.*/
  while (true) {
  }
 8000f76:	e7fe      	b.n	8000f76 <chSysHalt+0x6>
 8000f78:	20001150 	.word	0x20001150
 8000f7c:	f3af 8000 	nop.w

08000f80 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8000f80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8000f84:	4c1b      	ldr	r4, [pc, #108]	; (8000ff4 <chSysTimerHandlerI+0x74>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000f86:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8000f8a:	69e3      	ldr	r3, [r4, #28]
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8000f8c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8000f8e:	6a69      	ldr	r1, [r5, #36]	; 0x24

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8000f90:	6898      	ldr	r0, [r3, #8]
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8000f92:	1a8e      	subs	r6, r1, r2

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8000f94:	4286      	cmp	r6, r0
 8000f96:	f104 061c 	add.w	r6, r4, #28
 8000f9a:	d319      	bcc.n	8000fd0 <chSysTimerHandlerI+0x50>

    /* The timer is removed from the list and marked as non-armed.*/
    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = (vtfunc_t)NULL;
 8000f9c:	f04f 0800 	mov.w	r8, #0

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000fa0:	2720      	movs	r7, #32
    /* The "last time" becomes this timer's expiration time.*/
    delta -= vtp->vt_delta;
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    /* The timer is removed from the list and marked as non-armed.*/
    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000fa2:	6819      	ldr	r1, [r3, #0]
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 8000fa4:	f8d3 c00c 	ldr.w	ip, [r3, #12]
      break;
    }

    /* The "last time" becomes this timer's expiration time.*/
    delta -= vtp->vt_delta;
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8000fa8:	4402      	add	r2, r0
 8000faa:	62a2      	str	r2, [r4, #40]	; 0x28

    /* The timer is removed from the list and marked as non-armed.*/
    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000fac:	604e      	str	r6, [r1, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 8000fae:	61e1      	str	r1, [r4, #28]
    fn = vtp->vt_func;
    vtp->vt_func = (vtfunc_t)NULL;
 8000fb0:	f8c3 800c 	str.w	r8, [r3, #12]
 8000fb4:	f388 8811 	msr	BASEPRI, r8

    /* The callback is invoked outside the kernel critical zone.*/
    chSysUnlockFromISR();
    fn(vtp->vt_par);
 8000fb8:	6918      	ldr	r0, [r3, #16]
 8000fba:	47e0      	blx	ip
 8000fbc:	f387 8811 	msr	BASEPRI, r7
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8000fc0:	69e3      	ldr	r3, [r4, #28]
 8000fc2:	6a69      	ldr	r1, [r5, #36]	; 0x24
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8000fc4:	6aa2      	ldr	r2, [r4, #40]	; 0x28

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8000fc6:	6898      	ldr	r0, [r3, #8]
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8000fc8:	ebc2 0e01 	rsb	lr, r2, r1

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8000fcc:	4586      	cmp	lr, r0
 8000fce:	d2e8      	bcs.n	8000fa2 <chSysTimerHandlerI+0x22>
    /* The callback is invoked outside the kernel critical zone.*/
    chSysUnlockFromISR();
    fn(vtp->vt_par);
    chSysLockFromISR();
  }
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000fd0:	42b3      	cmp	r3, r6
 8000fd2:	d00b      	beq.n	8000fec <chSysTimerHandlerI+0x6c>
    port_timer_stop_alarm();
  }
  else {
    /* Updating the alarm to the next deadline, deadline that must not be
       closer in time than the minimum time delta.*/
    if (vtp->vt_delta >= CH_CFG_ST_TIMEDELTA) {
 8000fd4:	2801      	cmp	r0, #1
 8000fd6:	d004      	beq.n	8000fe2 <chSysTimerHandlerI+0x62>
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8000fd8:	4408      	add	r0, r1
#endif
  chVTDoTickI();
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 8000fda:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8000fde:	f005 baef 	b.w	80065c0 <stSetAlarm>
 8000fe2:	1c88      	adds	r0, r1, #2
 8000fe4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8000fe8:	f005 baea 	b.w	80065c0 <stSetAlarm>
 8000fec:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 8000ff0:	f005 bade 	b.w	80065b0 <stStopAlarm>
 8000ff4:	20001150 	.word	0x20001150
 8000ff8:	f3af 8000 	nop.w
 8000ffc:	f3af 8000 	nop.w

08001000 <chSysIsCounterWithinX>:
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return end > start ? (cnt >= start) && (cnt < end) :
 8001000:	428a      	cmp	r2, r1
 8001002:	d906      	bls.n	8001012 <chSysIsCounterWithinX+0x12>
 8001004:	4281      	cmp	r1, r0
 8001006:	d808      	bhi.n	800101a <chSysIsCounterWithinX+0x1a>
 8001008:	4282      	cmp	r2, r0
 800100a:	bf94      	ite	ls
 800100c:	2000      	movls	r0, #0
 800100e:	2001      	movhi	r0, #1
 8001010:	4770      	bx	lr
                       (cnt >= start) || (cnt < end);
 8001012:	4281      	cmp	r1, r0
 8001014:	d8f8      	bhi.n	8001008 <chSysIsCounterWithinX+0x8>
 8001016:	2001      	movs	r0, #1
}
 8001018:	4770      	bx	lr
 800101a:	2000      	movs	r0, #0
 800101c:	4770      	bx	lr
 800101e:	bf00      	nop

08001020 <chSysPolledDelayX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8001020:	4908      	ldr	r1, [pc, #32]	; (8001044 <chSysPolledDelayX+0x24>)
 8001022:	684a      	ldr	r2, [r1, #4]
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;
 8001024:	4410      	add	r0, r2
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return end > start ? (cnt >= start) && (cnt < end) :
 8001026:	4290      	cmp	r0, r2
 8001028:	684b      	ldr	r3, [r1, #4]
 800102a:	d902      	bls.n	8001032 <chSysPolledDelayX+0x12>
 800102c:	4293      	cmp	r3, r2
 800102e:	d202      	bcs.n	8001036 <chSysPolledDelayX+0x16>
 8001030:	4770      	bx	lr
                       (cnt >= start) || (cnt < end);
 8001032:	4293      	cmp	r3, r2
 8001034:	d2f7      	bcs.n	8001026 <chSysPolledDelayX+0x6>
 8001036:	4283      	cmp	r3, r0
 8001038:	bf2c      	ite	cs
 800103a:	2300      	movcs	r3, #0
 800103c:	2301      	movcc	r3, #1
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 800103e:	2b00      	cmp	r3, #0
 8001040:	d1f1      	bne.n	8001026 <chSysPolledDelayX+0x6>
 8001042:	4770      	bx	lr
 8001044:	e0001000 	.word	0xe0001000
 8001048:	f3af 8000 	nop.w
 800104c:	f3af 8000 	nop.w

08001050 <chTMStartMeasurementX>:
 8001050:	4b01      	ldr	r3, [pc, #4]	; (8001058 <chTMStartMeasurementX+0x8>)
 8001052:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8001054:	6083      	str	r3, [r0, #8]
 8001056:	4770      	bx	lr
 8001058:	e0001000 	.word	0xe0001000
 800105c:	f3af 8000 	nop.w

08001060 <chTMStopMeasurementX>:
 8001060:	4b0f      	ldr	r3, [pc, #60]	; (80010a0 <chTMStopMeasurementX+0x40>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8001062:	4910      	ldr	r1, [pc, #64]	; (80010a4 <chTMStopMeasurementX+0x44>)
 8001064:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = now - tmp->last - offset;
 8001066:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8001068:	b4f0      	push	{r4, r5, r6, r7}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 800106a:	6f4f      	ldr	r7, [r1, #116]	; 0x74

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800106c:	68c6      	ldr	r6, [r0, #12]
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 800106e:	6841      	ldr	r1, [r0, #4]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8001070:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = now - tmp->last - offset;
 8001074:	1ad3      	subs	r3, r2, r3
 8001076:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
 8001078:	18e4      	adds	r4, r4, r3
 800107a:	f145 0500 	adc.w	r5, r5, #0

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800107e:	3601      	adds	r6, #1
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 8001080:	428b      	cmp	r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8001082:	60c6      	str	r6, [r0, #12]
  tmp->last = now - tmp->last - offset;
 8001084:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8001086:	e9c0 4504 	strd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
 800108a:	d805      	bhi.n	8001098 <chTMStopMeasurementX+0x38>
    tmp->worst = tmp->last;
  }
  else if (tmp->last < tmp->best) {
 800108c:	6802      	ldr	r2, [r0, #0]
 800108e:	4293      	cmp	r3, r2
    tmp->best = tmp->last;
 8001090:	bf38      	it	cc
 8001092:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8001094:	bcf0      	pop	{r4, r5, r6, r7}
 8001096:	4770      	bx	lr

  tmp->n++;
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 8001098:	6043      	str	r3, [r0, #4]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 800109a:	bcf0      	pop	{r4, r5, r6, r7}
 800109c:	4770      	bx	lr
 800109e:	bf00      	nop
 80010a0:	e0001000 	.word	0xe0001000
 80010a4:	20001150 	.word	0x20001150
 80010a8:	f3af 8000 	nop.w
 80010ac:	f3af 8000 	nop.w

080010b0 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 80010b0:	b5d0      	push	{r4, r6, r7, lr}
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
 80010b2:	4c0c      	ldr	r4, [pc, #48]	; (80010e4 <_tm_init+0x34>)
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 80010b4:	b086      	sub	sp, #24
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
 80010b6:	2300      	movs	r3, #0
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 80010b8:	f04f 32ff 	mov.w	r2, #4294967295
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 80010bc:	4668      	mov	r0, sp

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 80010be:	2600      	movs	r6, #0
 80010c0:	2700      	movs	r7, #0
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
 80010c2:	6763      	str	r3, [r4, #116]	; 0x74
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 80010c4:	9301      	str	r3, [sp, #4]
  tmp->last       = (rtcnt_t)0;
 80010c6:	9302      	str	r3, [sp, #8]
  tmp->n          = (ucnt_t)0;
 80010c8:	9303      	str	r3, [sp, #12]
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 80010ca:	9200      	str	r2, [sp, #0]
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 80010cc:	e9cd 6704 	strd	r6, r7, [sp, #16]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 80010d0:	f7ff ffbe 	bl	8001050 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 80010d4:	4668      	mov	r0, sp
 80010d6:	f7ff ffc3 	bl	8001060 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 80010da:	9b02      	ldr	r3, [sp, #8]
 80010dc:	6763      	str	r3, [r4, #116]	; 0x74
}
 80010de:	b006      	add	sp, #24
 80010e0:	bdd0      	pop	{r4, r6, r7, pc}
 80010e2:	bf00      	nop
 80010e4:	20001150 	.word	0x20001150
 80010e8:	f3af 8000 	nop.w
 80010ec:	f3af 8000 	nop.w

080010f0 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 80010f0:	b410      	push	{r4}
 80010f2:	2320      	movs	r3, #32
 80010f4:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 80010f8:	7f03      	ldrb	r3, [r0, #28]
 80010fa:	2b07      	cmp	r3, #7
 80010fc:	d80e      	bhi.n	800111c <wakeup+0x2c>
 80010fe:	e8df f003 	tbb	[pc, r3]
 8001102:	0d27      	.short	0x0d27
 8001104:	0408230d 	.word	0x0408230d
 8001108:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *(thread_reference_t *)tp->p_u.wtobjp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES
  case CH_STATE_WTSEM:
    chSemFastSignalI((semaphore_t *)tp->p_u.wtobjp);
 800110a:	6a02      	ldr	r2, [r0, #32]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 800110c:	6893      	ldr	r3, [r2, #8]
 800110e:	3301      	adds	r3, #1
 8001110:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8001112:	e890 000c 	ldmia.w	r0, {r2, r3}
 8001116:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001118:	6802      	ldr	r2, [r0, #0]
 800111a:	6053      	str	r3, [r2, #4]
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    queue_dequeue(tp);
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 800111c:	f04f 34ff 	mov.w	r4, #4294967295
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001120:	2200      	movs	r2, #0
 8001122:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001124:	4b0d      	ldr	r3, [pc, #52]	; (800115c <wakeup+0x6c>)
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    queue_dequeue(tp);
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8001126:	6204      	str	r4, [r0, #32]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001128:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800112a:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800112c:	689a      	ldr	r2, [r3, #8]
 800112e:	428a      	cmp	r2, r1
 8001130:	d2fb      	bcs.n	800112a <wakeup+0x3a>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001132:	685a      	ldr	r2, [r3, #4]
 8001134:	6042      	str	r2, [r0, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001136:	6003      	str	r3, [r0, #0]
 8001138:	2100      	movs	r1, #0
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 800113a:	6058      	str	r0, [r3, #4]
 800113c:	6010      	str	r0, [r2, #0]
 800113e:	f381 8811 	msr	BASEPRI, r1
    queue_dequeue(tp);
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8001142:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001146:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *(thread_reference_t *)tp->p_u.wtobjp = NULL;
 8001148:	6a03      	ldr	r3, [r0, #32]
 800114a:	2200      	movs	r2, #0
 800114c:	601a      	str	r2, [r3, #0]
    break;
 800114e:	e7e5      	b.n	800111c <wakeup+0x2c>
 8001150:	2300      	movs	r3, #0
 8001152:	f383 8811 	msr	BASEPRI, r3
    queue_dequeue(tp);
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8001156:	f85d 4b04 	ldr.w	r4, [sp], #4
 800115a:	4770      	bx	lr
 800115c:	20001150 	.word	0x20001150

08001160 <_scheduler_init>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8001160:	4b03      	ldr	r3, [pc, #12]	; (8001170 <_scheduler_init+0x10>)
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 8001162:	2200      	movs	r2, #0
 8001164:	605b      	str	r3, [r3, #4]
 8001166:	601b      	str	r3, [r3, #0]
#if CH_CFG_USE_REGISTRY
  ch.rlist.r_newer = ch.rlist.r_older = (thread_t *)&ch.rlist;
 8001168:	615b      	str	r3, [r3, #20]
 800116a:	611b      	str	r3, [r3, #16]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 800116c:	609a      	str	r2, [r3, #8]
 800116e:	4770      	bx	lr
 8001170:	20001150 	.word	0x20001150
 8001174:	f3af 8000 	nop.w
 8001178:	f3af 8000 	nop.w
 800117c:	f3af 8000 	nop.w

08001180 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001180:	2200      	movs	r2, #0
 8001182:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001184:	4b08      	ldr	r3, [pc, #32]	; (80011a8 <chSchReadyI+0x28>)
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8001186:	b410      	push	{r4}
 8001188:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800118a:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800118c:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800118e:	689a      	ldr	r2, [r3, #8]
 8001190:	428a      	cmp	r2, r1
 8001192:	d2fb      	bcs.n	800118c <chSchReadyI+0xc>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001194:	685a      	ldr	r2, [r3, #4]
 8001196:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001198:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;

  return tp;
}
 800119a:	4620      	mov	r0, r4
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 800119c:	605c      	str	r4, [r3, #4]
 800119e:	6014      	str	r4, [r2, #0]

  return tp;
}
 80011a0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80011a4:	4770      	bx	lr
 80011a6:	bf00      	nop
 80011a8:	20001150 	.word	0x20001150
 80011ac:	f3af 8000 	nop.w

080011b0 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 80011b0:	4b07      	ldr	r3, [pc, #28]	; (80011d0 <chSchGoSleepS+0x20>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 80011b2:	b430      	push	{r4, r5}
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80011b4:	681a      	ldr	r2, [r3, #0]
  thread_t *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 80011b6:	6999      	ldr	r1, [r3, #24]

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 80011b8:	6814      	ldr	r4, [r2, #0]
 80011ba:	7708      	strb	r0, [r1, #28]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80011bc:	2501      	movs	r5, #1
 80011be:	6063      	str	r3, [r4, #4]
 80011c0:	7715      	strb	r5, [r2, #28]
 80011c2:	601c      	str	r4, [r3, #0]
  chSysSwitch(currp, otp);
 80011c4:	4610      	mov	r0, r2
}
 80011c6:	bc30      	pop	{r4, r5}
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80011c8:	619a      	str	r2, [r3, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 80011ca:	f7ff b889 	b.w	80002e0 <_port_switch>
 80011ce:	bf00      	nop
 80011d0:	20001150 	.word	0x20001150
 80011d4:	f3af 8000 	nop.w
 80011d8:	f3af 8000 	nop.w
 80011dc:	f3af 8000 	nop.w

080011e0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80011e0:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80011e2:	1c4b      	adds	r3, r1, #1
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80011e4:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80011e6:	d012      	beq.n	800120e <chSchGoSleepTimeoutS+0x2e>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 80011e8:	4c0c      	ldr	r4, [pc, #48]	; (800121c <chSchGoSleepTimeoutS+0x3c>)
 80011ea:	4a0d      	ldr	r2, [pc, #52]	; (8001220 <chSchGoSleepTimeoutS+0x40>)
 80011ec:	69a3      	ldr	r3, [r4, #24]
 80011ee:	4605      	mov	r5, r0
 80011f0:	a801      	add	r0, sp, #4
 80011f2:	f000 f8c5 	bl	8001380 <chVTDoSetI>
    chSchGoSleepS(newstate);
 80011f6:	4628      	mov	r0, r5
 80011f8:	f7ff ffda 	bl	80011b0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt))
 80011fc:	9b04      	ldr	r3, [sp, #16]
 80011fe:	b113      	cbz	r3, 8001206 <chSchGoSleepTimeoutS+0x26>
      chVTDoResetI(&vt);
 8001200:	a801      	add	r0, sp, #4
 8001202:	f000 f8f5 	bl	80013f0 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 8001206:	69a3      	ldr	r3, [r4, #24]
}
 8001208:	6a18      	ldr	r0, [r3, #32]
 800120a:	b007      	add	sp, #28
 800120c:	bd30      	pop	{r4, r5, pc}
 800120e:	4c03      	ldr	r4, [pc, #12]	; (800121c <chSchGoSleepTimeoutS+0x3c>)
    chSchGoSleepS(newstate);
    if (chVTIsArmedI(&vt))
      chVTDoResetI(&vt);
  }
  else {
    chSchGoSleepS(newstate);
 8001210:	f7ff ffce 	bl	80011b0 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8001214:	69a3      	ldr	r3, [r4, #24]
}
 8001216:	6a18      	ldr	r0, [r3, #32]
 8001218:	b007      	add	sp, #28
 800121a:	bd30      	pop	{r4, r5, pc}
 800121c:	20001150 	.word	0x20001150
 8001220:	080010f1 	.word	0x080010f1
 8001224:	f3af 8000 	nop.w
 8001228:	f3af 8000 	nop.w
 800122c:	f3af 8000 	nop.w

08001230 <chSchWakeupS>:

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8001230:	4b14      	ldr	r3, [pc, #80]	; (8001284 <chSchWakeupS+0x54>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8001232:	b4f0      	push	{r4, r5, r6, r7}

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8001234:	699e      	ldr	r6, [r3, #24]
 8001236:	6884      	ldr	r4, [r0, #8]
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8001238:	4605      	mov	r5, r0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800123a:	68b0      	ldr	r0, [r6, #8]

  chDbgCheckClassS();

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 800123c:	6229      	str	r1, [r5, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800123e:	4284      	cmp	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001240:	f04f 0200 	mov.w	r2, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8001244:	d80b      	bhi.n	800125e <chSchWakeupS+0x2e>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001246:	772a      	strb	r2, [r5, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 8001248:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800124a:	689a      	ldr	r2, [r3, #8]
 800124c:	4294      	cmp	r4, r2
 800124e:	d9fb      	bls.n	8001248 <chSchWakeupS+0x18>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001250:	685a      	ldr	r2, [r3, #4]
 8001252:	606a      	str	r2, [r5, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001254:	602b      	str	r3, [r5, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 8001256:	605d      	str	r5, [r3, #4]
 8001258:	6015      	str	r5, [r2, #0]
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 800125a:	bcf0      	pop	{r4, r5, r6, r7}
 800125c:	4770      	bx	lr
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800125e:	7732      	strb	r2, [r6, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001260:	461a      	mov	r2, r3
  do {
    cp = cp->p_next;
 8001262:	6812      	ldr	r2, [r2, #0]
  } while (cp->p_prio >= tp->p_prio);
 8001264:	6891      	ldr	r1, [r2, #8]
 8001266:	4288      	cmp	r0, r1
 8001268:	d9fb      	bls.n	8001262 <chSchWakeupS+0x32>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800126a:	6854      	ldr	r4, [r2, #4]
 800126c:	6074      	str	r4, [r6, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 800126e:	2701      	movs	r7, #1
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001270:	6032      	str	r2, [r6, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 8001272:	6056      	str	r6, [r2, #4]
 8001274:	6026      	str	r6, [r4, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8001276:	772f      	strb	r7, [r5, #28]
    chSysSwitch(ntp, otp);
 8001278:	4631      	mov	r1, r6
 800127a:	4628      	mov	r0, r5
  if (ntp->p_prio <= currp->p_prio) {
    chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 800127c:	619d      	str	r5, [r3, #24]
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 800127e:	bcf0      	pop	{r4, r5, r6, r7}
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8001280:	f7ff b82e 	b.w	80002e0 <_port_switch>
 8001284:	20001150 	.word	0x20001150
 8001288:	f3af 8000 	nop.w
 800128c:	f3af 8000 	nop.w

08001290 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8001290:	4b04      	ldr	r3, [pc, #16]	; (80012a4 <chSchIsPreemptionRequired+0x14>)
 8001292:	681a      	ldr	r2, [r3, #0]
  tprio_t p2 = currp->p_prio;
 8001294:	699b      	ldr	r3, [r3, #24]
     if the first thread on the ready queue has equal or higher priority.*/
  return currp->p_preempt ? p1 > p2 : p1 >= p2;
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8001296:	6890      	ldr	r0, [r2, #8]
 8001298:	689b      	ldr	r3, [r3, #8]
#endif
}
 800129a:	4298      	cmp	r0, r3
 800129c:	bf94      	ite	ls
 800129e:	2000      	movls	r0, #0
 80012a0:	2001      	movhi	r0, #1
 80012a2:	4770      	bx	lr
 80012a4:	20001150 	.word	0x20001150
 80012a8:	f3af 8000 	nop.w
 80012ac:	f3af 8000 	nop.w

080012b0 <chSchDoRescheduleBehind>:
 * @special
 */
void chSchDoRescheduleBehind(void) {
  thread_t *otp;

  otp = currp;
 80012b0:	4a0d      	ldr	r2, [pc, #52]	; (80012e8 <chSchDoRescheduleBehind+0x38>)
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80012b2:	6810      	ldr	r0, [r2, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleBehind(void) {
 80012b4:	b470      	push	{r4, r5, r6}

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 80012b6:	6803      	ldr	r3, [r0, #0]
  thread_t *otp;

  otp = currp;
 80012b8:	6994      	ldr	r4, [r2, #24]
 80012ba:	6013      	str	r3, [r2, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80012bc:	2601      	movs	r6, #1
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80012be:	2500      	movs	r5, #0
 80012c0:	68a1      	ldr	r1, [r4, #8]
 80012c2:	605a      	str	r2, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80012c4:	7706      	strb	r6, [r0, #28]
void chSchDoRescheduleBehind(void) {
  thread_t *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80012c6:	6190      	str	r0, [r2, #24]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80012c8:	7725      	strb	r5, [r4, #28]
 80012ca:	e000      	b.n	80012ce <chSchDoRescheduleBehind+0x1e>
 80012cc:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
 80012ce:	689a      	ldr	r2, [r3, #8]
 80012d0:	428a      	cmp	r2, r1
 80012d2:	d2fb      	bcs.n	80012cc <chSchDoRescheduleBehind+0x1c>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80012d4:	685a      	ldr	r2, [r3, #4]
 80012d6:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80012d8:	6023      	str	r3, [r4, #0]
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
  chSysSwitch(currp, otp);
 80012da:	4621      	mov	r1, r4
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 80012dc:	605c      	str	r4, [r3, #4]
 80012de:	6014      	str	r4, [r2, #0]
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
  chSysSwitch(currp, otp);
}
 80012e0:	bc70      	pop	{r4, r5, r6}
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
  chSysSwitch(currp, otp);
 80012e2:	f7fe bffd 	b.w	80002e0 <_port_switch>
 80012e6:	bf00      	nop
 80012e8:	20001150 	.word	0x20001150
 80012ec:	f3af 8000 	nop.w

080012f0 <chSchDoRescheduleAhead>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 80012f0:	4a0d      	ldr	r2, [pc, #52]	; (8001328 <chSchDoRescheduleAhead+0x38>)
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80012f2:	6810      	ldr	r0, [r2, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80012f4:	b470      	push	{r4, r5, r6}

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 80012f6:	6803      	ldr	r3, [r0, #0]
  thread_t *otp, *cp;

  otp = currp;
 80012f8:	6994      	ldr	r4, [r2, #24]
 80012fa:	6013      	str	r3, [r2, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80012fc:	2601      	movs	r6, #1

  otp->p_state = CH_STATE_READY;
 80012fe:	2500      	movs	r5, #0
 8001300:	68a1      	ldr	r1, [r4, #8]
 8001302:	605a      	str	r2, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8001304:	7706      	strb	r6, [r0, #28]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8001306:	6190      	str	r0, [r2, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 8001308:	7725      	strb	r5, [r4, #28]
 800130a:	e000      	b.n	800130e <chSchDoRescheduleAhead+0x1e>
 800130c:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 800130e:	689a      	ldr	r2, [r3, #8]
 8001310:	428a      	cmp	r2, r1
 8001312:	d8fb      	bhi.n	800130c <chSchDoRescheduleAhead+0x1c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8001314:	685a      	ldr	r2, [r3, #4]
 8001316:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8001318:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
 800131a:	4621      	mov	r1, r4
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;
 800131c:	605c      	str	r4, [r3, #4]
 800131e:	6014      	str	r4, [r2, #0]

  chSysSwitch(currp, otp);
}
 8001320:	bc70      	pop	{r4, r5, r6}
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
 8001322:	f7fe bfdd 	b.w	80002e0 <_port_switch>
 8001326:	bf00      	nop
 8001328:	20001150 	.word	0x20001150
 800132c:	f3af 8000 	nop.w

08001330 <chSchRescheduleS>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 8001330:	4b04      	ldr	r3, [pc, #16]	; (8001344 <chSchRescheduleS+0x14>)
 8001332:	681a      	ldr	r2, [r3, #0]
 8001334:	699b      	ldr	r3, [r3, #24]
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8001336:	6892      	ldr	r2, [r2, #8]
 8001338:	689b      	ldr	r3, [r3, #8]
 800133a:	429a      	cmp	r2, r3
 800133c:	d800      	bhi.n	8001340 <chSchRescheduleS+0x10>
 800133e:	4770      	bx	lr
    chSchDoRescheduleAhead();
 8001340:	f7ff bfd6 	b.w	80012f0 <chSchDoRescheduleAhead>
 8001344:	20001150 	.word	0x20001150
 8001348:	f3af 8000 	nop.w
 800134c:	f3af 8000 	nop.w

08001350 <chSchDoReschedule>:
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8001350:	f7ff bfce 	b.w	80012f0 <chSchDoRescheduleAhead>
 8001354:	f3af 8000 	nop.w
 8001358:	f3af 8000 	nop.w
 800135c:	f3af 8000 	nop.w

08001360 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
 8001360:	4b05      	ldr	r3, [pc, #20]	; (8001378 <_vt_init+0x18>)
  ch.vtlist.vt_delta = (systime_t)-1;
 8001362:	f04f 30ff 	mov.w	r0, #4294967295
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
 8001366:	f103 021c 	add.w	r2, r3, #28
  ch.vtlist.vt_delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = 0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = 0;
 800136a:	2100      	movs	r1, #0
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 800136c:	6258      	str	r0, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = 0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = 0;
 800136e:	6299      	str	r1, [r3, #40]	; 0x28
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
 8001370:	621a      	str	r2, [r3, #32]
 8001372:	61da      	str	r2, [r3, #28]
 8001374:	4770      	bx	lr
 8001376:	bf00      	nop
 8001378:	20001150 	.word	0x20001150
 800137c:	f3af 8000 	nop.w

08001380 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8001380:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = ch.vtlist.vt_next;
 8001382:	4f1a      	ldr	r7, [pc, #104]	; (80013ec <chVTDoSetI+0x6c>)
 8001384:	46be      	mov	lr, r7
    systime_t now = port_timer_get_time();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < CH_CFG_ST_TIMEDELTA) {
      delay = CH_CFG_ST_TIMEDELTA;
 8001386:	2901      	cmp	r1, #1
 8001388:	bf8c      	ite	hi
 800138a:	460d      	movhi	r5, r1
 800138c:	2502      	movls	r5, #2
  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = ch.vtlist.vt_next;
 800138e:	f85e 4f1c 	ldr.w	r4, [lr, #28]!
  virtual_timer_t *p;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8001392:	6103      	str	r3, [r0, #16]
 8001394:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
       is raised to the minimum safe value.*/
    if (delay < CH_CFG_ST_TIMEDELTA) {
      delay = CH_CFG_ST_TIMEDELTA;
    }

    if (&ch.vtlist == (virtual_timers_list_t *)p) {
 8001398:	4574      	cmp	r4, lr

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 800139a:	60c2      	str	r2, [r0, #12]
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 800139c:	4606      	mov	r6, r0
 800139e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
       is raised to the minimum safe value.*/
    if (delay < CH_CFG_ST_TIMEDELTA) {
      delay = CH_CFG_ST_TIMEDELTA;
    }

    if (&ch.vtlist == (virtual_timers_list_t *)p) {
 80013a0:	d01d      	beq.n	80013de <chVTDoSetI+0x5e>
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
    }
    else {
      /* Now the delay is calculated as delta from the last tick interrupt
         time.*/
      delay += now - ch.vtlist.vt_lasttime;
 80013a2:	6ab8      	ldr	r0, [r7, #40]	; 0x28

      /* If the specified delay is closer in time than the first element
         in the delta list then it becomes the next alarm event in time.*/
      if (delay < p->vt_delta) {
 80013a4:	68a3      	ldr	r3, [r4, #8]
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
    }
    else {
      /* Now the delay is calculated as delta from the last tick interrupt
         time.*/
      delay += now - ch.vtlist.vt_lasttime;
 80013a6:	1a12      	subs	r2, r2, r0
 80013a8:	4415      	add	r5, r2

      /* If the specified delay is closer in time than the first element
         in the delta list then it becomes the next alarm event in time.*/
      if (delay < p->vt_delta) {
 80013aa:	429d      	cmp	r5, r3
 80013ac:	d203      	bcs.n	80013b6 <chVTDoSetI+0x36>
 80013ae:	e011      	b.n	80013d4 <chVTDoSetI+0x54>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delay) {
    delay -= p->vt_delta;
    p = p->vt_next;
 80013b0:	6824      	ldr	r4, [r4, #0]
#endif /* CH_CFG_ST_TIMEDELTA > 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delay) {
    delay -= p->vt_delta;
 80013b2:	1aed      	subs	r5, r5, r3
  }
#endif /* CH_CFG_ST_TIMEDELTA > 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delay) {
 80013b4:	68a3      	ldr	r3, [r4, #8]
 80013b6:	42ab      	cmp	r3, r5
 80013b8:	d3fa      	bcc.n	80013b0 <chVTDoSetI+0x30>
    delay -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
 80013ba:	6863      	ldr	r3, [r4, #4]
 80013bc:	6073      	str	r3, [r6, #4]
 80013be:	6034      	str	r4, [r6, #0]
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
 80013c0:	6066      	str	r6, [r4, #4]
 80013c2:	601e      	str	r6, [r3, #0]
  vtp->vt_delta = delay
 80013c4:	60b5      	str	r5, [r6, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delay;
 80013c6:	68a1      	ldr	r1, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 80013c8:	f04f 33ff 	mov.w	r3, #4294967295
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
  vtp->vt_delta = delay

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delay;
 80013cc:	1b49      	subs	r1, r1, r5
 80013ce:	60a1      	str	r1, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 80013d0:	627b      	str	r3, [r7, #36]	; 0x24
 80013d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 80013d4:	4428      	add	r0, r5
 80013d6:	f005 f8f3 	bl	80065c0 <stSetAlarm>
 80013da:	68a3      	ldr	r3, [r4, #8]
 80013dc:	e7eb      	b.n	80013b6 <chVTDoSetI+0x36>
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {

  stStartAlarm(time);
 80013de:	18a8      	adds	r0, r5, r2
    }

    if (&ch.vtlist == (virtual_timers_list_t *)p) {
      /* The delta list is empty, the current time becomes the new
         delta list base time.*/
      ch.vtlist.vt_lasttime = now;
 80013e0:	62ba      	str	r2, [r7, #40]	; 0x28
 80013e2:	f005 f8dd 	bl	80065a0 <stStartAlarm>
 80013e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80013e8:	e7e5      	b.n	80013b6 <chVTDoSetI+0x36>
 80013ea:	bf00      	nop
 80013ec:	20001150 	.word	0x20001150

080013f0 <chVTDoResetI>:
  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 80013f0:	6802      	ldr	r2, [r0, #0]
 80013f2:	6883      	ldr	r3, [r0, #8]
 80013f4:	6891      	ldr	r1, [r2, #8]
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 80013f6:	b430      	push	{r4, r5}
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = (vtfunc_t)NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 80013f8:	4c10      	ldr	r4, [pc, #64]	; (800143c <chVTDoResetI+0x4c>)
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
 80013fa:	6845      	ldr	r5, [r0, #4]
  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 80013fc:	4419      	add	r1, r3
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80013fe:	4623      	mov	r3, r4
  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8001400:	6091      	str	r1, [r2, #8]
  vtp->vt_prev->vt_next = vtp->vt_next;
 8001402:	602a      	str	r2, [r5, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
 8001404:	6801      	ldr	r1, [r0, #0]
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8001406:	f853 2f1c 	ldr.w	r2, [r3, #28]!
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
 800140a:	604d      	str	r5, [r1, #4]
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800140c:	429a      	cmp	r2, r3

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = (vtfunc_t)NULL;
 800140e:	f04f 0500 	mov.w	r5, #0

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8001412:	f04f 31ff 	mov.w	r1, #4294967295

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = (vtfunc_t)NULL;
 8001416:	60c5      	str	r5, [r0, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8001418:	6261      	str	r1, [r4, #36]	; 0x24

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800141a:	d00b      	beq.n	8001434 <chVTDoResetI+0x44>
      port_timer_stop_alarm();
    }
    else {
      /* Updating the alarm to the next deadline, deadline that must not be
         closer in time than the minimum time delta.*/
      if (ch.vtlist.vt_next->vt_delta >= CH_CFG_ST_TIMEDELTA) {
 800141c:	6893      	ldr	r3, [r2, #8]
        port_timer_set_alarm(ch.vtlist.vt_lasttime +
 800141e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
      port_timer_stop_alarm();
    }
    else {
      /* Updating the alarm to the next deadline, deadline that must not be
         closer in time than the minimum time delta.*/
      if (ch.vtlist.vt_next->vt_delta >= CH_CFG_ST_TIMEDELTA) {
 8001420:	2b01      	cmp	r3, #1
 8001422:	d903      	bls.n	800142c <chVTDoResetI+0x3c>
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8001424:	4418      	add	r0, r3
                             CH_CFG_ST_TIMEDELTA);
      }
    }
  }
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001426:	bc30      	pop	{r4, r5}
 8001428:	f005 b8ca 	b.w	80065c0 <stSetAlarm>
 800142c:	3002      	adds	r0, #2
 800142e:	bc30      	pop	{r4, r5}
 8001430:	f005 b8c6 	b.w	80065c0 <stSetAlarm>
 8001434:	bc30      	pop	{r4, r5}
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 8001436:	f005 b8bb 	b.w	80065b0 <stStopAlarm>
 800143a:	bf00      	nop
 800143c:	20001150 	.word	0x20001150

08001440 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8001440:	b5f0      	push	{r4, r5, r6, r7, lr}
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001442:	4c0e      	ldr	r4, [pc, #56]	; (800147c <_thread_init+0x3c>)
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
 8001444:	63c1      	str	r1, [r0, #60]	; 0x3c
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001446:	6966      	ldr	r6, [r4, #20]
 8001448:	6146      	str	r6, [r0, #20]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800144a:	2200      	movs	r2, #0
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
 800144c:	f100 0528 	add.w	r5, r0, #40	; 0x28
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8001450:	f04f 0c02 	mov.w	ip, #2
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 8001454:	f04f 0e01 	mov.w	lr, #1
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
 8001458:	f100 0724 	add.w	r7, r0, #36	; 0x24
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 800145c:	6081      	str	r1, [r0, #8]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 800145e:	6104      	str	r4, [r0, #16]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8001460:	f880 c01c 	strb.w	ip, [r0, #28]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001464:	6160      	str	r0, [r4, #20]
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 8001466:	f880 e01e 	strb.w	lr, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800146a:	7742      	strb	r2, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 800146c:	6382      	str	r2, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS
  tp->p_epending = 0;
 800146e:	6342      	str	r2, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
 8001470:	6182      	str	r2, [r0, #24]
  REG_INSERT(tp);
 8001472:	6130      	str	r0, [r6, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8001474:	6247      	str	r7, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8001476:	62c5      	str	r5, [r0, #44]	; 0x2c
 8001478:	6285      	str	r5, [r0, #40]	; 0x28
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
}
 800147a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800147c:	20001150 	.word	0x20001150

08001480 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 8001480:	e92d 4ef0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001484:	3964      	subs	r1, #100	; 0x64
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001486:	4f16      	ldr	r7, [pc, #88]	; (80014e0 <chThdCreateI+0x60>)

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001488:	f8df 9058 	ldr.w	r9, [pc, #88]	; 80014e4 <chThdCreateI+0x64>
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 800148c:	f8d7 e014 	ldr.w	lr, [r7, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001490:	4401      	add	r1, r0
 8001492:	60c1      	str	r1, [r0, #12]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001494:	2500      	movs	r5, #0

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001496:	640b      	str	r3, [r1, #64]	; 0x40
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 8001498:	4694      	mov	ip, r2
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800149a:	f04f 0b02 	mov.w	fp, #2
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
 800149e:	f100 0228 	add.w	r2, r0, #40	; 0x28
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 80014a2:	f04f 0a01 	mov.w	sl, #1
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
 80014a6:	f100 0624 	add.w	r6, r0, #36	; 0x24

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80014aa:	9b08      	ldr	r3, [sp, #32]
 80014ac:	644b      	str	r3, [r1, #68]	; 0x44
 80014ae:	f8c1 9060 	str.w	r9, [r1, #96]	; 0x60
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80014b2:	f8c0 c008 	str.w	ip, [r0, #8]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 80014b6:	6107      	str	r7, [r0, #16]
 80014b8:	f8c0 e014 	str.w	lr, [r0, #20]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
 80014bc:	f8c0 c03c 	str.w	ip, [r0, #60]	; 0x3c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80014c0:	f880 b01c 	strb.w	fp, [r0, #28]
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 80014c4:	f880 a01e 	strb.w	sl, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80014c8:	7745      	strb	r5, [r0, #29]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 80014ca:	6178      	str	r0, [r7, #20]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 80014cc:	6385      	str	r5, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS
  tp->p_epending = 0;
 80014ce:	6345      	str	r5, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
 80014d0:	6185      	str	r5, [r0, #24]
  REG_INSERT(tp);
 80014d2:	f8ce 0010 	str.w	r0, [lr, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 80014d6:	6246      	str	r6, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 80014d8:	62c2      	str	r2, [r0, #44]	; 0x2c
 80014da:	6282      	str	r2, [r0, #40]	; 0x28
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);

  return _thread_init(tp, prio);
}
 80014dc:	e8bd 8ef0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, fp, pc}
 80014e0:	20001150 	.word	0x20001150
 80014e4:	080002f9 	.word	0x080002f9
 80014e8:	f3af 8000 	nop.w
 80014ec:	f3af 8000 	nop.w

080014f0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 80014f0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80014f4:	469a      	mov	sl, r3
 80014f6:	4604      	mov	r4, r0
 80014f8:	2320      	movs	r3, #32
 80014fa:	f383 8811 	msr	BASEPRI, r3
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 80014fe:	4e19      	ldr	r6, [pc, #100]	; (8001564 <chThdCreateStatic+0x74>)

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001500:	9b0a      	ldr	r3, [sp, #40]	; 0x28
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001502:	f8d6 b014 	ldr.w	fp, [r6, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001506:	f8df 9060 	ldr.w	r9, [pc, #96]	; 8001568 <chThdCreateStatic+0x78>
 800150a:	3964      	subs	r1, #100	; 0x64
 800150c:	4401      	add	r1, r0
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800150e:	2500      	movs	r5, #0
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
 8001510:	f100 0728 	add.w	r7, r0, #40	; 0x28
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 8001514:	f04f 0c01 	mov.w	ip, #1
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
 8001518:	f100 0e24 	add.w	lr, r0, #36	; 0x24
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800151c:	f04f 0802 	mov.w	r8, #2

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001520:	60c1      	str	r1, [r0, #12]
 8001522:	f8c1 a040 	str.w	sl, [r1, #64]	; 0x40
 8001526:	644b      	str	r3, [r1, #68]	; 0x44
 8001528:	f8c1 9060 	str.w	r9, [r1, #96]	; 0x60
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 800152c:	6082      	str	r2, [r0, #8]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 800152e:	6106      	str	r6, [r0, #16]
 8001530:	f8c0 b014 	str.w	fp, [r0, #20]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
 8001534:	63c2      	str	r2, [r0, #60]	; 0x3c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8001536:	f880 801c 	strb.w	r8, [r0, #28]
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 800153a:	f880 c01e 	strb.w	ip, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800153e:	7745      	strb	r5, [r0, #29]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001540:	6170      	str	r0, [r6, #20]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8001542:	6385      	str	r5, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS
  tp->p_epending = 0;
 8001544:	6345      	str	r5, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
 8001546:	6185      	str	r5, [r0, #24]
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), MSG_OK);
 8001548:	4629      	mov	r1, r5
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 800154a:	f8cb 0010 	str.w	r0, [fp, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 800154e:	f8c0 e024 	str.w	lr, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8001552:	62c7      	str	r7, [r0, #44]	; 0x2c
 8001554:	6287      	str	r7, [r0, #40]	; 0x28
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), MSG_OK);
 8001556:	f7ff fe6b 	bl	8001230 <chSchWakeupS>
 800155a:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
 800155e:	4620      	mov	r0, r4
 8001560:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001564:	20001150 	.word	0x20001150
 8001568:	080002f9 	.word	0x080002f9
 800156c:	f3af 8000 	nop.w

08001570 <chThdStart>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdStart(thread_t *tp) {
 8001570:	b508      	push	{r3, lr}
 8001572:	2320      	movs	r3, #32
 8001574:	f383 8811 	msr	BASEPRI, r3
 */
static inline thread_t *chThdStartI(thread_t *tp) {

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");

  return chSchReadyI(tp);
 8001578:	f7ff fe02 	bl	8001180 <chSchReadyI>
 800157c:	2300      	movs	r3, #0
 800157e:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  tp = chThdStartI(tp);
  chSysUnlock();

  return tp;
}
 8001582:	bd08      	pop	{r3, pc}
 8001584:	f3af 8000 	nop.w
 8001588:	f3af 8000 	nop.w
 800158c:	f3af 8000 	nop.w

08001590 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8001590:	b510      	push	{r4, lr}
 8001592:	2320      	movs	r3, #32
 8001594:	f383 8811 	msr	BASEPRI, r3

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
#if CH_CFG_USE_MUTEXES
  oldprio = currp->p_realprio;
 8001598:	4b08      	ldr	r3, [pc, #32]	; (80015bc <chThdSetPriority+0x2c>)
 800159a:	699b      	ldr	r3, [r3, #24]
 800159c:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
 800159e:	6899      	ldr	r1, [r3, #8]
 80015a0:	428c      	cmp	r4, r1
 80015a2:	d001      	beq.n	80015a8 <chThdSetPriority+0x18>
 80015a4:	4281      	cmp	r1, r0
 80015a6:	d200      	bcs.n	80015aa <chThdSetPriority+0x1a>
    currp->p_prio = newprio;
 80015a8:	6098      	str	r0, [r3, #8]
  }
  currp->p_realprio = newprio;
 80015aa:	63d8      	str	r0, [r3, #60]	; 0x3c
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
 80015ac:	f7ff fec0 	bl	8001330 <chSchRescheduleS>
 80015b0:	2300      	movs	r3, #0
 80015b2:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return oldprio;
}
 80015b6:	4620      	mov	r0, r4
 80015b8:	bd10      	pop	{r4, pc}
 80015ba:	bf00      	nop
 80015bc:	20001150 	.word	0x20001150

080015c0 <chThdTerminate>:
 80015c0:	2320      	movs	r3, #32
 80015c2:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chThdTerminate(thread_t *tp) {

  chSysLock();
  tp->p_flags |= CH_FLAG_TERMINATE;
 80015c6:	7f43      	ldrb	r3, [r0, #29]
 80015c8:	f043 0304 	orr.w	r3, r3, #4
 80015cc:	7743      	strb	r3, [r0, #29]
 80015ce:	2300      	movs	r3, #0
 80015d0:	f383 8811 	msr	BASEPRI, r3
 80015d4:	4770      	bx	lr
 80015d6:	bf00      	nop
 80015d8:	f3af 8000 	nop.w
 80015dc:	f3af 8000 	nop.w

080015e0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80015e0:	b508      	push	{r3, lr}
 80015e2:	4601      	mov	r1, r0
 80015e4:	2320      	movs	r3, #32
 80015e6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80015ea:	2008      	movs	r0, #8
 80015ec:	f7ff fdf8 	bl	80011e0 <chSchGoSleepTimeoutS>
 80015f0:	2300      	movs	r3, #0
 80015f2:	f383 8811 	msr	BASEPRI, r3
 80015f6:	bd08      	pop	{r3, pc}
 80015f8:	f3af 8000 	nop.w
 80015fc:	f3af 8000 	nop.w

08001600 <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
 8001600:	b508      	push	{r3, lr}
 8001602:	2320      	movs	r3, #32
 8001604:	f383 8811 	msr	BASEPRI, r3
 8001608:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800160c:	6a59      	ldr	r1, [r3, #36]	; 0x24

  chSysLock();
  if ((time -= chVTGetSystemTimeX()) > 0) {
 800160e:	1a41      	subs	r1, r0, r1
 8001610:	d002      	beq.n	8001618 <chThdSleepUntil+0x18>
 8001612:	2008      	movs	r0, #8
 8001614:	f7ff fde4 	bl	80011e0 <chSchGoSleepTimeoutS>
 8001618:	2300      	movs	r3, #0
 800161a:	f383 8811 	msr	BASEPRI, r3
 800161e:	bd08      	pop	{r3, pc}

08001620 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 8001620:	b508      	push	{r3, lr}
 8001622:	2320      	movs	r3, #32
 8001624:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.r_queue) >= currp->p_prio;
 8001628:	4b06      	ldr	r3, [pc, #24]	; (8001644 <chThdYield+0x24>)
 800162a:	681a      	ldr	r2, [r3, #0]
 800162c:	699b      	ldr	r3, [r3, #24]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 800162e:	6892      	ldr	r2, [r2, #8]
 8001630:	689b      	ldr	r3, [r3, #8]
 8001632:	429a      	cmp	r2, r3
 8001634:	d301      	bcc.n	800163a <chThdYield+0x1a>
    chSchDoRescheduleBehind();
 8001636:	f7ff fe3b 	bl	80012b0 <chSchDoRescheduleBehind>
 800163a:	2300      	movs	r3, #0
 800163c:	f383 8811 	msr	BASEPRI, r3
 8001640:	bd08      	pop	{r3, pc}
 8001642:	bf00      	nop
 8001644:	20001150 	.word	0x20001150
 8001648:	f3af 8000 	nop.w
 800164c:	f3af 8000 	nop.w

08001650 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8001650:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
 8001652:	4b0e      	ldr	r3, [pc, #56]	; (800168c <chThdExitS+0x3c>)
 8001654:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8001656:	6a63      	ldr	r3, [r4, #36]	; 0x24

  tp->p_u.exitcode = msg;
 8001658:	6220      	str	r0, [r4, #32]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  while (list_notempty(&tp->p_waiting)) {
 800165a:	f104 0524 	add.w	r5, r4, #36	; 0x24
 800165e:	429d      	cmp	r5, r3
 8001660:	d007      	beq.n	8001672 <chThdExitS+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 8001662:	681a      	ldr	r2, [r3, #0]
 8001664:	6262      	str	r2, [r4, #36]	; 0x24
    chSchReadyI(list_remove(&tp->p_waiting));
 8001666:	4618      	mov	r0, r3
 8001668:	f7ff fd8a 	bl	8001180 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 800166c:	6a63      	ldr	r3, [r4, #36]	; 0x24
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  while (list_notempty(&tp->p_waiting)) {
 800166e:	42ab      	cmp	r3, r5
 8001670:	d1f7      	bne.n	8001662 <chThdExitS+0x12>
  }
#endif
#if CH_CFG_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8001672:	7f63      	ldrb	r3, [r4, #29]
 8001674:	079b      	lsls	r3, r3, #30
 8001676:	d104      	bne.n	8001682 <chThdExitS+0x32>
    REG_REMOVE(tp);
 8001678:	6963      	ldr	r3, [r4, #20]
 800167a:	6922      	ldr	r2, [r4, #16]
 800167c:	611a      	str	r2, [r3, #16]
 800167e:	6922      	ldr	r2, [r4, #16]
 8001680:	6153      	str	r3, [r2, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8001682:	200f      	movs	r0, #15

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 8001684:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8001688:	f7ff bd92 	b.w	80011b0 <chSchGoSleepS>
 800168c:	20001150 	.word	0x20001150

08001690 <chThdExit>:
 8001690:	2320      	movs	r3, #32
 8001692:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
 8001696:	f7ff bfdb 	b.w	8001650 <chThdExitS>
 800169a:	bf00      	nop
 800169c:	f3af 8000 	nop.w

080016a0 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 80016a0:	b538      	push	{r3, r4, r5, lr}
 80016a2:	4604      	mov	r4, r0
 80016a4:	2320      	movs	r3, #32
 80016a6:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_DYNAMIC
  chDbgAssert(tp->p_refs > 0, "not referenced");
#endif
  if (tp->p_state != CH_STATE_FINAL) {
 80016aa:	7f03      	ldrb	r3, [r0, #28]
 80016ac:	2b0f      	cmp	r3, #15
 80016ae:	d007      	beq.n	80016c0 <chThdWait+0x20>
    list_insert(currp, &tp->p_waiting);
 80016b0:	4b08      	ldr	r3, [pc, #32]	; (80016d4 <chThdWait+0x34>)
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {

  tp->p_next = tlp->p_next;
 80016b2:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80016b4:	699b      	ldr	r3, [r3, #24]
    chSchGoSleepS(CH_STATE_WTEXIT);
 80016b6:	2009      	movs	r0, #9
 80016b8:	601a      	str	r2, [r3, #0]
  tlp->p_next = tp;
 80016ba:	6263      	str	r3, [r4, #36]	; 0x24
 80016bc:	f7ff fd78 	bl	80011b0 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
 80016c0:	6a25      	ldr	r5, [r4, #32]
 80016c2:	2300      	movs	r3, #0
 80016c4:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

#if CH_CFG_USE_DYNAMIC
  chThdRelease(tp);
 80016c8:	4620      	mov	r0, r4
 80016ca:	f000 f859 	bl	8001780 <chThdRelease>
#endif

  return msg;
}
 80016ce:	4628      	mov	r0, r5
 80016d0:	bd38      	pop	{r3, r4, r5, pc}
 80016d2:	bf00      	nop
 80016d4:	20001150 	.word	0x20001150
 80016d8:	f3af 8000 	nop.w
 80016dc:	f3af 8000 	nop.w

080016e0 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 80016e0:	b169      	cbz	r1, 80016fe <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 80016e2:	4b08      	ldr	r3, [pc, #32]	; (8001704 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 80016e4:	b410      	push	{r4}
 80016e6:	4602      	mov	r2, r0
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 80016e8:	6844      	ldr	r4, [r0, #4]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 80016ea:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80016ec:	2004      	movs	r0, #4
 80016ee:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->p_prev->p_next = tqp->p_prev = tp;
 80016f2:	6053      	str	r3, [r2, #4]
 80016f4:	6023      	str	r3, [r4, #0]
}
 80016f6:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80016fa:	f7ff bd71 	b.w	80011e0 <chSchGoSleepTimeoutS>
}
 80016fe:	f04f 30ff 	mov.w	r0, #4294967295
 8001702:	4770      	bx	lr
 8001704:	20001150 	.word	0x20001150
 8001708:	f3af 8000 	nop.w
 800170c:	f3af 8000 	nop.w

08001710 <chThdDequeueNextI>:
 *
 * @notapi
 */
static inline bool queue_notempty(threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (thread_t *)tqp);
 8001710:	6802      	ldr	r2, [r0, #0]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8001712:	4290      	cmp	r0, r2
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8001714:	4603      	mov	r3, r0

  if (queue_notempty(tqp)) {
 8001716:	d009      	beq.n	800172c <chThdDequeueNextI+0x1c>
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8001718:	b410      	push	{r4}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 800171a:	6814      	ldr	r4, [r2, #0]
 800171c:	6004      	str	r4, [r0, #0]
 800171e:	6063      	str	r3, [r4, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8001720:	6211      	str	r1, [r2, #32]
  chSchReadyI(tp);
 8001722:	4610      	mov	r0, r2

  if (queue_notempty(tqp)) {
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8001724:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001728:	f7ff bd2a 	b.w	8001180 <chSchReadyI>
 800172c:	4770      	bx	lr
 800172e:	bf00      	nop

08001730 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8001730:	b538      	push	{r3, r4, r5, lr}
 *
 * @notapi
 */
static inline bool queue_notempty(threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (thread_t *)tqp);
 8001732:	6803      	ldr	r3, [r0, #0]

  while (queue_notempty(tqp)) {
 8001734:	4298      	cmp	r0, r3
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8001736:	4604      	mov	r4, r0
 8001738:	460d      	mov	r5, r1

  while (queue_notempty(tqp)) {
 800173a:	d009      	beq.n	8001750 <chThdDequeueAllI+0x20>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 800173c:	681a      	ldr	r2, [r3, #0]
 800173e:	6022      	str	r2, [r4, #0]
 8001740:	4618      	mov	r0, r3
 8001742:	6054      	str	r4, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8001744:	621d      	str	r5, [r3, #32]
  chSchReadyI(tp);
 8001746:	f7ff fd1b 	bl	8001180 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (thread_t *)tqp);
 800174a:	6823      	ldr	r3, [r4, #0]
 800174c:	429c      	cmp	r4, r3
 800174e:	d1f5      	bne.n	800173c <chThdDequeueAllI+0xc>
 8001750:	bd38      	pop	{r3, r4, r5, pc}
 8001752:	bf00      	nop
 8001754:	f3af 8000 	nop.w
 8001758:	f3af 8000 	nop.w
 800175c:	f3af 8000 	nop.w

08001760 <chThdAddRef>:
 8001760:	2320      	movs	r3, #32
 8001762:	f383 8811 	msr	BASEPRI, r3
 */
thread_t *chThdAddRef(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->p_refs < 255, "too many references");
  tp->p_refs++;
 8001766:	7f83      	ldrb	r3, [r0, #30]
 8001768:	3301      	adds	r3, #1
 800176a:	7783      	strb	r3, [r0, #30]
 800176c:	2300      	movs	r3, #0
 800176e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  return tp;
}
 8001772:	4770      	bx	lr
 8001774:	f3af 8000 	nop.w
 8001778:	f3af 8000 	nop.w
 800177c:	f3af 8000 	nop.w

08001780 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8001780:	4601      	mov	r1, r0
 8001782:	2320      	movs	r3, #32
 8001784:	f383 8811 	msr	BASEPRI, r3
  trefs_t refs;

  chSysLock();
  chDbgAssert(tp->p_refs > 0, "not referenced");
  refs = --tp->p_refs;
 8001788:	7f83      	ldrb	r3, [r0, #30]
 800178a:	3b01      	subs	r3, #1
 800178c:	b2db      	uxtb	r3, r3
 800178e:	7783      	strb	r3, [r0, #30]
 8001790:	2200      	movs	r2, #0
 8001792:	f382 8811 	msr	BASEPRI, r2
  chSysUnlock();

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == 0) && (tp->p_state == CH_STATE_FINAL)) {
 8001796:	b913      	cbnz	r3, 800179e <chThdRelease+0x1e>
 8001798:	7f03      	ldrb	r3, [r0, #28]
 800179a:	2b0f      	cmp	r3, #15
 800179c:	d000      	beq.n	80017a0 <chThdRelease+0x20>
 800179e:	4770      	bx	lr
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
 80017a0:	7f43      	ldrb	r3, [r0, #29]
 80017a2:	f003 0303 	and.w	r3, r3, #3
 80017a6:	2b01      	cmp	r3, #1
 80017a8:	d002      	beq.n	80017b0 <chThdRelease+0x30>
 80017aa:	2b02      	cmp	r3, #2
 80017ac:	d007      	beq.n	80017be <chThdRelease+0x3e>
 80017ae:	4770      	bx	lr
#if CH_CFG_USE_HEAP
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY
      REG_REMOVE(tp);
 80017b0:	6943      	ldr	r3, [r0, #20]
 80017b2:	6902      	ldr	r2, [r0, #16]
 80017b4:	611a      	str	r2, [r3, #16]
 80017b6:	6902      	ldr	r2, [r0, #16]
 80017b8:	6153      	str	r3, [r2, #20]
#endif
      chHeapFree(tp);
 80017ba:	f001 b881 	b.w	80028c0 <chHeapFree>
      break;
#endif
#if CH_CFG_USE_MEMPOOLS
    case CH_FLAG_MODE_MEMPOOL:
#if CH_CFG_USE_REGISTRY
      REG_REMOVE(tp);
 80017be:	6943      	ldr	r3, [r0, #20]
 80017c0:	6902      	ldr	r2, [r0, #16]
 80017c2:	611a      	str	r2, [r3, #16]
 80017c4:	6902      	ldr	r2, [r0, #16]
#endif
      chPoolFree(tp->p_mpool, tp);
 80017c6:	6c00      	ldr	r0, [r0, #64]	; 0x40
      break;
#endif
#if CH_CFG_USE_MEMPOOLS
    case CH_FLAG_MODE_MEMPOOL:
#if CH_CFG_USE_REGISTRY
      REG_REMOVE(tp);
 80017c8:	6153      	str	r3, [r2, #20]
#endif
      chPoolFree(tp->p_mpool, tp);
 80017ca:	f001 b929 	b.w	8002a20 <chPoolFree>
 80017ce:	bf00      	nop

080017d0 <chThdCreateFromHeap>:
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
                              tprio_t prio, tfunc_t pf, void *arg) {
 80017d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80017d2:	b083      	sub	sp, #12
 80017d4:	4616      	mov	r6, r2
 80017d6:	461d      	mov	r5, r3
 80017d8:	460f      	mov	r7, r1
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
 80017da:	f001 f829 	bl	8002830 <chHeapAlloc>
  if (wsp == NULL) {
 80017de:	b198      	cbz	r0, 8001808 <chThdCreateFromHeap+0x38>
 80017e0:	2320      	movs	r3, #32
 80017e2:	f383 8811 	msr	BASEPRI, r3
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif
  
  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 80017e6:	9b08      	ldr	r3, [sp, #32]
 80017e8:	9300      	str	r3, [sp, #0]
 80017ea:	4639      	mov	r1, r7
 80017ec:	4632      	mov	r2, r6
 80017ee:	462b      	mov	r3, r5
 80017f0:	f7ff fe46 	bl	8001480 <chThdCreateI>
  tp->p_flags = CH_FLAG_MODE_HEAP;
 80017f4:	2301      	movs	r3, #1
 80017f6:	7743      	strb	r3, [r0, #29]
  chSchWakeupS(tp, MSG_OK);
 80017f8:	2100      	movs	r1, #0
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif
  
  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 80017fa:	4604      	mov	r4, r0
  tp->p_flags = CH_FLAG_MODE_HEAP;
  chSchWakeupS(tp, MSG_OK);
 80017fc:	f7ff fd18 	bl	8001230 <chSchWakeupS>
 8001800:	2300      	movs	r3, #0
 8001802:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
 8001806:	4620      	mov	r0, r4
}
 8001808:	b003      	add	sp, #12
 800180a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800180c:	f3af 8000 	nop.w

08001810 <chThdCreateFromMemoryPool>:
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
                                    tfunc_t pf, void *arg) {
 8001810:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001814:	b082      	sub	sp, #8
 8001816:	460f      	mov	r7, r1
 8001818:	4616      	mov	r6, r2
 800181a:	4698      	mov	r8, r3
 800181c:	4605      	mov	r5, r0
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 800181e:	f001 f8e7 	bl	80029f0 <chPoolAlloc>
  if (wsp == NULL) {
 8001822:	b1a0      	cbz	r0, 800184e <chThdCreateFromMemoryPool+0x3e>
 8001824:	2320      	movs	r3, #32
 8001826:	f383 8811 	msr	BASEPRI, r3
                  (uint8_t *)wsp + mp->mp_object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
 800182a:	6869      	ldr	r1, [r5, #4]
 800182c:	f8cd 8000 	str.w	r8, [sp]
 8001830:	463a      	mov	r2, r7
 8001832:	4633      	mov	r3, r6
 8001834:	f7ff fe24 	bl	8001480 <chThdCreateI>
  tp->p_flags = CH_FLAG_MODE_MEMPOOL;
 8001838:	2302      	movs	r3, #2
 800183a:	7743      	strb	r3, [r0, #29]
  tp->p_mpool = mp;
 800183c:	6405      	str	r5, [r0, #64]	; 0x40
  chSchWakeupS(tp, MSG_OK);
 800183e:	2100      	movs	r1, #0
                  (uint8_t *)wsp + mp->mp_object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
 8001840:	4604      	mov	r4, r0
  tp->p_flags = CH_FLAG_MODE_MEMPOOL;
  tp->p_mpool = mp;
  chSchWakeupS(tp, MSG_OK);
 8001842:	f7ff fcf5 	bl	8001230 <chSchWakeupS>
 8001846:	2300      	movs	r3, #0
 8001848:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
 800184c:	4620      	mov	r0, r4
}
 800184e:	b002      	add	sp, #8
 8001850:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001854:	f3af 8000 	nop.w
 8001858:	f3af 8000 	nop.w
 800185c:	f3af 8000 	nop.w

08001860 <chRegFirstThread>:
 8001860:	2320      	movs	r3, #32
 8001862:	f383 8811 	msr	BASEPRI, r3
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.r_newer;
 8001866:	4b04      	ldr	r3, [pc, #16]	; (8001878 <chRegFirstThread+0x18>)
 8001868:	6918      	ldr	r0, [r3, #16]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs++;
 800186a:	7f83      	ldrb	r3, [r0, #30]
 800186c:	3301      	adds	r3, #1
 800186e:	7783      	strb	r3, [r0, #30]
 8001870:	2300      	movs	r3, #0
 8001872:	f383 8811 	msr	BASEPRI, r3
#endif
  chSysUnlock();

  return tp;
}
 8001876:	4770      	bx	lr
 8001878:	20001150 	.word	0x20001150
 800187c:	f3af 8000 	nop.w

08001880 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 8001880:	b510      	push	{r4, lr}
 8001882:	2320      	movs	r3, #32
 8001884:	f383 8811 	msr	BASEPRI, r3
  thread_t *ntp;

  chSysLock();
  ntp = tp->p_newer;
  if (ntp == (thread_t *)&ch.rlist) {
 8001888:	4b07      	ldr	r3, [pc, #28]	; (80018a8 <chRegNextThread+0x28>)
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->p_newer;
 800188a:	6904      	ldr	r4, [r0, #16]
  if (ntp == (thread_t *)&ch.rlist) {
 800188c:	429c      	cmp	r4, r3
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC
  else {
    chDbgAssert(ntp->p_refs < 255, "too many references");
    ntp->p_refs++;
 800188e:	bf1d      	ittte	ne
 8001890:	7fa3      	ldrbne	r3, [r4, #30]
 8001892:	3301      	addne	r3, #1
 8001894:	77a3      	strbne	r3, [r4, #30]
  thread_t *ntp;

  chSysLock();
  ntp = tp->p_newer;
  if (ntp == (thread_t *)&ch.rlist) {
    ntp = NULL;
 8001896:	2400      	moveq	r4, #0
 8001898:	2300      	movs	r3, #0
 800189a:	f383 8811 	msr	BASEPRI, r3
    ntp->p_refs++;
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC
  chThdRelease(tp);
 800189e:	f7ff ff6f 	bl	8001780 <chThdRelease>
#endif

  return ntp;
}
 80018a2:	4620      	mov	r0, r4
 80018a4:	bd10      	pop	{r4, pc}
 80018a6:	bf00      	nop
 80018a8:	20001150 	.word	0x20001150
 80018ac:	f3af 8000 	nop.w

080018b0 <chSemObjectInit>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 80018b0:	6040      	str	r0, [r0, #4]
 80018b2:	6000      	str	r0, [r0, #0]
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= 0));

  queue_init(&sp->s_queue);
  sp->s_cnt = n;
 80018b4:	6081      	str	r1, [r0, #8]
 80018b6:	4770      	bx	lr
 80018b8:	f3af 8000 	nop.w
 80018bc:	f3af 8000 	nop.w

080018c0 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 80018c0:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck((sp != NULL) && (n >= 0));
  chDbgAssert(((sp->s_cnt >= 0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
 80018c2:	6885      	ldr	r5, [r0, #8]
  sp->s_cnt = n;
 80018c4:	6081      	str	r1, [r0, #8]
  while (++cnt <= 0) {
 80018c6:	3501      	adds	r5, #1
 80018c8:	2d00      	cmp	r5, #0
 80018ca:	dc0c      	bgt.n	80018e6 <chSemResetI+0x26>
 80018cc:	4604      	mov	r4, r0
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 80018ce:	f06f 0601 	mvn.w	r6, #1

  return tp;
}

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_prev;
 80018d2:	6860      	ldr	r0, [r4, #4]

  (tqp->p_prev = tp->p_prev)->p_next = (thread_t *)tqp;
 80018d4:	6843      	ldr	r3, [r0, #4]
 80018d6:	6063      	str	r3, [r4, #4]
 80018d8:	601c      	str	r4, [r3, #0]
 80018da:	f7ff fc51 	bl	8001180 <chSchReadyI>
              ((sp->s_cnt < 0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= 0) {
 80018de:	3501      	adds	r5, #1
 80018e0:	2d01      	cmp	r5, #1
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 80018e2:	6206      	str	r6, [r0, #32]
              ((sp->s_cnt < 0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= 0) {
 80018e4:	d1f5      	bne.n	80018d2 <chSemResetI+0x12>
 80018e6:	bd70      	pop	{r4, r5, r6, pc}
 80018e8:	f3af 8000 	nop.w
 80018ec:	f3af 8000 	nop.w

080018f0 <chSemReset>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {
 80018f0:	b508      	push	{r3, lr}
 80018f2:	2320      	movs	r3, #32
 80018f4:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chSemResetI(sp, n);
 80018f8:	f7ff ffe2 	bl	80018c0 <chSemResetI>
  chSchRescheduleS();
 80018fc:	f7ff fd18 	bl	8001330 <chSchRescheduleS>
 8001900:	2300      	movs	r3, #0
 8001902:	f383 8811 	msr	BASEPRI, r3
 8001906:	bd08      	pop	{r3, pc}
 8001908:	f3af 8000 	nop.w
 800190c:	f3af 8000 	nop.w

08001910 <chSemWait>:
 8001910:	2320      	movs	r3, #32
 8001912:	f383 8811 	msr	BASEPRI, r3
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= 0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
 8001916:	6883      	ldr	r3, [r0, #8]
 8001918:	3b01      	subs	r3, #1
 800191a:	2b00      	cmp	r3, #0
 800191c:	6083      	str	r3, [r0, #8]
 800191e:	db04      	blt.n	800192a <chSemWait+0x1a>
    chSchGoSleepS(CH_STATE_WTSEM);

    return currp->p_u.rdymsg;
  }

  return MSG_OK;
 8001920:	2000      	movs	r0, #0
 8001922:	2300      	movs	r3, #0
 8001924:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  msg = chSemWaitS(sp);
  chSysUnlock();

  return msg;
}
 8001928:	4770      	bx	lr
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 800192a:	b510      	push	{r4, lr}
  chDbgAssert(((sp->s_cnt >= 0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
    currp->p_u.wtobjp = sp;
 800192c:	4c08      	ldr	r4, [pc, #32]	; (8001950 <chSemWait+0x40>)
 800192e:	69a2      	ldr	r2, [r4, #24]
 8001930:	6210      	str	r0, [r2, #32]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8001932:	6841      	ldr	r1, [r0, #4]
 8001934:	6051      	str	r1, [r2, #4]
 8001936:	4603      	mov	r3, r0
  tp->p_prev->p_next = cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 8001938:	6010      	str	r0, [r2, #0]
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
 800193a:	605a      	str	r2, [r3, #4]
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(CH_STATE_WTSEM);
 800193c:	2005      	movs	r0, #5
 800193e:	600a      	str	r2, [r1, #0]
 8001940:	f7ff fc36 	bl	80011b0 <chSchGoSleepS>

    return currp->p_u.rdymsg;
 8001944:	69a3      	ldr	r3, [r4, #24]
 8001946:	6a18      	ldr	r0, [r3, #32]
 8001948:	2300      	movs	r3, #0
 800194a:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  msg = chSemWaitS(sp);
  chSysUnlock();

  return msg;
}
 800194e:	bd10      	pop	{r4, pc}
 8001950:	20001150 	.word	0x20001150
 8001954:	f3af 8000 	nop.w
 8001958:	f3af 8000 	nop.w
 800195c:	f3af 8000 	nop.w

08001960 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8001960:	4603      	mov	r3, r0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= 0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
 8001962:	6880      	ldr	r0, [r0, #8]
 8001964:	1e42      	subs	r2, r0, #1
 8001966:	2a00      	cmp	r2, #0
 8001968:	609a      	str	r2, [r3, #8]
 800196a:	db01      	blt.n	8001970 <chSemWaitTimeoutS+0x10>
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
 800196c:	2000      	movs	r0, #0
 800196e:	4770      	bx	lr
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8001970:	b410      	push	{r4}
  chDbgAssert(((sp->s_cnt >= 0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
    if (TIME_IMMEDIATE == time) {
 8001972:	b161      	cbz	r1, 800198e <chSemWaitTimeoutS+0x2e>
      sp->s_cnt++;

      return MSG_TIMEOUT;
    }
    currp->p_u.wtobjp = sp;
 8001974:	4a09      	ldr	r2, [pc, #36]	; (800199c <chSemWaitTimeoutS+0x3c>)
 8001976:	6992      	ldr	r2, [r2, #24]
 8001978:	6213      	str	r3, [r2, #32]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 800197a:	685c      	ldr	r4, [r3, #4]
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 800197c:	2005      	movs	r0, #5
 800197e:	e882 0018 	stmia.w	r2, {r3, r4}
  tp->p_prev->p_next = tqp->p_prev = tp;
 8001982:	605a      	str	r2, [r3, #4]
 8001984:	6022      	str	r2, [r4, #0]
  }

  return MSG_OK;
}
 8001986:	f85d 4b04 	ldr.w	r4, [sp], #4
      return MSG_TIMEOUT;
    }
    currp->p_u.wtobjp = sp;
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 800198a:	f7ff bc29 	b.w	80011e0 <chSchGoSleepTimeoutS>
              ((sp->s_cnt < 0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < 0) {
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;
 800198e:	6098      	str	r0, [r3, #8]

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
}
 8001990:	f85d 4b04 	ldr.w	r4, [sp], #4

  if (--sp->s_cnt < 0) {
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;

      return MSG_TIMEOUT;
 8001994:	f04f 30ff 	mov.w	r0, #4294967295

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
}
 8001998:	4770      	bx	lr
 800199a:	bf00      	nop
 800199c:	20001150 	.word	0x20001150

080019a0 <chSemWaitTimeout>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t time) {
 80019a0:	b508      	push	{r3, lr}
 80019a2:	2320      	movs	r3, #32
 80019a4:	f383 8811 	msr	BASEPRI, r3
  msg_t msg;

  chSysLock();
  msg = chSemWaitTimeoutS(sp, time);
 80019a8:	f7ff ffda 	bl	8001960 <chSemWaitTimeoutS>
 80019ac:	2300      	movs	r3, #0
 80019ae:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return msg;
}
 80019b2:	bd08      	pop	{r3, pc}
 80019b4:	f3af 8000 	nop.w
 80019b8:	f3af 8000 	nop.w
 80019bc:	f3af 8000 	nop.w

080019c0 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 80019c0:	b508      	push	{r3, lr}
 80019c2:	2320      	movs	r3, #32
 80019c4:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(((sp->s_cnt >= 0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sp->s_cnt <= 0) {
 80019c8:	6883      	ldr	r3, [r0, #8]
 80019ca:	3301      	adds	r3, #1
 80019cc:	2b00      	cmp	r3, #0
 80019ce:	6083      	str	r3, [r0, #8]
 80019d0:	dd03      	ble.n	80019da <chSemSignal+0x1a>
 80019d2:	2300      	movs	r3, #0
 80019d4:	f383 8811 	msr	BASEPRI, r3
 80019d8:	bd08      	pop	{r3, pc}
 80019da:	4603      	mov	r3, r0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80019dc:	6800      	ldr	r0, [r0, #0]

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 80019de:	6802      	ldr	r2, [r0, #0]
 80019e0:	601a      	str	r2, [r3, #0]
    chSchWakeupS(queue_fifo_remove(&sp->s_queue), MSG_OK);
 80019e2:	2100      	movs	r1, #0
 80019e4:	6053      	str	r3, [r2, #4]
 80019e6:	f7ff fc23 	bl	8001230 <chSchWakeupS>
 80019ea:	2300      	movs	r3, #0
 80019ec:	f383 8811 	msr	BASEPRI, r3
 80019f0:	bd08      	pop	{r3, pc}
 80019f2:	bf00      	nop
 80019f4:	f3af 8000 	nop.w
 80019f8:	f3af 8000 	nop.w
 80019fc:	f3af 8000 	nop.w

08001a00 <chSemSignalI>:
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= 0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= 0) {
 8001a00:	6883      	ldr	r3, [r0, #8]
 8001a02:	3301      	adds	r3, #1
 8001a04:	2b00      	cmp	r3, #0
 8001a06:	6083      	str	r3, [r0, #8]
 8001a08:	dd00      	ble.n	8001a0c <chSemSignalI+0xc>
 8001a0a:	4770      	bx	lr
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8001a0c:	6803      	ldr	r3, [r0, #0]

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8001a0e:	681a      	ldr	r2, [r3, #0]
 8001a10:	6002      	str	r2, [r0, #0]
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
 8001a12:	2100      	movs	r1, #0
 8001a14:	6050      	str	r0, [r2, #4]
    chSchReadyI(tp);
 8001a16:	4618      	mov	r0, r3

  if (++sp->s_cnt <= 0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
 8001a18:	6219      	str	r1, [r3, #32]
    chSchReadyI(tp);
 8001a1a:	f7ff bbb1 	b.w	8001180 <chSchReadyI>
 8001a1e:	bf00      	nop

08001a20 <chSemAddCounterI>:
 * @param[in] n         value to be added to the semaphore counter. The value
 *                      must be positive.
 *
 * @iclass
 */
void chSemAddCounterI(semaphore_t *sp, cnt_t n) {
 8001a20:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck((sp != NULL) && (n > 0));
  chDbgAssert(((sp->s_cnt >= 0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > 0) {
 8001a22:	1e0c      	subs	r4, r1, #0
 8001a24:	dd12      	ble.n	8001a4c <chSemAddCounterI+0x2c>
 8001a26:	4605      	mov	r5, r0
    if (++sp->s_cnt <= 0) {
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 8001a28:	2600      	movs	r6, #0
 8001a2a:	e001      	b.n	8001a30 <chSemAddCounterI+0x10>
  chDbgCheck((sp != NULL) && (n > 0));
  chDbgAssert(((sp->s_cnt >= 0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > 0) {
 8001a2c:	3c01      	subs	r4, #1
 8001a2e:	d00d      	beq.n	8001a4c <chSemAddCounterI+0x2c>
    if (++sp->s_cnt <= 0) {
 8001a30:	68ab      	ldr	r3, [r5, #8]
 8001a32:	3301      	adds	r3, #1
 8001a34:	2b00      	cmp	r3, #0
 8001a36:	60ab      	str	r3, [r5, #8]
 8001a38:	dcf8      	bgt.n	8001a2c <chSemAddCounterI+0xc>
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8001a3a:	6828      	ldr	r0, [r5, #0]

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8001a3c:	6803      	ldr	r3, [r0, #0]
 8001a3e:	602b      	str	r3, [r5, #0]
 8001a40:	605d      	str	r5, [r3, #4]
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 8001a42:	f7ff fb9d 	bl	8001180 <chSchReadyI>
  chDbgCheck((sp != NULL) && (n > 0));
  chDbgAssert(((sp->s_cnt >= 0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > 0) {
 8001a46:	3c01      	subs	r4, #1
    if (++sp->s_cnt <= 0) {
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 8001a48:	6206      	str	r6, [r0, #32]
  chDbgCheck((sp != NULL) && (n > 0));
  chDbgAssert(((sp->s_cnt >= 0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < 0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > 0) {
 8001a4a:	d1f1      	bne.n	8001a30 <chSemAddCounterI+0x10>
 8001a4c:	bd70      	pop	{r4, r5, r6, pc}
 8001a4e:	bf00      	nop

08001a50 <chSemSignalWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 8001a50:	b510      	push	{r4, lr}
 8001a52:	4602      	mov	r2, r0
 8001a54:	b082      	sub	sp, #8
 8001a56:	2320      	movs	r3, #32
 8001a58:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(((spw->s_cnt >= 0) && queue_isempty(&spw->s_queue)) ||
              ((spw->s_cnt < 0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->s_cnt <= 0) {
 8001a5c:	6883      	ldr	r3, [r0, #8]
 8001a5e:	3301      	adds	r3, #1
 8001a60:	2b00      	cmp	r3, #0
 8001a62:	6083      	str	r3, [r0, #8]
 8001a64:	dd1d      	ble.n	8001aa2 <chSemSignalWait+0x52>
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < 0) {
 8001a66:	688b      	ldr	r3, [r1, #8]
 8001a68:	3b01      	subs	r3, #1
 8001a6a:	2b00      	cmp	r3, #0
 8001a6c:	608b      	str	r3, [r1, #8]
 8001a6e:	db07      	blt.n	8001a80 <chSemSignalWait+0x30>
    ctp->p_u.wtobjp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
    msg = ctp->p_u.rdymsg;
  }
  else {
    chSchRescheduleS();
 8001a70:	f7ff fc5e 	bl	8001330 <chSchRescheduleS>
    msg = MSG_OK;
 8001a74:	2000      	movs	r0, #0
 8001a76:	2300      	movs	r3, #0
 8001a78:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return msg;
}
 8001a7c:	b002      	add	sp, #8
 8001a7e:	bd10      	pop	{r4, pc}
  chSysLock();
  if (++sps->s_cnt <= 0) {
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < 0) {
    thread_t *ctp = currp;
 8001a80:	4a0d      	ldr	r2, [pc, #52]	; (8001ab8 <chSemSignalWait+0x68>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8001a82:	684b      	ldr	r3, [r1, #4]
 8001a84:	6994      	ldr	r4, [r2, #24]
    sem_insert(ctp, &spw->s_queue);
    ctp->p_u.wtobjp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
 8001a86:	2005      	movs	r0, #5
 8001a88:	e884 000a 	stmia.w	r4, {r1, r3}
  tp->p_prev->p_next = tqp->p_prev = tp;
 8001a8c:	604c      	str	r4, [r1, #4]
 8001a8e:	601c      	str	r4, [r3, #0]
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < 0) {
    thread_t *ctp = currp;
    sem_insert(ctp, &spw->s_queue);
    ctp->p_u.wtobjp = spw;
 8001a90:	6221      	str	r1, [r4, #32]
    chSchGoSleepS(CH_STATE_WTSEM);
 8001a92:	f7ff fb8d 	bl	80011b0 <chSchGoSleepS>
    msg = ctp->p_u.rdymsg;
 8001a96:	6a20      	ldr	r0, [r4, #32]
 8001a98:	2300      	movs	r3, #0
 8001a9a:	f383 8811 	msr	BASEPRI, r3
    msg = MSG_OK;
  }
  chSysUnlock();

  return msg;
}
 8001a9e:	b002      	add	sp, #8
 8001aa0:	bd10      	pop	{r4, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8001aa2:	6800      	ldr	r0, [r0, #0]
 8001aa4:	9101      	str	r1, [sp, #4]

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8001aa6:	6803      	ldr	r3, [r0, #0]
 8001aa8:	6013      	str	r3, [r2, #0]
 8001aaa:	605a      	str	r2, [r3, #4]
              ((spw->s_cnt < 0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->s_cnt <= 0) {
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
 8001aac:	f7ff fb68 	bl	8001180 <chSchReadyI>
 8001ab0:	2300      	movs	r3, #0
 8001ab2:	6203      	str	r3, [r0, #32]
 8001ab4:	9901      	ldr	r1, [sp, #4]
 8001ab6:	e7d6      	b.n	8001a66 <chSemSignalWait+0x16>
 8001ab8:	20001150 	.word	0x20001150
 8001abc:	f3af 8000 	nop.w

08001ac0 <chMtxObjectInit>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 8001ac0:	2300      	movs	r3, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8001ac2:	6040      	str	r0, [r0, #4]
 8001ac4:	6000      	str	r0, [r0, #0]
 8001ac6:	6083      	str	r3, [r0, #8]
 8001ac8:	4770      	bx	lr
 8001aca:	bf00      	nop
 8001acc:	f3af 8000 	nop.w

08001ad0 <chMtxLockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8001ad0:	4b30      	ldr	r3, [pc, #192]	; (8001b94 <chMtxLockS+0xc4>)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8001ad2:	6882      	ldr	r2, [r0, #8]
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8001ad4:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8001ad6:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8001ad8:	2a00      	cmp	r2, #0
 8001ada:	d055      	beq.n	8001b88 <chMtxLockS+0xb8>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8001adc:	68a1      	ldr	r1, [r4, #8]
 8001ade:	6893      	ldr	r3, [r2, #8]
 8001ae0:	4299      	cmp	r1, r3
 8001ae2:	4605      	mov	r5, r0
 8001ae4:	d906      	bls.n	8001af4 <chMtxLockS+0x24>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8001ae6:	7f13      	ldrb	r3, [r2, #28]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 8001ae8:	6091      	str	r1, [r2, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8001aea:	2b06      	cmp	r3, #6
 8001aec:	d033      	beq.n	8001b56 <chMtxLockS+0x86>
 8001aee:	2b07      	cmp	r3, #7
 8001af0:	d01d      	beq.n	8001b2e <chMtxLockS+0x5e>
 8001af2:	b19b      	cbz	r3, 8001b1c <chMtxLockS+0x4c>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001af4:	462b      	mov	r3, r5
 8001af6:	e003      	b.n	8001b00 <chMtxLockS+0x30>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001af8:	6899      	ldr	r1, [r3, #8]
 8001afa:	68a2      	ldr	r2, [r4, #8]
 8001afc:	4291      	cmp	r1, r2
 8001afe:	d302      	bcc.n	8001b06 <chMtxLockS+0x36>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8001b00:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001b02:	429d      	cmp	r5, r3
 8001b04:	d1f8      	bne.n	8001af8 <chMtxLockS+0x28>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001b06:	685a      	ldr	r2, [r3, #4]
 8001b08:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8001b0a:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 8001b0c:	605c      	str	r4, [r3, #4]
 8001b0e:	6014      	str	r4, [r2, #0]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtobjp = mp;
 8001b10:	6225      	str	r5, [r4, #32]
      chSchGoSleepS(CH_STATE_WTMTX);
 8001b12:	2006      	movs	r0, #6
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
  }
}
 8001b14:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtobjp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8001b18:	f7ff bb4a 	b.w	80011b0 <chSchGoSleepS>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8001b1c:	e892 000a 	ldmia.w	r2, {r1, r3}
 8001b20:	6019      	str	r1, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001b22:	6811      	ldr	r1, [r2, #0]
  #if CH_DBG_ENABLE_ASSERTS
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
  #endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          chSchReadyI(queue_dequeue(tp));
 8001b24:	4610      	mov	r0, r2
 8001b26:	604b      	str	r3, [r1, #4]
 8001b28:	f7ff fb2a 	bl	8001180 <chSchReadyI>
          break;
 8001b2c:	e7e2      	b.n	8001af4 <chMtxLockS+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8001b2e:	e892 0009 	ldmia.w	r2, {r0, r3}
 8001b32:	6018      	str	r0, [r3, #0]
  #if CH_CFG_USE_MESSAGES && CH_CFG_USE_MESSAGES_PRIORITY
        case CH_STATE_SNDMSGQ:
  #endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp),
                            (threads_queue_t *)tp->p_u.wtobjp);
 8001b34:	6a16      	ldr	r6, [r2, #32]
  tp->p_next->p_prev = tp->p_prev;
 8001b36:	6810      	ldr	r0, [r2, #0]
 8001b38:	6043      	str	r3, [r0, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001b3a:	4633      	mov	r3, r6
 8001b3c:	e002      	b.n	8001b44 <chMtxLockS+0x74>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001b3e:	6898      	ldr	r0, [r3, #8]
 8001b40:	4288      	cmp	r0, r1
 8001b42:	d302      	bcc.n	8001b4a <chMtxLockS+0x7a>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8001b44:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001b46:	429e      	cmp	r6, r3
 8001b48:	d1f9      	bne.n	8001b3e <chMtxLockS+0x6e>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001b4a:	6859      	ldr	r1, [r3, #4]
 8001b4c:	6051      	str	r1, [r2, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8001b4e:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 8001b50:	605a      	str	r2, [r3, #4]
 8001b52:	600a      	str	r2, [r1, #0]
 8001b54:	e7ce      	b.n	8001af4 <chMtxLockS+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8001b56:	e892 0009 	ldmia.w	r2, {r0, r3}
 8001b5a:	6018      	str	r0, [r3, #0]
        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp),
                            (threads_queue_t *)tp->p_u.wtobjp);
 8001b5c:	6a16      	ldr	r6, [r2, #32]
  tp->p_next->p_prev = tp->p_prev;
 8001b5e:	6810      	ldr	r0, [r2, #0]
 8001b60:	6043      	str	r3, [r0, #4]
 8001b62:	4633      	mov	r3, r6
 8001b64:	e002      	b.n	8001b6c <chMtxLockS+0x9c>
static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001b66:	6898      	ldr	r0, [r3, #8]
 8001b68:	4288      	cmp	r0, r1
 8001b6a:	d302      	bcc.n	8001b72 <chMtxLockS+0xa2>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8001b6c:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001b6e:	429e      	cmp	r6, r3
 8001b70:	d1f9      	bne.n	8001b66 <chMtxLockS+0x96>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001b72:	6859      	ldr	r1, [r3, #4]
 8001b74:	6051      	str	r1, [r2, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8001b76:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 8001b78:	605a      	str	r2, [r3, #4]
 8001b7a:	600a      	str	r2, [r1, #0]
          tp = ((mutex_t *)tp->p_u.wtobjp)->m_owner;
 8001b7c:	68b2      	ldr	r2, [r6, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8001b7e:	68a1      	ldr	r1, [r4, #8]
 8001b80:	6893      	ldr	r3, [r2, #8]
 8001b82:	428b      	cmp	r3, r1
 8001b84:	d3af      	bcc.n	8001ae6 <chMtxLockS+0x16>
 8001b86:	e7b5      	b.n	8001af4 <chMtxLockS+0x24>

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
 8001b88:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001b8a:	60c3      	str	r3, [r0, #12]
    chDbgAssert(mp->m_cnt == 0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 8001b8c:	6084      	str	r4, [r0, #8]
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
 8001b8e:	63a0      	str	r0, [r4, #56]	; 0x38
 8001b90:	bd70      	pop	{r4, r5, r6, pc}
 8001b92:	bf00      	nop
 8001b94:	20001150 	.word	0x20001150
 8001b98:	f3af 8000 	nop.w
 8001b9c:	f3af 8000 	nop.w

08001ba0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8001ba0:	b508      	push	{r3, lr}
 8001ba2:	2320      	movs	r3, #32
 8001ba4:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chMtxLockS(mp);
 8001ba8:	f7ff ff92 	bl	8001ad0 <chMtxLockS>
 8001bac:	2300      	movs	r3, #0
 8001bae:	f383 8811 	msr	BASEPRI, r3
 8001bb2:	bd08      	pop	{r3, pc}
 8001bb4:	f3af 8000 	nop.w
 8001bb8:	f3af 8000 	nop.w
 8001bbc:	f3af 8000 	nop.w

08001bc0 <chMtxTryLock>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @api
 */
bool chMtxTryLock(mutex_t *mp) {
 8001bc0:	4603      	mov	r3, r0
 8001bc2:	2220      	movs	r2, #32
 8001bc4:	f382 8811 	msr	BASEPRI, r2
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->m_owner != NULL) {
 8001bc8:	6882      	ldr	r2, [r0, #8]
    if (mp->m_owner == currp) {
      mp->m_cnt++;
      return true;
    }
#endif
    return false;
 8001bca:	2000      	movs	r0, #0
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->m_owner != NULL) {
 8001bcc:	b11a      	cbz	r2, 8001bd6 <chMtxTryLock+0x16>
 8001bce:	2300      	movs	r3, #0
 8001bd0:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  b = chMtxTryLockS(mp);
  chSysUnlock();

  return b;
}
 8001bd4:	4770      	bx	lr

  chDbgAssert(mp->m_cnt == 0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 8001bd6:	4a05      	ldr	r2, [pc, #20]	; (8001bec <chMtxTryLock+0x2c>)
 8001bd8:	6992      	ldr	r2, [r2, #24]
 8001bda:	609a      	str	r2, [r3, #8]
  mp->m_next = currp->p_mtxlist;
 8001bdc:	6b91      	ldr	r1, [r2, #56]	; 0x38
 8001bde:	60d9      	str	r1, [r3, #12]
  currp->p_mtxlist = mp;
 8001be0:	2001      	movs	r0, #1
 8001be2:	6393      	str	r3, [r2, #56]	; 0x38
 8001be4:	2300      	movs	r3, #0
 8001be6:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  b = chMtxTryLockS(mp);
  chSysUnlock();

  return b;
}
 8001bea:	4770      	bx	lr
 8001bec:	20001150 	.word	0x20001150

08001bf0 <chMtxUnlock>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 8001bf0:	4b16      	ldr	r3, [pc, #88]	; (8001c4c <chMtxUnlock+0x5c>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8001bf2:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8001bf4:	699d      	ldr	r5, [r3, #24]
 8001bf6:	2320      	movs	r3, #32
 8001bf8:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (thread_t *)tqp);
 8001bfc:	6804      	ldr	r4, [r0, #0]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 8001bfe:	68c3      	ldr	r3, [r0, #12]
 8001c00:	63ab      	str	r3, [r5, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8001c02:	42a0      	cmp	r0, r4
 8001c04:	d01c      	beq.n	8001c40 <chMtxUnlock+0x50>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8001c06:	6be9      	ldr	r1, [r5, #60]	; 0x3c
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8001c08:	b14b      	cbz	r3, 8001c1e <chMtxUnlock+0x2e>
 8001c0a:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8001c0c:	4293      	cmp	r3, r2
 8001c0e:	d003      	beq.n	8001c18 <chMtxUnlock+0x28>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 8001c10:	6892      	ldr	r2, [r2, #8]
 8001c12:	4291      	cmp	r1, r2
 8001c14:	bf38      	it	cc
 8001c16:	4611      	movcc	r1, r2
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 8001c18:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8001c1a:	2b00      	cmp	r3, #0
 8001c1c:	d1f5      	bne.n	8001c0a <chMtxUnlock+0x1a>
 8001c1e:	4603      	mov	r3, r0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8001c20:	6822      	ldr	r2, [r4, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE
      mp->m_cnt = 1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 8001c22:	6ba6      	ldr	r6, [r4, #56]	; 0x38
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 8001c24:	60a9      	str	r1, [r5, #8]
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
      chSchWakeupS(tp, MSG_OK);
 8001c26:	4620      	mov	r0, r4
 8001c28:	601a      	str	r2, [r3, #0]
 8001c2a:	2100      	movs	r1, #0
 8001c2c:	6053      	str	r3, [r2, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE
      mp->m_cnt = 1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 8001c2e:	609c      	str	r4, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 8001c30:	60de      	str	r6, [r3, #12]
      tp->p_mtxlist = mp;
 8001c32:	63a3      	str	r3, [r4, #56]	; 0x38
      chSchWakeupS(tp, MSG_OK);
 8001c34:	f7ff fafc 	bl	8001230 <chSchWakeupS>
 8001c38:	2300      	movs	r3, #0
 8001c3a:	f383 8811 	msr	BASEPRI, r3
 8001c3e:	bd70      	pop	{r4, r5, r6, pc}
    }
    else {
      mp->m_owner = NULL;
 8001c40:	2300      	movs	r3, #0
 8001c42:	6083      	str	r3, [r0, #8]
 8001c44:	2300      	movs	r3, #0
 8001c46:	f383 8811 	msr	BASEPRI, r3
 8001c4a:	bd70      	pop	{r4, r5, r6, pc}
 8001c4c:	20001150 	.word	0x20001150

08001c50 <chMtxUnlockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8001c50:	4b12      	ldr	r3, [pc, #72]	; (8001c9c <chMtxUnlockS+0x4c>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8001c52:	b430      	push	{r4, r5}
 8001c54:	4604      	mov	r4, r0
 *
 * @notapi
 */
static inline bool queue_notempty(threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (thread_t *)tqp);
 8001c56:	6805      	ldr	r5, [r0, #0]
  thread_t *ctp = currp;
 8001c58:	6998      	ldr	r0, [r3, #24]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 8001c5a:	68e3      	ldr	r3, [r4, #12]
 8001c5c:	6383      	str	r3, [r0, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8001c5e:	42ac      	cmp	r4, r5
 8001c60:	d017      	beq.n	8001c92 <chMtxUnlockS+0x42>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8001c62:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8001c64:	b14b      	cbz	r3, 8001c7a <chMtxUnlockS+0x2a>
 8001c66:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8001c68:	4293      	cmp	r3, r2
 8001c6a:	d003      	beq.n	8001c74 <chMtxUnlockS+0x24>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 8001c6c:	6892      	ldr	r2, [r2, #8]
 8001c6e:	4291      	cmp	r1, r2
 8001c70:	bf38      	it	cc
 8001c72:	4611      	movcc	r1, r2
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 8001c74:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8001c76:	2b00      	cmp	r3, #0
 8001c78:	d1f5      	bne.n	8001c66 <chMtxUnlockS+0x16>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8001c7a:	682b      	ldr	r3, [r5, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE
      mp->m_cnt = 1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 8001c7c:	6baa      	ldr	r2, [r5, #56]	; 0x38
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 8001c7e:	6081      	str	r1, [r0, #8]
 8001c80:	6023      	str	r3, [r4, #0]
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
      chSchReadyI(tp);
 8001c82:	4628      	mov	r0, r5
 8001c84:	605c      	str	r4, [r3, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE
      mp->m_cnt = 1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 8001c86:	60a5      	str	r5, [r4, #8]
      mp->m_next = tp->p_mtxlist;
 8001c88:	60e2      	str	r2, [r4, #12]
      tp->p_mtxlist = mp;
 8001c8a:	63ac      	str	r4, [r5, #56]	; 0x38
      mp->m_owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE
  }
#endif
}
 8001c8c:	bc30      	pop	{r4, r5}
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
      chSchReadyI(tp);
 8001c8e:	f7ff ba77 	b.w	8001180 <chSchReadyI>
    }
    else {
      mp->m_owner = NULL;
 8001c92:	2300      	movs	r3, #0
 8001c94:	60a3      	str	r3, [r4, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE
  }
#endif
}
 8001c96:	bc30      	pop	{r4, r5}
 8001c98:	4770      	bx	lr
 8001c9a:	bf00      	nop
 8001c9c:	20001150 	.word	0x20001150

08001ca0 <chMtxUnlockAll>:
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
  thread_t *ctp = currp;
 8001ca0:	4a13      	ldr	r2, [pc, #76]	; (8001cf0 <chMtxUnlockAll+0x50>)
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
 8001ca2:	b570      	push	{r4, r5, r6, lr}
 8001ca4:	2320      	movs	r3, #32
  thread_t *ctp = currp;
 8001ca6:	6994      	ldr	r4, [r2, #24]
 8001ca8:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
 8001cac:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001cae:	b1d3      	cbz	r3, 8001ce6 <chMtxUnlockAll+0x46>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE
        mp->m_cnt = 0;
#endif
        mp->m_owner = NULL;
 8001cb0:	2600      	movs	r6, #0
 8001cb2:	e00a      	b.n	8001cca <chMtxUnlockAll+0x2a>
 8001cb4:	6811      	ldr	r1, [r2, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE
        mp->m_cnt = 1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
        mp->m_owner = tp;
        mp->m_next = tp->p_mtxlist;
 8001cb6:	6b95      	ldr	r5, [r2, #56]	; 0x38
 8001cb8:	6019      	str	r1, [r3, #0]
 8001cba:	604b      	str	r3, [r1, #4]
      if (chMtxQueueNotEmptyS(mp)) {
#if CH_CFG_USE_MUTEXES_RECURSIVE
        mp->m_cnt = 1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
        mp->m_owner = tp;
 8001cbc:	609a      	str	r2, [r3, #8]
        mp->m_next = tp->p_mtxlist;
 8001cbe:	60dd      	str	r5, [r3, #12]
        tp->p_mtxlist = mp;
 8001cc0:	6393      	str	r3, [r2, #56]	; 0x38
        chSchReadyI(tp);
 8001cc2:	f7ff fa5d 	bl	8001180 <chSchReadyI>
#if CH_CFG_USE_MUTEXES_RECURSIVE
        mp->m_cnt = 0;
#endif
        mp->m_owner = NULL;
      }
    } while (ctp->p_mtxlist != NULL);
 8001cc6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001cc8:	b14b      	cbz	r3, 8001cde <chMtxUnlockAll+0x3e>
 *
 * @notapi
 */
static inline bool queue_notempty(threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (thread_t *)tqp);
 8001cca:	681a      	ldr	r2, [r3, #0]

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
    do {
      mutex_t *mp = ctp->p_mtxlist;
      ctp->p_mtxlist = mp->m_next;
 8001ccc:	68d9      	ldr	r1, [r3, #12]
 8001cce:	63a1      	str	r1, [r4, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
 8001cd0:	4293      	cmp	r3, r2
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
        mp->m_owner = tp;
        mp->m_next = tp->p_mtxlist;
        tp->p_mtxlist = mp;
        chSchReadyI(tp);
 8001cd2:	4610      	mov	r0, r2
  chSysLock();
  if (ctp->p_mtxlist != NULL) {
    do {
      mutex_t *mp = ctp->p_mtxlist;
      ctp->p_mtxlist = mp->m_next;
      if (chMtxQueueNotEmptyS(mp)) {
 8001cd4:	d1ee      	bne.n	8001cb4 <chMtxUnlockAll+0x14>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE
        mp->m_cnt = 0;
#endif
        mp->m_owner = NULL;
 8001cd6:	609e      	str	r6, [r3, #8]
      }
    } while (ctp->p_mtxlist != NULL);
 8001cd8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001cda:	2b00      	cmp	r3, #0
 8001cdc:	d1f5      	bne.n	8001cca <chMtxUnlockAll+0x2a>
    ctp->p_prio = ctp->p_realprio;
 8001cde:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001ce0:	60a3      	str	r3, [r4, #8]
    chSchRescheduleS();
 8001ce2:	f7ff fb25 	bl	8001330 <chSchRescheduleS>
 8001ce6:	2300      	movs	r3, #0
 8001ce8:	f383 8811 	msr	BASEPRI, r3
 8001cec:	bd70      	pop	{r4, r5, r6, pc}
 8001cee:	bf00      	nop
 8001cf0:	20001150 	.word	0x20001150
 8001cf4:	f3af 8000 	nop.w
 8001cf8:	f3af 8000 	nop.w
 8001cfc:	f3af 8000 	nop.w

08001d00 <chCondObjectInit>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8001d00:	6040      	str	r0, [r0, #4]
 8001d02:	6000      	str	r0, [r0, #0]
 8001d04:	4770      	bx	lr
 8001d06:	bf00      	nop
 8001d08:	f3af 8000 	nop.w
 8001d0c:	f3af 8000 	nop.w

08001d10 <chCondSignal>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 8001d10:	b508      	push	{r3, lr}
 8001d12:	2320      	movs	r3, #32
 8001d14:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (thread_t *)tqp);
 8001d18:	6802      	ldr	r2, [r0, #0]

  chDbgCheck(cp != NULL);

  chSysLock();
  if (queue_notempty(&cp->c_queue)) {
 8001d1a:	4282      	cmp	r2, r0
 8001d1c:	d007      	beq.n	8001d2e <chCondSignal+0x1e>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8001d1e:	6811      	ldr	r1, [r2, #0]
 8001d20:	6001      	str	r1, [r0, #0]
 8001d22:	4603      	mov	r3, r0
 8001d24:	604b      	str	r3, [r1, #4]
    chSchWakeupS(queue_fifo_remove(&cp->c_queue), MSG_OK);
 8001d26:	4610      	mov	r0, r2
 8001d28:	2100      	movs	r1, #0
 8001d2a:	f7ff fa81 	bl	8001230 <chSchWakeupS>
 8001d2e:	2300      	movs	r3, #0
 8001d30:	f383 8811 	msr	BASEPRI, r3
 8001d34:	bd08      	pop	{r3, pc}
 8001d36:	bf00      	nop
 8001d38:	f3af 8000 	nop.w
 8001d3c:	f3af 8000 	nop.w

08001d40 <chCondSignalI>:
 *
 * @notapi
 */
static inline bool queue_notempty(threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (thread_t *)tqp);
 8001d40:	6803      	ldr	r3, [r0, #0]
void chCondSignalI(condition_variable_t *cp) {

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->c_queue)) {
 8001d42:	4298      	cmp	r0, r3
 8001d44:	d007      	beq.n	8001d56 <chCondSignalI+0x16>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8001d46:	681a      	ldr	r2, [r3, #0]
 8001d48:	6002      	str	r2, [r0, #0]
    thread_t *tp = queue_fifo_remove(&cp->c_queue);
    tp->p_u.rdymsg = MSG_OK;
 8001d4a:	2100      	movs	r1, #0
 8001d4c:	6050      	str	r0, [r2, #4]
    chSchReadyI(tp);
 8001d4e:	4618      	mov	r0, r3
  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->c_queue)) {
    thread_t *tp = queue_fifo_remove(&cp->c_queue);
    tp->p_u.rdymsg = MSG_OK;
 8001d50:	6219      	str	r1, [r3, #32]
    chSchReadyI(tp);
 8001d52:	f7ff ba15 	b.w	8001180 <chSchReadyI>
 8001d56:	4770      	bx	lr
 8001d58:	f3af 8000 	nop.w
 8001d5c:	f3af 8000 	nop.w

08001d60 <chCondBroadcastI>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondBroadcastI(condition_variable_t *cp) {
 8001d60:	b538      	push	{r3, r4, r5, lr}
 8001d62:	4604      	mov	r4, r0
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (cp->c_queue.p_next != (void *)&cp->c_queue) {
 8001d64:	6800      	ldr	r0, [r0, #0]
 8001d66:	42a0      	cmp	r0, r4
 8001d68:	d00a      	beq.n	8001d80 <chCondBroadcastI+0x20>
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
 8001d6a:	f06f 0501 	mvn.w	r5, #1
 8001d6e:	6803      	ldr	r3, [r0, #0]
 8001d70:	6023      	str	r3, [r4, #0]
 8001d72:	605c      	str	r4, [r3, #4]
 8001d74:	f7ff fa04 	bl	8001180 <chSchReadyI>
 8001d78:	6205      	str	r5, [r0, #32]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (cp->c_queue.p_next != (void *)&cp->c_queue) {
 8001d7a:	6820      	ldr	r0, [r4, #0]
 8001d7c:	42a0      	cmp	r0, r4
 8001d7e:	d1f6      	bne.n	8001d6e <chCondBroadcastI+0xe>
 8001d80:	bd38      	pop	{r3, r4, r5, pc}
 8001d82:	bf00      	nop
 8001d84:	f3af 8000 	nop.w
 8001d88:	f3af 8000 	nop.w
 8001d8c:	f3af 8000 	nop.w

08001d90 <chCondBroadcast>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondBroadcast(condition_variable_t *cp) {
 8001d90:	b508      	push	{r3, lr}
 8001d92:	2320      	movs	r3, #32
 8001d94:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chCondBroadcastI(cp);
 8001d98:	f7ff ffe2 	bl	8001d60 <chCondBroadcastI>
  chSchRescheduleS();
 8001d9c:	f7ff fac8 	bl	8001330 <chSchRescheduleS>
 8001da0:	2300      	movs	r3, #0
 8001da2:	f383 8811 	msr	BASEPRI, r3
 8001da6:	bd08      	pop	{r3, pc}
 8001da8:	f3af 8000 	nop.w
 8001dac:	f3af 8000 	nop.w

08001db0 <chCondWaitS>:
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
  thread_t *ctp = currp;
 8001db0:	4b0f      	ldr	r3, [pc, #60]	; (8001df0 <chCondWaitS+0x40>)
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
 8001db2:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8001db4:	699c      	ldr	r4, [r3, #24]
 *
 * @sclass
 */
static inline mutex_t *chMtxGetNextMutexS(void) {

  return chThdGetSelfX()->p_mtxlist;
 8001db6:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
 8001db8:	4605      	mov	r5, r0
  chDbgCheck(cp != NULL);
  chDbgAssert(ctp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 8001dba:	4630      	mov	r0, r6
 8001dbc:	f7ff ff48 	bl	8001c50 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->p_u.wtobjp = cp;
 8001dc0:	6225      	str	r5, [r4, #32]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001dc2:	462b      	mov	r3, r5
 8001dc4:	e003      	b.n	8001dce <chCondWaitS+0x1e>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001dc6:	6899      	ldr	r1, [r3, #8]
 8001dc8:	68a2      	ldr	r2, [r4, #8]
 8001dca:	4291      	cmp	r1, r2
 8001dcc:	d302      	bcc.n	8001dd4 <chCondWaitS+0x24>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8001dce:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001dd0:	429d      	cmp	r5, r3
 8001dd2:	d1f8      	bne.n	8001dc6 <chCondWaitS+0x16>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001dd4:	685a      	ldr	r2, [r3, #4]
 8001dd6:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8001dd8:	6023      	str	r3, [r4, #0]
  queue_prio_insert(ctp, &cp->c_queue);
  chSchGoSleepS(CH_STATE_WTCOND);
 8001dda:	2007      	movs	r0, #7
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 8001ddc:	605c      	str	r4, [r3, #4]
 8001dde:	6014      	str	r4, [r2, #0]
 8001de0:	f7ff f9e6 	bl	80011b0 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 8001de4:	6a24      	ldr	r4, [r4, #32]
  chMtxLockS(mp);
 8001de6:	4630      	mov	r0, r6
 8001de8:	f7ff fe72 	bl	8001ad0 <chMtxLockS>

  return msg;
}
 8001dec:	4620      	mov	r0, r4
 8001dee:	bd70      	pop	{r4, r5, r6, pc}
 8001df0:	20001150 	.word	0x20001150
 8001df4:	f3af 8000 	nop.w
 8001df8:	f3af 8000 	nop.w
 8001dfc:	f3af 8000 	nop.w

08001e00 <chCondWait>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @api
 */
msg_t chCondWait(condition_variable_t *cp) {
 8001e00:	b508      	push	{r3, lr}
 8001e02:	2320      	movs	r3, #32
 8001e04:	f383 8811 	msr	BASEPRI, r3
  msg_t msg;

  chSysLock();
  msg = chCondWaitS(cp);
 8001e08:	f7ff ffd2 	bl	8001db0 <chCondWaitS>
 8001e0c:	2300      	movs	r3, #0
 8001e0e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  return msg;
}
 8001e12:	bd08      	pop	{r3, pc}
 8001e14:	f3af 8000 	nop.w
 8001e18:	f3af 8000 	nop.w
 8001e1c:	f3af 8000 	nop.w

08001e20 <chCondWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(condition_variable_t *cp, systime_t time) {
 8001e20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001e22:	4c12      	ldr	r4, [pc, #72]	; (8001e6c <chCondWaitTimeoutS+0x4c>)
 8001e24:	69a3      	ldr	r3, [r4, #24]
 8001e26:	6b9e      	ldr	r6, [r3, #56]	; 0x38
 8001e28:	4605      	mov	r5, r0
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 8001e2a:	4630      	mov	r0, r6
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(condition_variable_t *cp, systime_t time) {
 8001e2c:	460f      	mov	r7, r1
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 8001e2e:	f7ff ff0f 	bl	8001c50 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->p_u.wtobjp = cp;
 8001e32:	69a4      	ldr	r4, [r4, #24]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001e34:	462b      	mov	r3, r5
 8001e36:	6225      	str	r5, [r4, #32]
 8001e38:	e003      	b.n	8001e42 <chCondWaitTimeoutS+0x22>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001e3a:	6898      	ldr	r0, [r3, #8]
 8001e3c:	68a2      	ldr	r2, [r4, #8]
 8001e3e:	4290      	cmp	r0, r2
 8001e40:	d302      	bcc.n	8001e48 <chCondWaitTimeoutS+0x28>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8001e42:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001e44:	429d      	cmp	r5, r3
 8001e46:	d1f8      	bne.n	8001e3a <chCondWaitTimeoutS+0x1a>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001e48:	685a      	ldr	r2, [r3, #4]
 8001e4a:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8001e4c:	6023      	str	r3, [r4, #0]
  queue_prio_insert(currp, &cp->c_queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
 8001e4e:	4639      	mov	r1, r7
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 8001e50:	605c      	str	r4, [r3, #4]
 8001e52:	2007      	movs	r0, #7
 8001e54:	6014      	str	r4, [r2, #0]
 8001e56:	f7ff f9c3 	bl	80011e0 <chSchGoSleepTimeoutS>
  if (msg != MSG_TIMEOUT) {
 8001e5a:	1c43      	adds	r3, r0, #1

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->p_u.wtobjp = cp;
  queue_prio_insert(currp, &cp->c_queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
 8001e5c:	4604      	mov	r4, r0
  if (msg != MSG_TIMEOUT) {
 8001e5e:	d002      	beq.n	8001e66 <chCondWaitTimeoutS+0x46>
    chMtxLockS(mp);
 8001e60:	4630      	mov	r0, r6
 8001e62:	f7ff fe35 	bl	8001ad0 <chMtxLockS>
  }

  return msg;
}
 8001e66:	4620      	mov	r0, r4
 8001e68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001e6a:	bf00      	nop
 8001e6c:	20001150 	.word	0x20001150

08001e70 <chCondWaitTimeout>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chCondWaitTimeout(condition_variable_t *cp, systime_t time) {
 8001e70:	b508      	push	{r3, lr}
 8001e72:	2320      	movs	r3, #32
 8001e74:	f383 8811 	msr	BASEPRI, r3
  msg_t msg;

  chSysLock();
  msg = chCondWaitTimeoutS(cp, time);
 8001e78:	f7ff ffd2 	bl	8001e20 <chCondWaitTimeoutS>
 8001e7c:	2300      	movs	r3, #0
 8001e7e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return msg;
}
 8001e82:	bd08      	pop	{r3, pc}
 8001e84:	f3af 8000 	nop.w
 8001e88:	f3af 8000 	nop.w
 8001e8c:	f3af 8000 	nop.w

08001e90 <chEvtRegisterMaskWithFlags>:
 * @api
 */
void chEvtRegisterMaskWithFlags(event_source_t *esp,
                                event_listener_t *elp,
                                eventmask_t events,
                                eventflags_t wflags) {
 8001e90:	b430      	push	{r4, r5}
 8001e92:	2420      	movs	r4, #32
 8001e94:	f384 8811 	msr	BASEPRI, r4
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
 8001e98:	4d06      	ldr	r5, [pc, #24]	; (8001eb4 <chEvtRegisterMaskWithFlags+0x24>)
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 8001e9a:	6804      	ldr	r4, [r0, #0]
  esp->es_next     = elp;
  elp->el_listener = currp;
 8001e9c:	69ad      	ldr	r5, [r5, #24]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 8001e9e:	600c      	str	r4, [r1, #0]
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
  elp->el_flags    = 0;
 8001ea0:	2400      	movs	r4, #0

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
 8001ea2:	6001      	str	r1, [r0, #0]
  elp->el_listener = currp;
 8001ea4:	604d      	str	r5, [r1, #4]
  elp->el_events   = events;
 8001ea6:	608a      	str	r2, [r1, #8]
  elp->el_flags    = 0;
  elp->el_wflags   = wflags;
 8001ea8:	610b      	str	r3, [r1, #16]
  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
  elp->el_flags    = 0;
 8001eaa:	60cc      	str	r4, [r1, #12]
 8001eac:	f384 8811 	msr	BASEPRI, r4
  elp->el_wflags   = wflags;
  chSysUnlock();
}
 8001eb0:	bc30      	pop	{r4, r5}
 8001eb2:	4770      	bx	lr
 8001eb4:	20001150 	.word	0x20001150
 8001eb8:	f3af 8000 	nop.w
 8001ebc:	f3af 8000 	nop.w

08001ec0 <chEvtUnregister>:
 8001ec0:	2320      	movs	r3, #32
 8001ec2:	f383 8811 	msr	BASEPRI, r3
void chEvtUnregister(event_source_t *esp, event_listener_t *elp) {
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));

  p = (event_listener_t *)esp;
 8001ec6:	4602      	mov	r2, r0
 8001ec8:	e002      	b.n	8001ed0 <chEvtUnregister+0x10>
  chSysLock();
  while (p->el_next != (event_listener_t *)esp) {
    if (p->el_next == elp) {
 8001eca:	428b      	cmp	r3, r1
 8001ecc:	d007      	beq.n	8001ede <chEvtUnregister+0x1e>
 8001ece:	461a      	mov	r2, r3

  chDbgCheck((esp != NULL) && (elp != NULL));

  p = (event_listener_t *)esp;
  chSysLock();
  while (p->el_next != (event_listener_t *)esp) {
 8001ed0:	6813      	ldr	r3, [r2, #0]
 8001ed2:	4283      	cmp	r3, r0
 8001ed4:	d1f9      	bne.n	8001eca <chEvtUnregister+0xa>
 8001ed6:	2300      	movs	r3, #0
 8001ed8:	f383 8811 	msr	BASEPRI, r3
 8001edc:	4770      	bx	lr
    if (p->el_next == elp) {
      p->el_next = elp->el_next;
 8001ede:	680b      	ldr	r3, [r1, #0]
 8001ee0:	6013      	str	r3, [r2, #0]
 8001ee2:	2300      	movs	r3, #0
 8001ee4:	f383 8811 	msr	BASEPRI, r3
 8001ee8:	4770      	bx	lr
 8001eea:	bf00      	nop
 8001eec:	f3af 8000 	nop.w

08001ef0 <chEvtGetAndClearEvents>:
 8001ef0:	2320      	movs	r3, #32
 8001ef2:	f383 8811 	msr	BASEPRI, r3
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  eventmask_t m;

  chSysLock();
  m = currp->p_epending & events;
 8001ef6:	4b05      	ldr	r3, [pc, #20]	; (8001f0c <chEvtGetAndClearEvents+0x1c>)
 8001ef8:	699a      	ldr	r2, [r3, #24]
 8001efa:	6b53      	ldr	r3, [r2, #52]	; 0x34
  currp->p_epending &= ~events;
 8001efc:	ea23 0100 	bic.w	r1, r3, r0
 8001f00:	6351      	str	r1, [r2, #52]	; 0x34
 8001f02:	2200      	movs	r2, #0
 8001f04:	f382 8811 	msr	BASEPRI, r2
  chSysUnlock();

  return m;
}
 8001f08:	4018      	ands	r0, r3
 8001f0a:	4770      	bx	lr
 8001f0c:	20001150 	.word	0x20001150

08001f10 <chEvtAddEvents>:
 8001f10:	2320      	movs	r3, #32
 8001f12:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {

  chSysLock();
  events = (currp->p_epending |= events);
 8001f16:	4b04      	ldr	r3, [pc, #16]	; (8001f28 <chEvtAddEvents+0x18>)
 8001f18:	699a      	ldr	r2, [r3, #24]
 8001f1a:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8001f1c:	4318      	orrs	r0, r3
 8001f1e:	6350      	str	r0, [r2, #52]	; 0x34
 8001f20:	2300      	movs	r3, #0
 8001f22:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return events;
}
 8001f26:	4770      	bx	lr
 8001f28:	20001150 	.word	0x20001150
 8001f2c:	f3af 8000 	nop.w

08001f30 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8001f30:	6b43      	ldr	r3, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001f32:	7f02      	ldrb	r2, [r0, #28]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8001f34:	4319      	orrs	r1, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001f36:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8001f38:	6341      	str	r1, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001f3a:	d00a      	beq.n	8001f52 <chEvtSignalI+0x22>
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
 8001f3c:	2a0b      	cmp	r2, #11
 8001f3e:	d000      	beq.n	8001f42 <chEvtSignalI+0x12>
 8001f40:	4770      	bx	lr
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8001f42:	6a03      	ldr	r3, [r0, #32]
 8001f44:	4019      	ands	r1, r3

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8001f46:	428b      	cmp	r3, r1
 8001f48:	d1fa      	bne.n	8001f40 <chEvtSignalI+0x10>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8001f4a:	2300      	movs	r3, #0
 8001f4c:	6203      	str	r3, [r0, #32]
    chSchReadyI(tp);
 8001f4e:	f7ff b917 	b.w	8001180 <chSchReadyI>
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
 8001f52:	6a03      	ldr	r3, [r0, #32]
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001f54:	4219      	tst	r1, r3
 8001f56:	d1f8      	bne.n	8001f4a <chEvtSignalI+0x1a>
 8001f58:	4770      	bx	lr
 8001f5a:	bf00      	nop
 8001f5c:	f3af 8000 	nop.w

08001f60 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8001f60:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8001f62:	6804      	ldr	r4, [r0, #0]
  while (elp != (event_listener_t *)esp) {
 8001f64:	42a0      	cmp	r0, r4
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8001f66:	4606      	mov	r6, r0
 8001f68:	460d      	mov	r5, r1

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  while (elp != (event_listener_t *)esp) {
 8001f6a:	d00d      	beq.n	8001f88 <chEvtBroadcastFlagsI+0x28>
    elp->el_flags |= flags;
 8001f6c:	68e3      	ldr	r3, [r4, #12]
 8001f6e:	432b      	orrs	r3, r5
 8001f70:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == 0) || ((elp->el_flags & elp->el_wflags) != 0)) {
 8001f72:	b115      	cbz	r5, 8001f7a <chEvtBroadcastFlagsI+0x1a>
 8001f74:	6922      	ldr	r2, [r4, #16]
 8001f76:	4213      	tst	r3, r2
 8001f78:	d003      	beq.n	8001f82 <chEvtBroadcastFlagsI+0x22>
      chEvtSignalI(elp->el_listener, elp->el_events);
 8001f7a:	6860      	ldr	r0, [r4, #4]
 8001f7c:	68a1      	ldr	r1, [r4, #8]
 8001f7e:	f7ff ffd7 	bl	8001f30 <chEvtSignalI>
    }
    elp = elp->el_next;
 8001f82:	6824      	ldr	r4, [r4, #0]

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  while (elp != (event_listener_t *)esp) {
 8001f84:	42a6      	cmp	r6, r4
 8001f86:	d1f1      	bne.n	8001f6c <chEvtBroadcastFlagsI+0xc>
 8001f88:	bd70      	pop	{r4, r5, r6, pc}
 8001f8a:	bf00      	nop
 8001f8c:	f3af 8000 	nop.w

08001f90 <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t events) {
 8001f90:	b508      	push	{r3, lr}
 8001f92:	2320      	movs	r3, #32
 8001f94:	f383 8811 	msr	BASEPRI, r3

  chDbgCheck(tp != NULL);

  chSysLock();
  chEvtSignalI(tp, events);
 8001f98:	f7ff ffca 	bl	8001f30 <chEvtSignalI>
  chSchRescheduleS();
 8001f9c:	f7ff f9c8 	bl	8001330 <chSchRescheduleS>
 8001fa0:	2300      	movs	r3, #0
 8001fa2:	f383 8811 	msr	BASEPRI, r3
 8001fa6:	bd08      	pop	{r3, pc}
 8001fa8:	f3af 8000 	nop.w
 8001fac:	f3af 8000 	nop.w

08001fb0 <chEvtBroadcastFlags>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {
 8001fb0:	b508      	push	{r3, lr}
 8001fb2:	2320      	movs	r3, #32
 8001fb4:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 8001fb8:	f7ff ffd2 	bl	8001f60 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 8001fbc:	f7ff f9b8 	bl	8001330 <chSchRescheduleS>
 8001fc0:	2300      	movs	r3, #0
 8001fc2:	f383 8811 	msr	BASEPRI, r3
 8001fc6:	bd08      	pop	{r3, pc}
 8001fc8:	f3af 8000 	nop.w
 8001fcc:	f3af 8000 	nop.w

08001fd0 <chEvtDispatch>:
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
 8001fd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = 0;
  while (events) {
 8001fd2:	460d      	mov	r5, r1
 8001fd4:	b1a9      	cbz	r1, 8002002 <chEvtDispatch+0x32>
 8001fd6:	4607      	mov	r7, r0
 8001fd8:	2400      	movs	r4, #0
    if (events & EVENT_MASK(eid)) {
 8001fda:	2601      	movs	r6, #1
 8001fdc:	fa06 f304 	lsl.w	r3, r6, r4
 8001fe0:	422b      	tst	r3, r5
 8001fe2:	d104      	bne.n	8001fee <chEvtDispatch+0x1e>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
 8001fe4:	3401      	adds	r4, #1

  chDbgCheck(handlers != NULL);

  eid = 0;
  while (events) {
    if (events & EVENT_MASK(eid)) {
 8001fe6:	fa06 f304 	lsl.w	r3, r6, r4
 8001fea:	422b      	tst	r3, r5
 8001fec:	d0fa      	beq.n	8001fe4 <chEvtDispatch+0x14>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
 8001fee:	4620      	mov	r0, r4

  eid = 0;
  while (events) {
    if (events & EVENT_MASK(eid)) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 8001ff0:	ea25 0503 	bic.w	r5, r5, r3
      handlers[eid](eid);
 8001ff4:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
 8001ff8:	4798      	blx	r3
    }
    eid++;
 8001ffa:	3401      	adds	r4, #1
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = 0;
  while (events) {
 8001ffc:	2d00      	cmp	r5, #0
 8001ffe:	d1ed      	bne.n	8001fdc <chEvtDispatch+0xc>
 8002000:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002002:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002004:	f3af 8000 	nop.w
 8002008:	f3af 8000 	nop.w
 800200c:	f3af 8000 	nop.w

08002010 <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 8002010:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8002012:	4b0d      	ldr	r3, [pc, #52]	; (8002048 <chEvtWaitOne+0x38>)
 8002014:	699d      	ldr	r5, [r3, #24]
 8002016:	2320      	movs	r3, #32
 8002018:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  if ((m = (ctp->p_epending & events)) == 0) {
 800201c:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800201e:	ea10 0203 	ands.w	r2, r0, r3
 8002022:	d107      	bne.n	8002034 <chEvtWaitOne+0x24>
 8002024:	4604      	mov	r4, r0
    ctp->p_u.ewmask = events;
 8002026:	6228      	str	r0, [r5, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 8002028:	200a      	movs	r0, #10
 800202a:	f7ff f8c1 	bl	80011b0 <chSchGoSleepS>
    m = ctp->p_epending & events;
 800202e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002030:	ea04 0203 	and.w	r2, r4, r3
  }
  m ^= m & (m - 1);
 8002034:	4250      	negs	r0, r2
 8002036:	4010      	ands	r0, r2
  ctp->p_epending &= ~m;
 8002038:	ea23 0300 	bic.w	r3, r3, r0
 800203c:	636b      	str	r3, [r5, #52]	; 0x34
 800203e:	2300      	movs	r3, #0
 8002040:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8002044:	bd38      	pop	{r3, r4, r5, pc}
 8002046:	bf00      	nop
 8002048:	20001150 	.word	0x20001150
 800204c:	f3af 8000 	nop.w

08002050 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 8002050:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8002052:	4b0c      	ldr	r3, [pc, #48]	; (8002084 <chEvtWaitAny+0x34>)
 8002054:	699d      	ldr	r5, [r3, #24]
 8002056:	2320      	movs	r3, #32
 8002058:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  if ((m = (ctp->p_epending & events)) == 0) {
 800205c:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800205e:	ea10 0403 	ands.w	r4, r0, r3
 8002062:	d106      	bne.n	8002072 <chEvtWaitAny+0x22>
 8002064:	4604      	mov	r4, r0
    ctp->p_u.ewmask = events;
 8002066:	6228      	str	r0, [r5, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 8002068:	200a      	movs	r0, #10
 800206a:	f7ff f8a1 	bl	80011b0 <chSchGoSleepS>
    m = ctp->p_epending & events;
 800206e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002070:	401c      	ands	r4, r3
  }
  ctp->p_epending &= ~m;
 8002072:	ea23 0304 	bic.w	r3, r3, r4
 8002076:	636b      	str	r3, [r5, #52]	; 0x34
 8002078:	2300      	movs	r3, #0
 800207a:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 800207e:	4620      	mov	r0, r4
 8002080:	bd38      	pop	{r3, r4, r5, pc}
 8002082:	bf00      	nop
 8002084:	20001150 	.word	0x20001150
 8002088:	f3af 8000 	nop.w
 800208c:	f3af 8000 	nop.w

08002090 <chEvtWaitAll>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 8002090:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8002092:	4b0c      	ldr	r3, [pc, #48]	; (80020c4 <chEvtWaitAll+0x34>)
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 8002094:	4604      	mov	r4, r0
  thread_t *ctp = currp;
 8002096:	699d      	ldr	r5, [r3, #24]
 8002098:	2320      	movs	r3, #32
 800209a:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if ((ctp->p_epending & events) != events) {
 800209e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80020a0:	ea00 0203 	and.w	r2, r0, r3
 80020a4:	4282      	cmp	r2, r0
 80020a6:	d004      	beq.n	80020b2 <chEvtWaitAll+0x22>
    ctp->p_u.ewmask = events;
 80020a8:	6228      	str	r0, [r5, #32]
    chSchGoSleepS(CH_STATE_WTANDEVT);
 80020aa:	200b      	movs	r0, #11
 80020ac:	f7ff f880 	bl	80011b0 <chSchGoSleepS>
 80020b0:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  }
  ctp->p_epending &= ~events;
 80020b2:	ea23 0304 	bic.w	r3, r3, r4
 80020b6:	636b      	str	r3, [r5, #52]	; 0x34
 80020b8:	2300      	movs	r3, #0
 80020ba:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return events;
}
 80020be:	4620      	mov	r0, r4
 80020c0:	bd38      	pop	{r3, r4, r5, pc}
 80020c2:	bf00      	nop
 80020c4:	20001150 	.word	0x20001150
 80020c8:	f3af 8000 	nop.w
 80020cc:	f3af 8000 	nop.w

080020d0 <chEvtWaitOneTimeout>:
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 80020d0:	4b12      	ldr	r3, [pc, #72]	; (800211c <chEvtWaitOneTimeout+0x4c>)
 * @return              The mask of the lowest event id served and cleared.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
 80020d2:	b570      	push	{r4, r5, r6, lr}
 80020d4:	2220      	movs	r2, #32
  thread_t *ctp = currp;
 80020d6:	699d      	ldr	r5, [r3, #24]
 80020d8:	f382 8811 	msr	BASEPRI, r2
  eventmask_t m;

  chSysLock();
  if ((m = (ctp->p_epending & events)) == 0) {
 80020dc:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 80020de:	ea10 0602 	ands.w	r6, r0, r2
 80020e2:	d10e      	bne.n	8002102 <chEvtWaitOneTimeout+0x32>
    if (TIME_IMMEDIATE == time) {
 80020e4:	b919      	cbnz	r1, 80020ee <chEvtWaitOneTimeout+0x1e>
 80020e6:	f381 8811 	msr	BASEPRI, r1
      chSysUnlock();
      return (eventmask_t)0;
 80020ea:	4608      	mov	r0, r1
 80020ec:	bd70      	pop	{r4, r5, r6, pc}
    }
    ctp->p_u.ewmask = events;
 80020ee:	6228      	str	r0, [r5, #32]
 80020f0:	4604      	mov	r4, r0
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 80020f2:	200a      	movs	r0, #10
 80020f4:	f7ff f874 	bl	80011e0 <chSchGoSleepTimeoutS>
 80020f8:	2800      	cmp	r0, #0
 80020fa:	db0b      	blt.n	8002114 <chEvtWaitOneTimeout+0x44>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
 80020fc:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 80020fe:	ea04 0602 	and.w	r6, r4, r2
  }
  m ^= m & (m - 1);
 8002102:	4270      	negs	r0, r6
 8002104:	4030      	ands	r0, r6
  ctp->p_epending &= ~m;
 8002106:	ea22 0200 	bic.w	r2, r2, r0
 800210a:	636a      	str	r2, [r5, #52]	; 0x34
 800210c:	2300      	movs	r3, #0
 800210e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8002112:	bd70      	pop	{r4, r5, r6, pc}
 8002114:	f386 8811 	msr	BASEPRI, r6
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
      chSysUnlock();
      return (eventmask_t)0;
 8002118:	4630      	mov	r0, r6
 800211a:	bd70      	pop	{r4, r5, r6, pc}
 800211c:	20001150 	.word	0x20001150

08002120 <chEvtWaitAnyTimeout>:
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8002120:	4b12      	ldr	r3, [pc, #72]	; (800216c <chEvtWaitAnyTimeout+0x4c>)
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
 8002122:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8002124:	699e      	ldr	r6, [r3, #24]
 8002126:	2320      	movs	r3, #32
 8002128:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  if ((m = (ctp->p_epending & events)) == 0) {
 800212c:	6b73      	ldr	r3, [r6, #52]	; 0x34
 800212e:	ea10 0403 	ands.w	r4, r0, r3
 8002132:	d10e      	bne.n	8002152 <chEvtWaitAnyTimeout+0x32>
    if (TIME_IMMEDIATE == time) {
 8002134:	b919      	cbnz	r1, 800213e <chEvtWaitAnyTimeout+0x1e>
 8002136:	f381 8811 	msr	BASEPRI, r1
      chSysUnlock();
      return (eventmask_t)0;
 800213a:	4608      	mov	r0, r1
 800213c:	bd70      	pop	{r4, r5, r6, pc}
    }
    ctp->p_u.ewmask = events;
 800213e:	6230      	str	r0, [r6, #32]
 8002140:	4605      	mov	r5, r0
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8002142:	200a      	movs	r0, #10
 8002144:	f7ff f84c 	bl	80011e0 <chSchGoSleepTimeoutS>
 8002148:	2800      	cmp	r0, #0
 800214a:	db0a      	blt.n	8002162 <chEvtWaitAnyTimeout+0x42>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
 800214c:	6b73      	ldr	r3, [r6, #52]	; 0x34
 800214e:	ea05 0403 	and.w	r4, r5, r3
  }
  ctp->p_epending &= ~m;
 8002152:	ea23 0304 	bic.w	r3, r3, r4
 8002156:	6373      	str	r3, [r6, #52]	; 0x34
 8002158:	2300      	movs	r3, #0
 800215a:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
 800215e:	4620      	mov	r0, r4
}
 8002160:	bd70      	pop	{r4, r5, r6, pc}
 8002162:	f384 8811 	msr	BASEPRI, r4
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
      chSysUnlock();
      return (eventmask_t)0;
 8002166:	4620      	mov	r0, r4
 8002168:	bd70      	pop	{r4, r5, r6, pc}
 800216a:	bf00      	nop
 800216c:	20001150 	.word	0x20001150

08002170 <chEvtWaitAllTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
 8002170:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8002172:	4b10      	ldr	r3, [pc, #64]	; (80021b4 <chEvtWaitAllTimeout+0x44>)
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
 8002174:	4604      	mov	r4, r0
  thread_t *ctp = currp;
 8002176:	699d      	ldr	r5, [r3, #24]
 8002178:	2320      	movs	r3, #32
 800217a:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if ((ctp->p_epending & events) != events) {
 800217e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002180:	ea00 0203 	and.w	r2, r0, r3
 8002184:	4282      	cmp	r2, r0
 8002186:	d00b      	beq.n	80021a0 <chEvtWaitAllTimeout+0x30>
 8002188:	4608      	mov	r0, r1
    if (TIME_IMMEDIATE == time) {
 800218a:	b911      	cbnz	r1, 8002192 <chEvtWaitAllTimeout+0x22>
 800218c:	f380 8811 	msr	BASEPRI, r0
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
      chSysUnlock();
      return (eventmask_t)0;
 8002190:	bd38      	pop	{r3, r4, r5, pc}
  if ((ctp->p_epending & events) != events) {
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
 8002192:	622c      	str	r4, [r5, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
 8002194:	200b      	movs	r0, #11
 8002196:	f7ff f823 	bl	80011e0 <chSchGoSleepTimeoutS>
 800219a:	2800      	cmp	r0, #0
 800219c:	db08      	blt.n	80021b0 <chEvtWaitAllTimeout+0x40>
 800219e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->p_epending &= ~events;
 80021a0:	ea23 0304 	bic.w	r3, r3, r4
 80021a4:	636b      	str	r3, [r5, #52]	; 0x34
 80021a6:	2300      	movs	r3, #0
 80021a8:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return events;
 80021ac:	4620      	mov	r0, r4
}
 80021ae:	bd38      	pop	{r3, r4, r5, pc}
 80021b0:	2000      	movs	r0, #0
 80021b2:	e7eb      	b.n	800218c <chEvtWaitAllTimeout+0x1c>
 80021b4:	20001150 	.word	0x20001150
 80021b8:	f3af 8000 	nop.w
 80021bc:	f3af 8000 	nop.w

080021c0 <chMsgSend>:
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
  thread_t *ctp = currp;
 80021c0:	4b0e      	ldr	r3, [pc, #56]	; (80021fc <chMsgSend+0x3c>)
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 80021c2:	b570      	push	{r4, r5, r6, lr}
 80021c4:	2220      	movs	r2, #32
  thread_t *ctp = currp;
 80021c6:	699c      	ldr	r4, [r3, #24]
 80021c8:	f382 8811 	msr	BASEPRI, r2

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
 80021cc:	f100 0528 	add.w	r5, r0, #40	; 0x28
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == CH_STATE_WTMSG) {
 80021d0:	7f06      	ldrb	r6, [r0, #28]

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
 80021d2:	6225      	str	r5, [r4, #32]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 80021d4:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 80021d6:	6062      	str	r2, [r4, #4]
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == CH_STATE_WTMSG) {
 80021d8:	2e0e      	cmp	r6, #14
  thread_t *ctp = currp;

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->p_msg = msg;
 80021da:	6321      	str	r1, [r4, #48]	; 0x30
  tp->p_prev->p_next = cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 80021dc:	6025      	str	r5, [r4, #0]
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
 80021de:	62c4      	str	r4, [r0, #44]	; 0x2c
 80021e0:	6014      	str	r4, [r2, #0]
  ctp->p_u.wtobjp = &tp->p_msgqueue;
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == CH_STATE_WTMSG) {
 80021e2:	d007      	beq.n	80021f4 <chMsgSend+0x34>
    chSchReadyI(tp);
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 80021e4:	200c      	movs	r0, #12
 80021e6:	f7fe ffe3 	bl	80011b0 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 80021ea:	6a20      	ldr	r0, [r4, #32]
 80021ec:	2300      	movs	r3, #0
 80021ee:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return msg;
}
 80021f2:	bd70      	pop	{r4, r5, r6, pc}
  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == CH_STATE_WTMSG) {
    chSchReadyI(tp);
 80021f4:	f7fe ffc4 	bl	8001180 <chSchReadyI>
 80021f8:	e7f4      	b.n	80021e4 <chMsgSend+0x24>
 80021fa:	bf00      	nop
 80021fc:	20001150 	.word	0x20001150

08002200 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 8002200:	b510      	push	{r4, lr}
 8002202:	2320      	movs	r3, #32
 8002204:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
 8002208:	4c0b      	ldr	r4, [pc, #44]	; (8002238 <chMsgWait+0x38>)
 800220a:	69a2      	ldr	r2, [r4, #24]
 */
static inline bool chMsgIsPendingI(thread_t *tp) {

  chDbgCheckClassI();

  return (bool)(tp->p_msgqueue.p_next != (thread_t *)&tp->p_msgqueue);
 800220c:	4613      	mov	r3, r2
 800220e:	f853 0f28 	ldr.w	r0, [r3, #40]!
 8002212:	4298      	cmp	r0, r3
 8002214:	d008      	beq.n	8002228 <chMsgWait+0x28>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8002216:	6801      	ldr	r1, [r0, #0]
 8002218:	6291      	str	r1, [r2, #40]	; 0x28
    chSchGoSleepS(CH_STATE_WTMSG);
  }
  tp = queue_fifo_remove(&currp->p_msgqueue);
  tp->p_state = CH_STATE_SNDMSG;
 800221a:	220d      	movs	r2, #13
 800221c:	604b      	str	r3, [r1, #4]
 800221e:	2300      	movs	r3, #0
 8002220:	7702      	strb	r2, [r0, #28]
 8002222:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 8002226:	bd10      	pop	{r4, pc}
thread_t *chMsgWait(void) {
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
    chSchGoSleepS(CH_STATE_WTMSG);
 8002228:	200e      	movs	r0, #14
 800222a:	f7fe ffc1 	bl	80011b0 <chSchGoSleepS>
 800222e:	69a2      	ldr	r2, [r4, #24]
 8002230:	6a90      	ldr	r0, [r2, #40]	; 0x28
 8002232:	f102 0328 	add.w	r3, r2, #40	; 0x28
 8002236:	e7ee      	b.n	8002216 <chMsgWait+0x16>
 8002238:	20001150 	.word	0x20001150
 800223c:	f3af 8000 	nop.w

08002240 <chMsgRelease>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @api
 */
void chMsgRelease(thread_t *tp, msg_t msg) {
 8002240:	b508      	push	{r3, lr}
 8002242:	2320      	movs	r3, #32
 8002244:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 8002248:	f7fe fff2 	bl	8001230 <chSchWakeupS>
 800224c:	2300      	movs	r3, #0
 800224e:	f383 8811 	msr	BASEPRI, r3
 8002252:	bd08      	pop	{r3, pc}
 8002254:	f3af 8000 	nop.w
 8002258:	f3af 8000 	nop.w
 800225c:	f3af 8000 	nop.w

08002260 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
 8002260:	b510      	push	{r4, lr}
 8002262:	460b      	mov	r3, r1

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > 0));

  mbp->mb_buffer = mbp->mb_wrptr = mbp->mb_rdptr = buf;
  mbp->mb_top = &buf[n];
 8002264:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 8002268:	6041      	str	r1, [r0, #4]
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
 800226a:	4604      	mov	r4, r0

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > 0));

  mbp->mb_buffer = mbp->mb_wrptr = mbp->mb_rdptr = buf;
 800226c:	60c3      	str	r3, [r0, #12]
 800226e:	6083      	str	r3, [r0, #8]
 8002270:	6003      	str	r3, [r0, #0]
  mbp->mb_top = &buf[n];
  chSemObjectInit(&mbp->mb_emptysem, n);
 8002272:	4611      	mov	r1, r2
 8002274:	301c      	adds	r0, #28
 8002276:	f7ff fb1b 	bl	80018b0 <chSemObjectInit>
  chSemObjectInit(&mbp->mb_fullsem, 0);
 800227a:	f104 0010 	add.w	r0, r4, #16
 800227e:	2100      	movs	r1, #0
}
 8002280:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > 0));

  mbp->mb_buffer = mbp->mb_wrptr = mbp->mb_rdptr = buf;
  mbp->mb_top = &buf[n];
  chSemObjectInit(&mbp->mb_emptysem, n);
  chSemObjectInit(&mbp->mb_fullsem, 0);
 8002284:	f7ff bb14 	b.w	80018b0 <chSemObjectInit>
 8002288:	f3af 8000 	nop.w
 800228c:	f3af 8000 	nop.w

08002290 <chMBResetI>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBResetI(mailbox_t *mbp) {
 8002290:	b510      	push	{r4, lr}
 8002292:	4604      	mov	r4, r0

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_rdptr = mbp->mb_buffer;
  chSemResetI(&mbp->mb_emptysem, mbp->mb_top - mbp->mb_buffer);
 8002294:	301c      	adds	r0, #28
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_rdptr = mbp->mb_buffer;
 8002296:	6823      	ldr	r3, [r4, #0]
  chSemResetI(&mbp->mb_emptysem, mbp->mb_top - mbp->mb_buffer);
 8002298:	6861      	ldr	r1, [r4, #4]
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_rdptr = mbp->mb_buffer;
 800229a:	60e3      	str	r3, [r4, #12]
  chSemResetI(&mbp->mb_emptysem, mbp->mb_top - mbp->mb_buffer);
 800229c:	1ac9      	subs	r1, r1, r3
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_rdptr = mbp->mb_buffer;
 800229e:	60a3      	str	r3, [r4, #8]
  chSemResetI(&mbp->mb_emptysem, mbp->mb_top - mbp->mb_buffer);
 80022a0:	1089      	asrs	r1, r1, #2
 80022a2:	f7ff fb0d 	bl	80018c0 <chSemResetI>
  chSemResetI(&mbp->mb_fullsem, 0);
 80022a6:	f104 0010 	add.w	r0, r4, #16
 80022aa:	2100      	movs	r1, #0
}
 80022ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_rdptr = mbp->mb_buffer;
  chSemResetI(&mbp->mb_emptysem, mbp->mb_top - mbp->mb_buffer);
  chSemResetI(&mbp->mb_fullsem, 0);
 80022b0:	f7ff bb06 	b.w	80018c0 <chSemResetI>
 80022b4:	f3af 8000 	nop.w
 80022b8:	f3af 8000 	nop.w
 80022bc:	f3af 8000 	nop.w

080022c0 <chMBReset>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBReset(mailbox_t *mbp) {
 80022c0:	b508      	push	{r3, lr}
 80022c2:	2320      	movs	r3, #32
 80022c4:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chMBResetI(mbp);
 80022c8:	f7ff ffe2 	bl	8002290 <chMBResetI>
  chSchRescheduleS();
 80022cc:	f7ff f830 	bl	8001330 <chSchRescheduleS>
 80022d0:	2300      	movs	r3, #0
 80022d2:	f383 8811 	msr	BASEPRI, r3
 80022d6:	bd08      	pop	{r3, pc}
 80022d8:	f3af 8000 	nop.w
 80022dc:	f3af 8000 	nop.w

080022e0 <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t time) {
 80022e0:	b570      	push	{r4, r5, r6, lr}
 80022e2:	4604      	mov	r4, r0
 80022e4:	460e      	mov	r6, r1
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
 80022e6:	301c      	adds	r0, #28
 80022e8:	4611      	mov	r1, r2
 80022ea:	f7ff fb39 	bl	8001960 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 80022ee:	4605      	mov	r5, r0
 80022f0:	b978      	cbnz	r0, 8002312 <chMBPostS+0x32>
    *mbp->mb_wrptr++ = msg;
 80022f2:	68a2      	ldr	r2, [r4, #8]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 80022f4:	6861      	ldr	r1, [r4, #4]
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 80022f6:	1d13      	adds	r3, r2, #4
    if (mbp->mb_wrptr >= mbp->mb_top) {
 80022f8:	428b      	cmp	r3, r1
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 80022fa:	60a3      	str	r3, [r4, #8]
    if (mbp->mb_wrptr >= mbp->mb_top) {
      mbp->mb_wrptr = mbp->mb_buffer;
 80022fc:	bf28      	it	cs
 80022fe:	6823      	ldrcs	r3, [r4, #0]
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 8002300:	6016      	str	r6, [r2, #0]
    if (mbp->mb_wrptr >= mbp->mb_top) {
      mbp->mb_wrptr = mbp->mb_buffer;
    }
    chSemSignalI(&mbp->mb_fullsem);
 8002302:	f104 0010 	add.w	r0, r4, #16

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
    if (mbp->mb_wrptr >= mbp->mb_top) {
      mbp->mb_wrptr = mbp->mb_buffer;
 8002306:	bf28      	it	cs
 8002308:	60a3      	strcs	r3, [r4, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
 800230a:	f7ff fb79 	bl	8001a00 <chSemSignalI>
    chSchRescheduleS();
 800230e:	f7ff f80f 	bl	8001330 <chSchRescheduleS>
  }

  return rdymsg;
}
 8002312:	4628      	mov	r0, r5
 8002314:	bd70      	pop	{r4, r5, r6, pc}
 8002316:	bf00      	nop
 8002318:	f3af 8000 	nop.w
 800231c:	f3af 8000 	nop.w

08002320 <chMBPost>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t time) {
 8002320:	b508      	push	{r3, lr}
 8002322:	2320      	movs	r3, #32
 8002324:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chSysLock();
  rdymsg = chMBPostS(mbp, msg, time);
 8002328:	f7ff ffda 	bl	80022e0 <chMBPostS>
 800232c:	2300      	movs	r3, #0
 800232e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return rdymsg;
}
 8002332:	bd08      	pop	{r3, pc}
 8002334:	f3af 8000 	nop.w
 8002338:	f3af 8000 	nop.w
 800233c:	f3af 8000 	nop.w

08002340 <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8002340:	b538      	push	{r3, r4, r5, lr}
 8002342:	6a43      	ldr	r3, [r0, #36]	; 0x24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0) {
 8002344:	2b00      	cmp	r3, #0
 8002346:	dd12      	ble.n	800236e <chMBPostI+0x2e>
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 8002348:	6884      	ldr	r4, [r0, #8]
  if (mbp->mb_wrptr >= mbp->mb_top) {
 800234a:	6845      	ldr	r5, [r0, #4]
  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 800234c:	1d22      	adds	r2, r4, #4
 */
static inline void chSemFastWaitI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt--;
 800234e:	3b01      	subs	r3, #1
  if (mbp->mb_wrptr >= mbp->mb_top) {
 8002350:	42aa      	cmp	r2, r5
 8002352:	6243      	str	r3, [r0, #36]	; 0x24
    mbp->mb_wrptr = mbp->mb_buffer;
 8002354:	bf28      	it	cs
 8002356:	6803      	ldrcs	r3, [r0, #0]
  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 8002358:	6082      	str	r2, [r0, #8]
 800235a:	6021      	str	r1, [r4, #0]
  if (mbp->mb_wrptr >= mbp->mb_top) {
    mbp->mb_wrptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_fullsem);
 800235c:	f100 0010 	add.w	r0, r0, #16
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
  if (mbp->mb_wrptr >= mbp->mb_top) {
    mbp->mb_wrptr = mbp->mb_buffer;
 8002360:	bf28      	it	cs
 8002362:	f840 3c08 	strcs.w	r3, [r0, #-8]
  }
  chSemSignalI(&mbp->mb_fullsem);
 8002366:	f7ff fb4b 	bl	8001a00 <chSemSignalI>

  return MSG_OK;
 800236a:	2000      	movs	r0, #0
 800236c:	bd38      	pop	{r3, r4, r5, pc}

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0) {
    return MSG_TIMEOUT;
 800236e:	f04f 30ff 	mov.w	r0, #4294967295
    mbp->mb_wrptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_fullsem);

  return MSG_OK;
}
 8002372:	bd38      	pop	{r3, r4, r5, pc}
 8002374:	f3af 8000 	nop.w
 8002378:	f3af 8000 	nop.w
 800237c:	f3af 8000 	nop.w

08002380 <chMBPostAheadS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostAheadS(mailbox_t *mbp, msg_t msg, systime_t time) {
 8002380:	b570      	push	{r4, r5, r6, lr}
 8002382:	4604      	mov	r4, r0
 8002384:	460e      	mov	r6, r1
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
 8002386:	301c      	adds	r0, #28
 8002388:	4611      	mov	r1, r2
 800238a:	f7ff fae9 	bl	8001960 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 800238e:	4605      	mov	r5, r0
 8002390:	b960      	cbnz	r0, 80023ac <chMBPostAheadS+0x2c>
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
 8002392:	68e3      	ldr	r3, [r4, #12]
 8002394:	6822      	ldr	r2, [r4, #0]
 8002396:	3b04      	subs	r3, #4
 8002398:	4293      	cmp	r3, r2
 800239a:	60e3      	str	r3, [r4, #12]
 800239c:	d308      	bcc.n	80023b0 <chMBPostAheadS+0x30>
      mbp->mb_rdptr = mbp->mb_top - 1;
    }
    *mbp->mb_rdptr = msg;
 800239e:	601e      	str	r6, [r3, #0]
    chSemSignalI(&mbp->mb_fullsem);
 80023a0:	f104 0010 	add.w	r0, r4, #16
 80023a4:	f7ff fb2c 	bl	8001a00 <chSemSignalI>
    chSchRescheduleS();
 80023a8:	f7fe ffc2 	bl	8001330 <chSchRescheduleS>
  }

  return rdymsg;
}
 80023ac:	4628      	mov	r0, r5
 80023ae:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, time);
  if (rdymsg == MSG_OK) {
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
      mbp->mb_rdptr = mbp->mb_top - 1;
 80023b0:	6863      	ldr	r3, [r4, #4]
 80023b2:	3b04      	subs	r3, #4
 80023b4:	60e3      	str	r3, [r4, #12]
 80023b6:	e7f2      	b.n	800239e <chMBPostAheadS+0x1e>
 80023b8:	f3af 8000 	nop.w
 80023bc:	f3af 8000 	nop.w

080023c0 <chMBPostAhead>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t time) {
 80023c0:	b508      	push	{r3, lr}
 80023c2:	2320      	movs	r3, #32
 80023c4:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chSysLock();
  rdymsg = chMBPostAheadS(mbp, msg, time);
 80023c8:	f7ff ffda 	bl	8002380 <chMBPostAheadS>
 80023cc:	2300      	movs	r3, #0
 80023ce:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return rdymsg;
}
 80023d2:	bd08      	pop	{r3, pc}
 80023d4:	f3af 8000 	nop.w
 80023d8:	f3af 8000 	nop.w
 80023dc:	f3af 8000 	nop.w

080023e0 <chMBPostAheadI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 80023e0:	6a42      	ldr	r2, [r0, #36]	; 0x24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0) {
 80023e2:	2a00      	cmp	r2, #0
 80023e4:	dd11      	ble.n	800240a <chMBPostAheadI+0x2a>
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
 80023e6:	68c3      	ldr	r3, [r0, #12]
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 80023e8:	b510      	push	{r4, lr}

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
 80023ea:	6804      	ldr	r4, [r0, #0]
 80023ec:	3b04      	subs	r3, #4
 80023ee:	3a01      	subs	r2, #1
 80023f0:	42a3      	cmp	r3, r4
 80023f2:	6242      	str	r2, [r0, #36]	; 0x24
 80023f4:	60c3      	str	r3, [r0, #12]
 80023f6:	d202      	bcs.n	80023fe <chMBPostAheadI+0x1e>
    mbp->mb_rdptr = mbp->mb_top - 1;
 80023f8:	6843      	ldr	r3, [r0, #4]
 80023fa:	3b04      	subs	r3, #4
 80023fc:	60c3      	str	r3, [r0, #12]
  }
  *mbp->mb_rdptr = msg;
 80023fe:	6019      	str	r1, [r3, #0]
  chSemSignalI(&mbp->mb_fullsem);
 8002400:	3010      	adds	r0, #16
 8002402:	f7ff fafd 	bl	8001a00 <chSemSignalI>

  return MSG_OK;
 8002406:	2000      	movs	r0, #0
 8002408:	bd10      	pop	{r4, pc}

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= 0) {
    return MSG_TIMEOUT;
 800240a:	f04f 30ff 	mov.w	r0, #4294967295
 800240e:	4770      	bx	lr

08002410 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t time) {
 8002410:	b570      	push	{r4, r5, r6, lr}
 8002412:	4604      	mov	r4, r0
 8002414:	460e      	mov	r6, r1
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, time);
 8002416:	3010      	adds	r0, #16
 8002418:	4611      	mov	r1, r2
 800241a:	f7ff faa1 	bl	8001960 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 800241e:	4605      	mov	r5, r0
 8002420:	b980      	cbnz	r0, 8002444 <chMBFetchS+0x34>
    *msgp = *mbp->mb_rdptr++;
 8002422:	68e3      	ldr	r3, [r4, #12]
    if (mbp->mb_rdptr >= mbp->mb_top) {
 8002424:	6862      	ldr	r2, [r4, #4]
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, time);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
 8002426:	6819      	ldr	r1, [r3, #0]
 8002428:	3304      	adds	r3, #4
    if (mbp->mb_rdptr >= mbp->mb_top) {
 800242a:	4293      	cmp	r3, r2
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, time);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
 800242c:	60e3      	str	r3, [r4, #12]
    if (mbp->mb_rdptr >= mbp->mb_top) {
      mbp->mb_rdptr = mbp->mb_buffer;
 800242e:	bf28      	it	cs
 8002430:	6823      	ldrcs	r3, [r4, #0]
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, time);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
 8002432:	6031      	str	r1, [r6, #0]
    if (mbp->mb_rdptr >= mbp->mb_top) {
      mbp->mb_rdptr = mbp->mb_buffer;
    }
    chSemSignalI(&mbp->mb_emptysem);
 8002434:	f104 001c 	add.w	r0, r4, #28

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, time);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
    if (mbp->mb_rdptr >= mbp->mb_top) {
      mbp->mb_rdptr = mbp->mb_buffer;
 8002438:	bf28      	it	cs
 800243a:	60e3      	strcs	r3, [r4, #12]
    }
    chSemSignalI(&mbp->mb_emptysem);
 800243c:	f7ff fae0 	bl	8001a00 <chSemSignalI>
    chSchRescheduleS();
 8002440:	f7fe ff76 	bl	8001330 <chSchRescheduleS>
  }

  return rdymsg;
}
 8002444:	4628      	mov	r0, r5
 8002446:	bd70      	pop	{r4, r5, r6, pc}
 8002448:	f3af 8000 	nop.w
 800244c:	f3af 8000 	nop.w

08002450 <chMBFetch>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t time) {
 8002450:	b508      	push	{r3, lr}
 8002452:	2320      	movs	r3, #32
 8002454:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chSysLock();
  rdymsg = chMBFetchS(mbp, msgp, time);
 8002458:	f7ff ffda 	bl	8002410 <chMBFetchS>
 800245c:	2300      	movs	r3, #0
 800245e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return rdymsg;
}
 8002462:	bd08      	pop	{r3, pc}
 8002464:	f3af 8000 	nop.w
 8002468:	f3af 8000 	nop.w
 800246c:	f3af 8000 	nop.w

08002470 <chMBFetchI>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8002470:	6983      	ldr	r3, [r0, #24]

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->mb_fullsem) <= 0) {
 8002472:	2b00      	cmp	r3, #0
 8002474:	dd14      	ble.n	80024a0 <chMBFetchI+0x30>
 8002476:	1e5a      	subs	r2, r3, #1
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
 8002478:	68c3      	ldr	r3, [r0, #12]
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 800247a:	b510      	push	{r4, lr}
 800247c:	6182      	str	r2, [r0, #24]
  if (chSemGetCounterI(&mbp->mb_fullsem) <= 0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
  if (mbp->mb_rdptr >= mbp->mb_top) {
 800247e:	6842      	ldr	r2, [r0, #4]

  if (chSemGetCounterI(&mbp->mb_fullsem) <= 0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
 8002480:	681c      	ldr	r4, [r3, #0]
 8002482:	3304      	adds	r3, #4
  if (mbp->mb_rdptr >= mbp->mb_top) {
 8002484:	4293      	cmp	r3, r2

  if (chSemGetCounterI(&mbp->mb_fullsem) <= 0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
 8002486:	60c3      	str	r3, [r0, #12]
  if (mbp->mb_rdptr >= mbp->mb_top) {
    mbp->mb_rdptr = mbp->mb_buffer;
 8002488:	bf28      	it	cs
 800248a:	6803      	ldrcs	r3, [r0, #0]

  if (chSemGetCounterI(&mbp->mb_fullsem) <= 0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
 800248c:	600c      	str	r4, [r1, #0]
  if (mbp->mb_rdptr >= mbp->mb_top) {
    mbp->mb_rdptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_emptysem);
 800248e:	f100 001c 	add.w	r0, r0, #28
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
  if (mbp->mb_rdptr >= mbp->mb_top) {
    mbp->mb_rdptr = mbp->mb_buffer;
 8002492:	bf28      	it	cs
 8002494:	f840 3c10 	strcs.w	r3, [r0, #-16]
  }
  chSemSignalI(&mbp->mb_emptysem);
 8002498:	f7ff fab2 	bl	8001a00 <chSemSignalI>

  return MSG_OK;
 800249c:	2000      	movs	r0, #0
 800249e:	bd10      	pop	{r4, pc}

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->mb_fullsem) <= 0) {
    return MSG_TIMEOUT;
 80024a0:	f04f 30ff 	mov.w	r0, #4294967295
 80024a4:	4770      	bx	lr
 80024a6:	bf00      	nop
 80024a8:	f3af 8000 	nop.w
 80024ac:	f3af 8000 	nop.w

080024b0 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 80024b0:	b430      	push	{r4, r5}
 80024b2:	9c02      	ldr	r4, [sp, #8]
  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
  iqp->q_top = bp + size;
  iqp->q_notify = infy;
  iqp->q_link = link;
 80024b4:	6204      	str	r4, [r0, #32]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 80024b6:	2500      	movs	r5, #0
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
  iqp->q_top = bp + size;
 80024b8:	440a      	add	r2, r1
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 80024ba:	6085      	str	r5, [r0, #8]
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
  iqp->q_top = bp + size;
 80024bc:	6102      	str	r2, [r0, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 80024be:	6040      	str	r0, [r0, #4]
 80024c0:	6000      	str	r0, [r0, #0]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
 80024c2:	6141      	str	r1, [r0, #20]
 80024c4:	6181      	str	r1, [r0, #24]
 80024c6:	60c1      	str	r1, [r0, #12]
  iqp->q_top = bp + size;
  iqp->q_notify = infy;
 80024c8:	61c3      	str	r3, [r0, #28]
  iqp->q_link = link;
}
 80024ca:	bc30      	pop	{r4, r5}
 80024cc:	4770      	bx	lr
 80024ce:	bf00      	nop

080024d0 <chIQResetI>:
void chIQResetI(input_queue_t *iqp) {

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
 80024d0:	2100      	movs	r1, #0
 */
void chIQResetI(input_queue_t *iqp) {

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_wrptr = iqp->q_buffer;
 80024d2:	68c2      	ldr	r2, [r0, #12]
  iqp->q_counter = 0;
 80024d4:	6081      	str	r1, [r0, #8]
 */
void chIQResetI(input_queue_t *iqp) {

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_wrptr = iqp->q_buffer;
 80024d6:	6142      	str	r2, [r0, #20]
 80024d8:	6182      	str	r2, [r0, #24]
  iqp->q_counter = 0;
  chThdDequeueAllI(&iqp->q_waiting, Q_RESET);
 80024da:	f06f 0101 	mvn.w	r1, #1
 80024de:	f7ff b927 	b.w	8001730 <chThdDequeueAllI>
 80024e2:	bf00      	nop
 80024e4:	f3af 8000 	nop.w
 80024e8:	f3af 8000 	nop.w
 80024ec:	f3af 8000 	nop.w

080024f0 <chIQPutI>:
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0));
 80024f0:	6983      	ldr	r3, [r0, #24]
 80024f2:	6942      	ldr	r2, [r0, #20]
 80024f4:	429a      	cmp	r2, r3
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 80024f6:	b510      	push	{r4, lr}
 80024f8:	6883      	ldr	r3, [r0, #8]
 80024fa:	d00f      	beq.n	800251c <chIQPutI+0x2c>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 80024fc:	3301      	adds	r3, #1
  *iqp->q_wrptr++ = b;
 80024fe:	1c54      	adds	r4, r2, #1

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8002500:	6083      	str	r3, [r0, #8]
  *iqp->q_wrptr++ = b;
 8002502:	6144      	str	r4, [r0, #20]
 8002504:	7011      	strb	r1, [r2, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8002506:	6942      	ldr	r2, [r0, #20]
 8002508:	6903      	ldr	r3, [r0, #16]
 800250a:	429a      	cmp	r2, r3
 800250c:	d301      	bcc.n	8002512 <chIQPutI+0x22>
    iqp->q_wrptr = iqp->q_buffer;
 800250e:	68c3      	ldr	r3, [r0, #12]
 8002510:	6143      	str	r3, [r0, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 8002512:	2100      	movs	r1, #0
 8002514:	f7ff f8fc 	bl	8001710 <chThdDequeueNextI>

  return Q_OK;
 8002518:	2000      	movs	r0, #0
 800251a:	bd10      	pop	{r4, pc}
 800251c:	2b00      	cmp	r3, #0
 800251e:	d0ed      	beq.n	80024fc <chIQPutI+0xc>
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
 8002520:	f06f 0003 	mvn.w	r0, #3
 8002524:	bd10      	pop	{r4, pc}
 8002526:	bf00      	nop
 8002528:	f3af 8000 	nop.w
 800252c:	f3af 8000 	nop.w

08002530 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t time) {
 8002530:	b570      	push	{r4, r5, r6, lr}
 8002532:	2320      	movs	r3, #32
 8002534:	460e      	mov	r6, r1
 8002536:	4604      	mov	r4, r0
 8002538:	f383 8811 	msr	BASEPRI, r3
  uint8_t b;

  chSysLock();
  if (iqp->q_notify) {
 800253c:	69c3      	ldr	r3, [r0, #28]
 800253e:	b12b      	cbz	r3, 800254c <chIQGetTimeout+0x1c>
    iqp->q_notify(iqp);
 8002540:	4798      	blx	r3
 8002542:	e003      	b.n	800254c <chIQGetTimeout+0x1c>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg;
    if ((msg = chThdEnqueueTimeoutS(&iqp->q_waiting, time)) < Q_OK) {
 8002544:	f7ff f8cc 	bl	80016e0 <chThdEnqueueTimeoutS>
 8002548:	2800      	cmp	r0, #0
 800254a:	db15      	blt.n	8002578 <chIQGetTimeout+0x48>
 800254c:	68a5      	ldr	r5, [r4, #8]
 800254e:	4620      	mov	r0, r4
 8002550:	4631      	mov	r1, r6
  chSysLock();
  if (iqp->q_notify) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 8002552:	2d00      	cmp	r5, #0
 8002554:	d0f6      	beq.n	8002544 <chIQGetTimeout+0x14>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8002556:	69a2      	ldr	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
 8002558:	6921      	ldr	r1, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800255a:	1c53      	adds	r3, r2, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 800255c:	428b      	cmp	r3, r1
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 800255e:	f105 35ff 	add.w	r5, r5, #4294967295
  b = *iqp->q_rdptr++;
 8002562:	61a3      	str	r3, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8002564:	60a5      	str	r5, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8002566:	bf28      	it	cs
 8002568:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800256a:	7810      	ldrb	r0, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 800256c:	bf28      	it	cs
 800256e:	61a3      	strcs	r3, [r4, #24]
 8002570:	2300      	movs	r3, #0
 8002572:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return b;
}
 8002576:	bd70      	pop	{r4, r5, r6, pc}
 8002578:	f385 8811 	msr	BASEPRI, r5

  while (chIQIsEmptyI(iqp)) {
    msg_t msg;
    if ((msg = chThdEnqueueTimeoutS(&iqp->q_waiting, time)) < Q_OK) {
      chSysUnlock();
      return msg;
 800257c:	bd70      	pop	{r4, r5, r6, pc}
 800257e:	bf00      	nop

08002580 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t time) {
 8002580:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002584:	4604      	mov	r4, r0
 8002586:	b083      	sub	sp, #12
 8002588:	4689      	mov	r9, r1
 800258a:	4693      	mov	fp, r2
 800258c:	461d      	mov	r5, r3
  qnotify_t nfy = iqp->q_notify;
 800258e:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8002592:	2720      	movs	r7, #32
 8002594:	f387 8811 	msr	BASEPRI, r7
  size_t r = 0;
 8002598:	2600      	movs	r6, #0
 800259a:	9701      	str	r7, [sp, #4]
 800259c:	46b2      	mov	sl, r6

  chDbgCheck(n > 0);

  chSysLock();
  while (true) {
    if (nfy) {
 800259e:	f1b8 0f00 	cmp.w	r8, #0
 80025a2:	d005      	beq.n	80025b0 <chIQReadTimeout+0x30>
      nfy(iqp);
 80025a4:	4620      	mov	r0, r4
 80025a6:	47c0      	blx	r8
 80025a8:	e002      	b.n	80025b0 <chIQReadTimeout+0x30>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, time) != Q_OK) {
 80025aa:	f7ff f899 	bl	80016e0 <chThdEnqueueTimeoutS>
 80025ae:	b9d8      	cbnz	r0, 80025e8 <chIQReadTimeout+0x68>
 80025b0:	68a7      	ldr	r7, [r4, #8]
 80025b2:	4620      	mov	r0, r4
 80025b4:	4629      	mov	r1, r5
  while (true) {
    if (nfy) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 80025b6:	2f00      	cmp	r7, #0
 80025b8:	d0f7      	beq.n	80025aa <chIQReadTimeout+0x2a>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 80025ba:	69a2      	ldr	r2, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 80025bc:	1e7b      	subs	r3, r7, #1
    *bp++ = *iqp->q_rdptr++;
 80025be:	1c51      	adds	r1, r2, #1
 80025c0:	61a1      	str	r1, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 80025c2:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 80025c4:	7813      	ldrb	r3, [r2, #0]
 80025c6:	f809 3b01 	strb.w	r3, [r9], #1
    if (iqp->q_rdptr >= iqp->q_top)
 80025ca:	6923      	ldr	r3, [r4, #16]
 80025cc:	69a2      	ldr	r2, [r4, #24]
 80025ce:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 80025d0:	bf24      	itt	cs
 80025d2:	68e3      	ldrcs	r3, [r4, #12]
 80025d4:	61a3      	strcs	r3, [r4, #24]
 80025d6:	f38a 8811 	msr	BASEPRI, sl

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    r++;
 80025da:	3601      	adds	r6, #1
    if (--n == 0) {
 80025dc:	45b3      	cmp	fp, r6
 80025de:	d005      	beq.n	80025ec <chIQReadTimeout+0x6c>
 80025e0:	9b01      	ldr	r3, [sp, #4]
 80025e2:	f383 8811 	msr	BASEPRI, r3
 80025e6:	e7da      	b.n	800259e <chIQReadTimeout+0x1e>
 80025e8:	f387 8811 	msr	BASEPRI, r7
      return r;
    }

    chSysLock();
  }
}
 80025ec:	4630      	mov	r0, r6
 80025ee:	b003      	add	sp, #12
 80025f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80025f4:	f3af 8000 	nop.w
 80025f8:	f3af 8000 	nop.w
 80025fc:	f3af 8000 	nop.w

08002600 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 8002600:	b430      	push	{r4, r5}
 8002602:	9c02      	ldr	r4, [sp, #8]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
  oqp->q_top = bp + size;
  oqp->q_notify = onfy;
  oqp->q_link = link;
 8002604:	6204      	str	r4, [r0, #32]
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
  oqp->q_top = bp + size;
 8002606:	188d      	adds	r5, r1, r2
 8002608:	6105      	str	r5, [r0, #16]
 800260a:	6040      	str	r0, [r0, #4]
 800260c:	6000      	str	r0, [r0, #0]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 800260e:	6082      	str	r2, [r0, #8]
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
 8002610:	6141      	str	r1, [r0, #20]
 8002612:	6181      	str	r1, [r0, #24]
 8002614:	60c1      	str	r1, [r0, #12]
  oqp->q_top = bp + size;
  oqp->q_notify = onfy;
 8002616:	61c3      	str	r3, [r0, #28]
  oqp->q_link = link;
}
 8002618:	bc30      	pop	{r4, r5}
 800261a:	4770      	bx	lr
 800261c:	f3af 8000 	nop.w

08002620 <chOQResetI>:
 *
 * @param[in] oqp       pointer to an @p output_queue_t structure
 *
 * @iclass
 */
void chOQResetI(output_queue_t *oqp) {
 8002620:	b410      	push	{r4}

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeI(oqp);
 8002622:	6902      	ldr	r2, [r0, #16]
 */
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_wrptr = oqp->q_buffer;
 8002624:	68c4      	ldr	r4, [r0, #12]
 8002626:	6144      	str	r4, [r0, #20]
  oqp->q_counter = chQSizeI(oqp);
 8002628:	1b12      	subs	r2, r2, r4
 */
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_wrptr = oqp->q_buffer;
 800262a:	6184      	str	r4, [r0, #24]
  oqp->q_counter = chQSizeI(oqp);
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
 800262c:	f06f 0101 	mvn.w	r1, #1
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeI(oqp);
 8002630:	6082      	str	r2, [r0, #8]
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
}
 8002632:	f85d 4b04 	ldr.w	r4, [sp], #4

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeI(oqp);
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
 8002636:	f7ff b87b 	b.w	8001730 <chThdDequeueAllI>
 800263a:	bf00      	nop
 800263c:	f3af 8000 	nop.w

08002640 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t time) {
 8002640:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002642:	4604      	mov	r4, r0
 8002644:	460f      	mov	r7, r1
 8002646:	4616      	mov	r6, r2
 8002648:	2320      	movs	r3, #32
 800264a:	f383 8811 	msr	BASEPRI, r3
 800264e:	e003      	b.n	8002658 <chOQPutTimeout+0x18>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg;

    if ((msg = chThdEnqueueTimeoutS(&oqp->q_waiting, time)) < Q_OK) {
 8002650:	f7ff f846 	bl	80016e0 <chThdEnqueueTimeoutS>
 8002654:	2800      	cmp	r0, #0
 8002656:	db18      	blt.n	800268a <chOQPutTimeout+0x4a>
 8002658:	68a5      	ldr	r5, [r4, #8]
 800265a:	4620      	mov	r0, r4
 800265c:	4631      	mov	r1, r6
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t time) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 800265e:	2d00      	cmp	r5, #0
 8002660:	d0f6      	beq.n	8002650 <chOQPutTimeout+0x10>
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8002662:	6963      	ldr	r3, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8002664:	3d01      	subs	r5, #1
  *oqp->q_wrptr++ = b;
 8002666:	1c5a      	adds	r2, r3, #1
 8002668:	6162      	str	r2, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 800266a:	60a5      	str	r5, [r4, #8]
  *oqp->q_wrptr++ = b;
 800266c:	701f      	strb	r7, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 800266e:	6923      	ldr	r3, [r4, #16]
 8002670:	6962      	ldr	r2, [r4, #20]
 8002672:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8002674:	bf24      	itt	cs
 8002676:	68e3      	ldrcs	r3, [r4, #12]
 8002678:	6163      	strcs	r3, [r4, #20]
  }

  if (oqp->q_notify) {
 800267a:	69e3      	ldr	r3, [r4, #28]
 800267c:	b10b      	cbz	r3, 8002682 <chOQPutTimeout+0x42>
    oqp->q_notify(oqp);
 800267e:	4620      	mov	r0, r4
 8002680:	4798      	blx	r3
 8002682:	2000      	movs	r0, #0
 8002684:	f380 8811 	msr	BASEPRI, r0
  }
  chSysUnlock();

  return Q_OK;
}
 8002688:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800268a:	f385 8811 	msr	BASEPRI, r5
  while (chOQIsFullI(oqp)) {
    msg_t msg;

    if ((msg = chThdEnqueueTimeoutS(&oqp->q_waiting, time)) < Q_OK) {
      chSysUnlock();
      return msg;
 800268e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08002690 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 8002690:	b538      	push	{r3, r4, r5, lr}
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0));
 8002692:	6982      	ldr	r2, [r0, #24]
 8002694:	6943      	ldr	r3, [r0, #20]
 8002696:	4293      	cmp	r3, r2
 8002698:	6883      	ldr	r3, [r0, #8]
 800269a:	d00e      	beq.n	80026ba <chOQGetI+0x2a>
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 800269c:	6905      	ldr	r5, [r0, #16]
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 800269e:	1c51      	adds	r1, r2, #1

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 80026a0:	3301      	adds	r3, #1
 80026a2:	6083      	str	r3, [r0, #8]
  b = *oqp->q_rdptr++;
 80026a4:	6181      	str	r1, [r0, #24]
  if (oqp->q_rdptr >= oqp->q_top) {
 80026a6:	42a9      	cmp	r1, r5
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 80026a8:	7814      	ldrb	r4, [r2, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 80026aa:	d301      	bcc.n	80026b0 <chOQGetI+0x20>
    oqp->q_rdptr = oqp->q_buffer;
 80026ac:	68c3      	ldr	r3, [r0, #12]
 80026ae:	6183      	str	r3, [r0, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 80026b0:	2100      	movs	r1, #0
 80026b2:	f7ff f82d 	bl	8001710 <chThdDequeueNextI>

  return b;
 80026b6:	4620      	mov	r0, r4
 80026b8:	bd38      	pop	{r3, r4, r5, pc}
 80026ba:	2b00      	cmp	r3, #0
 80026bc:	d0ee      	beq.n	800269c <chOQGetI+0xc>
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
 80026be:	f06f 0002 	mvn.w	r0, #2
 80026c2:	bd38      	pop	{r3, r4, r5, pc}
 80026c4:	f3af 8000 	nop.w
 80026c8:	f3af 8000 	nop.w
 80026cc:	f3af 8000 	nop.w

080026d0 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t time) {
 80026d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80026d4:	b083      	sub	sp, #12
 80026d6:	4604      	mov	r4, r0
 80026d8:	468b      	mov	fp, r1
 80026da:	4616      	mov	r6, r2
 80026dc:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 80026de:	f8d0 801c 	ldr.w	r8, [r0, #28]
 80026e2:	f04f 0920 	mov.w	r9, #32
 80026e6:	f389 8811 	msr	BASEPRI, r9
  size_t w = 0;
 80026ea:	2700      	movs	r7, #0
 80026ec:	f8cd 9000 	str.w	r9, [sp]
 80026f0:	46ba      	mov	sl, r7
 80026f2:	68a5      	ldr	r5, [r4, #8]
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 80026f4:	f10b 0901 	add.w	r9, fp, #1
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 80026f8:	1e6a      	subs	r2, r5, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy) {
      nfy(oqp);
 80026fa:	4620      	mov	r0, r4

  chDbgCheck(n > 0);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 80026fc:	b30d      	cbz	r5, 8002742 <chOQWriteTimeout+0x72>
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 80026fe:	6963      	ldr	r3, [r4, #20]
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 8002700:	60a2      	str	r2, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8002702:	1c5a      	adds	r2, r3, #1
 8002704:	6162      	str	r2, [r4, #20]
 8002706:	f89b 2000 	ldrb.w	r2, [fp]
 800270a:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 800270c:	6923      	ldr	r3, [r4, #16]
 800270e:	6962      	ldr	r2, [r4, #20]
 8002710:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 8002712:	bf24      	itt	cs
 8002714:	68e3      	ldrcs	r3, [r4, #12]
 8002716:	6163      	strcs	r3, [r4, #20]
    }

    if (nfy) {
 8002718:	f1b8 0f00 	cmp.w	r8, #0
 800271c:	d000      	beq.n	8002720 <chOQWriteTimeout+0x50>
      nfy(oqp);
 800271e:	47c0      	blx	r8
 8002720:	f38a 8811 	msr	BASEPRI, sl
    }

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    w++;
    if (--n == 0) {
 8002724:	3e01      	subs	r6, #1
    if (nfy) {
      nfy(oqp);
    }

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    w++;
 8002726:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0) {
 800272a:	d012      	beq.n	8002752 <chOQWriteTimeout+0x82>
 800272c:	9b00      	ldr	r3, [sp, #0]
 800272e:	f383 8811 	msr	BASEPRI, r3
 8002732:	68a5      	ldr	r5, [r4, #8]
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8002734:	46cb      	mov	fp, r9
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 8002736:	1e6a      	subs	r2, r5, #1
    *oqp->q_wrptr++ = *bp++;
 8002738:	f10b 0901 	add.w	r9, fp, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy) {
      nfy(oqp);
 800273c:	4620      	mov	r0, r4

  chDbgCheck(n > 0);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 800273e:	2d00      	cmp	r5, #0
 8002740:	d1dd      	bne.n	80026fe <chOQWriteTimeout+0x2e>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
 8002742:	4620      	mov	r0, r4
 8002744:	9901      	ldr	r1, [sp, #4]
 8002746:	f7fe ffcb 	bl	80016e0 <chThdEnqueueTimeoutS>
 800274a:	2800      	cmp	r0, #0
 800274c:	d0d1      	beq.n	80026f2 <chOQWriteTimeout+0x22>
 800274e:	f385 8811 	msr	BASEPRI, r5
    if (--n == 0) {
      return w;
    }
    chSysLock();
  }
}
 8002752:	4638      	mov	r0, r7
 8002754:	b003      	add	sp, #12
 8002756:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800275a:	bf00      	nop
 800275c:	f3af 8000 	nop.w

08002760 <_core_init>:
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8002760:	4a05      	ldr	r2, [pc, #20]	; (8002778 <_core_init+0x18>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8002762:	4b06      	ldr	r3, [pc, #24]	; (800277c <_core_init+0x1c>)
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8002764:	4806      	ldr	r0, [pc, #24]	; (8002780 <_core_init+0x20>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8002766:	4907      	ldr	r1, [pc, #28]	; (8002784 <_core_init+0x24>)
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8002768:	f022 0207 	bic.w	r2, r2, #7
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800276c:	f023 0307 	bic.w	r3, r3, #7
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8002770:	6002      	str	r2, [r0, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8002772:	600b      	str	r3, [r1, #0]
 8002774:	4770      	bx	lr
 8002776:	bf00      	nop
 8002778:	200187bf 	.word	0x200187bf
 800277c:	2001c000 	.word	0x2001c000
 8002780:	2000132c 	.word	0x2000132c
 8002784:	20001328 	.word	0x20001328
 8002788:	f3af 8000 	nop.w
 800278c:	f3af 8000 	nop.w

08002790 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8002790:	b410      	push	{r4}
 8002792:	2320      	movs	r3, #32
 8002794:	f383 8811 	msr	BASEPRI, r3
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  if ((size_t)(endmem - nextmem) < size) {
 8002798:	4c09      	ldr	r4, [pc, #36]	; (80027c0 <chCoreAlloc+0x30>)
 800279a:	4b0a      	ldr	r3, [pc, #40]	; (80027c4 <chCoreAlloc+0x34>)
 800279c:	6822      	ldr	r2, [r4, #0]
 800279e:	6819      	ldr	r1, [r3, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 80027a0:	1dc3      	adds	r3, r0, #7
 80027a2:	f023 0307 	bic.w	r3, r3, #7
  if ((size_t)(endmem - nextmem) < size) {
 80027a6:	1a89      	subs	r1, r1, r2
 80027a8:	428b      	cmp	r3, r1
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 80027aa:	bf9d      	ittte	ls
 80027ac:	189b      	addls	r3, r3, r2
 80027ae:	6023      	strls	r3, [r4, #0]

  return p;
 80027b0:	4610      	movls	r0, r2

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  if ((size_t)(endmem - nextmem) < size) {
    return NULL;
 80027b2:	2000      	movhi	r0, #0
 80027b4:	2300      	movs	r3, #0
 80027b6:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 80027ba:	f85d 4b04 	ldr.w	r4, [sp], #4
 80027be:	4770      	bx	lr
 80027c0:	2000132c 	.word	0x2000132c
 80027c4:	20001328 	.word	0x20001328
 80027c8:	f3af 8000 	nop.w
 80027cc:	f3af 8000 	nop.w

080027d0 <chCoreGetStatusX>:
 *
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  return (size_t)(endmem - nextmem);
 80027d0:	4a02      	ldr	r2, [pc, #8]	; (80027dc <chCoreGetStatusX+0xc>)
 80027d2:	4b03      	ldr	r3, [pc, #12]	; (80027e0 <chCoreGetStatusX+0x10>)
 80027d4:	6810      	ldr	r0, [r2, #0]
 80027d6:	681b      	ldr	r3, [r3, #0]
}
 80027d8:	1ac0      	subs	r0, r0, r3
 80027da:	4770      	bx	lr
 80027dc:	20001328 	.word	0x20001328
 80027e0:	2000132c 	.word	0x2000132c
 80027e4:	f3af 8000 	nop.w
 80027e8:	f3af 8000 	nop.w
 80027ec:	f3af 8000 	nop.w

080027f0 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 80027f0:	4b04      	ldr	r3, [pc, #16]	; (8002804 <_heap_init+0x14>)
 80027f2:	4a05      	ldr	r2, [pc, #20]	; (8002808 <_heap_init+0x18>)
 80027f4:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = (union heap_header *)NULL;
  default_heap.h_free.h.size = 0;
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 80027f6:	f103 0010 	add.w	r0, r3, #16
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
  default_heap.h_free.h.u.next = (union heap_header *)NULL;
 80027fa:	2200      	movs	r2, #0
 80027fc:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 80027fe:	60da      	str	r2, [r3, #12]
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8002800:	f7ff b95e 	b.w	8001ac0 <chMtxObjectInit>
 8002804:	20001330 	.word	0x20001330
 8002808:	08002791 	.word	0x08002791
 800280c:	f3af 8000 	nop.w

08002810 <chHeapObjectInit>:
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = (memgetfunc_t)NULL;
 8002810:	2300      	movs	r3, #0
  heapp->h_free.h.u.next = hp = buf;
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8002812:	3a08      	subs	r2, #8
  union heap_header *hp;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = (memgetfunc_t)NULL;
  heapp->h_free.h.u.next = hp = buf;
 8002814:	6081      	str	r1, [r0, #8]
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = (memgetfunc_t)NULL;
 8002816:	6003      	str	r3, [r0, #0]
  heapp->h_free.h.u.next = hp = buf;
  heapp->h_free.h.size = 0;
 8002818:	60c3      	str	r3, [r0, #12]
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxObjectInit(&heapp->h_mtx);
 800281a:	3010      	adds	r0, #16

  heapp->h_provider = (memgetfunc_t)NULL;
  heapp->h_free.h.u.next = hp = buf;
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 800281c:	604a      	str	r2, [r1, #4]
  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = (memgetfunc_t)NULL;
  heapp->h_free.h.u.next = hp = buf;
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
 800281e:	600b      	str	r3, [r1, #0]
  hp->h.size = size - sizeof(union heap_header);
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxObjectInit(&heapp->h_mtx);
 8002820:	f7ff b94e 	b.w	8001ac0 <chMtxObjectInit>
 8002824:	f3af 8000 	nop.w
 8002828:	f3af 8000 	nop.w
 800282c:	f3af 8000 	nop.w

08002830 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 8002830:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL)
    heapp = &default_heap;
 8002832:	4e21      	ldr	r6, [pc, #132]	; (80028b8 <chHeapAlloc+0x88>)
 8002834:	2800      	cmp	r0, #0
 8002836:	bf18      	it	ne
 8002838:	4606      	movne	r6, r0
  
  size = MEM_ALIGN_NEXT(size);
  
  qp = &heapp->h_free;
  
  H_LOCK(heapp);
 800283a:	f106 0710 	add.w	r7, r6, #16
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL)
    heapp = &default_heap;
  
  size = MEM_ALIGN_NEXT(size);
 800283e:	3107      	adds	r1, #7
  
  qp = &heapp->h_free;
  
  H_LOCK(heapp);
 8002840:	4638      	mov	r0, r7
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL)
    heapp = &default_heap;
  
  size = MEM_ALIGN_NEXT(size);
 8002842:	f021 0507 	bic.w	r5, r1, #7
  
  qp = &heapp->h_free;
 8002846:	f106 0408 	add.w	r4, r6, #8
  
  H_LOCK(heapp);
 800284a:	f7ff f9a9 	bl	8001ba0 <chMtxLock>
  
  while (qp->h.u.next != NULL) {
 800284e:	e003      	b.n	8002858 <chHeapAlloc+0x28>
    //chprintf((BaseSequentialStream *)&itm_port, "qp->h.u.next: %i\n", qp->h.u.next);
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
 8002850:	6843      	ldr	r3, [r0, #4]
 8002852:	429d      	cmp	r5, r3
 8002854:	d912      	bls.n	800287c <chHeapAlloc+0x4c>
 8002856:	4604      	mov	r4, r0
  
  qp = &heapp->h_free;
  
  H_LOCK(heapp);
  
  while (qp->h.u.next != NULL) {
 8002858:	6820      	ldr	r0, [r4, #0]
 800285a:	2800      	cmp	r0, #0
 800285c:	d1f8      	bne.n	8002850 <chHeapAlloc+0x20>
      return (void *)(hp + 1);
    }
    qp = hp;
  }
  
  H_UNLOCK(heapp);
 800285e:	4638      	mov	r0, r7
 8002860:	f7ff f9c6 	bl	8001bf0 <chMtxUnlock>
  

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider) {
 8002864:	6833      	ldr	r3, [r6, #0]
 8002866:	b32b      	cbz	r3, 80028b4 <chHeapAlloc+0x84>
    hp = heapp->h_provider(size + sizeof(union heap_header));
 8002868:	f105 0008 	add.w	r0, r5, #8
 800286c:	4798      	blx	r3
    if (hp != NULL) {
 800286e:	b308      	cbz	r0, 80028b4 <chHeapAlloc+0x84>
      hp->h.u.heap = heapp;
 8002870:	6006      	str	r6, [r0, #0]
      hp->h.size = size;
 8002872:	6045      	str	r5, [r0, #4]
      hp++;
 8002874:	f100 0408 	add.w	r4, r0, #8
      return (void *)hp;
    }
  }

  return NULL;
}
 8002878:	4620      	mov	r0, r4
 800287a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  
  while (qp->h.u.next != NULL) {
    //chprintf((BaseSequentialStream *)&itm_port, "qp->h.u.next: %i\n", qp->h.u.next);
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
      if (hp->h.size < size + sizeof(union heap_header)) {
 800287c:	f105 0208 	add.w	r2, r5, #8
 8002880:	429a      	cmp	r2, r3
 8002882:	d909      	bls.n	8002898 <chHeapAlloc+0x68>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 8002884:	6803      	ldr	r3, [r0, #0]
 8002886:	6023      	str	r3, [r4, #0]
        fp->h.u.next = hp->h.u.next;
        fp->h.size = hp->h.size - sizeof(union heap_header) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
 8002888:	4604      	mov	r4, r0
      H_UNLOCK(heapp);
 800288a:	4638      	mov	r0, r7
        fp->h.u.next = hp->h.u.next;
        fp->h.size = hp->h.size - sizeof(union heap_header) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
 800288c:	f844 6b08 	str.w	r6, [r4], #8
      H_UNLOCK(heapp);
 8002890:	f7ff f9ae 	bl	8001bf0 <chMtxUnlock>
      return (void *)hp;
    }
  }

  return NULL;
}
 8002894:	4620      	mov	r0, r4
 8002896:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002898:	f06f 0107 	mvn.w	r1, #7
 800289c:	1b49      	subs	r1, r1, r5
           useful.*/
        qp->h.u.next = hp->h.u.next;
      }
      else {
        /* Block bigger enough, must split it.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
 800289e:	eb00 0e02 	add.w	lr, r0, r2
        fp->h.u.next = hp->h.u.next;
        fp->h.size = hp->h.size - sizeof(union heap_header) - size;
 80028a2:	440b      	add	r3, r1
        qp->h.u.next = hp->h.u.next;
      }
      else {
        /* Block bigger enough, must split it.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        fp->h.u.next = hp->h.u.next;
 80028a4:	6801      	ldr	r1, [r0, #0]
 80028a6:	5081      	str	r1, [r0, r2]
        fp->h.size = hp->h.size - sizeof(union heap_header) - size;
 80028a8:	f8ce 3004 	str.w	r3, [lr, #4]
        qp->h.u.next = fp;
 80028ac:	f8c4 e000 	str.w	lr, [r4]
        hp->h.size = size;
 80028b0:	6045      	str	r5, [r0, #4]
 80028b2:	e7e9      	b.n	8002888 <chHeapAlloc+0x58>

      return (void *)hp;
    }
  }

  return NULL;
 80028b4:	2400      	movs	r4, #0
 80028b6:	e7df      	b.n	8002878 <chHeapAlloc+0x48>
 80028b8:	20001330 	.word	0x20001330
 80028bc:	f3af 8000 	nop.w

080028c0 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 80028c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);

  hp = (union heap_header *)p - 1;
  heapp = hp->h.u.heap;
 80028c2:	f850 5c08 	ldr.w	r5, [r0, #-8]
  qp = &heapp->h_free;

  H_LOCK(heapp);
 80028c6:	f105 0710 	add.w	r7, r5, #16
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 80028ca:	4606      	mov	r6, r0
  union heap_header *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);

  hp = (union heap_header *)p - 1;
 80028cc:	f1a0 0408 	sub.w	r4, r0, #8
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 80028d0:	3508      	adds	r5, #8

  H_LOCK(heapp);
 80028d2:	4638      	mov	r0, r7
 80028d4:	f7ff f964 	bl	8001ba0 <chMtxLock>

  chDbgCheck(p != NULL);

  hp = (union heap_header *)p - 1;
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 80028d8:	462b      	mov	r3, r5

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 80028da:	42ab      	cmp	r3, r5
 80028dc:	d004      	beq.n	80028e8 <chHeapFree+0x28>
 80028de:	42a3      	cmp	r3, r4
 80028e0:	d302      	bcc.n	80028e8 <chHeapFree+0x28>
 80028e2:	681b      	ldr	r3, [r3, #0]
 80028e4:	42ab      	cmp	r3, r5
 80028e6:	d1fa      	bne.n	80028de <chHeapFree+0x1e>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 80028e8:	681a      	ldr	r2, [r3, #0]

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 80028ea:	b11a      	cbz	r2, 80028f4 <chHeapFree+0x34>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 80028ec:	4294      	cmp	r4, r2
 80028ee:	d301      	bcc.n	80028f4 <chHeapFree+0x34>
 80028f0:	4613      	mov	r3, r2
        qp->h.u.next = hp->h.u.next;
      }
      break;
    }
    qp = qp->h.u.next;
  }
 80028f2:	e7f2      	b.n	80028da <chHeapFree+0x1a>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 80028f4:	f856 1c04 	ldr.w	r1, [r6, #-4]
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
 80028f8:	f846 2c08 	str.w	r2, [r6, #-8]
      qp->h.u.next = hp;
 80028fc:	601c      	str	r4, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 80028fe:	f101 0208 	add.w	r2, r1, #8
 8002902:	f856 5c08 	ldr.w	r5, [r6, #-8]
 8002906:	18a0      	adds	r0, r4, r2
 8002908:	42a8      	cmp	r0, r5
 800290a:	d00a      	beq.n	8002922 <chHeapFree+0x62>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
 800290c:	6859      	ldr	r1, [r3, #4]
 800290e:	f101 0208 	add.w	r2, r1, #8
 8002912:	441a      	add	r2, r3
 8002914:	4294      	cmp	r4, r2
 8002916:	d012      	beq.n	800293e <chHeapFree+0x7e>
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8002918:	4638      	mov	r0, r7

  return;
}
 800291a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 800291e:	f7ff b967 	b.w	8001bf0 <chMtxUnlock>
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 8002922:	6840      	ldr	r0, [r0, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
 8002924:	58a2      	ldr	r2, [r4, r2]
 8002926:	f846 2c08 	str.w	r2, [r6, #-8]
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 800292a:	180a      	adds	r2, r1, r0
 800292c:	3208      	adds	r2, #8
 800292e:	f846 2c04 	str.w	r2, [r6, #-4]
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
 8002932:	6859      	ldr	r1, [r3, #4]
 8002934:	f101 0208 	add.w	r2, r1, #8
 8002938:	441a      	add	r2, r3
 800293a:	4294      	cmp	r4, r2
 800293c:	d1ec      	bne.n	8002918 <chHeapFree+0x58>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
        qp->h.u.next = hp->h.u.next;
 800293e:	e916 0005 	ldmdb	r6, {r0, r2}
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 8002942:	440a      	add	r2, r1
 8002944:	3208      	adds	r2, #8
        qp->h.u.next = hp->h.u.next;
 8002946:	6018      	str	r0, [r3, #0]
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 8002948:	605a      	str	r2, [r3, #4]
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 800294a:	4638      	mov	r0, r7

  return;
}
 800294c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8002950:	f7ff b94e 	b.w	8001bf0 <chMtxUnlock>
 8002954:	f3af 8000 	nop.w
 8002958:	f3af 8000 	nop.w
 800295c:	f3af 8000 	nop.w

08002960 <chHeapStatus>:
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
 8002960:	b570      	push	{r4, r5, r6, lr}
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL) {
    heapp = &default_heap;
 8002962:	4c0f      	ldr	r4, [pc, #60]	; (80029a0 <chHeapStatus+0x40>)
 8002964:	2800      	cmp	r0, #0
 8002966:	bf18      	it	ne
 8002968:	4604      	movne	r4, r0
  }

  H_LOCK(heapp);
 800296a:	f104 0510 	add.w	r5, r4, #16
 800296e:	4628      	mov	r0, r5
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
 8002970:	460e      	mov	r6, r1

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
 8002972:	f7ff f915 	bl	8001ba0 <chMtxLock>
  sz = 0;
  for (n = 0, qp = &heapp->h_free; qp->h.u.next; n++, qp = qp->h.u.next) {
 8002976:	68a3      	ldr	r3, [r4, #8]
 8002978:	b173      	cbz	r3, 8002998 <chHeapStatus+0x38>
 800297a:	2200      	movs	r2, #0
 800297c:	4614      	mov	r4, r2
    sz += qp->h.u.next->h.size;
 800297e:	6858      	ldr	r0, [r3, #4]
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  sz = 0;
  for (n = 0, qp = &heapp->h_free; qp->h.u.next; n++, qp = qp->h.u.next) {
 8002980:	681b      	ldr	r3, [r3, #0]
 8002982:	3401      	adds	r4, #1
    sz += qp->h.u.next->h.size;
 8002984:	4402      	add	r2, r0
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  sz = 0;
  for (n = 0, qp = &heapp->h_free; qp->h.u.next; n++, qp = qp->h.u.next) {
 8002986:	2b00      	cmp	r3, #0
 8002988:	d1f9      	bne.n	800297e <chHeapStatus+0x1e>
    sz += qp->h.u.next->h.size;
  }
  if (sizep) {
 800298a:	b106      	cbz	r6, 800298e <chHeapStatus+0x2e>
    *sizep = sz;
 800298c:	6032      	str	r2, [r6, #0]
  }
  H_UNLOCK(heapp);
 800298e:	4628      	mov	r0, r5
 8002990:	f7ff f92e 	bl	8001bf0 <chMtxUnlock>

  return n;
}
 8002994:	4620      	mov	r0, r4
 8002996:	bd70      	pop	{r4, r5, r6, pc}
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  sz = 0;
 8002998:	461a      	mov	r2, r3
  for (n = 0, qp = &heapp->h_free; qp->h.u.next; n++, qp = qp->h.u.next) {
 800299a:	461c      	mov	r4, r3
 800299c:	e7f5      	b.n	800298a <chHeapStatus+0x2a>
 800299e:	bf00      	nop
 80029a0:	20001330 	.word	0x20001330
 80029a4:	f3af 8000 	nop.w
 80029a8:	f3af 8000 	nop.w
 80029ac:	f3af 8000 	nop.w

080029b0 <chPoolObjectInit>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 80029b0:	2300      	movs	r3, #0
  mp->mp_object_size = size;
 80029b2:	6041      	str	r1, [r0, #4]
  mp->mp_provider = provider;
 80029b4:	6082      	str	r2, [r0, #8]
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 80029b6:	6003      	str	r3, [r0, #0]
 80029b8:	4770      	bx	lr
 80029ba:	bf00      	nop
 80029bc:	f3af 8000 	nop.w

080029c0 <chPoolLoadArray>:
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0));

  while (n) {
 80029c0:	b172      	cbz	r2, 80029e0 <chPoolLoadArray+0x20>
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {
 80029c2:	b430      	push	{r4, r5}
 80029c4:	2520      	movs	r5, #32
 80029c6:	2400      	movs	r4, #0
 80029c8:	f385 8811 	msr	BASEPRI, r5
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 80029cc:	6803      	ldr	r3, [r0, #0]
 80029ce:	600b      	str	r3, [r1, #0]
  mp->mp_next = php;
 80029d0:	6001      	str	r1, [r0, #0]
 80029d2:	f384 8811 	msr	BASEPRI, r4

  chDbgCheck((mp != NULL) && (n != 0));

  while (n) {
    chPoolAdd(mp, p);
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 80029d6:	6843      	ldr	r3, [r0, #4]
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0));

  while (n) {
 80029d8:	3a01      	subs	r2, #1
    chPoolAdd(mp, p);
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 80029da:	4419      	add	r1, r3
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0));

  while (n) {
 80029dc:	d1f4      	bne.n	80029c8 <chPoolLoadArray+0x8>
    chPoolAdd(mp, p);
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
    n--;
  }
}
 80029de:	bc30      	pop	{r4, r5}
 80029e0:	4770      	bx	lr
 80029e2:	bf00      	nop
 80029e4:	f3af 8000 	nop.w
 80029e8:	f3af 8000 	nop.w
 80029ec:	f3af 8000 	nop.w

080029f0 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 80029f0:	b508      	push	{r3, lr}
 80029f2:	2220      	movs	r2, #32
 80029f4:	4603      	mov	r3, r0
 80029f6:	f382 8811 	msr	BASEPRI, r2
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  if ((objp = mp->mp_next) != NULL) {
 80029fa:	6800      	ldr	r0, [r0, #0]
 80029fc:	b128      	cbz	r0, 8002a0a <chPoolAlloc+0x1a>
    mp->mp_next = mp->mp_next->ph_next;
 80029fe:	6802      	ldr	r2, [r0, #0]
 8002a00:	601a      	str	r2, [r3, #0]
 8002a02:	2300      	movs	r3, #0
 8002a04:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 8002a08:	bd08      	pop	{r3, pc}
  chDbgCheck(mp != NULL);

  if ((objp = mp->mp_next) != NULL) {
    mp->mp_next = mp->mp_next->ph_next;
  }
  else if (mp->mp_provider != NULL) {
 8002a0a:	689a      	ldr	r2, [r3, #8]
 8002a0c:	2a00      	cmp	r2, #0
 8002a0e:	d0f8      	beq.n	8002a02 <chPoolAlloc+0x12>
    objp = mp->mp_provider(mp->mp_object_size);
 8002a10:	6858      	ldr	r0, [r3, #4]
 8002a12:	4790      	blx	r2
 8002a14:	2300      	movs	r3, #0
 8002a16:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 8002a1a:	bd08      	pop	{r3, pc}
 8002a1c:	f3af 8000 	nop.w

08002a20 <chPoolFree>:
 8002a20:	2320      	movs	r3, #32
 8002a22:	f383 8811 	msr	BASEPRI, r3
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8002a26:	6803      	ldr	r3, [r0, #0]
 8002a28:	600b      	str	r3, [r1, #0]
 8002a2a:	2300      	movs	r3, #0
  mp->mp_next = php;
 8002a2c:	6001      	str	r1, [r0, #0]
 8002a2e:	f383 8811 	msr	BASEPRI, r3
 8002a32:	4770      	bx	lr
 8002a34:	f3af 8000 	nop.w
 8002a38:	f3af 8000 	nop.w
 8002a3c:	f3af 8000 	nop.w

08002a40 <tmr>:

static virtual_timer_t vt;
static void tmr(void *p) {
  (void)p;

  test_timer_done = TRUE;
 8002a40:	4b01      	ldr	r3, [pc, #4]	; (8002a48 <tmr+0x8>)
 8002a42:	2201      	movs	r2, #1
 8002a44:	701a      	strb	r2, [r3, #0]
 8002a46:	4770      	bx	lr
 8002a48:	20001c65 	.word	0x20001c65
 8002a4c:	f3af 8000 	nop.w

08002a50 <print_line>:
    tcp->teardown();

  test_wait_threads();
}

static void print_line(void) {
 8002a50:	b570      	push	{r4, r5, r6, lr}
 8002a52:	4e09      	ldr	r6, [pc, #36]	; (8002a78 <print_line+0x28>)
 8002a54:	244c      	movs	r4, #76	; 0x4c
  unsigned i;

  for (i = 0; i < 76; i++)
    chSequentialStreamPut(chp, '-');
 8002a56:	6830      	ldr	r0, [r6, #0]
 8002a58:	4d07      	ldr	r5, [pc, #28]	; (8002a78 <print_line+0x28>)
 8002a5a:	6803      	ldr	r3, [r0, #0]
 8002a5c:	212d      	movs	r1, #45	; 0x2d
 8002a5e:	689b      	ldr	r3, [r3, #8]
 8002a60:	4798      	blx	r3
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 8002a62:	3c01      	subs	r4, #1
 8002a64:	d1f7      	bne.n	8002a56 <print_line+0x6>
    chSequentialStreamPut(chp, '-');
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 8002a66:	6828      	ldr	r0, [r5, #0]
 8002a68:	4904      	ldr	r1, [pc, #16]	; (8002a7c <print_line+0x2c>)
 8002a6a:	6803      	ldr	r3, [r0, #0]
 8002a6c:	2202      	movs	r2, #2
 8002a6e:	681b      	ldr	r3, [r3, #0]
}
 8002a70:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
    chSequentialStreamPut(chp, '-');
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 8002a74:	4718      	bx	r3
 8002a76:	bf00      	nop
 8002a78:	20001c98 	.word	0x20001c98
 8002a7c:	080160f0 	.word	0x080160f0

08002a80 <test_printn>:
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
 8002a80:	b310      	cbz	r0, 8002ac8 <test_printn+0x48>
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
 8002a82:	b570      	push	{r4, r5, r6, lr}
  if (!n)
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 8002a84:	4a13      	ldr	r2, [pc, #76]	; (8002ad4 <test_printn+0x54>)
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
 8002a86:	b084      	sub	sp, #16
  char buf[16], *p;

  if (!n)
 8002a88:	466d      	mov	r5, sp
 8002a8a:	466c      	mov	r4, sp
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 8002a8c:	fba2 1300 	umull	r1, r3, r2, r0
 8002a90:	08db      	lsrs	r3, r3, #3
 8002a92:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8002a96:	eba0 0041 	sub.w	r0, r0, r1, lsl #1
 8002a9a:	f100 0130 	add.w	r1, r0, #48	; 0x30
 8002a9e:	b2c9      	uxtb	r1, r1
 8002aa0:	f804 1b01 	strb.w	r1, [r4], #1

  if (!n)
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
 8002aa4:	4618      	mov	r0, r3
 8002aa6:	2b00      	cmp	r3, #0
 8002aa8:	d1f0      	bne.n	8002a8c <test_printn+0xc>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8002aaa:	42ac      	cmp	r4, r5
 8002aac:	d90a      	bls.n	8002ac4 <test_printn+0x44>
 8002aae:	4e0a      	ldr	r6, [pc, #40]	; (8002ad8 <test_printn+0x58>)
 8002ab0:	3c01      	subs	r4, #1
 8002ab2:	e001      	b.n	8002ab8 <test_printn+0x38>
 8002ab4:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
      chSequentialStreamPut(chp, *--p);
 8002ab8:	6830      	ldr	r0, [r6, #0]
 8002aba:	6803      	ldr	r3, [r0, #0]
 8002abc:	689b      	ldr	r3, [r3, #8]
 8002abe:	4798      	blx	r3
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8002ac0:	42ac      	cmp	r4, r5
 8002ac2:	d1f7      	bne.n	8002ab4 <test_printn+0x34>
      chSequentialStreamPut(chp, *--p);
  }
}
 8002ac4:	b004      	add	sp, #16
 8002ac6:	bd70      	pop	{r4, r5, r6, pc}
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
    chSequentialStreamPut(chp, '0');
 8002ac8:	4b03      	ldr	r3, [pc, #12]	; (8002ad8 <test_printn+0x58>)
 8002aca:	6818      	ldr	r0, [r3, #0]
 8002acc:	6803      	ldr	r3, [r0, #0]
 8002ace:	2130      	movs	r1, #48	; 0x30
 8002ad0:	689b      	ldr	r3, [r3, #8]
 8002ad2:	4718      	bx	r3
 8002ad4:	cccccccd 	.word	0xcccccccd
 8002ad8:	20001c98 	.word	0x20001c98
 8002adc:	f3af 8000 	nop.w

08002ae0 <test_print>:
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
 8002ae0:	b538      	push	{r3, r4, r5, lr}

  while (*msgp)
 8002ae2:	7801      	ldrb	r1, [r0, #0]
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
 8002ae4:	4604      	mov	r4, r0

  while (*msgp)
 8002ae6:	b141      	cbz	r1, 8002afa <test_print+0x1a>
 8002ae8:	4d04      	ldr	r5, [pc, #16]	; (8002afc <test_print+0x1c>)
    chSequentialStreamPut(chp, *msgp++);
 8002aea:	6828      	ldr	r0, [r5, #0]
 8002aec:	6803      	ldr	r3, [r0, #0]
 8002aee:	689b      	ldr	r3, [r3, #8]
 8002af0:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002af2:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8002af6:	2900      	cmp	r1, #0
 8002af8:	d1f7      	bne.n	8002aea <test_print+0xa>
 8002afa:	bd38      	pop	{r3, r4, r5, pc}
 8002afc:	20001c98 	.word	0x20001c98

08002b00 <test_println>:
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
 8002b00:	b570      	push	{r4, r5, r6, lr}
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002b02:	7801      	ldrb	r1, [r0, #0]
 8002b04:	4d09      	ldr	r5, [pc, #36]	; (8002b2c <test_println+0x2c>)
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
 8002b06:	4604      	mov	r4, r0
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002b08:	b139      	cbz	r1, 8002b1a <test_println+0x1a>
    chSequentialStreamPut(chp, *msgp++);
 8002b0a:	6828      	ldr	r0, [r5, #0]
 8002b0c:	6803      	ldr	r3, [r0, #0]
 8002b0e:	689b      	ldr	r3, [r3, #8]
 8002b10:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002b12:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8002b16:	2900      	cmp	r1, #0
 8002b18:	d1f7      	bne.n	8002b0a <test_println+0xa>
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {

  test_print(msgp);
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 8002b1a:	6828      	ldr	r0, [r5, #0]
 8002b1c:	4904      	ldr	r1, [pc, #16]	; (8002b30 <test_println+0x30>)
 8002b1e:	6803      	ldr	r3, [r0, #0]
 8002b20:	2202      	movs	r2, #2
 8002b22:	681b      	ldr	r3, [r3, #0]
}
 8002b24:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {

  test_print(msgp);
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 8002b28:	4718      	bx	r3
 8002b2a:	bf00      	nop
 8002b2c:	20001c98 	.word	0x20001c98
 8002b30:	080160f0 	.word	0x080160f0
 8002b34:	f3af 8000 	nop.w
 8002b38:	f3af 8000 	nop.w
 8002b3c:	f3af 8000 	nop.w

08002b40 <test_emit_token>:
 8002b40:	2320      	movs	r3, #32
 8002b42:	f383 8811 	msr	BASEPRI, r3
 * @param[in] token     the token as a char
 */
void test_emit_token(char token) {

  chSysLock();
  *tokp++ = token;
 8002b46:	4b04      	ldr	r3, [pc, #16]	; (8002b58 <test_emit_token+0x18>)
 8002b48:	681a      	ldr	r2, [r3, #0]
 8002b4a:	1c51      	adds	r1, r2, #1
 8002b4c:	6019      	str	r1, [r3, #0]
 8002b4e:	7010      	strb	r0, [r2, #0]
 8002b50:	2300      	movs	r3, #0
 8002b52:	f383 8811 	msr	BASEPRI, r3
 8002b56:	4770      	bx	lr
 8002b58:	20001c68 	.word	0x20001c68
 8002b5c:	f3af 8000 	nop.w

08002b60 <_test_assert>:
  return TRUE;
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
 8002b60:	b959      	cbnz	r1, 8002b7a <_test_assert+0x1a>
  global_fail = TRUE;
  failpoint = point;
  return TRUE;
}

bool _test_assert(unsigned point, bool condition) {
 8002b62:	b410      	push	{r4}
 * Assertions.
 */
bool _test_fail(unsigned point) {

  local_fail = TRUE;
  global_fail = TRUE;
 8002b64:	4906      	ldr	r1, [pc, #24]	; (8002b80 <_test_assert+0x20>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  local_fail = TRUE;
 8002b66:	4c07      	ldr	r4, [pc, #28]	; (8002b84 <_test_assert+0x24>)
  global_fail = TRUE;
  failpoint = point;
 8002b68:	4a07      	ldr	r2, [pc, #28]	; (8002b88 <_test_assert+0x28>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  local_fail = TRUE;
 8002b6a:	2301      	movs	r3, #1
 8002b6c:	7023      	strb	r3, [r4, #0]
  global_fail = TRUE;
  failpoint = point;
 8002b6e:	6010      	str	r0, [r2, #0]
 * Assertions.
 */
bool _test_fail(unsigned point) {

  local_fail = TRUE;
  global_fail = TRUE;
 8002b70:	700b      	strb	r3, [r1, #0]
bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
  return FALSE;
}
 8002b72:	4618      	mov	r0, r3
 8002b74:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002b78:	4770      	bx	lr

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
  return FALSE;
 8002b7a:	2300      	movs	r3, #0
}
 8002b7c:	4618      	mov	r0, r3
 8002b7e:	4770      	bx	lr
 8002b80:	20001c6c 	.word	0x20001c6c
 8002b84:	20001c64 	.word	0x20001c64
 8002b88:	20001c60 	.word	0x20001c60
 8002b8c:	f3af 8000 	nop.w

08002b90 <_test_assert_sequence>:

bool _test_assert_sequence(unsigned point, char *expected) {
 8002b90:	b4f0      	push	{r4, r5, r6, r7}
 8002b92:	4e0e      	ldr	r6, [pc, #56]	; (8002bcc <_test_assert_sequence+0x3c>)
  char *cp = tokens_buffer;
 8002b94:	4f0e      	ldr	r7, [pc, #56]	; (8002bd0 <_test_assert_sequence+0x40>)
 8002b96:	6835      	ldr	r5, [r6, #0]
 8002b98:	463b      	mov	r3, r7
  while (cp < tokp) {
 8002b9a:	e005      	b.n	8002ba8 <_test_assert_sequence+0x18>
    if (*cp++ != *expected++)
 8002b9c:	f813 4b01 	ldrb.w	r4, [r3], #1
 8002ba0:	f811 2b01 	ldrb.w	r2, [r1], #1
 8002ba4:	4294      	cmp	r4, r2
 8002ba6:	d107      	bne.n	8002bb8 <_test_assert_sequence+0x28>
  return FALSE;
}

bool _test_assert_sequence(unsigned point, char *expected) {
  char *cp = tokens_buffer;
  while (cp < tokp) {
 8002ba8:	42ab      	cmp	r3, r5
 8002baa:	d3f7      	bcc.n	8002b9c <_test_assert_sequence+0xc>
    if (*cp++ != *expected++)
     return _test_fail(point);
  }
  if (*expected)
 8002bac:	780b      	ldrb	r3, [r1, #0]
 8002bae:	b91b      	cbnz	r3, 8002bb8 <_test_assert_sequence+0x28>
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 8002bb0:	6037      	str	r7, [r6, #0]
  }
  if (*expected)
    return _test_fail(point);
  clear_tokens();
  return FALSE;
}
 8002bb2:	4618      	mov	r0, r3
 8002bb4:	bcf0      	pop	{r4, r5, r6, r7}
 8002bb6:	4770      	bx	lr
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  local_fail = TRUE;
 8002bb8:	4c06      	ldr	r4, [pc, #24]	; (8002bd4 <_test_assert_sequence+0x44>)
  global_fail = TRUE;
 8002bba:	4907      	ldr	r1, [pc, #28]	; (8002bd8 <_test_assert_sequence+0x48>)
  failpoint = point;
 8002bbc:	4a07      	ldr	r2, [pc, #28]	; (8002bdc <_test_assert_sequence+0x4c>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  local_fail = TRUE;
 8002bbe:	2301      	movs	r3, #1
 8002bc0:	7023      	strb	r3, [r4, #0]
  global_fail = TRUE;
  failpoint = point;
 8002bc2:	6010      	str	r0, [r2, #0]
 * Assertions.
 */
bool _test_fail(unsigned point) {

  local_fail = TRUE;
  global_fail = TRUE;
 8002bc4:	700b      	strb	r3, [r1, #0]
  }
  if (*expected)
    return _test_fail(point);
  clear_tokens();
  return FALSE;
}
 8002bc6:	4618      	mov	r0, r3
 8002bc8:	bcf0      	pop	{r4, r5, r6, r7}
 8002bca:	4770      	bx	lr
 8002bcc:	20001c68 	.word	0x20001c68
 8002bd0:	20001c9c 	.word	0x20001c9c
 8002bd4:	20001c64 	.word	0x20001c64
 8002bd8:	20001c6c 	.word	0x20001c6c
 8002bdc:	20001c60 	.word	0x20001c60

08002be0 <_test_assert_time_window>:

bool _test_assert_time_window(unsigned point, systime_t start, systime_t end) {
 8002be0:	b410      	push	{r4}
 8002be2:	2320      	movs	r3, #32
 8002be4:	f383 8811 	msr	BASEPRI, r3
 8002be8:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
 8002bec:	2300      	movs	r3, #0
 8002bee:	6a64      	ldr	r4, [r4, #36]	; 0x24
 8002bf0:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)(time - start < end - start);
 8002bf4:	1a64      	subs	r4, r4, r1
 8002bf6:	1a52      	subs	r2, r2, r1
  return TRUE;
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
 8002bf8:	4294      	cmp	r4, r2
 8002bfa:	d306      	bcc.n	8002c0a <_test_assert_time_window+0x2a>
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  local_fail = TRUE;
 8002bfc:	4c05      	ldr	r4, [pc, #20]	; (8002c14 <_test_assert_time_window+0x34>)
  global_fail = TRUE;
 8002bfe:	4906      	ldr	r1, [pc, #24]	; (8002c18 <_test_assert_time_window+0x38>)
  failpoint = point;
 8002c00:	4a06      	ldr	r2, [pc, #24]	; (8002c1c <_test_assert_time_window+0x3c>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  local_fail = TRUE;
 8002c02:	2301      	movs	r3, #1
 8002c04:	7023      	strb	r3, [r4, #0]
  global_fail = TRUE;
 8002c06:	700b      	strb	r3, [r1, #0]
  failpoint = point;
 8002c08:	6010      	str	r0, [r2, #0]
}

bool _test_assert_time_window(unsigned point, systime_t start, systime_t end) {

  return _test_assert(point, chVTIsSystemTimeWithin(start, end));
}
 8002c0a:	4618      	mov	r0, r3
 8002c0c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002c10:	4770      	bx	lr
 8002c12:	bf00      	nop
 8002c14:	20001c64 	.word	0x20001c64
 8002c18:	20001c6c 	.word	0x20001c6c
 8002c1c:	20001c60 	.word	0x20001c60

08002c20 <test_terminate_threads>:
 */

/**
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 8002c20:	b538      	push	{r3, r4, r5, lr}
 8002c22:	4c06      	ldr	r4, [pc, #24]	; (8002c3c <test_terminate_threads+0x1c>)
 8002c24:	f104 0514 	add.w	r5, r4, #20
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
 8002c28:	f854 3b04 	ldr.w	r3, [r4], #4
      chThdTerminate(threads[i]);
 8002c2c:	4618      	mov	r0, r3
 */
void test_terminate_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
 8002c2e:	b10b      	cbz	r3, 8002c34 <test_terminate_threads+0x14>
      chThdTerminate(threads[i]);
 8002c30:	f7fe fcc6 	bl	80015c0 <chThdTerminate>
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 8002c34:	42ac      	cmp	r4, r5
 8002c36:	d1f7      	bne.n	8002c28 <test_terminate_threads+0x8>
    if (threads[i])
      chThdTerminate(threads[i]);
}
 8002c38:	bd38      	pop	{r3, r4, r5, pc}
 8002c3a:	bf00      	nop
 8002c3c:	20001c84 	.word	0x20001c84

08002c40 <test_wait_threads>:

/**
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 8002c40:	b570      	push	{r4, r5, r6, lr}
 8002c42:	4c07      	ldr	r4, [pc, #28]	; (8002c60 <test_wait_threads+0x20>)
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
 8002c44:	2600      	movs	r6, #0
 8002c46:	f104 0514 	add.w	r5, r4, #20
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
 8002c4a:	f854 0b04 	ldr.w	r0, [r4], #4
 8002c4e:	b118      	cbz	r0, 8002c58 <test_wait_threads+0x18>
      chThdWait(threads[i]);
 8002c50:	f7fe fd26 	bl	80016a0 <chThdWait>
      threads[i] = NULL;
 8002c54:	f844 6c04 	str.w	r6, [r4, #-4]
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 8002c58:	42ac      	cmp	r4, r5
 8002c5a:	d1f6      	bne.n	8002c4a <test_wait_threads+0xa>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
 8002c5c:	bd70      	pop	{r4, r5, r6, pc}
 8002c5e:	bf00      	nop
 8002c60:	20001c84 	.word	0x20001c84
 8002c64:	f3af 8000 	nop.w
 8002c68:	f3af 8000 	nop.w
 8002c6c:	f3af 8000 	nop.w

08002c70 <test_wait_tick>:
/**
 * @brief   Delays execution until next system time tick.
 *
 * @return              The system time.
 */
systime_t test_wait_tick(void) {
 8002c70:	b508      	push	{r3, lr}

  chThdSleep(1);
 8002c72:	2001      	movs	r0, #1
 8002c74:	f7fe fcb4 	bl	80015e0 <chThdSleep>
 8002c78:	2320      	movs	r3, #32
 8002c7a:	f383 8811 	msr	BASEPRI, r3
 8002c7e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8002c82:	2300      	movs	r3, #0
 8002c84:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8002c86:	f383 8811 	msr	BASEPRI, r3
  return chVTGetSystemTime();
}
 8002c8a:	bd08      	pop	{r3, pc}
 8002c8c:	f3af 8000 	nop.w

08002c90 <test_start_timer>:
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {

  systime_t duration = MS2ST(ms);
 8002c90:	f242 7310 	movw	r3, #10000	; 0x2710
/**
 * @brief   Starts the test timer.
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {
 8002c94:	b510      	push	{r4, lr}

  systime_t duration = MS2ST(ms);
 8002c96:	fb03 f000 	mul.w	r0, r3, r0
 8002c9a:	4c0d      	ldr	r4, [pc, #52]	; (8002cd0 <test_start_timer+0x40>)
  test_timer_done = FALSE;
 8002c9c:	4a0d      	ldr	r2, [pc, #52]	; (8002cd4 <test_start_timer+0x44>)
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {

  systime_t duration = MS2ST(ms);
 8002c9e:	3801      	subs	r0, #1
 8002ca0:	fba4 3400 	umull	r3, r4, r4, r0
 8002ca4:	09a4      	lsrs	r4, r4, #6
  test_timer_done = FALSE;
 8002ca6:	2300      	movs	r3, #0
 8002ca8:	7013      	strb	r3, [r2, #0]
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {

  systime_t duration = MS2ST(ms);
 8002caa:	3401      	adds	r4, #1
 8002cac:	2320      	movs	r3, #32
 8002cae:	f383 8811 	msr	BASEPRI, r3
 8002cb2:	4809      	ldr	r0, [pc, #36]	; (8002cd8 <test_start_timer+0x48>)
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8002cb4:	68c3      	ldr	r3, [r0, #12]
 8002cb6:	b10b      	cbz	r3, 8002cbc <test_start_timer+0x2c>
    chVTDoResetI(vtp);
 8002cb8:	f7fe fb9a 	bl	80013f0 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8002cbc:	4621      	mov	r1, r4
 8002cbe:	4806      	ldr	r0, [pc, #24]	; (8002cd8 <test_start_timer+0x48>)
 8002cc0:	4a06      	ldr	r2, [pc, #24]	; (8002cdc <test_start_timer+0x4c>)
 8002cc2:	2300      	movs	r3, #0
 8002cc4:	f7fe fb5c 	bl	8001380 <chVTDoSetI>
 8002cc8:	2300      	movs	r3, #0
 8002cca:	f383 8811 	msr	BASEPRI, r3
 8002cce:	bd10      	pop	{r4, pc}
 8002cd0:	10624dd3 	.word	0x10624dd3
 8002cd4:	20001c65 	.word	0x20001c65
 8002cd8:	20001c70 	.word	0x20001c70
 8002cdc:	08002a41 	.word	0x08002a41

08002ce0 <TestThread>:
 * @brief   Test execution thread function.
 *
 * @param[in] p         pointer to a @p BaseChannel object for test output
 * @return              A failure boolean value.
 */
msg_t TestThread(void *p) {
 8002ce0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int i, j;

  chp = p;
 8002ce4:	4ca0      	ldr	r4, [pc, #640]	; (8002f68 <TestThread+0x288>)
  test_println("");
  test_println("*** ChibiOS/RT test suite");
  test_println("***");
 8002ce6:	4da1      	ldr	r5, [pc, #644]	; (8002f6c <TestThread+0x28c>)
 * @return              A failure boolean value.
 */
msg_t TestThread(void *p) {
  int i, j;

  chp = p;
 8002ce8:	6020      	str	r0, [r4, #0]
 * @brief   Test execution thread function.
 *
 * @param[in] p         pointer to a @p BaseChannel object for test output
 * @return              A failure boolean value.
 */
msg_t TestThread(void *p) {
 8002cea:	b083      	sub	sp, #12
  int i, j;

  chp = p;
  test_println("");
 8002cec:	48a0      	ldr	r0, [pc, #640]	; (8002f70 <TestThread+0x290>)
 8002cee:	f7ff ff07 	bl	8002b00 <test_println>
  test_println("*** ChibiOS/RT test suite");
 8002cf2:	48a0      	ldr	r0, [pc, #640]	; (8002f74 <TestThread+0x294>)
 8002cf4:	f7ff ff04 	bl	8002b00 <test_println>
  test_println("***");
 8002cf8:	489f      	ldr	r0, [pc, #636]	; (8002f78 <TestThread+0x298>)
 8002cfa:	f7ff ff01 	bl	8002b00 <test_println>
 8002cfe:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002d00:	6820      	ldr	r0, [r4, #0]
 8002d02:	6803      	ldr	r3, [r0, #0]
 8002d04:	689b      	ldr	r3, [r3, #8]
 8002d06:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002d08:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8002d0c:	2900      	cmp	r1, #0
 8002d0e:	d1f7      	bne.n	8002d00 <TestThread+0x20>
  chp = p;
  test_println("");
  test_println("*** ChibiOS/RT test suite");
  test_println("***");
  test_print("*** Kernel:       ");
  test_println(CH_KERNEL_VERSION);
 8002d10:	489a      	ldr	r0, [pc, #616]	; (8002f7c <TestThread+0x29c>)
 8002d12:	4d9b      	ldr	r5, [pc, #620]	; (8002f80 <TestThread+0x2a0>)
 8002d14:	f7ff fef4 	bl	8002b00 <test_println>
 8002d18:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002d1a:	6820      	ldr	r0, [r4, #0]
 8002d1c:	6803      	ldr	r3, [r0, #0]
 8002d1e:	689b      	ldr	r3, [r3, #8]
 8002d20:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002d22:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8002d26:	2900      	cmp	r1, #0
 8002d28:	d1f7      	bne.n	8002d1a <TestThread+0x3a>
  test_println("*** ChibiOS/RT test suite");
  test_println("***");
  test_print("*** Kernel:       ");
  test_println(CH_KERNEL_VERSION);
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
 8002d2a:	4896      	ldr	r0, [pc, #600]	; (8002f84 <TestThread+0x2a4>)
 8002d2c:	4d96      	ldr	r5, [pc, #600]	; (8002f88 <TestThread+0x2a8>)
 8002d2e:	f7ff fee7 	bl	8002b00 <test_println>
 8002d32:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002d34:	6820      	ldr	r0, [r4, #0]
 8002d36:	6803      	ldr	r3, [r0, #0]
 8002d38:	689b      	ldr	r3, [r3, #8]
 8002d3a:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002d3c:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8002d40:	2900      	cmp	r1, #0
 8002d42:	d1f7      	bne.n	8002d34 <TestThread+0x54>
  test_println(CH_KERNEL_VERSION);
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
  test_println(PORT_COMPILER_NAME);
 8002d44:	4891      	ldr	r0, [pc, #580]	; (8002f8c <TestThread+0x2ac>)
 8002d46:	4d92      	ldr	r5, [pc, #584]	; (8002f90 <TestThread+0x2b0>)
 8002d48:	f7ff feda 	bl	8002b00 <test_println>
 8002d4c:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002d4e:	6820      	ldr	r0, [r4, #0]
 8002d50:	6803      	ldr	r3, [r0, #0]
 8002d52:	689b      	ldr	r3, [r3, #8]
 8002d54:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002d56:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8002d5a:	2900      	cmp	r1, #0
 8002d5c:	d1f7      	bne.n	8002d4e <TestThread+0x6e>
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
  test_println(PORT_COMPILER_NAME);
#endif
  test_print("*** Architecture: ");
  test_println(PORT_ARCHITECTURE_NAME);
 8002d5e:	488d      	ldr	r0, [pc, #564]	; (8002f94 <TestThread+0x2b4>)
 8002d60:	4d8d      	ldr	r5, [pc, #564]	; (8002f98 <TestThread+0x2b8>)
 8002d62:	f7ff fecd 	bl	8002b00 <test_println>
 8002d66:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002d68:	6820      	ldr	r0, [r4, #0]
 8002d6a:	6803      	ldr	r3, [r0, #0]
 8002d6c:	689b      	ldr	r3, [r3, #8]
 8002d6e:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002d70:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8002d74:	2900      	cmp	r1, #0
 8002d76:	d1f7      	bne.n	8002d68 <TestThread+0x88>
#endif
  test_print("*** Architecture: ");
  test_println(PORT_ARCHITECTURE_NAME);
#ifdef PORT_CORE_VARIANT_NAME
  test_print("*** Core Variant: ");
  test_println(PORT_CORE_VARIANT_NAME);
 8002d78:	4888      	ldr	r0, [pc, #544]	; (8002f9c <TestThread+0x2bc>)
 8002d7a:	4d89      	ldr	r5, [pc, #548]	; (8002fa0 <TestThread+0x2c0>)
 8002d7c:	f7ff fec0 	bl	8002b00 <test_println>
 8002d80:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002d82:	6820      	ldr	r0, [r4, #0]
 8002d84:	6803      	ldr	r3, [r0, #0]
 8002d86:	689b      	ldr	r3, [r3, #8]
 8002d88:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002d8a:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8002d8e:	2900      	cmp	r1, #0
 8002d90:	d1f7      	bne.n	8002d82 <TestThread+0xa2>
  test_print("*** Core Variant: ");
  test_println(PORT_CORE_VARIANT_NAME);
#endif
#ifdef PORT_INFO
  test_print("*** Port Info:    ");
  test_println(PORT_INFO);
 8002d92:	4884      	ldr	r0, [pc, #528]	; (8002fa4 <TestThread+0x2c4>)
 8002d94:	4d84      	ldr	r5, [pc, #528]	; (8002fa8 <TestThread+0x2c8>)
 8002d96:	f7ff feb3 	bl	8002b00 <test_println>
 8002d9a:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002d9c:	6820      	ldr	r0, [r4, #0]
 8002d9e:	6803      	ldr	r3, [r0, #0]
 8002da0:	689b      	ldr	r3, [r3, #8]
 8002da2:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002da4:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8002da8:	2900      	cmp	r1, #0
 8002daa:	d1f7      	bne.n	8002d9c <TestThread+0xbc>
  test_print("*** Port Info:    ");
  test_println(PORT_INFO);
#endif
#ifdef PLATFORM_NAME
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
 8002dac:	487f      	ldr	r0, [pc, #508]	; (8002fac <TestThread+0x2cc>)
 8002dae:	4d80      	ldr	r5, [pc, #512]	; (8002fb0 <TestThread+0x2d0>)
 8002db0:	f7ff fea6 	bl	8002b00 <test_println>
 8002db4:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002db6:	6820      	ldr	r0, [r4, #0]
 8002db8:	6803      	ldr	r3, [r0, #0]
 8002dba:	689b      	ldr	r3, [r3, #8]
 8002dbc:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002dbe:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8002dc2:	2900      	cmp	r1, #0
 8002dc4:	d1f7      	bne.n	8002db6 <TestThread+0xd6>
 8002dc6:	4b7b      	ldr	r3, [pc, #492]	; (8002fb4 <TestThread+0x2d4>)
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
 8002dc8:	487b      	ldr	r0, [pc, #492]	; (8002fb8 <TestThread+0x2d8>)
 8002dca:	9100      	str	r1, [sp, #0]
 8002dcc:	9301      	str	r3, [sp, #4]
 8002dce:	f7ff fe97 	bl	8002b00 <test_println>
#endif
  test_println("");
 8002dd2:	4867      	ldr	r0, [pc, #412]	; (8002f70 <TestThread+0x290>)

  global_fail = FALSE;
 8002dd4:	f8df 8220 	ldr.w	r8, [pc, #544]	; 8002ff8 <TestThread+0x318>
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002dd8:	f8df b18c 	ldr.w	fp, [pc, #396]	; 8002f68 <TestThread+0x288>
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
#endif
  test_println("");
 8002ddc:	f7ff fe90 	bl	8002b00 <test_println>

  global_fail = FALSE;
 8002de0:	4b76      	ldr	r3, [pc, #472]	; (8002fbc <TestThread+0x2dc>)
 8002de2:	9900      	ldr	r1, [sp, #0]
 8002de4:	7019      	strb	r1, [r3, #0]
 8002de6:	9b00      	ldr	r3, [sp, #0]
 8002de8:	3301      	adds	r3, #1
 8002dea:	9300      	str	r3, [sp, #0]
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 8002dec:	2600      	movs	r6, #0

  global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 8002dee:	f858 3026 	ldr.w	r3, [r8, r6, lsl #2]
 8002df2:	eb08 0786 	add.w	r7, r8, r6, lsl #2
 8002df6:	2b00      	cmp	r3, #0
 8002df8:	f000 8087 	beq.w	8002f0a <TestThread+0x22a>
      print_line();
 8002dfc:	4d70      	ldr	r5, [pc, #448]	; (8002fc0 <TestThread+0x2e0>)
 8002dfe:	f7ff fe27 	bl	8002a50 <print_line>
 8002e02:	212d      	movs	r1, #45	; 0x2d
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002e04:	6820      	ldr	r0, [r4, #0]
 8002e06:	6803      	ldr	r3, [r0, #0]
 8002e08:	689b      	ldr	r3, [r3, #8]
 8002e0a:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002e0c:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8002e10:	2900      	cmp	r1, #0
 8002e12:	d1f7      	bne.n	8002e04 <TestThread+0x124>
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
 8002e14:	9800      	ldr	r0, [sp, #0]
      test_print(".");
      test_printn(j + 1);
 8002e16:	4d6b      	ldr	r5, [pc, #428]	; (8002fc4 <TestThread+0x2e4>)
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
 8002e18:	f7ff fe32 	bl	8002a80 <test_printn>
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002e1c:	f8db 0000 	ldr.w	r0, [fp]
 8002e20:	6803      	ldr	r3, [r0, #0]
 8002e22:	212e      	movs	r1, #46	; 0x2e
 8002e24:	689b      	ldr	r3, [r3, #8]
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 8002e26:	3601      	adds	r6, #1
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002e28:	4798      	blx	r3
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 8002e2a:	4630      	mov	r0, r6
 8002e2c:	f7ff fe28 	bl	8002a80 <test_printn>
 8002e30:	2120      	movs	r1, #32
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002e32:	6820      	ldr	r0, [r4, #0]
 8002e34:	6803      	ldr	r3, [r0, #0]
 8002e36:	689b      	ldr	r3, [r3, #8]
 8002e38:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002e3a:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8002e3e:	2900      	cmp	r1, #0
 8002e40:	d1f7      	bne.n	8002e32 <TestThread+0x152>
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(patterns[i][j]->name);
 8002e42:	683b      	ldr	r3, [r7, #0]
 8002e44:	681d      	ldr	r5, [r3, #0]
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002e46:	7829      	ldrb	r1, [r5, #0]
 8002e48:	b139      	cbz	r1, 8002e5a <TestThread+0x17a>
    chSequentialStreamPut(chp, *msgp++);
 8002e4a:	6820      	ldr	r0, [r4, #0]
 8002e4c:	6803      	ldr	r3, [r0, #0]
 8002e4e:	689b      	ldr	r3, [r3, #8]
 8002e50:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002e52:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8002e56:	2900      	cmp	r1, #0
 8002e58:	d1f7      	bne.n	8002e4a <TestThread+0x16a>
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(patterns[i][j]->name);
      test_println(")");
 8002e5a:	485b      	ldr	r0, [pc, #364]	; (8002fc8 <TestThread+0x2e8>)
static void execute_test(const struct testcase *tcp) {
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
 8002e5c:	f8df 919c 	ldr.w	r9, [pc, #412]	; 8002ffc <TestThread+0x31c>
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 8002e60:	4d5a      	ldr	r5, [pc, #360]	; (8002fcc <TestThread+0x2ec>)
 8002e62:	f8df a17c 	ldr.w	sl, [pc, #380]	; 8002fe0 <TestThread+0x300>
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(patterns[i][j]->name);
      test_println(")");
 8002e66:	f7ff fe4b 	bl	8002b00 <test_println>
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
 8002e6a:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8002e6e:	f7fe fbb7 	bl	80015e0 <chThdSleep>

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
  for (i = 0; i < MAX_THREADS; i++)
    threads[i] = NULL;
 8002e72:	4a57      	ldr	r2, [pc, #348]	; (8002fd0 <TestThread+0x2f0>)
      test_print(patterns[i][j]->name);
      test_println(")");
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
 8002e74:	683f      	ldr	r7, [r7, #0]
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 8002e76:	f8c5 a000 	str.w	sl, [r5]
static void execute_test(const struct testcase *tcp) {
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
 8002e7a:	2300      	movs	r3, #0
  for (i = 0; i < MAX_THREADS; i++)
    threads[i] = NULL;
 8002e7c:	6013      	str	r3, [r2, #0]
 8002e7e:	6053      	str	r3, [r2, #4]
 8002e80:	6093      	str	r3, [r2, #8]
 8002e82:	60d3      	str	r3, [r2, #12]
 8002e84:	6113      	str	r3, [r2, #16]

  if (tcp->setup != NULL)
 8002e86:	687a      	ldr	r2, [r7, #4]
static void execute_test(const struct testcase *tcp) {
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
 8002e88:	f889 3000 	strb.w	r3, [r9]
  for (i = 0; i < MAX_THREADS; i++)
    threads[i] = NULL;

  if (tcp->setup != NULL)
 8002e8c:	b102      	cbz	r2, 8002e90 <TestThread+0x1b0>
    tcp->setup();
 8002e8e:	4790      	blx	r2
  tcp->execute();
 8002e90:	68fb      	ldr	r3, [r7, #12]
 8002e92:	4798      	blx	r3
  if (tcp->teardown != NULL)
 8002e94:	68bb      	ldr	r3, [r7, #8]
 8002e96:	b103      	cbz	r3, 8002e9a <TestThread+0x1ba>
    tcp->teardown();
 8002e98:	4798      	blx	r3

  test_wait_threads();
 8002e9a:	f7ff fed1 	bl	8002c40 <test_wait_threads>
      test_println(")");
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
      if (local_fail) {
 8002e9e:	f899 3000 	ldrb.w	r3, [r9]
 8002ea2:	2b00      	cmp	r3, #0
 8002ea4:	d053      	beq.n	8002f4e <TestThread+0x26e>
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 8002ea6:	4f4b      	ldr	r7, [pc, #300]	; (8002fd4 <TestThread+0x2f4>)
 8002ea8:	212d      	movs	r1, #45	; 0x2d
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002eaa:	6820      	ldr	r0, [r4, #0]
 8002eac:	6803      	ldr	r3, [r0, #0]
 8002eae:	689b      	ldr	r3, [r3, #8]
 8002eb0:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002eb2:	f817 1f01 	ldrb.w	r1, [r7, #1]!
 8002eb6:	2900      	cmp	r1, #0
 8002eb8:	d1f7      	bne.n	8002eaa <TestThread+0x1ca>
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
      if (local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(failpoint);
 8002eba:	4b47      	ldr	r3, [pc, #284]	; (8002fd8 <TestThread+0x2f8>)
 8002ebc:	4f47      	ldr	r7, [pc, #284]	; (8002fdc <TestThread+0x2fc>)
 8002ebe:	6818      	ldr	r0, [r3, #0]
 8002ec0:	f7ff fdde 	bl	8002a80 <test_printn>
 8002ec4:	2120      	movs	r1, #32
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002ec6:	6820      	ldr	r0, [r4, #0]
 8002ec8:	6803      	ldr	r3, [r0, #0]
 8002eca:	689b      	ldr	r3, [r3, #8]
 8002ecc:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002ece:	f817 1f01 	ldrb.w	r1, [r7, #1]!
 8002ed2:	2900      	cmp	r1, #0
 8002ed4:	d1f7      	bne.n	8002ec6 <TestThread+0x1e6>
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 8002ed6:	682b      	ldr	r3, [r5, #0]
 8002ed8:	4553      	cmp	r3, sl
 8002eda:	d909      	bls.n	8002ef0 <TestThread+0x210>
 8002edc:	4f40      	ldr	r7, [pc, #256]	; (8002fe0 <TestThread+0x300>)
    chSequentialStreamPut(chp, *cp++);
 8002ede:	6820      	ldr	r0, [r4, #0]
 8002ee0:	f817 1b01 	ldrb.w	r1, [r7], #1
 8002ee4:	6803      	ldr	r3, [r0, #0]
 8002ee6:	689b      	ldr	r3, [r3, #8]
 8002ee8:	4798      	blx	r3
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 8002eea:	682b      	ldr	r3, [r5, #0]
 8002eec:	429f      	cmp	r7, r3
 8002eee:	d3f6      	bcc.n	8002ede <TestThread+0x1fe>
      if (local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(failpoint);
        test_print(" [");
        print_tokens();
        test_println("])");
 8002ef0:	483c      	ldr	r0, [pc, #240]	; (8002fe4 <TestThread+0x304>)
 8002ef2:	f7ff fe05 	bl	8002b00 <test_println>
 8002ef6:	9b01      	ldr	r3, [sp, #4]
 8002ef8:	f8d3 8000 	ldr.w	r8, [r3]

  global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 8002efc:	f858 3026 	ldr.w	r3, [r8, r6, lsl #2]
 8002f00:	eb08 0786 	add.w	r7, r8, r6, lsl #2
 8002f04:	2b00      	cmp	r3, #0
 8002f06:	f47f af79 	bne.w	8002dfc <TestThread+0x11c>
#endif
  test_println("");

  global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
 8002f0a:	9b01      	ldr	r3, [sp, #4]
 8002f0c:	f853 8f04 	ldr.w	r8, [r3, #4]!
 8002f10:	9301      	str	r3, [sp, #4]
 8002f12:	f1b8 0f00 	cmp.w	r8, #0
 8002f16:	f47f af66 	bne.w	8002de6 <TestThread+0x106>
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
  }
  print_line();
 8002f1a:	f7ff fd99 	bl	8002a50 <print_line>
  test_println("");
 8002f1e:	4d32      	ldr	r5, [pc, #200]	; (8002fe8 <TestThread+0x308>)
 8002f20:	4813      	ldr	r0, [pc, #76]	; (8002f70 <TestThread+0x290>)
 8002f22:	f7ff fded 	bl	8002b00 <test_println>
 8002f26:	2146      	movs	r1, #70	; 0x46
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002f28:	6820      	ldr	r0, [r4, #0]
 8002f2a:	6803      	ldr	r3, [r0, #0]
 8002f2c:	689b      	ldr	r3, [r3, #8]
 8002f2e:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002f30:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8002f34:	2900      	cmp	r1, #0
 8002f36:	d1f7      	bne.n	8002f28 <TestThread+0x248>
    i++;
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (global_fail)
 8002f38:	4b20      	ldr	r3, [pc, #128]	; (8002fbc <TestThread+0x2dc>)
 8002f3a:	781b      	ldrb	r3, [r3, #0]
 8002f3c:	b95b      	cbnz	r3, 8002f56 <TestThread+0x276>
    test_println("FAILURE");
  else
    test_println("SUCCESS");
 8002f3e:	482b      	ldr	r0, [pc, #172]	; (8002fec <TestThread+0x30c>)
 8002f40:	f7ff fdde 	bl	8002b00 <test_println>

  return (msg_t)global_fail;
 8002f44:	4b1d      	ldr	r3, [pc, #116]	; (8002fbc <TestThread+0x2dc>)
 8002f46:	7818      	ldrb	r0, [r3, #0]
}
 8002f48:	b003      	add	sp, #12
 8002f4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        test_print(" [");
        print_tokens();
        test_println("])");
      }
      else
        test_println("--- Result: SUCCESS");
 8002f4e:	4828      	ldr	r0, [pc, #160]	; (8002ff0 <TestThread+0x310>)
 8002f50:	f7ff fdd6 	bl	8002b00 <test_println>
 8002f54:	e74b      	b.n	8002dee <TestThread+0x10e>
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (global_fail)
    test_println("FAILURE");
 8002f56:	4827      	ldr	r0, [pc, #156]	; (8002ff4 <TestThread+0x314>)
 8002f58:	f7ff fdd2 	bl	8002b00 <test_println>
  else
    test_println("SUCCESS");

  return (msg_t)global_fail;
 8002f5c:	4b17      	ldr	r3, [pc, #92]	; (8002fbc <TestThread+0x2dc>)
 8002f5e:	7818      	ldrb	r0, [r3, #0]
}
 8002f60:	b003      	add	sp, #12
 8002f62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002f66:	bf00      	nop
 8002f68:	20001c98 	.word	0x20001c98
 8002f6c:	080160f4 	.word	0x080160f4
 8002f70:	0801cd6c 	.word	0x0801cd6c
 8002f74:	080161d4 	.word	0x080161d4
 8002f78:	080161f0 	.word	0x080161f0
 8002f7c:	08016214 	.word	0x08016214
 8002f80:	08016108 	.word	0x08016108
 8002f84:	08016220 	.word	0x08016220
 8002f88:	0801611c 	.word	0x0801611c
 8002f8c:	08016238 	.word	0x08016238
 8002f90:	08016130 	.word	0x08016130
 8002f94:	08016280 	.word	0x08016280
 8002f98:	08016144 	.word	0x08016144
 8002f9c:	0801628c 	.word	0x0801628c
 8002fa0:	08016158 	.word	0x08016158
 8002fa4:	08016298 	.word	0x08016298
 8002fa8:	0801616c 	.word	0x0801616c
 8002fac:	080162b0 	.word	0x080162b0
 8002fb0:	08016180 	.word	0x08016180
 8002fb4:	08016310 	.word	0x08016310
 8002fb8:	080162dc 	.word	0x080162dc
 8002fbc:	20001c6c 	.word	0x20001c6c
 8002fc0:	08016194 	.word	0x08016194
 8002fc4:	080161a4 	.word	0x080161a4
 8002fc8:	08017fa4 	.word	0x08017fa4
 8002fcc:	20001c68 	.word	0x20001c68
 8002fd0:	20001c84 	.word	0x20001c84
 8002fd4:	080161a8 	.word	0x080161a8
 8002fd8:	20001c60 	.word	0x20001c60
 8002fdc:	080161c0 	.word	0x080161c0
 8002fe0:	20001c9c 	.word	0x20001c9c
 8002fe4:	080161f4 	.word	0x080161f4
 8002fe8:	080161c4 	.word	0x080161c4
 8002fec:	08016204 	.word	0x08016204
 8002ff0:	080161f8 	.word	0x080161f8
 8002ff4:	0801620c 	.word	0x0801620c
 8002ff8:	08016380 	.word	0x08016380
 8002ffc:	20001c64 	.word	0x20001c64

08003000 <thd1_execute>:

  test_emit_token(*(char *)p);
  return 0;
}

static void thd1_execute(void) {
 8003000:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003002:	4f27      	ldr	r7, [pc, #156]	; (80030a0 <thd1_execute+0xa0>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8003004:	4e27      	ldr	r6, [pc, #156]	; (80030a4 <thd1_execute+0xa4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003006:	69bb      	ldr	r3, [r7, #24]
 8003008:	4d27      	ldr	r5, [pc, #156]	; (80030a8 <thd1_execute+0xa8>)
 800300a:	689a      	ldr	r2, [r3, #8]
 800300c:	4b27      	ldr	r3, [pc, #156]	; (80030ac <thd1_execute+0xac>)
 800300e:	6830      	ldr	r0, [r6, #0]
 8003010:	4c27      	ldr	r4, [pc, #156]	; (80030b0 <thd1_execute+0xb0>)

  test_emit_token(*(char *)p);
  return 0;
}

static void thd1_execute(void) {
 8003012:	b083      	sub	sp, #12

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8003014:	3a05      	subs	r2, #5
 8003016:	9300      	str	r3, [sp, #0]
 8003018:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800301c:	462b      	mov	r3, r5
 800301e:	f7fe fa67 	bl	80014f0 <chThdCreateStatic>
 8003022:	69bb      	ldr	r3, [r7, #24]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8003024:	4923      	ldr	r1, [pc, #140]	; (80030b4 <thd1_execute+0xb4>)
 8003026:	689a      	ldr	r2, [r3, #8]
 8003028:	6873      	ldr	r3, [r6, #4]
  return 0;
}

static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800302a:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800302c:	9100      	str	r1, [sp, #0]
 800302e:	3a04      	subs	r2, #4
 8003030:	4618      	mov	r0, r3
 8003032:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003036:	462b      	mov	r3, r5
 8003038:	f7fe fa5a 	bl	80014f0 <chThdCreateStatic>
 800303c:	69ba      	ldr	r2, [r7, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800303e:	68b3      	ldr	r3, [r6, #8]
 8003040:	6892      	ldr	r2, [r2, #8]
 8003042:	491d      	ldr	r1, [pc, #116]	; (80030b8 <thd1_execute+0xb8>)
}

static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8003044:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8003046:	9100      	str	r1, [sp, #0]
 8003048:	3a03      	subs	r2, #3
 800304a:	4618      	mov	r0, r3
 800304c:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003050:	462b      	mov	r3, r5
 8003052:	f7fe fa4d 	bl	80014f0 <chThdCreateStatic>
 8003056:	69ba      	ldr	r2, [r7, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8003058:	68f3      	ldr	r3, [r6, #12]
 800305a:	6892      	ldr	r2, [r2, #8]
 800305c:	4917      	ldr	r1, [pc, #92]	; (80030bc <thd1_execute+0xbc>)

static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800305e:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8003060:	9100      	str	r1, [sp, #0]
 8003062:	3a02      	subs	r2, #2
 8003064:	4618      	mov	r0, r3
 8003066:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800306a:	462b      	mov	r3, r5
 800306c:	f7fe fa40 	bl	80014f0 <chThdCreateStatic>
 8003070:	69ba      	ldr	r2, [r7, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8003072:	6933      	ldr	r3, [r6, #16]
 8003074:	6892      	ldr	r2, [r2, #8]
 8003076:	4912      	ldr	r1, [pc, #72]	; (80030c0 <thd1_execute+0xc0>)
static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8003078:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800307a:	3a01      	subs	r2, #1
 800307c:	9100      	str	r1, [sp, #0]
 800307e:	4618      	mov	r0, r3
 8003080:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003084:	462b      	mov	r3, r5
 8003086:	f7fe fa33 	bl	80014f0 <chThdCreateStatic>
 800308a:	6120      	str	r0, [r4, #16]
  test_wait_threads();
 800308c:	f7ff fdd8 	bl	8002c40 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8003090:	490c      	ldr	r1, [pc, #48]	; (80030c4 <thd1_execute+0xc4>)
 8003092:	2001      	movs	r0, #1
}
 8003094:	b003      	add	sp, #12
 8003096:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
 800309a:	f7ff bd79 	b.w	8002b90 <_test_assert_sequence>
 800309e:	bf00      	nop
 80030a0:	20001150 	.word	0x20001150
 80030a4:	080160d0 	.word	0x080160d0
 80030a8:	080030d1 	.word	0x080030d1
 80030ac:	080163b0 	.word	0x080163b0
 80030b0:	20001c84 	.word	0x20001c84
 80030b4:	08017310 	.word	0x08017310
 80030b8:	080163a0 	.word	0x080163a0
 80030bc:	080163a4 	.word	0x080163a4
 80030c0:	080163a8 	.word	0x080163a8
 80030c4:	080163ac 	.word	0x080163ac
 80030c8:	f3af 8000 	nop.w
 80030cc:	f3af 8000 	nop.w

080030d0 <thread>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static msg_t thread(void *p) {
 80030d0:	b508      	push	{r3, lr}

  test_emit_token(*(char *)p);
 80030d2:	7800      	ldrb	r0, [r0, #0]
 80030d4:	f7ff fd34 	bl	8002b40 <test_emit_token>
  return 0;
}
 80030d8:	2000      	movs	r0, #0
 80030da:	bd08      	pop	{r3, pc}
 80030dc:	f3af 8000 	nop.w

080030e0 <thd2_execute>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 80030e0:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80030e2:	4f2b      	ldr	r7, [pc, #172]	; (8003190 <thd2_execute+0xb0>)

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80030e4:	4e2b      	ldr	r6, [pc, #172]	; (8003194 <thd2_execute+0xb4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80030e6:	69bb      	ldr	r3, [r7, #24]
 80030e8:	4d2b      	ldr	r5, [pc, #172]	; (8003198 <thd2_execute+0xb8>)
 80030ea:	689a      	ldr	r2, [r3, #8]
 80030ec:	4b2b      	ldr	r3, [pc, #172]	; (800319c <thd2_execute+0xbc>)
 80030ee:	6870      	ldr	r0, [r6, #4]
 80030f0:	4c2b      	ldr	r4, [pc, #172]	; (80031a0 <thd2_execute+0xc0>)
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 80030f2:	b083      	sub	sp, #12

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80030f4:	3a04      	subs	r2, #4
 80030f6:	9300      	str	r3, [sp, #0]
 80030f8:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80030fc:	462b      	mov	r3, r5
 80030fe:	f7fe f9f7 	bl	80014f0 <chThdCreateStatic>
 8003102:	69bb      	ldr	r3, [r7, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8003104:	4927      	ldr	r1, [pc, #156]	; (80031a4 <thd2_execute+0xc4>)
 8003106:	689a      	ldr	r2, [r3, #8]
 8003108:	6833      	ldr	r3, [r6, #0]
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800310a:	6060      	str	r0, [r4, #4]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800310c:	9100      	str	r1, [sp, #0]
 800310e:	3a05      	subs	r2, #5
 8003110:	4618      	mov	r0, r3
 8003112:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003116:	462b      	mov	r3, r5
 8003118:	f7fe f9ea 	bl	80014f0 <chThdCreateStatic>
 800311c:	69ba      	ldr	r2, [r7, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800311e:	6933      	ldr	r3, [r6, #16]
 8003120:	6892      	ldr	r2, [r2, #8]
 8003122:	4921      	ldr	r1, [pc, #132]	; (80031a8 <thd2_execute+0xc8>)
 */

static void thd2_execute(void) {

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8003124:	6020      	str	r0, [r4, #0]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8003126:	9100      	str	r1, [sp, #0]
 8003128:	3a01      	subs	r2, #1
 800312a:	4618      	mov	r0, r3
 800312c:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003130:	462b      	mov	r3, r5
 8003132:	f7fe f9dd 	bl	80014f0 <chThdCreateStatic>
 8003136:	69ba      	ldr	r2, [r7, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8003138:	68f3      	ldr	r3, [r6, #12]
 800313a:	6892      	ldr	r2, [r2, #8]
 800313c:	491b      	ldr	r1, [pc, #108]	; (80031ac <thd2_execute+0xcc>)

static void thd2_execute(void) {

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800313e:	6120      	str	r0, [r4, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8003140:	9100      	str	r1, [sp, #0]
 8003142:	3a02      	subs	r2, #2
 8003144:	4618      	mov	r0, r3
 8003146:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800314a:	462b      	mov	r3, r5
 800314c:	f7fe f9d0 	bl	80014f0 <chThdCreateStatic>
 8003150:	2320      	movs	r3, #32
 8003152:	60e0      	str	r0, [r4, #12]
 8003154:	f383 8811 	msr	BASEPRI, r3
 8003158:	69bb      	ldr	r3, [r7, #24]
  /* Done this way for coverage of chThdCreateI() and chThdStart().*/
  chSysLock();
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800315a:	68b0      	ldr	r0, [r6, #8]
 800315c:	689a      	ldr	r2, [r3, #8]
 800315e:	4b14      	ldr	r3, [pc, #80]	; (80031b0 <thd2_execute+0xd0>)
 8003160:	9300      	str	r3, [sp, #0]
 8003162:	3a03      	subs	r2, #3
 8003164:	462b      	mov	r3, r5
 8003166:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800316a:	f7fe f989 	bl	8001480 <chThdCreateI>
 800316e:	2300      	movs	r3, #0
 8003170:	60a0      	str	r0, [r4, #8]
 8003172:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  chThdStart(threads[2]);
 8003176:	68a0      	ldr	r0, [r4, #8]
 8003178:	f7fe f9fa 	bl	8001570 <chThdStart>
  test_wait_threads();
 800317c:	f7ff fd60 	bl	8002c40 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8003180:	490c      	ldr	r1, [pc, #48]	; (80031b4 <thd2_execute+0xd4>)
 8003182:	2001      	movs	r0, #1
}
 8003184:	b003      	add	sp, #12
 8003186:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  chSysLock();
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
  chSysUnlock();
  chThdStart(threads[2]);
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
 800318a:	f7ff bd01 	b.w	8002b90 <_test_assert_sequence>
 800318e:	bf00      	nop
 8003190:	20001150 	.word	0x20001150
 8003194:	080160d0 	.word	0x080160d0
 8003198:	080030d1 	.word	0x080030d1
 800319c:	08017310 	.word	0x08017310
 80031a0:	20001c84 	.word	0x20001c84
 80031a4:	080163b0 	.word	0x080163b0
 80031a8:	080163a8 	.word	0x080163a8
 80031ac:	080163a4 	.word	0x080163a4
 80031b0:	080163a0 	.word	0x080163a0
 80031b4:	080163ac 	.word	0x080163ac
 80031b8:	f3af 8000 	nop.w
 80031bc:	f3af 8000 	nop.w

080031c0 <thd3_execute>:
 * to verify that the priority change happens as expected.<br>
 * If the @p CH_CFG_USE_MUTEXES option is enabled then the priority changes are
 * also tested under priority inheritance boosted priority state.
 */

static void thd3_execute(void) {
 80031c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80031c2:	4e49      	ldr	r6, [pc, #292]	; (80032e8 <thd3_execute+0x128>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80031c4:	69b3      	ldr	r3, [r6, #24]
 80031c6:	689c      	ldr	r4, [r3, #8]
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
  p1 = chThdSetPriority(prio + 1);
 80031c8:	1c65      	adds	r5, r4, #1
 80031ca:	4628      	mov	r0, r5
 80031cc:	f7fe f9e0 	bl	8001590 <chThdSetPriority>
  test_assert(1, p1 == prio,
 80031d0:	1b01      	subs	r1, r0, r4

static void thd3_execute(void) {
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
  p1 = chThdSetPriority(prio + 1);
 80031d2:	4607      	mov	r7, r0
  test_assert(1, p1 == prio,
 80031d4:	fab1 f181 	clz	r1, r1
 80031d8:	2001      	movs	r0, #1
 80031da:	0949      	lsrs	r1, r1, #5
 80031dc:	f7ff fcc0 	bl	8002b60 <_test_assert>
 80031e0:	b100      	cbz	r0, 80031e4 <thd3_execute+0x24>
 80031e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80031e4:	69b3      	ldr	r3, [r6, #24]
              "unexpected returned priority level");
  test_assert(2, chThdGetPriorityX() == prio + 1,
 80031e6:	6899      	ldr	r1, [r3, #8]
 80031e8:	2002      	movs	r0, #2
 80031ea:	1a69      	subs	r1, r5, r1
 80031ec:	fab1 f181 	clz	r1, r1
 80031f0:	0949      	lsrs	r1, r1, #5
 80031f2:	f7ff fcb5 	bl	8002b60 <_test_assert>
 80031f6:	2800      	cmp	r0, #0
 80031f8:	d1f3      	bne.n	80031e2 <thd3_execute+0x22>
              "unexpected priority level");
  p1 = chThdSetPriority(p1);
 80031fa:	4638      	mov	r0, r7
 80031fc:	f7fe f9c8 	bl	8001590 <chThdSetPriority>
  test_assert(3, p1 == prio + 1,
 8003200:	1a29      	subs	r1, r5, r0
 8003202:	2003      	movs	r0, #3
 8003204:	fab1 f181 	clz	r1, r1
 8003208:	0949      	lsrs	r1, r1, #5
 800320a:	f7ff fca9 	bl	8002b60 <_test_assert>
 800320e:	2800      	cmp	r0, #0
 8003210:	d1e7      	bne.n	80031e2 <thd3_execute+0x22>
 8003212:	69b3      	ldr	r3, [r6, #24]
              "unexpected returned priority level");
  test_assert(4, chThdGetPriorityX() == prio,
 8003214:	6899      	ldr	r1, [r3, #8]
 8003216:	2004      	movs	r0, #4
 8003218:	1a61      	subs	r1, r4, r1
 800321a:	fab1 f181 	clz	r1, r1
 800321e:	0949      	lsrs	r1, r1, #5
 8003220:	f7ff fc9e 	bl	8002b60 <_test_assert>
 8003224:	2800      	cmp	r0, #0
 8003226:	d1dc      	bne.n	80031e2 <thd3_execute+0x22>
 8003228:	2320      	movs	r3, #32
 800322a:	f383 8811 	msr	BASEPRI, r3
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800322e:	69b2      	ldr	r2, [r6, #24]
              "unexpected priority level");

#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  /* Simulates a priority boost situation (p_prio > p_realprio).*/
  chSysLock();
  chThdGetSelfX()->p_prio += 2;
 8003230:	6893      	ldr	r3, [r2, #8]
 8003232:	3302      	adds	r3, #2
 8003234:	6093      	str	r3, [r2, #8]
 8003236:	f380 8811 	msr	BASEPRI, r0
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 800323a:	69b3      	ldr	r3, [r6, #24]
  chSysUnlock();
  test_assert(5, chThdGetPriorityX() == prio + 2,
 800323c:	6899      	ldr	r1, [r3, #8]
 800323e:	1ca7      	adds	r7, r4, #2
 8003240:	1a79      	subs	r1, r7, r1
 8003242:	2005      	movs	r0, #5
 8003244:	fab1 f181 	clz	r1, r1
 8003248:	0949      	lsrs	r1, r1, #5
 800324a:	f7ff fc89 	bl	8002b60 <_test_assert>
 800324e:	2800      	cmp	r0, #0
 8003250:	d1c7      	bne.n	80031e2 <thd3_execute+0x22>
              "unexpected priority level");

  /* Tries to raise but below the boost level. */
  p1 = chThdSetPriority(prio + 1);
 8003252:	4628      	mov	r0, r5
 8003254:	f7fe f99c 	bl	8001590 <chThdSetPriority>
  test_assert(6, p1 == prio,
 8003258:	1b01      	subs	r1, r0, r4
 800325a:	2006      	movs	r0, #6
 800325c:	fab1 f181 	clz	r1, r1
 8003260:	0949      	lsrs	r1, r1, #5
 8003262:	f7ff fc7d 	bl	8002b60 <_test_assert>
 8003266:	2800      	cmp	r0, #0
 8003268:	d1bb      	bne.n	80031e2 <thd3_execute+0x22>
              "unexpected returned priority level");
  test_assert(7, chThdGetSelfX()->p_prio == prio + 2,
 800326a:	69b3      	ldr	r3, [r6, #24]
 800326c:	6899      	ldr	r1, [r3, #8]
 800326e:	2007      	movs	r0, #7
 8003270:	1a79      	subs	r1, r7, r1
 8003272:	fab1 f181 	clz	r1, r1
 8003276:	0949      	lsrs	r1, r1, #5
 8003278:	f7ff fc72 	bl	8002b60 <_test_assert>
 800327c:	2800      	cmp	r0, #0
 800327e:	d1b0      	bne.n	80031e2 <thd3_execute+0x22>
              "unexpected priority level");
  test_assert(8, chThdGetSelfX()->p_realprio == prio + 1,
 8003280:	69b3      	ldr	r3, [r6, #24]
 8003282:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8003284:	2008      	movs	r0, #8
 8003286:	1a69      	subs	r1, r5, r1
 8003288:	fab1 f181 	clz	r1, r1
 800328c:	0949      	lsrs	r1, r1, #5
 800328e:	f7ff fc67 	bl	8002b60 <_test_assert>
 8003292:	2800      	cmp	r0, #0
 8003294:	d1a5      	bne.n	80031e2 <thd3_execute+0x22>
              "unexpected returned real priority level");

  /* Tries to raise above the boost level. */
  p1 = chThdSetPriority(prio + 3);
 8003296:	1ce7      	adds	r7, r4, #3
 8003298:	4638      	mov	r0, r7
 800329a:	f7fe f979 	bl	8001590 <chThdSetPriority>
  test_assert(9, p1 == prio + 1,
 800329e:	1a28      	subs	r0, r5, r0
 80032a0:	4241      	negs	r1, r0
 80032a2:	4141      	adcs	r1, r0
 80032a4:	2009      	movs	r0, #9
 80032a6:	f7ff fc5b 	bl	8002b60 <_test_assert>
 80032aa:	2800      	cmp	r0, #0
 80032ac:	d199      	bne.n	80031e2 <thd3_execute+0x22>
              "unexpected returned priority level");
  test_assert(10, chThdGetSelfX()->p_prio == prio + 3,
 80032ae:	69b3      	ldr	r3, [r6, #24]
 80032b0:	6899      	ldr	r1, [r3, #8]
 80032b2:	1a7a      	subs	r2, r7, r1
 80032b4:	4251      	negs	r1, r2
 80032b6:	4151      	adcs	r1, r2
 80032b8:	200a      	movs	r0, #10
 80032ba:	f7ff fc51 	bl	8002b60 <_test_assert>
 80032be:	2800      	cmp	r0, #0
 80032c0:	d18f      	bne.n	80031e2 <thd3_execute+0x22>
              "unexpected priority level");
  test_assert(11, chThdGetSelfX()->p_realprio == prio + 3,
 80032c2:	69b3      	ldr	r3, [r6, #24]
 80032c4:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 80032c6:	1a7b      	subs	r3, r7, r1
 80032c8:	4259      	negs	r1, r3
 80032ca:	4159      	adcs	r1, r3
 80032cc:	200b      	movs	r0, #11
 80032ce:	f7ff fc47 	bl	8002b60 <_test_assert>
 80032d2:	2800      	cmp	r0, #0
 80032d4:	d185      	bne.n	80031e2 <thd3_execute+0x22>
 80032d6:	2320      	movs	r3, #32
 80032d8:	f383 8811 	msr	BASEPRI, r3
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80032dc:	69b3      	ldr	r3, [r6, #24]
              "unexpected real priority level");

  chSysLock();
  chThdGetSelfX()->p_prio = prio;
 80032de:	609c      	str	r4, [r3, #8]
  chThdGetSelfX()->p_realprio = prio;
 80032e0:	63dc      	str	r4, [r3, #60]	; 0x3c
 80032e2:	f380 8811 	msr	BASEPRI, r0
 80032e6:	e77c      	b.n	80031e2 <thd3_execute+0x22>
 80032e8:	20001150 	.word	0x20001150
 80032ec:	f3af 8000 	nop.w

080032f0 <thd4_execute>:
 * <h2>Description</h2>
 * Delay APIs and associated macros are tested, the invoking thread is verified
 * to wake up at the exact expected time.
 */

static void thd4_execute(void) {
 80032f0:	b570      	push	{r4, r5, r6, lr}
  systime_t time;

  test_wait_tick();
 80032f2:	f7ff fcbd 	bl	8002c70 <test_wait_tick>
 80032f6:	2620      	movs	r6, #32
 80032f8:	f386 8811 	msr	BASEPRI, r6
 80032fc:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 8003300:	2300      	movs	r3, #0
 8003302:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8003304:	f383 8811 	msr	BASEPRI, r3

  /* Timeouts in microseconds.*/
  time = chVTGetSystemTime();
  chThdSleepMicroseconds(100000);
 8003308:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800330c:	f7fe f968 	bl	80015e0 <chThdSleep>
  test_assert_time_window(1,
 8003310:	f504 717a 	add.w	r1, r4, #1000	; 0x3e8
 8003314:	f204 32eb 	addw	r2, r4, #1003	; 0x3eb
 8003318:	2001      	movs	r0, #1
 800331a:	f7ff fc61 	bl	8002be0 <_test_assert_time_window>
 800331e:	b100      	cbz	r0, 8003322 <thd4_execute+0x32>
 8003320:	bd70      	pop	{r4, r5, r6, pc}
 8003322:	f386 8811 	msr	BASEPRI, r6
 8003326:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8003328:	f380 8811 	msr	BASEPRI, r0
                          time + US2ST(100000),
                          time + US2ST(100000) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in milliseconds.*/
  time = chVTGetSystemTime();
  chThdSleepMilliseconds(100);
 800332c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8003330:	f7fe f956 	bl	80015e0 <chThdSleep>
  test_assert_time_window(2,
 8003334:	f504 717a 	add.w	r1, r4, #1000	; 0x3e8
 8003338:	f204 32eb 	addw	r2, r4, #1003	; 0x3eb
 800333c:	2002      	movs	r0, #2
 800333e:	f7ff fc4f 	bl	8002be0 <_test_assert_time_window>
 8003342:	2800      	cmp	r0, #0
 8003344:	d1ec      	bne.n	8003320 <thd4_execute+0x30>
 8003346:	f386 8811 	msr	BASEPRI, r6
 800334a:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 800334c:	f380 8811 	msr	BASEPRI, r0
                          time + MS2ST(100),
                          time + MS2ST(100) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in seconds.*/
  time = chVTGetSystemTime();
  chThdSleepSeconds(1);
 8003350:	f242 7010 	movw	r0, #10000	; 0x2710
 8003354:	f7fe f944 	bl	80015e0 <chThdSleep>
  test_assert_time_window(3,
 8003358:	f504 511c 	add.w	r1, r4, #9984	; 0x2700
 800335c:	460a      	mov	r2, r1
 800335e:	3213      	adds	r2, #19
 8003360:	3110      	adds	r1, #16
 8003362:	2003      	movs	r0, #3
 8003364:	f7ff fc3c 	bl	8002be0 <_test_assert_time_window>
 8003368:	2800      	cmp	r0, #0
 800336a:	d1d9      	bne.n	8003320 <thd4_execute+0x30>
 800336c:	f386 8811 	msr	BASEPRI, r6
 8003370:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8003372:	f380 8811 	msr	BASEPRI, r0
                          time + S2ST(1),
                          time + S2ST(1) + CH_CFG_ST_TIMEDELTA + 1);

  /* Absolute timelines.*/
  time = chVTGetSystemTime() + MS2ST(100);
 8003376:	f504 757a 	add.w	r5, r4, #1000	; 0x3e8
  chThdSleepUntil(time);
 800337a:	4628      	mov	r0, r5
 800337c:	f7fe f940 	bl	8001600 <chThdSleepUntil>
  test_assert_time_window(4,
 8003380:	4629      	mov	r1, r5
 8003382:	f204 32eb 	addw	r2, r4, #1003	; 0x3eb
 8003386:	2004      	movs	r0, #4
                          time,
                          time + CH_CFG_ST_TIMEDELTA + 1);
}
 8003388:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
                          time + S2ST(1) + CH_CFG_ST_TIMEDELTA + 1);

  /* Absolute timelines.*/
  time = chVTGetSystemTime() + MS2ST(100);
  chThdSleepUntil(time);
  test_assert_time_window(4,
 800338c:	f7ff bc28 	b.w	8002be0 <_test_assert_time_window>

08003390 <sem1_execute>:
  chSemWait(&sem1);
  test_emit_token(*(char *)p);
  return 0;
}

static void sem1_execute(void) {
 8003390:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8003394:	4e48      	ldr	r6, [pc, #288]	; (80034b8 <sem1_execute+0x128>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8003396:	4f49      	ldr	r7, [pc, #292]	; (80034bc <sem1_execute+0x12c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003398:	69b3      	ldr	r3, [r6, #24]
 800339a:	f8d7 8000 	ldr.w	r8, [r7]
 800339e:	689a      	ldr	r2, [r3, #8]
 80033a0:	f8df 913c 	ldr.w	r9, [pc, #316]	; 80034e0 <sem1_execute+0x150>
 80033a4:	4b46      	ldr	r3, [pc, #280]	; (80034c0 <sem1_execute+0x130>)
 80033a6:	4d47      	ldr	r5, [pc, #284]	; (80034c4 <sem1_execute+0x134>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
  chSemSignal(&sem1);
 80033a8:	4c47      	ldr	r4, [pc, #284]	; (80034c8 <sem1_execute+0x138>)
  chSemWait(&sem1);
  test_emit_token(*(char *)p);
  return 0;
}

static void sem1_execute(void) {
 80033aa:	b083      	sub	sp, #12

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80033ac:	3205      	adds	r2, #5
 80033ae:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80033b2:	f8cd 9000 	str.w	r9, [sp]
 80033b6:	4640      	mov	r0, r8
 80033b8:	f7fe f89a 	bl	80014f0 <chThdCreateStatic>
 80033bc:	69b3      	ldr	r3, [r6, #24]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 80033be:	6879      	ldr	r1, [r7, #4]
 80033c0:	689a      	ldr	r2, [r3, #8]
 80033c2:	4b42      	ldr	r3, [pc, #264]	; (80034cc <sem1_execute+0x13c>)
  return 0;
}

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80033c4:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 80033c6:	3201      	adds	r2, #1
 80033c8:	4608      	mov	r0, r1
 80033ca:	9300      	str	r3, [sp, #0]
 80033cc:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80033d0:	4b3b      	ldr	r3, [pc, #236]	; (80034c0 <sem1_execute+0x130>)
 80033d2:	f7fe f88d 	bl	80014f0 <chThdCreateStatic>
 80033d6:	69b3      	ldr	r3, [r6, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 80033d8:	68b9      	ldr	r1, [r7, #8]
 80033da:	689a      	ldr	r2, [r3, #8]
 80033dc:	4b3c      	ldr	r3, [pc, #240]	; (80034d0 <sem1_execute+0x140>)
}

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 80033de:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 80033e0:	3203      	adds	r2, #3
 80033e2:	4608      	mov	r0, r1
 80033e4:	9300      	str	r3, [sp, #0]
 80033e6:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80033ea:	4b35      	ldr	r3, [pc, #212]	; (80034c0 <sem1_execute+0x130>)
 80033ec:	f7fe f880 	bl	80014f0 <chThdCreateStatic>
 80033f0:	69b3      	ldr	r3, [r6, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 80033f2:	68f9      	ldr	r1, [r7, #12]
 80033f4:	689a      	ldr	r2, [r3, #8]
 80033f6:	4b37      	ldr	r3, [pc, #220]	; (80034d4 <sem1_execute+0x144>)

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 80033f8:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 80033fa:	3204      	adds	r2, #4
 80033fc:	4608      	mov	r0, r1
 80033fe:	9300      	str	r3, [sp, #0]
 8003400:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003404:	4b2e      	ldr	r3, [pc, #184]	; (80034c0 <sem1_execute+0x130>)
 8003406:	f7fe f873 	bl	80014f0 <chThdCreateStatic>
 800340a:	69b3      	ldr	r3, [r6, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 800340c:	6939      	ldr	r1, [r7, #16]
 800340e:	689a      	ldr	r2, [r3, #8]
 8003410:	4b31      	ldr	r3, [pc, #196]	; (80034d8 <sem1_execute+0x148>)
static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8003412:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8003414:	3202      	adds	r2, #2
 8003416:	4608      	mov	r0, r1
 8003418:	9300      	str	r3, [sp, #0]
 800341a:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800341e:	4b28      	ldr	r3, [pc, #160]	; (80034c0 <sem1_execute+0x130>)
 8003420:	f7fe f866 	bl	80014f0 <chThdCreateStatic>
 8003424:	6128      	str	r0, [r5, #16]
  chSemSignal(&sem1);
 8003426:	4620      	mov	r0, r4
 8003428:	f7fe faca 	bl	80019c0 <chSemSignal>
  chSemSignal(&sem1);
 800342c:	4620      	mov	r0, r4
 800342e:	f7fe fac7 	bl	80019c0 <chSemSignal>
  chSemSignal(&sem1);
 8003432:	4620      	mov	r0, r4
 8003434:	f7fe fac4 	bl	80019c0 <chSemSignal>
  chSemSignal(&sem1);
 8003438:	4620      	mov	r0, r4
 800343a:	f7fe fac1 	bl	80019c0 <chSemSignal>
  chSemSignal(&sem1);
 800343e:	4620      	mov	r0, r4
 8003440:	f7fe fabe 	bl	80019c0 <chSemSignal>
  test_wait_threads();
 8003444:	f7ff fbfc 	bl	8002c40 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
 8003448:	2001      	movs	r0, #1
 800344a:	4924      	ldr	r1, [pc, #144]	; (80034dc <sem1_execute+0x14c>)
 800344c:	f7ff fba0 	bl	8002b90 <_test_assert_sequence>
 8003450:	4607      	mov	r7, r0
 8003452:	b110      	cbz	r0, 800345a <sem1_execute+0xca>
  chSemAddCounterI(&sem1, 2);
  chSchRescheduleS();
  chSysUnlock();
  test_wait_threads();
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
}
 8003454:	b003      	add	sp, #12
 8003456:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800345a:	69b2      	ldr	r2, [r6, #24]
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
#endif
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800345c:	4b18      	ldr	r3, [pc, #96]	; (80034c0 <sem1_execute+0x130>)
 800345e:	6892      	ldr	r2, [r2, #8]
 8003460:	f8cd 9000 	str.w	r9, [sp]
 8003464:	3205      	adds	r2, #5
 8003466:	4640      	mov	r0, r8
 8003468:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800346c:	f7fe f840 	bl	80014f0 <chThdCreateStatic>
 8003470:	2620      	movs	r6, #32
 8003472:	6028      	str	r0, [r5, #0]
 8003474:	f386 8811 	msr	BASEPRI, r6
  chSysLock();
  chSemAddCounterI(&sem1, 2);
 8003478:	2102      	movs	r1, #2
 800347a:	4620      	mov	r0, r4
 800347c:	f7fe fad0 	bl	8001a20 <chSemAddCounterI>
  chSchRescheduleS();
 8003480:	f7fd ff56 	bl	8001330 <chSchRescheduleS>
 8003484:	f387 8811 	msr	BASEPRI, r7
  chSysUnlock();
  test_wait_threads();
 8003488:	f7ff fbda 	bl	8002c40 <test_wait_threads>
 800348c:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
 8003490:	68a1      	ldr	r1, [r4, #8]
 8003492:	2002      	movs	r0, #2
 8003494:	f1a1 0101 	sub.w	r1, r1, #1
 8003498:	fab1 f181 	clz	r1, r1
 800349c:	0949      	lsrs	r1, r1, #5
 800349e:	f7ff fb5f 	bl	8002b60 <_test_assert>
 80034a2:	b920      	cbnz	r0, 80034ae <sem1_execute+0x11e>
 80034a4:	f380 8811 	msr	BASEPRI, r0
}
 80034a8:	b003      	add	sp, #12
 80034aa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80034ae:	f387 8811 	msr	BASEPRI, r7
 80034b2:	b003      	add	sp, #12
 80034b4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80034b8:	20001150 	.word	0x20001150
 80034bc:	080160d0 	.word	0x080160d0
 80034c0:	08003511 	.word	0x08003511
 80034c4:	20001c84 	.word	0x20001c84
 80034c8:	20000800 	.word	0x20000800
 80034cc:	080163a4 	.word	0x080163a4
 80034d0:	080163a0 	.word	0x080163a0
 80034d4:	08017310 	.word	0x08017310
 80034d8:	080163b0 	.word	0x080163b0
 80034dc:	080163ac 	.word	0x080163ac
 80034e0:	080163a8 	.word	0x080163a8
 80034e4:	f3af 8000 	nop.w
 80034e8:	f3af 8000 	nop.w
 80034ec:	f3af 8000 	nop.w

080034f0 <thread3>:
static void sem3_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static msg_t thread3(void *p) {
 80034f0:	b510      	push	{r4, lr}

  (void)p;
  chSemWait(&sem1);
 80034f2:	4c04      	ldr	r4, [pc, #16]	; (8003504 <thread3+0x14>)
 80034f4:	4620      	mov	r0, r4
 80034f6:	f7fe fa0b 	bl	8001910 <chSemWait>
  chSemSignal(&sem1);
 80034fa:	4620      	mov	r0, r4
 80034fc:	f7fe fa60 	bl	80019c0 <chSemSignal>
  return 0;
}
 8003500:	2000      	movs	r0, #0
 8003502:	bd10      	pop	{r4, pc}
 8003504:	20000800 	.word	0x20000800
 8003508:	f3af 8000 	nop.w
 800350c:	f3af 8000 	nop.w

08003510 <thread1>:
static void sem1_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static msg_t thread1(void *p) {
 8003510:	b510      	push	{r4, lr}
 8003512:	4604      	mov	r4, r0

  chSemWait(&sem1);
 8003514:	4803      	ldr	r0, [pc, #12]	; (8003524 <thread1+0x14>)
 8003516:	f7fe f9fb 	bl	8001910 <chSemWait>
  test_emit_token(*(char *)p);
 800351a:	7820      	ldrb	r0, [r4, #0]
 800351c:	f7ff fb10 	bl	8002b40 <test_emit_token>
  return 0;
}
 8003520:	2000      	movs	r0, #0
 8003522:	bd10      	pop	{r4, pc}
 8003524:	20000800 	.word	0x20000800
 8003528:	f3af 8000 	nop.w
 800352c:	f3af 8000 	nop.w

08003530 <sem1_setup>:
 * setting.
 */

static void sem1_setup(void) {

  chSemObjectInit(&sem1, 0);
 8003530:	4801      	ldr	r0, [pc, #4]	; (8003538 <sem1_setup+0x8>)
 8003532:	2100      	movs	r1, #0
 8003534:	f7fe b9bc 	b.w	80018b0 <chSemObjectInit>
 8003538:	20000800 	.word	0x20000800
 800353c:	f3af 8000 	nop.w

08003540 <sem2_setup>:
 * correct after each operation.
 */

static void sem2_setup(void) {

  chSemObjectInit(&sem1, 0);
 8003540:	4801      	ldr	r0, [pc, #4]	; (8003548 <sem2_setup+0x8>)
 8003542:	2100      	movs	r1, #0
 8003544:	f7fe b9b4 	b.w	80018b0 <chSemObjectInit>
 8003548:	20000800 	.word	0x20000800
 800354c:	f3af 8000 	nop.w

08003550 <sem3_setup>:
 * correct after each operation.
 */

static void sem3_setup(void) {

  chSemObjectInit(&sem1, 0);
 8003550:	4801      	ldr	r0, [pc, #4]	; (8003558 <sem3_setup+0x8>)
 8003552:	2100      	movs	r1, #0
 8003554:	f7fe b9ac 	b.w	80018b0 <chSemObjectInit>
 8003558:	20000800 	.word	0x20000800
 800355c:	f3af 8000 	nop.w

08003560 <thread2>:
static void sem2_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static msg_t thread2(void *p) {
 8003560:	b508      	push	{r3, lr}

  (void)p;
  chThdSleepMilliseconds(50);
 8003562:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8003566:	f7fe f83b 	bl	80015e0 <chThdSleep>
 800356a:	2320      	movs	r3, #32
 800356c:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chSemSignalI(&sem1); /* For coverage reasons */
 8003570:	4804      	ldr	r0, [pc, #16]	; (8003584 <thread2+0x24>)
 8003572:	f7fe fa45 	bl	8001a00 <chSemSignalI>
  chSchRescheduleS();
 8003576:	f7fd fedb 	bl	8001330 <chSchRescheduleS>
 800357a:	2000      	movs	r0, #0
 800357c:	f380 8811 	msr	BASEPRI, r0
  chSysUnlock();
  return 0;
}
 8003580:	bd08      	pop	{r3, pc}
 8003582:	bf00      	nop
 8003584:	20000800 	.word	0x20000800
 8003588:	f3af 8000 	nop.w
 800358c:	f3af 8000 	nop.w

08003590 <sem2_execute>:

static void sem2_execute(void) {
 8003590:	b570      	push	{r4, r5, r6, lr}
  msg_t msg;

  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
 8003592:	4c4e      	ldr	r4, [pc, #312]	; (80036cc <sem2_execute+0x13c>)
  chSchRescheduleS();
  chSysUnlock();
  return 0;
}

static void sem2_execute(void) {
 8003594:	b082      	sub	sp, #8
  msg_t msg;

  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
 8003596:	2100      	movs	r1, #0
 8003598:	4620      	mov	r0, r4
 800359a:	f7fe fa01 	bl	80019a0 <chSemWaitTimeout>
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
 800359e:	f1a0 31ff 	sub.w	r1, r0, #4294967295
 80035a2:	2001      	movs	r0, #1
 80035a4:	fab1 f181 	clz	r1, r1
 80035a8:	0949      	lsrs	r1, r1, #5
 80035aa:	f7ff fad9 	bl	8002b60 <_test_assert>
 80035ae:	b108      	cbz	r0, 80035b4 <sem2_execute+0x24>
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
}
 80035b0:	b002      	add	sp, #8
 80035b2:	bd70      	pop	{r4, r5, r6, pc}
 *
 * @notapi
 */
static inline bool queue_isempty(threads_queue_t *tqp) {

  return (bool)(tqp->p_next == (thread_t *)tqp);
 80035b4:	6821      	ldr	r1, [r4, #0]
  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
  test_assert(2, queue_isempty(&sem1.s_queue), "queue not empty");
 80035b6:	2002      	movs	r0, #2
 80035b8:	1b09      	subs	r1, r1, r4
 80035ba:	fab1 f181 	clz	r1, r1
 80035be:	0949      	lsrs	r1, r1, #5
 80035c0:	f7ff face 	bl	8002b60 <_test_assert>
 80035c4:	2800      	cmp	r0, #0
 80035c6:	d1f3      	bne.n	80035b0 <sem2_execute+0x20>
  test_assert(3, sem1.s_cnt == 0, "counter not zero");
 80035c8:	68a1      	ldr	r1, [r4, #8]
 80035ca:	fab1 f181 	clz	r1, r1
 80035ce:	2003      	movs	r0, #3
 80035d0:	0949      	lsrs	r1, r1, #5
 80035d2:	f7ff fac5 	bl	8002b60 <_test_assert>
 80035d6:	2800      	cmp	r0, #0
 80035d8:	d1ea      	bne.n	80035b0 <sem2_execute+0x20>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80035da:	4b3d      	ldr	r3, [pc, #244]	; (80036d0 <sem2_execute+0x140>)

  /*
   * Testing not timeout condition.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80035dc:	4a3d      	ldr	r2, [pc, #244]	; (80036d4 <sem2_execute+0x144>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80035de:	699b      	ldr	r3, [r3, #24]
 80035e0:	6811      	ldr	r1, [r2, #0]
 80035e2:	689a      	ldr	r2, [r3, #8]
 80035e4:	4b3c      	ldr	r3, [pc, #240]	; (80036d8 <sem2_execute+0x148>)
 80035e6:	9000      	str	r0, [sp, #0]
 80035e8:	3a01      	subs	r2, #1
 80035ea:	4608      	mov	r0, r1
 80035ec:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80035f0:	f7fd ff7e 	bl	80014f0 <chThdCreateStatic>
 80035f4:	4b39      	ldr	r3, [pc, #228]	; (80036dc <sem2_execute+0x14c>)
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
 80035f6:	f241 3188 	movw	r1, #5000	; 0x1388
  test_assert(3, sem1.s_cnt == 0, "counter not zero");

  /*
   * Testing not timeout condition.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80035fa:	6018      	str	r0, [r3, #0]
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
 80035fc:	4620      	mov	r0, r4
 80035fe:	f7fe f9cf 	bl	80019a0 <chSemWaitTimeout>
 8003602:	4605      	mov	r5, r0
  test_wait_threads();
 8003604:	f7ff fb1c 	bl	8002c40 <test_wait_threads>
  test_assert(4, msg == MSG_OK, "wrong wake-up message");
 8003608:	fab5 f185 	clz	r1, r5
 800360c:	2004      	movs	r0, #4
 800360e:	0949      	lsrs	r1, r1, #5
 8003610:	f7ff faa6 	bl	8002b60 <_test_assert>
 8003614:	2800      	cmp	r0, #0
 8003616:	d1cb      	bne.n	80035b0 <sem2_execute+0x20>
 8003618:	6821      	ldr	r1, [r4, #0]
  test_assert(5, queue_isempty(&sem1.s_queue), "queue not empty");
 800361a:	2005      	movs	r0, #5
 800361c:	1b09      	subs	r1, r1, r4
 800361e:	fab1 f181 	clz	r1, r1
 8003622:	0949      	lsrs	r1, r1, #5
 8003624:	f7ff fa9c 	bl	8002b60 <_test_assert>
 8003628:	2800      	cmp	r0, #0
 800362a:	d1c1      	bne.n	80035b0 <sem2_execute+0x20>
  test_assert(6, sem1.s_cnt == 0, "counter not zero");
 800362c:	68a1      	ldr	r1, [r4, #8]
 800362e:	fab1 f181 	clz	r1, r1
 8003632:	2006      	movs	r0, #6
 8003634:	0949      	lsrs	r1, r1, #5
 8003636:	f7ff fa93 	bl	8002b60 <_test_assert>
 800363a:	4605      	mov	r5, r0
 800363c:	2800      	cmp	r0, #0
 800363e:	d1b7      	bne.n	80035b0 <sem2_execute+0x20>

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
 8003640:	f7ff fb16 	bl	8002c70 <test_wait_tick>
 8003644:	2320      	movs	r3, #32
 8003646:	f383 8811 	msr	BASEPRI, r3
 800364a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800364e:	6a5e      	ldr	r6, [r3, #36]	; 0x24
 8003650:	f385 8811 	msr	BASEPRI, r5
 8003654:	2541      	movs	r5, #65	; 0x41
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
    test_emit_token('A' + i);
 8003656:	4628      	mov	r0, r5
 8003658:	f7ff fa72 	bl	8002b40 <test_emit_token>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
 800365c:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8003660:	481a      	ldr	r0, [pc, #104]	; (80036cc <sem2_execute+0x13c>)
 8003662:	f7fe f99d 	bl	80019a0 <chSemWaitTimeout>
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
 8003666:	f1a0 31ff 	sub.w	r1, r0, #4294967295
 800366a:	2007      	movs	r0, #7
 800366c:	fab1 f181 	clz	r1, r1
 8003670:	0949      	lsrs	r1, r1, #5
 8003672:	f7ff fa75 	bl	8002b60 <_test_assert>
 8003676:	2800      	cmp	r0, #0
 8003678:	d19a      	bne.n	80035b0 <sem2_execute+0x20>
 800367a:	6821      	ldr	r1, [r4, #0]
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
 800367c:	2008      	movs	r0, #8
 800367e:	1b09      	subs	r1, r1, r4
 8003680:	fab1 f181 	clz	r1, r1
 8003684:	0949      	lsrs	r1, r1, #5
 8003686:	f7ff fa6b 	bl	8002b60 <_test_assert>
 800368a:	2800      	cmp	r0, #0
 800368c:	d190      	bne.n	80035b0 <sem2_execute+0x20>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
 800368e:	68a1      	ldr	r1, [r4, #8]
 8003690:	fab1 f181 	clz	r1, r1
 8003694:	2009      	movs	r0, #9
 8003696:	0949      	lsrs	r1, r1, #5
 8003698:	f7ff fa62 	bl	8002b60 <_test_assert>
 800369c:	3501      	adds	r5, #1
 800369e:	b2ed      	uxtb	r5, r5
 80036a0:	2800      	cmp	r0, #0
 80036a2:	d185      	bne.n	80035b0 <sem2_execute+0x20>
  /*
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
 80036a4:	2d46      	cmp	r5, #70	; 0x46
 80036a6:	d1d6      	bne.n	8003656 <sem2_execute+0xc6>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
 80036a8:	200a      	movs	r0, #10
 80036aa:	490d      	ldr	r1, [pc, #52]	; (80036e0 <sem2_execute+0x150>)
 80036ac:	f7ff fa70 	bl	8002b90 <_test_assert_sequence>
 80036b0:	2800      	cmp	r0, #0
 80036b2:	f47f af7d 	bne.w	80035b0 <sem2_execute+0x20>
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
 80036b6:	200b      	movs	r0, #11
 80036b8:	f606 11c4 	addw	r1, r6, #2500	; 0x9c4
 80036bc:	f606 12d8 	addw	r2, r6, #2520	; 0x9d8
}
 80036c0:	b002      	add	sp, #8
 80036c2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
 80036c6:	f7ff ba8b 	b.w	8002be0 <_test_assert_time_window>
 80036ca:	bf00      	nop
 80036cc:	20000800 	.word	0x20000800
 80036d0:	20001150 	.word	0x20001150
 80036d4:	080160d0 	.word	0x080160d0
 80036d8:	08003561 	.word	0x08003561
 80036dc:	20001c84 	.word	0x20001c84
 80036e0:	080163ac 	.word	0x080163ac
 80036e4:	f3af 8000 	nop.w
 80036e8:	f3af 8000 	nop.w
 80036ec:	f3af 8000 	nop.w

080036f0 <sem3_execute>:
  chSemWait(&sem1);
  chSemSignal(&sem1);
  return 0;
}

static void sem3_execute(void) {
 80036f0:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80036f2:	4b20      	ldr	r3, [pc, #128]	; (8003774 <sem3_execute+0x84>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 80036f4:	4a20      	ldr	r2, [pc, #128]	; (8003778 <sem3_execute+0x88>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80036f6:	699b      	ldr	r3, [r3, #24]
 80036f8:	6810      	ldr	r0, [r2, #0]
 80036fa:	689a      	ldr	r2, [r3, #8]
 80036fc:	4b1f      	ldr	r3, [pc, #124]	; (800377c <sem3_execute+0x8c>)
  chSemSignalWait(&sem1, &sem1);
 80036fe:	4c20      	ldr	r4, [pc, #128]	; (8003780 <sem3_execute+0x90>)
  chSemWait(&sem1);
  chSemSignal(&sem1);
  return 0;
}

static void sem3_execute(void) {
 8003700:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8003702:	2100      	movs	r1, #0
 8003704:	3201      	adds	r2, #1
 8003706:	9100      	str	r1, [sp, #0]
 8003708:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800370c:	f7fd fef0 	bl	80014f0 <chThdCreateStatic>
 8003710:	4b1c      	ldr	r3, [pc, #112]	; (8003784 <sem3_execute+0x94>)
  chSemSignalWait(&sem1, &sem1);
 8003712:	4621      	mov	r1, r4
  return 0;
}

static void sem3_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8003714:	6018      	str	r0, [r3, #0]
  chSemSignalWait(&sem1, &sem1);
 8003716:	4620      	mov	r0, r4
 8003718:	f7fe f99a 	bl	8001a50 <chSemSignalWait>
 800371c:	6821      	ldr	r1, [r4, #0]
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
 800371e:	2001      	movs	r0, #1
 8003720:	1b09      	subs	r1, r1, r4
 8003722:	fab1 f181 	clz	r1, r1
 8003726:	0949      	lsrs	r1, r1, #5
 8003728:	f7ff fa1a 	bl	8002b60 <_test_assert>
 800372c:	b108      	cbz	r0, 8003732 <sem3_execute+0x42>
  test_assert(2, sem1.s_cnt == 0, "counter not zero");

  chSemSignalWait(&sem1, &sem1);
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
}
 800372e:	b002      	add	sp, #8
 8003730:	bd10      	pop	{r4, pc}
static void sem3_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
  chSemSignalWait(&sem1, &sem1);
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(2, sem1.s_cnt == 0, "counter not zero");
 8003732:	68a1      	ldr	r1, [r4, #8]
 8003734:	fab1 f181 	clz	r1, r1
 8003738:	2002      	movs	r0, #2
 800373a:	0949      	lsrs	r1, r1, #5
 800373c:	f7ff fa10 	bl	8002b60 <_test_assert>
 8003740:	2800      	cmp	r0, #0
 8003742:	d1f4      	bne.n	800372e <sem3_execute+0x3e>

  chSemSignalWait(&sem1, &sem1);
 8003744:	4621      	mov	r1, r4
 8003746:	4620      	mov	r0, r4
 8003748:	f7fe f982 	bl	8001a50 <chSemSignalWait>
 800374c:	6821      	ldr	r1, [r4, #0]
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
 800374e:	2003      	movs	r0, #3
 8003750:	1b09      	subs	r1, r1, r4
 8003752:	fab1 f181 	clz	r1, r1
 8003756:	0949      	lsrs	r1, r1, #5
 8003758:	f7ff fa02 	bl	8002b60 <_test_assert>
 800375c:	2800      	cmp	r0, #0
 800375e:	d1e6      	bne.n	800372e <sem3_execute+0x3e>
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
 8003760:	68a1      	ldr	r1, [r4, #8]
 8003762:	fab1 f181 	clz	r1, r1
 8003766:	2004      	movs	r0, #4
 8003768:	0949      	lsrs	r1, r1, #5
}
 800376a:	b002      	add	sp, #8
 800376c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(2, sem1.s_cnt == 0, "counter not zero");

  chSemSignalWait(&sem1, &sem1);
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
 8003770:	f7ff b9f6 	b.w	8002b60 <_test_assert>
 8003774:	20001150 	.word	0x20001150
 8003778:	080160d0 	.word	0x080160d0
 800377c:	080034f1 	.word	0x080034f1
 8003780:	20000800 	.word	0x20000800
 8003784:	20001c84 	.word	0x20001c84
 8003788:	f3af 8000 	nop.w
 800378c:	f3af 8000 	nop.w

08003790 <thread4>:
 * <h2>Description</h2>
 * This test case tests the binary semaphores functionality. The test both
 * checks the binary semaphore status and the expected status of the underlying
 * counting semaphore.
 */
static msg_t thread4(void *p) {
 8003790:	b508      	push	{r3, lr}
 8003792:	2220      	movs	r2, #32
 8003794:	f382 8811 	msr	BASEPRI, r2
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < 1) {
 8003798:	6883      	ldr	r3, [r0, #8]
 800379a:	2b00      	cmp	r3, #0
 800379c:	dd05      	ble.n	80037aa <thread4+0x1a>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 800379e:	f7fd fdc7 	bl	8001330 <chSchRescheduleS>
 80037a2:	2000      	movs	r0, #0
 80037a4:	f380 8811 	msr	BASEPRI, r0

  chBSemSignal((binary_semaphore_t *)p);
  return 0;
}
 80037a8:	bd08      	pop	{r3, pc}
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < 1) {
    chSemSignalI(&bsp->bs_sem);
 80037aa:	f7fe f929 	bl	8001a00 <chSemSignalI>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 80037ae:	f7fd fdbf 	bl	8001330 <chSchRescheduleS>
 80037b2:	2000      	movs	r0, #0
 80037b4:	f380 8811 	msr	BASEPRI, r0
 80037b8:	bd08      	pop	{r3, pc}
 80037ba:	bf00      	nop
 80037bc:	f3af 8000 	nop.w

080037c0 <sem4_execute>:

static void sem4_execute(void) {
 80037c0:	b570      	push	{r4, r5, r6, lr}
 80037c2:	b086      	sub	sp, #24
 *
 * @init
 */
static inline void chBSemObjectInit(binary_semaphore_t *bsp, bool taken) {

  chSemObjectInit(&bsp->bs_sem, taken ? 0 : 1);
 80037c4:	a803      	add	r0, sp, #12
 80037c6:	2100      	movs	r1, #0
 80037c8:	f7fe f872 	bl	80018b0 <chSemObjectInit>
 *
 * @api
 */
static inline void chBSemReset(binary_semaphore_t *bsp, bool taken) {

  chSemReset(&bsp->bs_sem, taken ? 0 : 1);
 80037cc:	a803      	add	r0, sp, #12
 80037ce:	2100      	movs	r1, #0
 80037d0:	f7fe f88e 	bl	80018f0 <chSemReset>
 80037d4:	2520      	movs	r5, #32
 80037d6:	f385 8811 	msr	BASEPRI, r5
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return bsp->bs_sem.s_cnt > 0 ? false : true;
 80037da:	9905      	ldr	r1, [sp, #20]
  binary_semaphore_t bsem;
  
  /* Creates a taken binary semaphore.*/
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");
 80037dc:	2900      	cmp	r1, #0
 80037de:	f04f 0001 	mov.w	r0, #1
 80037e2:	bfcc      	ite	gt
 80037e4:	2100      	movgt	r1, #0
 80037e6:	2101      	movle	r1, #1
 80037e8:	f7ff f9ba 	bl	8002b60 <_test_assert>
 80037ec:	4604      	mov	r4, r0
 80037ee:	b120      	cbz	r0, 80037fa <sem4_execute+0x3a>
 80037f0:	2300      	movs	r3, #0
 80037f2:	f383 8811 	msr	BASEPRI, r3

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
}
 80037f6:	b006      	add	sp, #24
 80037f8:	bd70      	pop	{r4, r5, r6, pc}
 80037fa:	f380 8811 	msr	BASEPRI, r0
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80037fe:	4b41      	ldr	r3, [pc, #260]	; (8003904 <sem4_execute+0x144>)
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8003800:	4a41      	ldr	r2, [pc, #260]	; (8003908 <sem4_execute+0x148>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003802:	699b      	ldr	r3, [r3, #24]
 8003804:	6810      	ldr	r0, [r2, #0]
 8003806:	689a      	ldr	r2, [r3, #8]
 8003808:	4b40      	ldr	r3, [pc, #256]	; (800390c <sem4_execute+0x14c>)
 800380a:	a903      	add	r1, sp, #12
 800380c:	9100      	str	r1, [sp, #0]
 800380e:	3a01      	subs	r2, #1
 8003810:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003814:	f7fd fe6c 	bl	80014f0 <chThdCreateStatic>
 8003818:	4b3d      	ldr	r3, [pc, #244]	; (8003910 <sem4_execute+0x150>)
 800381a:	6018      	str	r0, [r3, #0]
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {

  return chSemWait(&bsp->bs_sem);
 800381c:	a803      	add	r0, sp, #12
 800381e:	f7fe f877 	bl	8001910 <chSemWait>
 8003822:	f385 8811 	msr	BASEPRI, r5
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return bsp->bs_sem.s_cnt > 0 ? false : true;
 8003826:	9905      	ldr	r1, [sp, #20]
                                 
  /* Waits to be signaled.*/
  chBSemWait(&bsem);
  
  /* The binary semaphore is expected to be taken.*/
  test_assert_lock(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
 8003828:	2900      	cmp	r1, #0
 800382a:	bfcc      	ite	gt
 800382c:	2100      	movgt	r1, #0
 800382e:	2101      	movle	r1, #1
 8003830:	2002      	movs	r0, #2
 8003832:	f7ff f995 	bl	8002b60 <_test_assert>
 8003836:	b118      	cbz	r0, 8003840 <sem4_execute+0x80>
 8003838:	f384 8811 	msr	BASEPRI, r4

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
}
 800383c:	b006      	add	sp, #24
 800383e:	bd70      	pop	{r4, r5, r6, pc}
 8003840:	f380 8811 	msr	BASEPRI, r0
 8003844:	f385 8811 	msr	BASEPRI, r5
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < 1) {
 8003848:	9b05      	ldr	r3, [sp, #20]
 800384a:	2b00      	cmp	r3, #0
 800384c:	dd24      	ble.n	8003898 <sem4_execute+0xd8>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 800384e:	f7fd fd6f 	bl	8001330 <chSchRescheduleS>
 8003852:	2400      	movs	r4, #0
 8003854:	f384 8811 	msr	BASEPRI, r4
 8003858:	2620      	movs	r6, #32
 800385a:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(2, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Releasing it, check both the binary semaphore state and the underlying
     counter semaphore state..*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
 800385e:	9905      	ldr	r1, [sp, #20]
 8003860:	42a1      	cmp	r1, r4
 8003862:	f04f 0003 	mov.w	r0, #3
 8003866:	bfd4      	ite	le
 8003868:	2100      	movle	r1, #0
 800386a:	2101      	movgt	r1, #1
 800386c:	f7ff f978 	bl	8002b60 <_test_assert>
 8003870:	4605      	mov	r5, r0
 8003872:	2800      	cmp	r0, #0
 8003874:	d1e0      	bne.n	8003838 <sem4_execute+0x78>
 8003876:	f380 8811 	msr	BASEPRI, r0
 800387a:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 800387e:	9905      	ldr	r1, [sp, #20]
 8003880:	2004      	movs	r0, #4
 8003882:	f1a1 0101 	sub.w	r1, r1, #1
 8003886:	fab1 f181 	clz	r1, r1
 800388a:	0949      	lsrs	r1, r1, #5
 800388c:	f7ff f968 	bl	8002b60 <_test_assert>
 8003890:	b130      	cbz	r0, 80038a0 <sem4_execute+0xe0>
 8003892:	f385 8811 	msr	BASEPRI, r5
 8003896:	e7ae      	b.n	80037f6 <sem4_execute+0x36>
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < 1) {
    chSemSignalI(&bsp->bs_sem);
 8003898:	a803      	add	r0, sp, #12
 800389a:	f7fe f8b1 	bl	8001a00 <chSemSignalI>
 800389e:	e7d6      	b.n	800384e <sem4_execute+0x8e>
 80038a0:	f380 8811 	msr	BASEPRI, r0
 80038a4:	f386 8811 	msr	BASEPRI, r6
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < 1) {
 80038a8:	9b05      	ldr	r3, [sp, #20]
 80038aa:	2b00      	cmp	r3, #0
 80038ac:	dd25      	ble.n	80038fa <sem4_execute+0x13a>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 80038ae:	f7fd fd3f 	bl	8001330 <chSchRescheduleS>
 80038b2:	2400      	movs	r4, #0
 80038b4:	f384 8811 	msr	BASEPRI, r4
 80038b8:	2620      	movs	r6, #32
 80038ba:	f386 8811 	msr	BASEPRI, r6

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
 80038be:	9905      	ldr	r1, [sp, #20]
 80038c0:	42a1      	cmp	r1, r4
 80038c2:	f04f 0003 	mov.w	r0, #3
 80038c6:	bfd4      	ite	le
 80038c8:	2100      	movle	r1, #0
 80038ca:	2101      	movgt	r1, #1
 80038cc:	f7ff f948 	bl	8002b60 <_test_assert>
 80038d0:	4605      	mov	r5, r0
 80038d2:	2800      	cmp	r0, #0
 80038d4:	d1b0      	bne.n	8003838 <sem4_execute+0x78>
 80038d6:	f380 8811 	msr	BASEPRI, r0
 80038da:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 80038de:	9905      	ldr	r1, [sp, #20]
 80038e0:	2005      	movs	r0, #5
 80038e2:	f1a1 0101 	sub.w	r1, r1, #1
 80038e6:	fab1 f181 	clz	r1, r1
 80038ea:	0949      	lsrs	r1, r1, #5
 80038ec:	f7ff f938 	bl	8002b60 <_test_assert>
 80038f0:	2800      	cmp	r0, #0
 80038f2:	d1ce      	bne.n	8003892 <sem4_execute+0xd2>
 80038f4:	f380 8811 	msr	BASEPRI, r0
 80038f8:	e77d      	b.n	80037f6 <sem4_execute+0x36>
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < 1) {
    chSemSignalI(&bsp->bs_sem);
 80038fa:	a803      	add	r0, sp, #12
 80038fc:	f7fe f880 	bl	8001a00 <chSemSignalI>
 8003900:	e7d5      	b.n	80038ae <sem4_execute+0xee>
 8003902:	bf00      	nop
 8003904:	20001150 	.word	0x20001150
 8003908:	080160d0 	.word	0x080160d0
 800390c:	08003791 	.word	0x08003791
 8003910:	20001c84 	.word	0x20001c84
 8003914:	f3af 8000 	nop.w
 8003918:	f3af 8000 	nop.w
 800391c:	f3af 8000 	nop.w

08003920 <mtx1_execute>:
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  return 0;
}

static void mtx1_execute(void) {
 8003920:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003922:	4f2b      	ldr	r7, [pc, #172]	; (80039d0 <mtx1_execute+0xb0>)

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8003924:	4e2b      	ldr	r6, [pc, #172]	; (80039d4 <mtx1_execute+0xb4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003926:	69bb      	ldr	r3, [r7, #24]
}

static void mtx1_execute(void) {

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
 8003928:	482b      	ldr	r0, [pc, #172]	; (80039d8 <mtx1_execute+0xb8>)
 800392a:	689c      	ldr	r4, [r3, #8]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 800392c:	4d2b      	ldr	r5, [pc, #172]	; (80039dc <mtx1_execute+0xbc>)
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  return 0;
}

static void mtx1_execute(void) {
 800392e:	b083      	sub	sp, #12

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
 8003930:	f7fe f936 	bl	8001ba0 <chMtxLock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8003934:	4b2a      	ldr	r3, [pc, #168]	; (80039e0 <mtx1_execute+0xc0>)
 8003936:	9300      	str	r3, [sp, #0]
 8003938:	1c62      	adds	r2, r4, #1
 800393a:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800393e:	4b29      	ldr	r3, [pc, #164]	; (80039e4 <mtx1_execute+0xc4>)
 8003940:	6830      	ldr	r0, [r6, #0]
 8003942:	f7fd fdd5 	bl	80014f0 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8003946:	6871      	ldr	r1, [r6, #4]
 8003948:	4b27      	ldr	r3, [pc, #156]	; (80039e8 <mtx1_execute+0xc8>)

static void mtx1_execute(void) {

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 800394a:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 800394c:	1ca2      	adds	r2, r4, #2
 800394e:	4608      	mov	r0, r1
 8003950:	9300      	str	r3, [sp, #0]
 8003952:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003956:	4b23      	ldr	r3, [pc, #140]	; (80039e4 <mtx1_execute+0xc4>)
 8003958:	f7fd fdca 	bl	80014f0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 800395c:	68b1      	ldr	r1, [r6, #8]
 800395e:	4b23      	ldr	r3, [pc, #140]	; (80039ec <mtx1_execute+0xcc>)
static void mtx1_execute(void) {

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8003960:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8003962:	1ce2      	adds	r2, r4, #3
 8003964:	4608      	mov	r0, r1
 8003966:	9300      	str	r3, [sp, #0]
 8003968:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800396c:	4b1d      	ldr	r3, [pc, #116]	; (80039e4 <mtx1_execute+0xc4>)
 800396e:	f7fd fdbf 	bl	80014f0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8003972:	68f1      	ldr	r1, [r6, #12]
 8003974:	4b1e      	ldr	r3, [pc, #120]	; (80039f0 <mtx1_execute+0xd0>)

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8003976:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8003978:	1d22      	adds	r2, r4, #4
 800397a:	4608      	mov	r0, r1
 800397c:	9300      	str	r3, [sp, #0]
 800397e:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003982:	4b18      	ldr	r3, [pc, #96]	; (80039e4 <mtx1_execute+0xc4>)
 8003984:	f7fd fdb4 	bl	80014f0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8003988:	6931      	ldr	r1, [r6, #16]
 800398a:	4b1a      	ldr	r3, [pc, #104]	; (80039f4 <mtx1_execute+0xd4>)
  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800398c:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800398e:	1d62      	adds	r2, r4, #5
 8003990:	4608      	mov	r0, r1
 8003992:	9300      	str	r3, [sp, #0]
 8003994:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003998:	4b12      	ldr	r3, [pc, #72]	; (80039e4 <mtx1_execute+0xc4>)
 800399a:	f7fd fda9 	bl	80014f0 <chThdCreateStatic>
 800399e:	6128      	str	r0, [r5, #16]
  chMtxUnlock(&m1);
 80039a0:	480d      	ldr	r0, [pc, #52]	; (80039d8 <mtx1_execute+0xb8>)
 80039a2:	f7fe f925 	bl	8001bf0 <chMtxUnlock>
  test_wait_threads();
 80039a6:	f7ff f94b 	bl	8002c40 <test_wait_threads>
 80039aa:	69bb      	ldr	r3, [r7, #24]
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
 80039ac:	6899      	ldr	r1, [r3, #8]
 80039ae:	2001      	movs	r0, #1
 80039b0:	1a61      	subs	r1, r4, r1
 80039b2:	fab1 f181 	clz	r1, r1
 80039b6:	0949      	lsrs	r1, r1, #5
 80039b8:	f7ff f8d2 	bl	8002b60 <_test_assert>
 80039bc:	b108      	cbz	r0, 80039c2 <mtx1_execute+0xa2>
  test_assert_sequence(2, "ABCDE");
}
 80039be:	b003      	add	sp, #12
 80039c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  chMtxUnlock(&m1);
  test_wait_threads();
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
  test_assert_sequence(2, "ABCDE");
 80039c2:	490d      	ldr	r1, [pc, #52]	; (80039f8 <mtx1_execute+0xd8>)
 80039c4:	2002      	movs	r0, #2
}
 80039c6:	b003      	add	sp, #12
 80039c8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  chMtxUnlock(&m1);
  test_wait_threads();
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
  test_assert_sequence(2, "ABCDE");
 80039cc:	f7ff b8e0 	b.w	8002b90 <_test_assert_sequence>
 80039d0:	20001150 	.word	0x20001150
 80039d4:	080160d0 	.word	0x080160d0
 80039d8:	2000080c 	.word	0x2000080c
 80039dc:	20001c84 	.word	0x20001c84
 80039e0:	080163b0 	.word	0x080163b0
 80039e4:	08003a01 	.word	0x08003a01
 80039e8:	08017310 	.word	0x08017310
 80039ec:	080163a0 	.word	0x080163a0
 80039f0:	080163a4 	.word	0x080163a4
 80039f4:	080163a8 	.word	0x080163a8
 80039f8:	080163ac 	.word	0x080163ac
 80039fc:	f3af 8000 	nop.w

08003a00 <thread1>:
static void mtx1_setup(void) {

  chMtxObjectInit(&m1);
}

static msg_t thread1(void *p) {
 8003a00:	b538      	push	{r3, r4, r5, lr}

  chMtxLock(&m1);
 8003a02:	4c06      	ldr	r4, [pc, #24]	; (8003a1c <thread1+0x1c>)
static void mtx1_setup(void) {

  chMtxObjectInit(&m1);
}

static msg_t thread1(void *p) {
 8003a04:	4605      	mov	r5, r0

  chMtxLock(&m1);
 8003a06:	4620      	mov	r0, r4
 8003a08:	f7fe f8ca 	bl	8001ba0 <chMtxLock>
  test_emit_token(*(char *)p);
 8003a0c:	7828      	ldrb	r0, [r5, #0]
 8003a0e:	f7ff f897 	bl	8002b40 <test_emit_token>
  chMtxUnlock(&m1);
 8003a12:	4620      	mov	r0, r4
 8003a14:	f7fe f8ec 	bl	8001bf0 <chMtxUnlock>
  return 0;
}
 8003a18:	2000      	movs	r0, #0
 8003a1a:	bd38      	pop	{r3, r4, r5, pc}
 8003a1c:	2000080c 	.word	0x2000080c

08003a20 <thread12>:
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
  return 0;
}

static msg_t thread12(void *p) {
 8003a20:	b538      	push	{r3, r4, r5, lr}

  chMtxLock(&m2);
 8003a22:	4c06      	ldr	r4, [pc, #24]	; (8003a3c <thread12+0x1c>)
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
  return 0;
}

static msg_t thread12(void *p) {
 8003a24:	4605      	mov	r5, r0

  chMtxLock(&m2);
 8003a26:	4620      	mov	r0, r4
 8003a28:	f7fe f8ba 	bl	8001ba0 <chMtxLock>
  test_emit_token(*(char *)p);
 8003a2c:	7828      	ldrb	r0, [r5, #0]
 8003a2e:	f7ff f887 	bl	8002b40 <test_emit_token>
  chMtxUnlock(&m2);
 8003a32:	4620      	mov	r0, r4
 8003a34:	f7fe f8dc 	bl	8001bf0 <chMtxUnlock>
  return 0;
}
 8003a38:	2000      	movs	r0, #0
 8003a3a:	bd38      	pop	{r3, r4, r5, pc}
 8003a3c:	2000081c 	.word	0x2000081c

08003a40 <mtx1_setup>:
 * priority order regardless of the initial order.
 */

static void mtx1_setup(void) {

  chMtxObjectInit(&m1);
 8003a40:	4801      	ldr	r0, [pc, #4]	; (8003a48 <mtx1_setup+0x8>)
 8003a42:	f7fe b83d 	b.w	8001ac0 <chMtxObjectInit>
 8003a46:	bf00      	nop
 8003a48:	2000080c 	.word	0x2000080c
 8003a4c:	f3af 8000 	nop.w

08003a50 <mtx4_setup>:
 * thread with precise timing.<br>
 * The test expects that the priority changes caused by the priority
 * inheritance algorithm happen at the right moment and with the right values.
 */

static void mtx4_setup(void) {
 8003a50:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 8003a52:	4804      	ldr	r0, [pc, #16]	; (8003a64 <mtx4_setup+0x14>)
 8003a54:	f7fe f834 	bl	8001ac0 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 8003a58:	4803      	ldr	r0, [pc, #12]	; (8003a68 <mtx4_setup+0x18>)
}
 8003a5a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 */

static void mtx4_setup(void) {

  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
 8003a5e:	f7fe b82f 	b.w	8001ac0 <chMtxObjectInit>
 8003a62:	bf00      	nop
 8003a64:	2000080c 	.word	0x2000080c
 8003a68:	2000081c 	.word	0x2000081c
 8003a6c:	f3af 8000 	nop.w

08003a70 <mtx5_setup>:
 * operation.
 */

static void mtx5_setup(void) {

  chMtxObjectInit(&m1);
 8003a70:	4801      	ldr	r0, [pc, #4]	; (8003a78 <mtx5_setup+0x8>)
 8003a72:	f7fe b825 	b.w	8001ac0 <chMtxObjectInit>
 8003a76:	bf00      	nop
 8003a78:	2000080c 	.word	0x2000080c
 8003a7c:	f3af 8000 	nop.w

08003a80 <thread4b>:
  chMtxLock(&m2);
  chMtxUnlock(&m2);
  return 0;
}

static msg_t thread4b(void *p) {
 8003a80:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(150);
  chMtxLock(&m1);
 8003a82:	4c06      	ldr	r4, [pc, #24]	; (8003a9c <thread4b+0x1c>)
}

static msg_t thread4b(void *p) {

  (void)p;
  chThdSleepMilliseconds(150);
 8003a84:	f240 50dc 	movw	r0, #1500	; 0x5dc
 8003a88:	f7fd fdaa 	bl	80015e0 <chThdSleep>
  chMtxLock(&m1);
 8003a8c:	4620      	mov	r0, r4
 8003a8e:	f7fe f887 	bl	8001ba0 <chMtxLock>
  chMtxUnlock(&m1);
 8003a92:	4620      	mov	r0, r4
 8003a94:	f7fe f8ac 	bl	8001bf0 <chMtxUnlock>
  return 0;
}
 8003a98:	2000      	movs	r0, #0
 8003a9a:	bd10      	pop	{r4, pc}
 8003a9c:	2000080c 	.word	0x2000080c

08003aa0 <thread4a>:

  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static msg_t thread4a(void *p) {
 8003aa0:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(50);
  chMtxLock(&m2);
 8003aa2:	4c06      	ldr	r4, [pc, #24]	; (8003abc <thread4a+0x1c>)
}

static msg_t thread4a(void *p) {

  (void)p;
  chThdSleepMilliseconds(50);
 8003aa4:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8003aa8:	f7fd fd9a 	bl	80015e0 <chThdSleep>
  chMtxLock(&m2);
 8003aac:	4620      	mov	r0, r4
 8003aae:	f7fe f877 	bl	8001ba0 <chMtxLock>
  chMtxUnlock(&m2);
 8003ab2:	4620      	mov	r0, r4
 8003ab4:	f7fe f89c 	bl	8001bf0 <chMtxUnlock>
  return 0;
}
 8003ab8:	2000      	movs	r0, #0
 8003aba:	bd10      	pop	{r4, pc}
 8003abc:	2000081c 	.word	0x2000081c

08003ac0 <mtx4_execute>:
  chMtxLock(&m1);
  chMtxUnlock(&m1);
  return 0;
}

static void mtx4_execute(void) {
 8003ac0:	e92d 46f0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003ac4:	4d8e      	ldr	r5, [pc, #568]	; (8003d00 <mtx4_execute+0x240>)
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 8003ac6:	4e8f      	ldr	r6, [pc, #572]	; (8003d04 <mtx4_execute+0x244>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003ac8:	69ab      	ldr	r3, [r5, #24]
 8003aca:	6832      	ldr	r2, [r6, #0]
 8003acc:	689c      	ldr	r4, [r3, #8]
 8003ace:	4b8e      	ldr	r3, [pc, #568]	; (8003d08 <mtx4_execute+0x248>)
 8003ad0:	4f8e      	ldr	r7, [pc, #568]	; (8003d0c <mtx4_execute+0x24c>)
  chMtxLock(&m1);
  chMtxUnlock(&m1);
  return 0;
}

static void mtx4_execute(void) {
 8003ad2:	b085      	sub	sp, #20
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
 8003ad4:	f104 0901 	add.w	r9, r4, #1
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 8003ad8:	4610      	mov	r0, r2
 8003ada:	9203      	str	r2, [sp, #12]
 8003adc:	9300      	str	r3, [sp, #0]
 8003ade:	464a      	mov	r2, r9
 8003ae0:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003ae4:	4b8a      	ldr	r3, [pc, #552]	; (8003d10 <mtx4_execute+0x250>)
 8003ae6:	f7fd fd03 	bl	80014f0 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 8003aea:	6876      	ldr	r6, [r6, #4]
 8003aec:	4b89      	ldr	r3, [pc, #548]	; (8003d14 <mtx4_execute+0x254>)
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 8003aee:	6038      	str	r0, [r7, #0]
static void mtx4_execute(void) {
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
 8003af0:	f104 0a02 	add.w	sl, r4, #2
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 8003af4:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003af8:	4652      	mov	r2, sl
 8003afa:	9300      	str	r3, [sp, #0]
 8003afc:	4630      	mov	r0, r6
 8003afe:	4b86      	ldr	r3, [pc, #536]	; (8003d18 <mtx4_execute+0x258>)
 8003b00:	f7fd fcf6 	bl	80014f0 <chThdCreateStatic>
 8003b04:	6078      	str	r0, [r7, #4]
  chMtxLock(&m2);
 8003b06:	4885      	ldr	r0, [pc, #532]	; (8003d1c <mtx4_execute+0x25c>)
 8003b08:	f7fe f84a 	bl	8001ba0 <chMtxLock>
 8003b0c:	69ab      	ldr	r3, [r5, #24]
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
 8003b0e:	6899      	ldr	r1, [r3, #8]
 8003b10:	2001      	movs	r0, #1
 8003b12:	1a61      	subs	r1, r4, r1
 8003b14:	fab1 f181 	clz	r1, r1
 8003b18:	0949      	lsrs	r1, r1, #5
 8003b1a:	f7ff f821 	bl	8002b60 <_test_assert>
 8003b1e:	b110      	cbz	r0, 8003b26 <mtx4_execute+0x66>
  chThdSleepMilliseconds(100);
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
  chMtxUnlockAll();
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
  test_wait_threads();
}
 8003b20:	b005      	add	sp, #20
 8003b22:	e8bd 86f0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, pc}
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
  chMtxLock(&m2);
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
  chThdSleepMilliseconds(100);
 8003b26:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8003b2a:	f7fd fd59 	bl	80015e0 <chThdSleep>
 8003b2e:	69ab      	ldr	r3, [r5, #24]
  test_assert(2, chThdGetPriorityX() == p1, "wrong priority level");
 8003b30:	6899      	ldr	r1, [r3, #8]
 8003b32:	2002      	movs	r0, #2
 8003b34:	ebc1 0109 	rsb	r1, r1, r9
 8003b38:	fab1 f181 	clz	r1, r1
 8003b3c:	0949      	lsrs	r1, r1, #5
 8003b3e:	f7ff f80f 	bl	8002b60 <_test_assert>
 8003b42:	2800      	cmp	r0, #0
 8003b44:	d1ec      	bne.n	8003b20 <mtx4_execute+0x60>
  chMtxLock(&m1);
 8003b46:	4876      	ldr	r0, [pc, #472]	; (8003d20 <mtx4_execute+0x260>)
 8003b48:	f7fe f82a 	bl	8001ba0 <chMtxLock>
 8003b4c:	69ab      	ldr	r3, [r5, #24]
  test_assert(3, chThdGetPriorityX() == p1, "wrong priority level");
 8003b4e:	6899      	ldr	r1, [r3, #8]
 8003b50:	2003      	movs	r0, #3
 8003b52:	ebc1 0109 	rsb	r1, r1, r9
 8003b56:	fab1 f181 	clz	r1, r1
 8003b5a:	0949      	lsrs	r1, r1, #5
 8003b5c:	f7ff f800 	bl	8002b60 <_test_assert>
 8003b60:	2800      	cmp	r0, #0
 8003b62:	d1dd      	bne.n	8003b20 <mtx4_execute+0x60>
  chThdSleepMilliseconds(100);
 8003b64:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8003b68:	f7fd fd3a 	bl	80015e0 <chThdSleep>
 8003b6c:	69ab      	ldr	r3, [r5, #24]
  test_assert(4, chThdGetPriorityX() == p2, "wrong priority level");
 8003b6e:	6899      	ldr	r1, [r3, #8]
 8003b70:	2004      	movs	r0, #4
 8003b72:	ebc1 010a 	rsb	r1, r1, sl
 8003b76:	fab1 f181 	clz	r1, r1
 8003b7a:	0949      	lsrs	r1, r1, #5
 8003b7c:	f7fe fff0 	bl	8002b60 <_test_assert>
 8003b80:	2800      	cmp	r0, #0
 8003b82:	d1cd      	bne.n	8003b20 <mtx4_execute+0x60>
  chMtxUnlock(&m1);
 8003b84:	4866      	ldr	r0, [pc, #408]	; (8003d20 <mtx4_execute+0x260>)
 8003b86:	f7fe f833 	bl	8001bf0 <chMtxUnlock>
 8003b8a:	69ab      	ldr	r3, [r5, #24]
  test_assert(5, chThdGetPriorityX() == p1, "wrong priority level");
 8003b8c:	6899      	ldr	r1, [r3, #8]
 8003b8e:	2005      	movs	r0, #5
 8003b90:	ebc1 0109 	rsb	r1, r1, r9
 8003b94:	fab1 f181 	clz	r1, r1
 8003b98:	0949      	lsrs	r1, r1, #5
 8003b9a:	f7fe ffe1 	bl	8002b60 <_test_assert>
 8003b9e:	2800      	cmp	r0, #0
 8003ba0:	d1be      	bne.n	8003b20 <mtx4_execute+0x60>
  chThdSleepMilliseconds(100);
 8003ba2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8003ba6:	f7fd fd1b 	bl	80015e0 <chThdSleep>
 8003baa:	69ab      	ldr	r3, [r5, #24]
  test_assert(6, chThdGetPriorityX() == p1, "wrong priority level");
 8003bac:	6899      	ldr	r1, [r3, #8]
 8003bae:	2006      	movs	r0, #6
 8003bb0:	ebc1 0109 	rsb	r1, r1, r9
 8003bb4:	fab1 f181 	clz	r1, r1
 8003bb8:	0949      	lsrs	r1, r1, #5
 8003bba:	f7fe ffd1 	bl	8002b60 <_test_assert>
 8003bbe:	2800      	cmp	r0, #0
 8003bc0:	d1ae      	bne.n	8003b20 <mtx4_execute+0x60>
  chMtxUnlockAll();
 8003bc2:	f7fe f86d 	bl	8001ca0 <chMtxUnlockAll>
 8003bc6:	69ab      	ldr	r3, [r5, #24]
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
 8003bc8:	6899      	ldr	r1, [r3, #8]
 8003bca:	2007      	movs	r0, #7
 8003bcc:	1a61      	subs	r1, r4, r1
 8003bce:	fab1 f181 	clz	r1, r1
 8003bd2:	0949      	lsrs	r1, r1, #5
 8003bd4:	f7fe ffc4 	bl	8002b60 <_test_assert>
 8003bd8:	2800      	cmp	r0, #0
 8003bda:	d1a1      	bne.n	8003b20 <mtx4_execute+0x60>
  test_wait_threads();
 8003bdc:	f7ff f830 	bl	8002c40 <test_wait_threads>

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 8003be0:	4b50      	ldr	r3, [pc, #320]	; (8003d24 <mtx4_execute+0x264>)
 8003be2:	9300      	str	r3, [sp, #0]
 8003be4:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003be8:	464a      	mov	r2, r9
 8003bea:	4b49      	ldr	r3, [pc, #292]	; (8003d10 <mtx4_execute+0x250>)
 8003bec:	9803      	ldr	r0, [sp, #12]
 8003bee:	f7fd fc7f 	bl	80014f0 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 8003bf2:	4b4d      	ldr	r3, [pc, #308]	; (8003d28 <mtx4_execute+0x268>)
  chMtxUnlockAll();
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
  test_wait_threads();

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 8003bf4:	6038      	str	r0, [r7, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 8003bf6:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003bfa:	9300      	str	r3, [sp, #0]
 8003bfc:	4652      	mov	r2, sl
 8003bfe:	4b46      	ldr	r3, [pc, #280]	; (8003d18 <mtx4_execute+0x258>)
 8003c00:	4630      	mov	r0, r6
 8003c02:	f7fd fc75 	bl	80014f0 <chThdCreateStatic>
 8003c06:	6078      	str	r0, [r7, #4]
  chMtxLock(&m2);
 8003c08:	4844      	ldr	r0, [pc, #272]	; (8003d1c <mtx4_execute+0x25c>)
 8003c0a:	f7fd ffc9 	bl	8001ba0 <chMtxLock>
 8003c0e:	69ab      	ldr	r3, [r5, #24]
  test_assert(8, chThdGetPriorityX() == p, "wrong priority level");
 8003c10:	6899      	ldr	r1, [r3, #8]
 8003c12:	2008      	movs	r0, #8
 8003c14:	1a61      	subs	r1, r4, r1
 8003c16:	fab1 f181 	clz	r1, r1
 8003c1a:	0949      	lsrs	r1, r1, #5
 8003c1c:	f7fe ffa0 	bl	8002b60 <_test_assert>
 8003c20:	2800      	cmp	r0, #0
 8003c22:	f47f af7d 	bne.w	8003b20 <mtx4_execute+0x60>
  chThdSleepMilliseconds(100);
 8003c26:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8003c2a:	f7fd fcd9 	bl	80015e0 <chThdSleep>
 8003c2e:	69ab      	ldr	r3, [r5, #24]
  test_assert(9, chThdGetPriorityX() == p1, "wrong priority level");
 8003c30:	6899      	ldr	r1, [r3, #8]
 8003c32:	ebc1 0c09 	rsb	ip, r1, r9
 8003c36:	f1dc 0100 	rsbs	r1, ip, #0
 8003c3a:	eb41 010c 	adc.w	r1, r1, ip
 8003c3e:	2009      	movs	r0, #9
 8003c40:	f7fe ff8e 	bl	8002b60 <_test_assert>
 8003c44:	2800      	cmp	r0, #0
 8003c46:	f47f af6b 	bne.w	8003b20 <mtx4_execute+0x60>
  chMtxLock(&m1);
 8003c4a:	4835      	ldr	r0, [pc, #212]	; (8003d20 <mtx4_execute+0x260>)
 8003c4c:	f7fd ffa8 	bl	8001ba0 <chMtxLock>
 8003c50:	69ab      	ldr	r3, [r5, #24]
  test_assert(10, chThdGetPriorityX() == p1, "wrong priority level");
 8003c52:	6899      	ldr	r1, [r3, #8]
 8003c54:	ebc1 0e09 	rsb	lr, r1, r9
 8003c58:	f1de 0100 	rsbs	r1, lr, #0
 8003c5c:	eb41 010e 	adc.w	r1, r1, lr
 8003c60:	200a      	movs	r0, #10
 8003c62:	f7fe ff7d 	bl	8002b60 <_test_assert>
 8003c66:	2800      	cmp	r0, #0
 8003c68:	f47f af5a 	bne.w	8003b20 <mtx4_execute+0x60>
  chThdSleepMilliseconds(100);
 8003c6c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8003c70:	f7fd fcb6 	bl	80015e0 <chThdSleep>
 8003c74:	69ab      	ldr	r3, [r5, #24]
  test_assert(11, chThdGetPriorityX() == p2, "wrong priority level");
 8003c76:	6899      	ldr	r1, [r3, #8]
 8003c78:	ebc1 070a 	rsb	r7, r1, sl
 8003c7c:	4279      	negs	r1, r7
 8003c7e:	f04f 000b 	mov.w	r0, #11
 8003c82:	4179      	adcs	r1, r7
 8003c84:	f7fe ff6c 	bl	8002b60 <_test_assert>
 8003c88:	4606      	mov	r6, r0
 8003c8a:	2800      	cmp	r0, #0
 8003c8c:	f47f af48 	bne.w	8003b20 <mtx4_execute+0x60>
 8003c90:	2320      	movs	r3, #32
 8003c92:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chMtxUnlockS(&m1);
 8003c96:	4822      	ldr	r0, [pc, #136]	; (8003d20 <mtx4_execute+0x260>)
 8003c98:	f7fd ffda 	bl	8001c50 <chMtxUnlockS>
  chSchRescheduleS();
 8003c9c:	f7fd fb48 	bl	8001330 <chSchRescheduleS>
 8003ca0:	f386 8811 	msr	BASEPRI, r6
 8003ca4:	69ab      	ldr	r3, [r5, #24]
  chSysUnlock();
  test_assert(12, chThdGetPriorityX() == p1, "wrong priority level");
 8003ca6:	6899      	ldr	r1, [r3, #8]
 8003ca8:	ebc1 0609 	rsb	r6, r1, r9
 8003cac:	4271      	negs	r1, r6
 8003cae:	4171      	adcs	r1, r6
 8003cb0:	200c      	movs	r0, #12
 8003cb2:	f7fe ff55 	bl	8002b60 <_test_assert>
 8003cb6:	2800      	cmp	r0, #0
 8003cb8:	f47f af32 	bne.w	8003b20 <mtx4_execute+0x60>
  chThdSleepMilliseconds(100);
 8003cbc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8003cc0:	f7fd fc8e 	bl	80015e0 <chThdSleep>
 8003cc4:	69ab      	ldr	r3, [r5, #24]
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
 8003cc6:	6899      	ldr	r1, [r3, #8]
 8003cc8:	ebc1 0209 	rsb	r2, r1, r9
 8003ccc:	4251      	negs	r1, r2
 8003cce:	4151      	adcs	r1, r2
 8003cd0:	200d      	movs	r0, #13
 8003cd2:	f7fe ff45 	bl	8002b60 <_test_assert>
 8003cd6:	2800      	cmp	r0, #0
 8003cd8:	f47f af22 	bne.w	8003b20 <mtx4_execute+0x60>
  chMtxUnlockAll();
 8003cdc:	f7fd ffe0 	bl	8001ca0 <chMtxUnlockAll>
 8003ce0:	69ab      	ldr	r3, [r5, #24]
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
 8003ce2:	6899      	ldr	r1, [r3, #8]
 8003ce4:	1a63      	subs	r3, r4, r1
 8003ce6:	4259      	negs	r1, r3
 8003ce8:	4159      	adcs	r1, r3
 8003cea:	200e      	movs	r0, #14
 8003cec:	f7fe ff38 	bl	8002b60 <_test_assert>
 8003cf0:	2800      	cmp	r0, #0
 8003cf2:	f47f af15 	bne.w	8003b20 <mtx4_execute+0x60>
  test_wait_threads();
}
 8003cf6:	b005      	add	sp, #20
 8003cf8:	e8bd 46f0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, lr}
  test_assert(12, chThdGetPriorityX() == p1, "wrong priority level");
  chThdSleepMilliseconds(100);
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
  chMtxUnlockAll();
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
  test_wait_threads();
 8003cfc:	f7fe bfa0 	b.w	8002c40 <test_wait_threads>
 8003d00:	20001150 	.word	0x20001150
 8003d04:	080160d0 	.word	0x080160d0
 8003d08:	080163a4 	.word	0x080163a4
 8003d0c:	20001c84 	.word	0x20001c84
 8003d10:	08003aa1 	.word	0x08003aa1
 8003d14:	080163a8 	.word	0x080163a8
 8003d18:	08003a81 	.word	0x08003a81
 8003d1c:	2000081c 	.word	0x2000081c
 8003d20:	2000080c 	.word	0x2000080c
 8003d24:	08017310 	.word	0x08017310
 8003d28:	080163a0 	.word	0x080163a0
 8003d2c:	f3af 8000 	nop.w

08003d30 <mtx5_execute>:
static void mtx5_setup(void) {

  chMtxObjectInit(&m1);
}

static void mtx5_execute(void) {
 8003d30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003d32:	4d2b      	ldr	r5, [pc, #172]	; (8003de0 <mtx5_execute+0xb0>)

#if !CH_CFG_USE_MUTEXES_RECURSIVE
  bool b;
  tprio_t prio = chThdGetPriorityX();

  b = chMtxTryLock(&m1);
 8003d34:	4c2b      	ldr	r4, [pc, #172]	; (8003de4 <mtx5_execute+0xb4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003d36:	69ab      	ldr	r3, [r5, #24]
 8003d38:	4620      	mov	r0, r4
 8003d3a:	689e      	ldr	r6, [r3, #8]
 8003d3c:	f7fd ff40 	bl	8001bc0 <chMtxTryLock>
 8003d40:	4601      	mov	r1, r0
  test_assert(1, b, "already locked");
 8003d42:	2001      	movs	r0, #1
 8003d44:	f7fe ff0c 	bl	8002b60 <_test_assert>
 8003d48:	b100      	cbz	r0, 8003d4c <mtx5_execute+0x1c>
 8003d4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  b = chMtxTryLock(&m1);
 8003d4c:	4620      	mov	r0, r4
 8003d4e:	f7fd ff37 	bl	8001bc0 <chMtxTryLock>
  test_assert(2, !b, "not locked");
 8003d52:	f080 0101 	eor.w	r1, r0, #1
 8003d56:	b2c9      	uxtb	r1, r1
 8003d58:	2002      	movs	r0, #2
 8003d5a:	f7fe ff01 	bl	8002b60 <_test_assert>
 8003d5e:	4607      	mov	r7, r0
 8003d60:	2800      	cmp	r0, #0
 8003d62:	d1f2      	bne.n	8003d4a <mtx5_execute+0x1a>
 8003d64:	2320      	movs	r3, #32
 8003d66:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chMtxUnlockS(&m1);
 8003d6a:	4620      	mov	r0, r4
 8003d6c:	f7fd ff70 	bl	8001c50 <chMtxUnlockS>
 8003d70:	f387 8811 	msr	BASEPRI, r7
 8003d74:	6821      	ldr	r1, [r4, #0]
  chSysUnlock();

  test_assert(3, queue_isempty(&m1.m_queue), "queue not empty");
 8003d76:	2003      	movs	r0, #3
 8003d78:	1b09      	subs	r1, r1, r4
 8003d7a:	fab1 f181 	clz	r1, r1
 8003d7e:	0949      	lsrs	r1, r1, #5
 8003d80:	f7fe feee 	bl	8002b60 <_test_assert>
 8003d84:	2800      	cmp	r0, #0
 8003d86:	d1e0      	bne.n	8003d4a <mtx5_execute+0x1a>
  test_assert(4, m1.m_owner == NULL, "still owned");
 8003d88:	68a1      	ldr	r1, [r4, #8]
 8003d8a:	fab1 f181 	clz	r1, r1
 8003d8e:	2004      	movs	r0, #4
 8003d90:	0949      	lsrs	r1, r1, #5
 8003d92:	f7fe fee5 	bl	8002b60 <_test_assert>
 8003d96:	2800      	cmp	r0, #0
 8003d98:	d1d7      	bne.n	8003d4a <mtx5_execute+0x1a>
 8003d9a:	69ab      	ldr	r3, [r5, #24]
  test_assert(5, chThdGetPriorityX() == prio, "wrong priority level");
 8003d9c:	6899      	ldr	r1, [r3, #8]
 8003d9e:	2005      	movs	r0, #5
 8003da0:	1a71      	subs	r1, r6, r1
 8003da2:	fab1 f181 	clz	r1, r1
 8003da6:	0949      	lsrs	r1, r1, #5
 8003da8:	f7fe feda 	bl	8002b60 <_test_assert>
 8003dac:	2800      	cmp	r0, #0
 8003dae:	d1cc      	bne.n	8003d4a <mtx5_execute+0x1a>
#endif /* !CH_CFG_USE_MUTEXES_RECURSIVE */
  
  chMtxLock(&m1);
 8003db0:	4620      	mov	r0, r4
 8003db2:	f7fd fef5 	bl	8001ba0 <chMtxLock>
  chMtxUnlockAll();
 8003db6:	f7fd ff73 	bl	8001ca0 <chMtxUnlockAll>
 8003dba:	6821      	ldr	r1, [r4, #0]
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
 8003dbc:	2006      	movs	r0, #6
 8003dbe:	1b09      	subs	r1, r1, r4
 8003dc0:	fab1 f181 	clz	r1, r1
 8003dc4:	0949      	lsrs	r1, r1, #5
 8003dc6:	f7fe fecb 	bl	8002b60 <_test_assert>
 8003dca:	2800      	cmp	r0, #0
 8003dcc:	d1bd      	bne.n	8003d4a <mtx5_execute+0x1a>
  test_assert(7, m1.m_owner == NULL, "still owned");
 8003dce:	68a1      	ldr	r1, [r4, #8]
 8003dd0:	fab1 f181 	clz	r1, r1
 8003dd4:	2007      	movs	r0, #7
 8003dd6:	0949      	lsrs	r1, r1, #5
}
 8003dd8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
#endif /* !CH_CFG_USE_MUTEXES_RECURSIVE */
  
  chMtxLock(&m1);
  chMtxUnlockAll();
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
  test_assert(7, m1.m_owner == NULL, "still owned");
 8003ddc:	f7fe bec0 	b.w	8002b60 <_test_assert>
 8003de0:	20001150 	.word	0x20001150
 8003de4:	2000080c 	.word	0x2000080c
 8003de8:	f3af 8000 	nop.w
 8003dec:	f3af 8000 	nop.w

08003df0 <mtx6_execute>:
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  return 0;
}

static void mtx6_execute(void) {
 8003df0:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003df2:	4b2f      	ldr	r3, [pc, #188]	; (8003eb0 <mtx6_execute+0xc0>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8003df4:	4f2f      	ldr	r7, [pc, #188]	; (8003eb4 <mtx6_execute+0xc4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003df6:	699b      	ldr	r3, [r3, #24]
 8003df8:	4d2f      	ldr	r5, [pc, #188]	; (8003eb8 <mtx6_execute+0xc8>)
 8003dfa:	689e      	ldr	r6, [r3, #8]
 8003dfc:	4b2f      	ldr	r3, [pc, #188]	; (8003ebc <mtx6_execute+0xcc>)
 8003dfe:	6838      	ldr	r0, [r7, #0]
 8003e00:	4c2f      	ldr	r4, [pc, #188]	; (8003ec0 <mtx6_execute+0xd0>)
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  return 0;
}

static void mtx6_execute(void) {
 8003e02:	b083      	sub	sp, #12

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8003e04:	1c72      	adds	r2, r6, #1
 8003e06:	9300      	str	r3, [sp, #0]
 8003e08:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003e0c:	462b      	mov	r3, r5
 8003e0e:	f7fd fb6f 	bl	80014f0 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8003e12:	687b      	ldr	r3, [r7, #4]
 8003e14:	492b      	ldr	r1, [pc, #172]	; (8003ec4 <mtx6_execute+0xd4>)
}

static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8003e16:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8003e18:	1cb2      	adds	r2, r6, #2
 8003e1a:	9100      	str	r1, [sp, #0]
 8003e1c:	4618      	mov	r0, r3
 8003e1e:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003e22:	462b      	mov	r3, r5
 8003e24:	f7fd fb64 	bl	80014f0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8003e28:	68bb      	ldr	r3, [r7, #8]
 8003e2a:	4927      	ldr	r1, [pc, #156]	; (8003ec8 <mtx6_execute+0xd8>)

static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8003e2c:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8003e2e:	1cf2      	adds	r2, r6, #3
 8003e30:	9100      	str	r1, [sp, #0]
 8003e32:	4618      	mov	r0, r3
 8003e34:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003e38:	462b      	mov	r3, r5
 8003e3a:	f7fd fb59 	bl	80014f0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8003e3e:	68fb      	ldr	r3, [r7, #12]
 8003e40:	4922      	ldr	r1, [pc, #136]	; (8003ecc <mtx6_execute+0xdc>)
static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8003e42:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8003e44:	1d32      	adds	r2, r6, #4
 8003e46:	9100      	str	r1, [sp, #0]
 8003e48:	4618      	mov	r0, r3
 8003e4a:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003e4e:	462b      	mov	r3, r5
 8003e50:	f7fd fb4e 	bl	80014f0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8003e54:	693b      	ldr	r3, [r7, #16]
 8003e56:	491e      	ldr	r1, [pc, #120]	; (8003ed0 <mtx6_execute+0xe0>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8003e58:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8003e5a:	1d72      	adds	r2, r6, #5
 8003e5c:	9100      	str	r1, [sp, #0]
 8003e5e:	4618      	mov	r0, r3
 8003e60:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003e64:	462b      	mov	r3, r5
 8003e66:	f7fd fb43 	bl	80014f0 <chThdCreateStatic>
 8003e6a:	2320      	movs	r3, #32
 8003e6c:	6120      	str	r0, [r4, #16]
 8003e6e:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chCondSignalI(&c1);
 8003e72:	4c18      	ldr	r4, [pc, #96]	; (8003ed4 <mtx6_execute+0xe4>)
 8003e74:	4620      	mov	r0, r4
 8003e76:	f7fd ff63 	bl	8001d40 <chCondSignalI>
  chCondSignalI(&c1);
 8003e7a:	4620      	mov	r0, r4
 8003e7c:	f7fd ff60 	bl	8001d40 <chCondSignalI>
  chCondSignalI(&c1);
 8003e80:	4620      	mov	r0, r4
 8003e82:	f7fd ff5d 	bl	8001d40 <chCondSignalI>
  chCondSignalI(&c1);
 8003e86:	4620      	mov	r0, r4
 8003e88:	f7fd ff5a 	bl	8001d40 <chCondSignalI>
  chCondSignalI(&c1);
 8003e8c:	4620      	mov	r0, r4
 8003e8e:	f7fd ff57 	bl	8001d40 <chCondSignalI>
  chSchRescheduleS();
 8003e92:	f7fd fa4d 	bl	8001330 <chSchRescheduleS>
 8003e96:	2300      	movs	r3, #0
 8003e98:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  test_wait_threads();
 8003e9c:	f7fe fed0 	bl	8002c40 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8003ea0:	490d      	ldr	r1, [pc, #52]	; (8003ed8 <mtx6_execute+0xe8>)
 8003ea2:	2001      	movs	r0, #1
}
 8003ea4:	b003      	add	sp, #12
 8003ea6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  chCondSignalI(&c1);
  chCondSignalI(&c1);
  chSchRescheduleS();
  chSysUnlock();
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
 8003eaa:	f7fe be71 	b.w	8002b90 <_test_assert_sequence>
 8003eae:	bf00      	nop
 8003eb0:	20001150 	.word	0x20001150
 8003eb4:	080160d0 	.word	0x080160d0
 8003eb8:	08003ee1 	.word	0x08003ee1
 8003ebc:	080163b0 	.word	0x080163b0
 8003ec0:	20001c84 	.word	0x20001c84
 8003ec4:	08017310 	.word	0x08017310
 8003ec8:	080163a0 	.word	0x080163a0
 8003ecc:	080163a4 	.word	0x080163a4
 8003ed0:	080163a8 	.word	0x080163a8
 8003ed4:	2000082c 	.word	0x2000082c
 8003ed8:	080163ac 	.word	0x080163ac
 8003edc:	f3af 8000 	nop.w

08003ee0 <thread10>:

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static msg_t thread10(void *p) {
 8003ee0:	b538      	push	{r3, r4, r5, lr}

  chMtxLock(&m1);
 8003ee2:	4c08      	ldr	r4, [pc, #32]	; (8003f04 <thread10+0x24>)

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static msg_t thread10(void *p) {
 8003ee4:	4605      	mov	r5, r0

  chMtxLock(&m1);
 8003ee6:	4620      	mov	r0, r4
 8003ee8:	f7fd fe5a 	bl	8001ba0 <chMtxLock>
  chCondWait(&c1);
 8003eec:	4806      	ldr	r0, [pc, #24]	; (8003f08 <thread10+0x28>)
 8003eee:	f7fd ff87 	bl	8001e00 <chCondWait>
  test_emit_token(*(char *)p);
 8003ef2:	7828      	ldrb	r0, [r5, #0]
 8003ef4:	f7fe fe24 	bl	8002b40 <test_emit_token>
  chMtxUnlock(&m1);
 8003ef8:	4620      	mov	r0, r4
 8003efa:	f7fd fe79 	bl	8001bf0 <chMtxUnlock>
  return 0;
}
 8003efe:	2000      	movs	r0, #0
 8003f00:	bd38      	pop	{r3, r4, r5, pc}
 8003f02:	bf00      	nop
 8003f04:	2000080c 	.word	0x2000080c
 8003f08:	2000082c 	.word	0x2000082c
 8003f0c:	f3af 8000 	nop.w

08003f10 <mtx6_setup>:
 * atomically.<br>
 * The test expects the threads to reach their goal in increasing priority
 * order regardless of the initial order.
 */

static void mtx6_setup(void) {
 8003f10:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 8003f12:	4804      	ldr	r0, [pc, #16]	; (8003f24 <mtx6_setup+0x14>)
 8003f14:	f7fd fef4 	bl	8001d00 <chCondObjectInit>
  chMtxObjectInit(&m1);
 8003f18:	4803      	ldr	r0, [pc, #12]	; (8003f28 <mtx6_setup+0x18>)
}
 8003f1a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 */

static void mtx6_setup(void) {

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
 8003f1e:	f7fd bdcf 	b.w	8001ac0 <chMtxObjectInit>
 8003f22:	bf00      	nop
 8003f24:	2000082c 	.word	0x2000082c
 8003f28:	2000080c 	.word	0x2000080c
 8003f2c:	f3af 8000 	nop.w

08003f30 <mtx7_setup>:
 * tester thread then proceeds to broadcast the conditional variable.<br>
 * The test expects the threads to reach their goal in increasing priority
 * order regardless of the initial order.
 */

static void mtx7_setup(void) {
 8003f30:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 8003f32:	4804      	ldr	r0, [pc, #16]	; (8003f44 <mtx7_setup+0x14>)
 8003f34:	f7fd fee4 	bl	8001d00 <chCondObjectInit>
  chMtxObjectInit(&m1);
 8003f38:	4803      	ldr	r0, [pc, #12]	; (8003f48 <mtx7_setup+0x18>)
}
 8003f3a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 */

static void mtx7_setup(void) {

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
 8003f3e:	f7fd bdbf 	b.w	8001ac0 <chMtxObjectInit>
 8003f42:	bf00      	nop
 8003f44:	2000082c 	.word	0x2000082c
 8003f48:	2000080c 	.word	0x2000080c
 8003f4c:	f3af 8000 	nop.w

08003f50 <mtx8_setup>:
 * This test case verifies the priority boost of a thread waiting on a
 * conditional variable queue. It tests this very specific situation in order
 * to complete the code coverage.
 */

static void mtx8_setup(void) {
 8003f50:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 8003f52:	4805      	ldr	r0, [pc, #20]	; (8003f68 <mtx8_setup+0x18>)
 8003f54:	f7fd fed4 	bl	8001d00 <chCondObjectInit>
  chMtxObjectInit(&m1);
 8003f58:	4804      	ldr	r0, [pc, #16]	; (8003f6c <mtx8_setup+0x1c>)
 8003f5a:	f7fd fdb1 	bl	8001ac0 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 8003f5e:	4804      	ldr	r0, [pc, #16]	; (8003f70 <mtx8_setup+0x20>)
}
 8003f60:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

static void mtx8_setup(void) {

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
 8003f64:	f7fd bdac 	b.w	8001ac0 <chMtxObjectInit>
 8003f68:	2000082c 	.word	0x2000082c
 8003f6c:	2000080c 	.word	0x2000080c
 8003f70:	2000081c 	.word	0x2000081c
 8003f74:	f3af 8000 	nop.w
 8003f78:	f3af 8000 	nop.w
 8003f7c:	f3af 8000 	nop.w

08003f80 <mtx7_execute>:

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void mtx7_execute(void) {
 8003f80:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003f82:	4b24      	ldr	r3, [pc, #144]	; (8004014 <mtx7_execute+0x94>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8003f84:	4f24      	ldr	r7, [pc, #144]	; (8004018 <mtx7_execute+0x98>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003f86:	699b      	ldr	r3, [r3, #24]
 8003f88:	4d24      	ldr	r5, [pc, #144]	; (800401c <mtx7_execute+0x9c>)
 8003f8a:	689e      	ldr	r6, [r3, #8]
 8003f8c:	4b24      	ldr	r3, [pc, #144]	; (8004020 <mtx7_execute+0xa0>)
 8003f8e:	6838      	ldr	r0, [r7, #0]
 8003f90:	4c24      	ldr	r4, [pc, #144]	; (8004024 <mtx7_execute+0xa4>)

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void mtx7_execute(void) {
 8003f92:	b083      	sub	sp, #12

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8003f94:	1c72      	adds	r2, r6, #1
 8003f96:	9300      	str	r3, [sp, #0]
 8003f98:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003f9c:	462b      	mov	r3, r5
 8003f9e:	f7fd faa7 	bl	80014f0 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8003fa2:	687b      	ldr	r3, [r7, #4]
 8003fa4:	4920      	ldr	r1, [pc, #128]	; (8004028 <mtx7_execute+0xa8>)
}

static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8003fa6:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8003fa8:	1cb2      	adds	r2, r6, #2
 8003faa:	9100      	str	r1, [sp, #0]
 8003fac:	4618      	mov	r0, r3
 8003fae:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003fb2:	462b      	mov	r3, r5
 8003fb4:	f7fd fa9c 	bl	80014f0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8003fb8:	68bb      	ldr	r3, [r7, #8]
 8003fba:	491c      	ldr	r1, [pc, #112]	; (800402c <mtx7_execute+0xac>)

static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8003fbc:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8003fbe:	1cf2      	adds	r2, r6, #3
 8003fc0:	9100      	str	r1, [sp, #0]
 8003fc2:	4618      	mov	r0, r3
 8003fc4:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003fc8:	462b      	mov	r3, r5
 8003fca:	f7fd fa91 	bl	80014f0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8003fce:	68fb      	ldr	r3, [r7, #12]
 8003fd0:	4917      	ldr	r1, [pc, #92]	; (8004030 <mtx7_execute+0xb0>)
static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8003fd2:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8003fd4:	1d32      	adds	r2, r6, #4
 8003fd6:	9100      	str	r1, [sp, #0]
 8003fd8:	4618      	mov	r0, r3
 8003fda:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003fde:	462b      	mov	r3, r5
 8003fe0:	f7fd fa86 	bl	80014f0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8003fe4:	693b      	ldr	r3, [r7, #16]
 8003fe6:	4913      	ldr	r1, [pc, #76]	; (8004034 <mtx7_execute+0xb4>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8003fe8:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8003fea:	1d72      	adds	r2, r6, #5
 8003fec:	9100      	str	r1, [sp, #0]
 8003fee:	4618      	mov	r0, r3
 8003ff0:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003ff4:	462b      	mov	r3, r5
 8003ff6:	f7fd fa7b 	bl	80014f0 <chThdCreateStatic>
 8003ffa:	6120      	str	r0, [r4, #16]
  chCondBroadcast(&c1);
 8003ffc:	480e      	ldr	r0, [pc, #56]	; (8004038 <mtx7_execute+0xb8>)
 8003ffe:	f7fd fec7 	bl	8001d90 <chCondBroadcast>
  test_wait_threads();
 8004002:	f7fe fe1d 	bl	8002c40 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8004006:	490d      	ldr	r1, [pc, #52]	; (800403c <mtx7_execute+0xbc>)
 8004008:	2001      	movs	r0, #1
}
 800400a:	b003      	add	sp, #12
 800400c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
  chCondBroadcast(&c1);
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
 8004010:	f7fe bdbe 	b.w	8002b90 <_test_assert_sequence>
 8004014:	20001150 	.word	0x20001150
 8004018:	080160d0 	.word	0x080160d0
 800401c:	08003ee1 	.word	0x08003ee1
 8004020:	080163b0 	.word	0x080163b0
 8004024:	20001c84 	.word	0x20001c84
 8004028:	08017310 	.word	0x08017310
 800402c:	080163a0 	.word	0x080163a0
 8004030:	080163a4 	.word	0x080163a4
 8004034:	080163a8 	.word	0x080163a8
 8004038:	2000082c 	.word	0x2000082c
 800403c:	080163ac 	.word	0x080163ac

08004040 <mtx8_execute>:
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
  return 0;
}

static void mtx8_execute(void) {
 8004040:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004042:	4b1b      	ldr	r3, [pc, #108]	; (80040b0 <mtx8_execute+0x70>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 8004044:	4e1b      	ldr	r6, [pc, #108]	; (80040b4 <mtx8_execute+0x74>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8004046:	699b      	ldr	r3, [r3, #24]
 8004048:	6830      	ldr	r0, [r6, #0]
 800404a:	689d      	ldr	r5, [r3, #8]
 800404c:	4b1a      	ldr	r3, [pc, #104]	; (80040b8 <mtx8_execute+0x78>)
 800404e:	4c1b      	ldr	r4, [pc, #108]	; (80040bc <mtx8_execute+0x7c>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
  chCondSignal(&c1);
 8004050:	4f1b      	ldr	r7, [pc, #108]	; (80040c0 <mtx8_execute+0x80>)
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
  return 0;
}

static void mtx8_execute(void) {
 8004052:	b083      	sub	sp, #12

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 8004054:	1c6a      	adds	r2, r5, #1
 8004056:	9300      	str	r3, [sp, #0]
 8004058:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800405c:	4b19      	ldr	r3, [pc, #100]	; (80040c4 <mtx8_execute+0x84>)
 800405e:	f7fd fa47 	bl	80014f0 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 8004062:	6871      	ldr	r1, [r6, #4]
 8004064:	4b18      	ldr	r3, [pc, #96]	; (80040c8 <mtx8_execute+0x88>)
}

static void mtx8_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 8004066:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 8004068:	1caa      	adds	r2, r5, #2
 800406a:	9300      	str	r3, [sp, #0]
 800406c:	4608      	mov	r0, r1
 800406e:	4b17      	ldr	r3, [pc, #92]	; (80040cc <mtx8_execute+0x8c>)
 8004070:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8004074:	f7fd fa3c 	bl	80014f0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 8004078:	68b1      	ldr	r1, [r6, #8]
 800407a:	4b15      	ldr	r3, [pc, #84]	; (80040d0 <mtx8_execute+0x90>)

static void mtx8_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 800407c:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 800407e:	1cea      	adds	r2, r5, #3
 8004080:	9300      	str	r3, [sp, #0]
 8004082:	4608      	mov	r0, r1
 8004084:	4b13      	ldr	r3, [pc, #76]	; (80040d4 <mtx8_execute+0x94>)
 8004086:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800408a:	f7fd fa31 	bl	80014f0 <chThdCreateStatic>
 800408e:	60a0      	str	r0, [r4, #8]
  chCondSignal(&c1);
 8004090:	4638      	mov	r0, r7
 8004092:	f7fd fe3d 	bl	8001d10 <chCondSignal>
  chCondSignal(&c1);
 8004096:	4638      	mov	r0, r7
 8004098:	f7fd fe3a 	bl	8001d10 <chCondSignal>
  test_wait_threads();
 800409c:	f7fe fdd0 	bl	8002c40 <test_wait_threads>
  test_assert_sequence(1, "ABC");
 80040a0:	490d      	ldr	r1, [pc, #52]	; (80040d8 <mtx8_execute+0x98>)
 80040a2:	2001      	movs	r0, #1
}
 80040a4:	b003      	add	sp, #12
 80040a6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
  chCondSignal(&c1);
  chCondSignal(&c1);
  test_wait_threads();
  test_assert_sequence(1, "ABC");
 80040aa:	f7fe bd71 	b.w	8002b90 <_test_assert_sequence>
 80040ae:	bf00      	nop
 80040b0:	20001150 	.word	0x20001150
 80040b4:	080160d0 	.word	0x080160d0
 80040b8:	080163a8 	.word	0x080163a8
 80040bc:	20001c84 	.word	0x20001c84
 80040c0:	2000082c 	.word	0x2000082c
 80040c4:	080040e1 	.word	0x080040e1
 80040c8:	080163a0 	.word	0x080163a0
 80040cc:	08003ee1 	.word	0x08003ee1
 80040d0:	080163a4 	.word	0x080163a4
 80040d4:	08003a21 	.word	0x08003a21
 80040d8:	08016530 	.word	0x08016530
 80040dc:	f3af 8000 	nop.w

080040e0 <thread11>:
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static msg_t thread11(void *p) {
 80040e0:	b570      	push	{r4, r5, r6, lr}

  chMtxLock(&m2);
 80040e2:	4c0c      	ldr	r4, [pc, #48]	; (8004114 <thread11+0x34>)
  chMtxLock(&m1);
 80040e4:	4d0c      	ldr	r5, [pc, #48]	; (8004118 <thread11+0x38>)
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static msg_t thread11(void *p) {
 80040e6:	4606      	mov	r6, r0

  chMtxLock(&m2);
 80040e8:	4620      	mov	r0, r4
 80040ea:	f7fd fd59 	bl	8001ba0 <chMtxLock>
  chMtxLock(&m1);
 80040ee:	4628      	mov	r0, r5
 80040f0:	f7fd fd56 	bl	8001ba0 <chMtxLock>
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
 80040f4:	f04f 31ff 	mov.w	r1, #4294967295
 80040f8:	4808      	ldr	r0, [pc, #32]	; (800411c <thread11+0x3c>)
 80040fa:	f7fd feb9 	bl	8001e70 <chCondWaitTimeout>
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 80040fe:	7830      	ldrb	r0, [r6, #0]
 8004100:	f7fe fd1e 	bl	8002b40 <test_emit_token>
  chMtxUnlock(&m1);
 8004104:	4628      	mov	r0, r5
 8004106:	f7fd fd73 	bl	8001bf0 <chMtxUnlock>
  chMtxUnlock(&m2);
 800410a:	4620      	mov	r0, r4
 800410c:	f7fd fd70 	bl	8001bf0 <chMtxUnlock>
  return 0;
}
 8004110:	2000      	movs	r0, #0
 8004112:	bd70      	pop	{r4, r5, r6, pc}
 8004114:	2000081c 	.word	0x2000081c
 8004118:	2000080c 	.word	0x2000080c
 800411c:	2000082c 	.word	0x2000082c

08004120 <msg1_execute>:
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
  return 0;
}

static void msg1_execute(void) {
 8004120:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004122:	4a18      	ldr	r2, [pc, #96]	; (8004184 <msg1_execute+0x64>)
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8004124:	4b18      	ldr	r3, [pc, #96]	; (8004188 <msg1_execute+0x68>)
 8004126:	6991      	ldr	r1, [r2, #24]
 8004128:	6818      	ldr	r0, [r3, #0]
 800412a:	688a      	ldr	r2, [r1, #8]
 800412c:	4b17      	ldr	r3, [pc, #92]	; (800418c <msg1_execute+0x6c>)
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
  return 0;
}

static void msg1_execute(void) {
 800412e:	b082      	sub	sp, #8
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8004130:	3201      	adds	r2, #1
 8004132:	9100      	str	r1, [sp, #0]
 8004134:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8004138:	f7fd f9da 	bl	80014f0 <chThdCreateStatic>
 800413c:	4b14      	ldr	r3, [pc, #80]	; (8004190 <msg1_execute+0x70>)
 800413e:	6018      	str	r0, [r3, #0]
                                 thread, chThdGetSelfX());
  tp = chMsgWait();
 8004140:	f7fe f85e 	bl	8002200 <chMsgWait>
 8004144:	6b04      	ldr	r4, [r0, #48]	; 0x30
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
 8004146:	4621      	mov	r1, r4
 8004148:	f7fe f87a 	bl	8002240 <chMsgRelease>
  test_emit_token(msg);
 800414c:	b2e0      	uxtb	r0, r4
 800414e:	f7fe fcf7 	bl	8002b40 <test_emit_token>
  tp = chMsgWait();
 8004152:	f7fe f855 	bl	8002200 <chMsgWait>
 8004156:	6b04      	ldr	r4, [r0, #48]	; 0x30
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
 8004158:	4621      	mov	r1, r4
 800415a:	f7fe f871 	bl	8002240 <chMsgRelease>
  test_emit_token(msg);
 800415e:	b2e0      	uxtb	r0, r4
 8004160:	f7fe fcee 	bl	8002b40 <test_emit_token>
  tp = chMsgWait();
 8004164:	f7fe f84c 	bl	8002200 <chMsgWait>
 8004168:	6b04      	ldr	r4, [r0, #48]	; 0x30
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
 800416a:	4621      	mov	r1, r4
 800416c:	f7fe f868 	bl	8002240 <chMsgRelease>
  test_emit_token(msg);
 8004170:	b2e0      	uxtb	r0, r4
 8004172:	f7fe fce5 	bl	8002b40 <test_emit_token>
  test_assert_sequence(1, "ABC");
 8004176:	4907      	ldr	r1, [pc, #28]	; (8004194 <msg1_execute+0x74>)
 8004178:	2001      	movs	r0, #1
}
 800417a:	b002      	add	sp, #8
 800417c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_emit_token(msg);
  tp = chMsgWait();
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
  test_emit_token(msg);
  test_assert_sequence(1, "ABC");
 8004180:	f7fe bd06 	b.w	8002b90 <_test_assert_sequence>
 8004184:	20001150 	.word	0x20001150
 8004188:	080160d0 	.word	0x080160d0
 800418c:	080041a1 	.word	0x080041a1
 8004190:	20001c84 	.word	0x20001c84
 8004194:	08016530 	.word	0x08016530
 8004198:	f3af 8000 	nop.w
 800419c:	f3af 8000 	nop.w

080041a0 <thread>:
 * A thread is spawned that sends four messages back to the tester thread.<br>
 * The test expect to receive the messages in the correct sequence and to
 * not find a fifth message waiting.
 */

static msg_t thread(void *p) {
 80041a0:	b510      	push	{r4, lr}

  chMsgSend(p, 'A');
 80041a2:	2141      	movs	r1, #65	; 0x41
 * A thread is spawned that sends four messages back to the tester thread.<br>
 * The test expect to receive the messages in the correct sequence and to
 * not find a fifth message waiting.
 */

static msg_t thread(void *p) {
 80041a4:	4604      	mov	r4, r0

  chMsgSend(p, 'A');
 80041a6:	f7fe f80b 	bl	80021c0 <chMsgSend>
  chMsgSend(p, 'B');
 80041aa:	4620      	mov	r0, r4
 80041ac:	2142      	movs	r1, #66	; 0x42
 80041ae:	f7fe f807 	bl	80021c0 <chMsgSend>
  chMsgSend(p, 'C');
 80041b2:	4620      	mov	r0, r4
 80041b4:	2143      	movs	r1, #67	; 0x43
 80041b6:	f7fe f803 	bl	80021c0 <chMsgSend>
  return 0;
}
 80041ba:	2000      	movs	r0, #0
 80041bc:	bd10      	pop	{r4, pc}
 80041be:	bf00      	nop

080041c0 <mbox1_execute>:
static void mbox1_setup(void) {

  chMBObjectInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
}

static void mbox1_execute(void) {
 80041c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80041c4:	2320      	movs	r3, #32
 80041c6:	b082      	sub	sp, #8
 80041c8:	f383 8811 	msr	BASEPRI, r3
 80041cc:	4ecc      	ldr	r6, [pc, #816]	; (8004500 <mbox1_execute+0x340>)
  unsigned i;

  /*
   * Testing initial space.
   */
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 80041ce:	6a71      	ldr	r1, [r6, #36]	; 0x24
 80041d0:	2001      	movs	r0, #1
 80041d2:	f1a1 0105 	sub.w	r1, r1, #5
 80041d6:	fab1 f181 	clz	r1, r1
 80041da:	0949      	lsrs	r1, r1, #5
 80041dc:	f7fe fcc0 	bl	8002b60 <_test_assert>
 80041e0:	2800      	cmp	r0, #0
 80041e2:	f040 811a 	bne.w	800441a <mbox1_execute+0x25a>
 80041e6:	f380 8811 	msr	BASEPRI, r0
 80041ea:	2442      	movs	r4, #66	; 0x42

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 80041ec:	4dc4      	ldr	r5, [pc, #784]	; (8004500 <mbox1_execute+0x340>)
 80041ee:	4621      	mov	r1, r4
 80041f0:	f04f 32ff 	mov.w	r2, #4294967295
 80041f4:	4628      	mov	r0, r5
 80041f6:	f7fe f893 	bl	8002320 <chMBPost>
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
 80041fa:	fab0 f180 	clz	r1, r0
 80041fe:	2002      	movs	r0, #2
 8004200:	0949      	lsrs	r1, r1, #5
 8004202:	f7fe fcad 	bl	8002b60 <_test_assert>
 8004206:	3401      	adds	r4, #1
 8004208:	b980      	cbnz	r0, 800422c <mbox1_execute+0x6c>
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
 800420a:	2c46      	cmp	r4, #70	; 0x46
 800420c:	d1ee      	bne.n	80041ec <mbox1_execute+0x2c>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
  }
  msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
 800420e:	2141      	movs	r1, #65	; 0x41
 8004210:	4628      	mov	r0, r5
 8004212:	f04f 32ff 	mov.w	r2, #4294967295
 8004216:	f7fe f8d3 	bl	80023c0 <chMBPostAhead>
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");
 800421a:	fab0 f180 	clz	r1, r0
 800421e:	2003      	movs	r0, #3
 8004220:	0949      	lsrs	r1, r1, #5
 8004222:	f7fe fc9d 	bl	8002b60 <_test_assert>
 8004226:	2800      	cmp	r0, #0
 8004228:	f000 80fd 	beq.w	8004426 <mbox1_execute+0x266>
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
}
 800422c:	b002      	add	sp, #8
 800422e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004232:	f385 8811 	msr	BASEPRI, r5
 8004236:	f387 8811 	msr	BASEPRI, r7
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(29, "ABCDE");
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  test_assert_lock(31, chMBGetUsedCountI(&mb1) == 0, "still full");
 800423a:	201f      	movs	r0, #31
 800423c:	69a1      	ldr	r1, [r4, #24]
 800423e:	fab1 f181 	clz	r1, r1
 8004242:	0949      	lsrs	r1, r1, #5
 8004244:	f7fe fc8c 	bl	8002b60 <_test_assert>
 8004248:	2800      	cmp	r0, #0
 800424a:	f040 82a0 	bne.w	800478e <mbox1_execute+0x5ce>
 800424e:	f385 8811 	msr	BASEPRI, r5
  test_assert(32, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8004252:	68e1      	ldr	r1, [r4, #12]
 8004254:	68a3      	ldr	r3, [r4, #8]
 8004256:	1acb      	subs	r3, r1, r3
 8004258:	4259      	negs	r1, r3
 800425a:	4159      	adcs	r1, r3
 800425c:	4638      	mov	r0, r7
 800425e:	f7fe fc7f 	bl	8002b60 <_test_assert>
 8004262:	2800      	cmp	r0, #0
 8004264:	d1e2      	bne.n	800422c <mbox1_execute+0x6c>
 8004266:	f387 8811 	msr	BASEPRI, r7

  chSysLock();
  msg1 = chMBPostAheadI(&mb1, 'E');
 800426a:	2145      	movs	r1, #69	; 0x45
 800426c:	4620      	mov	r0, r4
 800426e:	f7fe f8b7 	bl	80023e0 <chMBPostAheadI>
  test_assert(33, msg1 == MSG_OK, "wrong wake-up message");
 8004272:	fab0 f180 	clz	r1, r0
 8004276:	2021      	movs	r0, #33	; 0x21
 8004278:	0949      	lsrs	r1, r1, #5
 800427a:	f7fe fc71 	bl	8002b60 <_test_assert>
 800427e:	2800      	cmp	r0, #0
 8004280:	d1d4      	bne.n	800422c <mbox1_execute+0x6c>
  msg1 = chMBPostAheadI(&mb1, 'D');
 8004282:	2144      	movs	r1, #68	; 0x44
 8004284:	4620      	mov	r0, r4
 8004286:	f7fe f8ab 	bl	80023e0 <chMBPostAheadI>
  test_assert(34, msg1 == MSG_OK, "wrong wake-up message");
 800428a:	fab0 f180 	clz	r1, r0
 800428e:	2022      	movs	r0, #34	; 0x22
 8004290:	0949      	lsrs	r1, r1, #5
 8004292:	f7fe fc65 	bl	8002b60 <_test_assert>
 8004296:	2800      	cmp	r0, #0
 8004298:	d1c8      	bne.n	800422c <mbox1_execute+0x6c>
  msg1 = chMBPostAheadI(&mb1, 'C');
 800429a:	2143      	movs	r1, #67	; 0x43
 800429c:	4620      	mov	r0, r4
 800429e:	f7fe f89f 	bl	80023e0 <chMBPostAheadI>
  test_assert(35, msg1 == MSG_OK, "wrong wake-up message");
 80042a2:	fab0 f180 	clz	r1, r0
 80042a6:	2023      	movs	r0, #35	; 0x23
 80042a8:	0949      	lsrs	r1, r1, #5
 80042aa:	f7fe fc59 	bl	8002b60 <_test_assert>
 80042ae:	2800      	cmp	r0, #0
 80042b0:	d1bc      	bne.n	800422c <mbox1_execute+0x6c>
  msg1 = chMBPostAheadI(&mb1, 'B');
 80042b2:	2142      	movs	r1, #66	; 0x42
 80042b4:	4620      	mov	r0, r4
 80042b6:	f7fe f893 	bl	80023e0 <chMBPostAheadI>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
 80042ba:	fab0 f180 	clz	r1, r0
 80042be:	2024      	movs	r0, #36	; 0x24
 80042c0:	0949      	lsrs	r1, r1, #5
 80042c2:	f7fe fc4d 	bl	8002b60 <_test_assert>
 80042c6:	2800      	cmp	r0, #0
 80042c8:	d1b0      	bne.n	800422c <mbox1_execute+0x6c>
  msg1 = chMBPostAheadI(&mb1, 'A');
 80042ca:	4c8d      	ldr	r4, [pc, #564]	; (8004500 <mbox1_execute+0x340>)
 80042cc:	2141      	movs	r1, #65	; 0x41
 80042ce:	4620      	mov	r0, r4
 80042d0:	f7fe f886 	bl	80023e0 <chMBPostAheadI>
 80042d4:	2300      	movs	r3, #0
 80042d6:	4601      	mov	r1, r0
 80042d8:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
 80042dc:	2025      	movs	r0, #37	; 0x25
 80042de:	fab1 f181 	clz	r1, r1
 80042e2:	0949      	lsrs	r1, r1, #5
 80042e4:	f7fe fc3c 	bl	8002b60 <_test_assert>
 80042e8:	2800      	cmp	r0, #0
 80042ea:	d19f      	bne.n	800422c <mbox1_execute+0x6c>
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 80042ec:	68e1      	ldr	r1, [r4, #12]
 80042ee:	68a3      	ldr	r3, [r4, #8]
 80042f0:	ebc3 0801 	rsb	r8, r3, r1
 80042f4:	f1d8 0100 	rsbs	r1, r8, #0
 80042f8:	eb41 0108 	adc.w	r1, r1, r8
 80042fc:	2026      	movs	r0, #38	; 0x26
 80042fe:	f7fe fc2f 	bl	8002b60 <_test_assert>
 8004302:	2800      	cmp	r0, #0
 8004304:	d192      	bne.n	800422c <mbox1_execute+0x6c>
 8004306:	4607      	mov	r7, r0
 8004308:	2405      	movs	r4, #5
 800430a:	f04f 0820 	mov.w	r8, #32
 800430e:	2620      	movs	r6, #32
 8004310:	f388 8811 	msr	BASEPRI, r8
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
 8004314:	4d7a      	ldr	r5, [pc, #488]	; (8004500 <mbox1_execute+0x340>)
 8004316:	a901      	add	r1, sp, #4
 8004318:	4628      	mov	r0, r5
 800431a:	f7fe f8a9 	bl	8002470 <chMBFetchI>
 800431e:	4601      	mov	r1, r0
 8004320:	f387 8811 	msr	BASEPRI, r7
    chSysUnlock();
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
 8004324:	2027      	movs	r0, #39	; 0x27
 8004326:	fab1 f181 	clz	r1, r1
 800432a:	0949      	lsrs	r1, r1, #5
 800432c:	f7fe fc18 	bl	8002b60 <_test_assert>
 8004330:	2800      	cmp	r0, #0
 8004332:	f47f af7b 	bne.w	800422c <mbox1_execute+0x6c>
    test_emit_token(msg2);
 8004336:	f89d 0004 	ldrb.w	r0, [sp, #4]
 800433a:	f7fe fc01 	bl	8002b40 <test_emit_token>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostAheadI(&mb1, 'A');
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 800433e:	3c01      	subs	r4, #1
 8004340:	d1e5      	bne.n	800430e <mbox1_execute+0x14e>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(40, "ABCDE");
 8004342:	2028      	movs	r0, #40	; 0x28
 8004344:	496f      	ldr	r1, [pc, #444]	; (8004504 <mbox1_execute+0x344>)
 8004346:	f7fe fc23 	bl	8002b90 <_test_assert_sequence>
 800434a:	2800      	cmp	r0, #0
 800434c:	f47f af6e 	bne.w	800422c <mbox1_execute+0x6c>
 8004350:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(41, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8004354:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8004356:	f1a1 0c05 	sub.w	ip, r1, #5
 800435a:	f1dc 0100 	rsbs	r1, ip, #0
 800435e:	eb41 010c 	adc.w	r1, r1, ip
 8004362:	2029      	movs	r0, #41	; 0x29
 8004364:	f7fe fbfc 	bl	8002b60 <_test_assert>
 8004368:	2800      	cmp	r0, #0
 800436a:	f040 80c5 	bne.w	80044f8 <mbox1_execute+0x338>
 800436e:	f384 8811 	msr	BASEPRI, r4
 8004372:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(42, chMBGetUsedCountI(&mb1) == 0, "still full");
 8004376:	202a      	movs	r0, #42	; 0x2a
 8004378:	69a9      	ldr	r1, [r5, #24]
 800437a:	fab1 f181 	clz	r1, r1
 800437e:	0949      	lsrs	r1, r1, #5
 8004380:	f7fe fbee 	bl	8002b60 <_test_assert>
 8004384:	2800      	cmp	r0, #0
 8004386:	f040 80b7 	bne.w	80044f8 <mbox1_execute+0x338>
 800438a:	f384 8811 	msr	BASEPRI, r4
  test_assert(43, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800438e:	68e9      	ldr	r1, [r5, #12]
 8004390:	68ab      	ldr	r3, [r5, #8]
 8004392:	ebc3 0e01 	rsb	lr, r3, r1
 8004396:	f1de 0100 	rsbs	r1, lr, #0
 800439a:	eb41 010e 	adc.w	r1, r1, lr
 800439e:	202b      	movs	r0, #43	; 0x2b
 80043a0:	f7fe fbde 	bl	8002b60 <_test_assert>
 80043a4:	2800      	cmp	r0, #0
 80043a6:	f47f af41 	bne.w	800422c <mbox1_execute+0x6c>

  /*
   * Testing reset.
   */
  chMBReset(&mb1);
 80043aa:	4628      	mov	r0, r5
 80043ac:	f7fd ff88 	bl	80022c0 <chMBReset>
 80043b0:	f386 8811 	msr	BASEPRI, r6

  /*
   * Re-testing final conditions.
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80043b4:	6a69      	ldr	r1, [r5, #36]	; 0x24
 80043b6:	1f4f      	subs	r7, r1, #5
 80043b8:	4279      	negs	r1, r7
 80043ba:	4179      	adcs	r1, r7
 80043bc:	202c      	movs	r0, #44	; 0x2c
 80043be:	f7fe fbcf 	bl	8002b60 <_test_assert>
 80043c2:	2800      	cmp	r0, #0
 80043c4:	f040 8098 	bne.w	80044f8 <mbox1_execute+0x338>
 80043c8:	f384 8811 	msr	BASEPRI, r4
 80043cc:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
 80043d0:	202d      	movs	r0, #45	; 0x2d
 80043d2:	69a9      	ldr	r1, [r5, #24]
 80043d4:	fab1 f181 	clz	r1, r1
 80043d8:	0949      	lsrs	r1, r1, #5
 80043da:	f7fe fbc1 	bl	8002b60 <_test_assert>
 80043de:	2800      	cmp	r0, #0
 80043e0:	f040 808a 	bne.w	80044f8 <mbox1_execute+0x338>
 80043e4:	f384 8811 	msr	BASEPRI, r4
 80043e8:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 80043ec:	6829      	ldr	r1, [r5, #0]
 80043ee:	68ab      	ldr	r3, [r5, #8]
 80043f0:	1aca      	subs	r2, r1, r3
 80043f2:	4251      	negs	r1, r2
 80043f4:	4151      	adcs	r1, r2
 80043f6:	202e      	movs	r0, #46	; 0x2e
 80043f8:	f7fe fbb2 	bl	8002b60 <_test_assert>
 80043fc:	2800      	cmp	r0, #0
 80043fe:	d17b      	bne.n	80044f8 <mbox1_execute+0x338>
 8004400:	f384 8811 	msr	BASEPRI, r4
 8004404:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 8004408:	6829      	ldr	r1, [r5, #0]
 800440a:	68eb      	ldr	r3, [r5, #12]
 800440c:	1acb      	subs	r3, r1, r3
 800440e:	4259      	negs	r1, r3
 8004410:	f04f 002f 	mov.w	r0, #47	; 0x2f
 8004414:	4159      	adcs	r1, r3
 8004416:	f7fe fba3 	bl	8002b60 <_test_assert>
 800441a:	2300      	movs	r3, #0
 800441c:	f383 8811 	msr	BASEPRI, r3
}
 8004420:	b002      	add	sp, #8
 8004422:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");

  /*
   * Testing post timeout.
   */
  msg1 = chMBPost(&mb1, 'X', 1);
 8004426:	2158      	movs	r1, #88	; 0x58
 8004428:	2201      	movs	r2, #1
 800442a:	4628      	mov	r0, r5
 800442c:	f7fd ff78 	bl	8002320 <chMBPost>
  test_assert(4, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8004430:	f1a0 31ff 	sub.w	r1, r0, #4294967295
 8004434:	2004      	movs	r0, #4
 8004436:	fab1 f181 	clz	r1, r1
 800443a:	0949      	lsrs	r1, r1, #5
 800443c:	f7fe fb90 	bl	8002b60 <_test_assert>
 8004440:	4604      	mov	r4, r0
 8004442:	2800      	cmp	r0, #0
 8004444:	f47f aef2 	bne.w	800422c <mbox1_execute+0x6c>
 8004448:	2720      	movs	r7, #32
 800444a:	f387 8811 	msr	BASEPRI, r7
  chSysLock();
  msg1 = chMBPostI(&mb1, 'X');
 800444e:	2158      	movs	r1, #88	; 0x58
 8004450:	4628      	mov	r0, r5
 8004452:	f7fd ff75 	bl	8002340 <chMBPostI>
 8004456:	4601      	mov	r1, r0
 8004458:	f384 8811 	msr	BASEPRI, r4
  chSysUnlock();
  test_assert(5, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800445c:	2005      	movs	r0, #5
 800445e:	f1a1 31ff 	sub.w	r1, r1, #4294967295
 8004462:	fab1 f181 	clz	r1, r1
 8004466:	0949      	lsrs	r1, r1, #5
 8004468:	f7fe fb7a 	bl	8002b60 <_test_assert>
 800446c:	2800      	cmp	r0, #0
 800446e:	f47f aedd 	bne.w	800422c <mbox1_execute+0x6c>
  msg1 = chMBPostAhead(&mb1, 'X', 1);
 8004472:	2158      	movs	r1, #88	; 0x58
 8004474:	2201      	movs	r2, #1
 8004476:	4628      	mov	r0, r5
 8004478:	f7fd ffa2 	bl	80023c0 <chMBPostAhead>
  test_assert(6, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800447c:	f1a0 31ff 	sub.w	r1, r0, #4294967295
 8004480:	2006      	movs	r0, #6
 8004482:	fab1 f181 	clz	r1, r1
 8004486:	0949      	lsrs	r1, r1, #5
 8004488:	f7fe fb6a 	bl	8002b60 <_test_assert>
 800448c:	4604      	mov	r4, r0
 800448e:	2800      	cmp	r0, #0
 8004490:	f47f aecc 	bne.w	800422c <mbox1_execute+0x6c>
 8004494:	f387 8811 	msr	BASEPRI, r7
  chSysLock();
  msg1 = chMBPostAheadI(&mb1, 'X');
 8004498:	2158      	movs	r1, #88	; 0x58
 800449a:	4628      	mov	r0, r5
 800449c:	f7fd ffa0 	bl	80023e0 <chMBPostAheadI>
 80044a0:	4601      	mov	r1, r0
 80044a2:	f384 8811 	msr	BASEPRI, r4
  chSysUnlock();
  test_assert(7, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80044a6:	2007      	movs	r0, #7
 80044a8:	f1a1 31ff 	sub.w	r1, r1, #4294967295
 80044ac:	fab1 f181 	clz	r1, r1
 80044b0:	0949      	lsrs	r1, r1, #5
 80044b2:	f7fe fb55 	bl	8002b60 <_test_assert>
 80044b6:	4680      	mov	r8, r0
 80044b8:	2800      	cmp	r0, #0
 80044ba:	f47f aeb7 	bne.w	800422c <mbox1_execute+0x6c>
 80044be:	f387 8811 	msr	BASEPRI, r7

  /*
   * Testing final conditions.
   */
  test_assert_lock(8, chMBGetFreeCountI(&mb1) == 0, "still empty");
 80044c2:	2008      	movs	r0, #8
 80044c4:	6a69      	ldr	r1, [r5, #36]	; 0x24
 80044c6:	fab1 f181 	clz	r1, r1
 80044ca:	0949      	lsrs	r1, r1, #5
 80044cc:	f7fe fb48 	bl	8002b60 <_test_assert>
 80044d0:	4604      	mov	r4, r0
 80044d2:	b110      	cbz	r0, 80044da <mbox1_execute+0x31a>
 80044d4:	f388 8811 	msr	BASEPRI, r8
 80044d8:	e6a8      	b.n	800422c <mbox1_execute+0x6c>
 80044da:	f380 8811 	msr	BASEPRI, r0
 80044de:	f387 8811 	msr	BASEPRI, r7
  test_assert_lock(9, chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 80044e2:	69a9      	ldr	r1, [r5, #24]
 80044e4:	f1a1 0e05 	sub.w	lr, r1, #5
 80044e8:	f1de 0100 	rsbs	r1, lr, #0
 80044ec:	eb41 010e 	adc.w	r1, r1, lr
 80044f0:	2009      	movs	r0, #9
 80044f2:	f7fe fb35 	bl	8002b60 <_test_assert>
 80044f6:	b138      	cbz	r0, 8004508 <mbox1_execute+0x348>
 80044f8:	f384 8811 	msr	BASEPRI, r4
 80044fc:	e696      	b.n	800422c <mbox1_execute+0x6c>
 80044fe:	bf00      	nop
 8004500:	20000834 	.word	0x20000834
 8004504:	080163ac 	.word	0x080163ac
 8004508:	f380 8811 	msr	BASEPRI, r0
 800450c:	f387 8811 	msr	BASEPRI, r7
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8004510:	68e9      	ldr	r1, [r5, #12]
 8004512:	68ab      	ldr	r3, [r5, #8]
 8004514:	1acc      	subs	r4, r1, r3
 8004516:	4261      	negs	r1, r4
 8004518:	f04f 000a 	mov.w	r0, #10
 800451c:	4161      	adcs	r1, r4
 800451e:	f7fe fb1f 	bl	8002b60 <_test_assert>
 8004522:	2300      	movs	r3, #0
 8004524:	2800      	cmp	r0, #0
 8004526:	f47f af79 	bne.w	800441c <mbox1_execute+0x25c>
 800452a:	f383 8811 	msr	BASEPRI, r3
 800452e:	2505      	movs	r5, #5
 8004530:	e005      	b.n	800453e <mbox1_execute+0x37e>
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
 8004532:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8004536:	f7fe fb03 	bl	8002b40 <test_emit_token>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
 800453a:	3d01      	subs	r5, #1
 800453c:	d00f      	beq.n	800455e <mbox1_execute+0x39e>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800453e:	4c95      	ldr	r4, [pc, #596]	; (8004794 <mbox1_execute+0x5d4>)
 8004540:	a901      	add	r1, sp, #4
 8004542:	4620      	mov	r0, r4
 8004544:	f04f 32ff 	mov.w	r2, #4294967295
 8004548:	f7fd ff82 	bl	8002450 <chMBFetch>
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
 800454c:	fab0 f180 	clz	r1, r0
 8004550:	200b      	movs	r0, #11
 8004552:	0949      	lsrs	r1, r1, #5
 8004554:	f7fe fb04 	bl	8002b60 <_test_assert>
 8004558:	2800      	cmp	r0, #0
 800455a:	d0ea      	beq.n	8004532 <mbox1_execute+0x372>
 800455c:	e666      	b.n	800422c <mbox1_execute+0x6c>
    test_emit_token(msg2);
  }
  test_assert_sequence(12, "ABCDE");
 800455e:	200c      	movs	r0, #12
 8004560:	498d      	ldr	r1, [pc, #564]	; (8004798 <mbox1_execute+0x5d8>)
 8004562:	f7fe fb15 	bl	8002b90 <_test_assert_sequence>
 8004566:	2800      	cmp	r0, #0
 8004568:	f47f ae60 	bne.w	800422c <mbox1_execute+0x6c>

  /*
   * Testing buffer circularity.
   */
  msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800456c:	2147      	movs	r1, #71	; 0x47
 800456e:	4620      	mov	r0, r4
 8004570:	f04f 32ff 	mov.w	r2, #4294967295
 8004574:	f7fd fed4 	bl	8002320 <chMBPost>
  test_assert(13, msg1 == MSG_OK, "wrong wake-up message");
 8004578:	fab0 f180 	clz	r1, r0
 800457c:	200d      	movs	r0, #13
 800457e:	0949      	lsrs	r1, r1, #5
 8004580:	f7fe faee 	bl	8002b60 <_test_assert>
 8004584:	2800      	cmp	r0, #0
 8004586:	f47f ae51 	bne.w	800422c <mbox1_execute+0x6c>
  msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800458a:	a901      	add	r1, sp, #4
 800458c:	4620      	mov	r0, r4
 800458e:	f04f 32ff 	mov.w	r2, #4294967295
 8004592:	f7fd ff5d 	bl	8002450 <chMBFetch>
  test_assert(14, msg1 == MSG_OK, "wrong wake-up message");
 8004596:	fab0 f180 	clz	r1, r0
 800459a:	200e      	movs	r0, #14
 800459c:	0949      	lsrs	r1, r1, #5
 800459e:	f7fe fadf 	bl	8002b60 <_test_assert>
 80045a2:	2800      	cmp	r0, #0
 80045a4:	f47f ae42 	bne.w	800422c <mbox1_execute+0x6c>
  test_assert(15, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 80045a8:	6821      	ldr	r1, [r4, #0]
 80045aa:	68a3      	ldr	r3, [r4, #8]
 80045ac:	1aca      	subs	r2, r1, r3
 80045ae:	4251      	negs	r1, r2
 80045b0:	4151      	adcs	r1, r2
 80045b2:	200f      	movs	r0, #15
 80045b4:	f7fe fad4 	bl	8002b60 <_test_assert>
 80045b8:	2800      	cmp	r0, #0
 80045ba:	f47f ae37 	bne.w	800422c <mbox1_execute+0x6c>
  test_assert(16, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 80045be:	6821      	ldr	r1, [r4, #0]
 80045c0:	68e3      	ldr	r3, [r4, #12]
 80045c2:	1acb      	subs	r3, r1, r3
 80045c4:	4259      	negs	r1, r3
 80045c6:	4159      	adcs	r1, r3
 80045c8:	2010      	movs	r0, #16
 80045ca:	f7fe fac9 	bl	8002b60 <_test_assert>
 80045ce:	2800      	cmp	r0, #0
 80045d0:	f47f ae2c 	bne.w	800422c <mbox1_execute+0x6c>

  /*
   * Testing fetch timeout.
   */
  msg1 = chMBFetch(&mb1, &msg2, 1);
 80045d4:	a901      	add	r1, sp, #4
 80045d6:	4620      	mov	r0, r4
 80045d8:	2201      	movs	r2, #1
 80045da:	f7fd ff39 	bl	8002450 <chMBFetch>
  test_assert(17, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80045de:	f100 0801 	add.w	r8, r0, #1
 80045e2:	f1d8 0100 	rsbs	r1, r8, #0
 80045e6:	eb41 0108 	adc.w	r1, r1, r8
 80045ea:	2011      	movs	r0, #17
 80045ec:	f7fe fab8 	bl	8002b60 <_test_assert>
 80045f0:	2800      	cmp	r0, #0
 80045f2:	f47f ae1b 	bne.w	800422c <mbox1_execute+0x6c>
 80045f6:	2720      	movs	r7, #32
 80045f8:	f387 8811 	msr	BASEPRI, r7
  chSysLock();
  msg1 = chMBFetchI(&mb1, &msg2);
 80045fc:	a901      	add	r1, sp, #4
 80045fe:	4620      	mov	r0, r4
 8004600:	f7fd ff36 	bl	8002470 <chMBFetchI>
 8004604:	4601      	mov	r1, r0
 8004606:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();
  test_assert(18, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800460a:	f101 0c01 	add.w	ip, r1, #1
 800460e:	f1dc 0100 	rsbs	r1, ip, #0
 8004612:	eb41 010c 	adc.w	r1, r1, ip
 8004616:	2012      	movs	r0, #18
 8004618:	f7fe faa2 	bl	8002b60 <_test_assert>
 800461c:	2800      	cmp	r0, #0
 800461e:	f47f ae05 	bne.w	800422c <mbox1_execute+0x6c>
 8004622:	f387 8811 	msr	BASEPRI, r7

  /*
   * Testing final conditions.
   */
  test_assert_lock(19, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8004626:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8004628:	f1a1 0e05 	sub.w	lr, r1, #5
 800462c:	f1de 0100 	rsbs	r1, lr, #0
 8004630:	eb41 010e 	adc.w	r1, r1, lr
 8004634:	2013      	movs	r0, #19
 8004636:	f7fe fa93 	bl	8002b60 <_test_assert>
 800463a:	2800      	cmp	r0, #0
 800463c:	f47f aeed 	bne.w	800441a <mbox1_execute+0x25a>
 8004640:	2700      	movs	r7, #0
 8004642:	f387 8811 	msr	BASEPRI, r7
 8004646:	2520      	movs	r5, #32
 8004648:	f385 8811 	msr	BASEPRI, r5
  test_assert_lock(20, chMBGetUsedCountI(&mb1) == 0, "still full");
 800464c:	2014      	movs	r0, #20
 800464e:	69b1      	ldr	r1, [r6, #24]
 8004650:	fab1 f181 	clz	r1, r1
 8004654:	0949      	lsrs	r1, r1, #5
 8004656:	f7fe fa83 	bl	8002b60 <_test_assert>
 800465a:	4c4e      	ldr	r4, [pc, #312]	; (8004794 <mbox1_execute+0x5d4>)
 800465c:	4606      	mov	r6, r0
 800465e:	b110      	cbz	r0, 8004666 <mbox1_execute+0x4a6>
 8004660:	f387 8811 	msr	BASEPRI, r7
 8004664:	e5e2      	b.n	800422c <mbox1_execute+0x6c>
 8004666:	f380 8811 	msr	BASEPRI, r0
 800466a:	f385 8811 	msr	BASEPRI, r5
  test_assert_lock(21, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800466e:	68e1      	ldr	r1, [r4, #12]
 8004670:	68a3      	ldr	r3, [r4, #8]
 8004672:	1acf      	subs	r7, r1, r3
 8004674:	4279      	negs	r1, r7
 8004676:	4179      	adcs	r1, r7
 8004678:	2015      	movs	r0, #21
 800467a:	f7fe fa71 	bl	8002b60 <_test_assert>
 800467e:	b110      	cbz	r0, 8004686 <mbox1_execute+0x4c6>
 8004680:	f386 8811 	msr	BASEPRI, r6
 8004684:	e5d2      	b.n	800422c <mbox1_execute+0x6c>
 8004686:	f380 8811 	msr	BASEPRI, r0
 800468a:	f385 8811 	msr	BASEPRI, r5

  /*
   * Testing I-Class.
   */
  chSysLock();
  msg1 = chMBPostI(&mb1, 'A');
 800468e:	2141      	movs	r1, #65	; 0x41
 8004690:	4620      	mov	r0, r4
 8004692:	f7fd fe55 	bl	8002340 <chMBPostI>
  test_assert(22, msg1 == MSG_OK, "wrong wake-up message");
 8004696:	fab0 f180 	clz	r1, r0
 800469a:	2016      	movs	r0, #22
 800469c:	0949      	lsrs	r1, r1, #5
 800469e:	f7fe fa5f 	bl	8002b60 <_test_assert>
 80046a2:	2800      	cmp	r0, #0
 80046a4:	f47f adc2 	bne.w	800422c <mbox1_execute+0x6c>
  msg1 = chMBPostI(&mb1, 'B');
 80046a8:	2142      	movs	r1, #66	; 0x42
 80046aa:	4620      	mov	r0, r4
 80046ac:	f7fd fe48 	bl	8002340 <chMBPostI>
  test_assert(23, msg1 == MSG_OK, "wrong wake-up message");
 80046b0:	fab0 f180 	clz	r1, r0
 80046b4:	2017      	movs	r0, #23
 80046b6:	0949      	lsrs	r1, r1, #5
 80046b8:	f7fe fa52 	bl	8002b60 <_test_assert>
 80046bc:	2800      	cmp	r0, #0
 80046be:	f47f adb5 	bne.w	800422c <mbox1_execute+0x6c>
  msg1 = chMBPostI(&mb1, 'C');
 80046c2:	2143      	movs	r1, #67	; 0x43
 80046c4:	4620      	mov	r0, r4
 80046c6:	f7fd fe3b 	bl	8002340 <chMBPostI>
  test_assert(24, msg1 == MSG_OK, "wrong wake-up message");
 80046ca:	fab0 f180 	clz	r1, r0
 80046ce:	2018      	movs	r0, #24
 80046d0:	0949      	lsrs	r1, r1, #5
 80046d2:	f7fe fa45 	bl	8002b60 <_test_assert>
 80046d6:	2800      	cmp	r0, #0
 80046d8:	f47f ada8 	bne.w	800422c <mbox1_execute+0x6c>
  msg1 = chMBPostI(&mb1, 'D');
 80046dc:	2144      	movs	r1, #68	; 0x44
 80046de:	4620      	mov	r0, r4
 80046e0:	f7fd fe2e 	bl	8002340 <chMBPostI>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
 80046e4:	fab0 f180 	clz	r1, r0
 80046e8:	2019      	movs	r0, #25
 80046ea:	0949      	lsrs	r1, r1, #5
 80046ec:	f7fe fa38 	bl	8002b60 <_test_assert>
 80046f0:	4606      	mov	r6, r0
 80046f2:	2800      	cmp	r0, #0
 80046f4:	f47f ad9a 	bne.w	800422c <mbox1_execute+0x6c>
  msg1 = chMBPostI(&mb1, 'E');
 80046f8:	4620      	mov	r0, r4
 80046fa:	2145      	movs	r1, #69	; 0x45
 80046fc:	f7fd fe20 	bl	8002340 <chMBPostI>
 8004700:	4601      	mov	r1, r0
 8004702:	f386 8811 	msr	BASEPRI, r6
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
 8004706:	201a      	movs	r0, #26
 8004708:	fab1 f181 	clz	r1, r1
 800470c:	0949      	lsrs	r1, r1, #5
 800470e:	f7fe fa27 	bl	8002b60 <_test_assert>
 8004712:	2800      	cmp	r0, #0
 8004714:	f47f ad8a 	bne.w	800422c <mbox1_execute+0x6c>
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8004718:	68e1      	ldr	r1, [r4, #12]
 800471a:	68a3      	ldr	r3, [r4, #8]
 800471c:	1acc      	subs	r4, r1, r3
 800471e:	4261      	negs	r1, r4
 8004720:	4161      	adcs	r1, r4
 8004722:	201b      	movs	r0, #27
 8004724:	f7fe fa1c 	bl	8002b60 <_test_assert>
 8004728:	2800      	cmp	r0, #0
 800472a:	f47f ad7f 	bne.w	800422c <mbox1_execute+0x6c>
 800472e:	462e      	mov	r6, r5
 8004730:	4680      	mov	r8, r0
 8004732:	2505      	movs	r5, #5
 8004734:	2720      	movs	r7, #32
 8004736:	f386 8811 	msr	BASEPRI, r6
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
 800473a:	4c16      	ldr	r4, [pc, #88]	; (8004794 <mbox1_execute+0x5d4>)
 800473c:	a901      	add	r1, sp, #4
 800473e:	4620      	mov	r0, r4
 8004740:	f7fd fe96 	bl	8002470 <chMBFetchI>
 8004744:	4601      	mov	r1, r0
 8004746:	f388 8811 	msr	BASEPRI, r8
    chSysUnlock();
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
 800474a:	201c      	movs	r0, #28
 800474c:	fab1 f181 	clz	r1, r1
 8004750:	0949      	lsrs	r1, r1, #5
 8004752:	f7fe fa05 	bl	8002b60 <_test_assert>
 8004756:	2800      	cmp	r0, #0
 8004758:	f47f ad68 	bne.w	800422c <mbox1_execute+0x6c>
    test_emit_token(msg2);
 800475c:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8004760:	f7fe f9ee 	bl	8002b40 <test_emit_token>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostI(&mb1, 'E');
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 8004764:	3d01      	subs	r5, #1
 8004766:	d1e5      	bne.n	8004734 <mbox1_execute+0x574>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(29, "ABCDE");
 8004768:	201d      	movs	r0, #29
 800476a:	490b      	ldr	r1, [pc, #44]	; (8004798 <mbox1_execute+0x5d8>)
 800476c:	f7fe fa10 	bl	8002b90 <_test_assert_sequence>
 8004770:	2800      	cmp	r0, #0
 8004772:	f47f ad5b 	bne.w	800422c <mbox1_execute+0x6c>
 8004776:	f387 8811 	msr	BASEPRI, r7
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800477a:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800477c:	1f4a      	subs	r2, r1, #5
 800477e:	4251      	negs	r1, r2
 8004780:	4151      	adcs	r1, r2
 8004782:	201e      	movs	r0, #30
 8004784:	f7fe f9ec 	bl	8002b60 <_test_assert>
 8004788:	2800      	cmp	r0, #0
 800478a:	f43f ad52 	beq.w	8004232 <mbox1_execute+0x72>
 800478e:	f385 8811 	msr	BASEPRI, r5
 8004792:	e54b      	b.n	800422c <mbox1_execute+0x6c>
 8004794:	20000834 	.word	0x20000834
 8004798:	080163ac 	.word	0x080163ac
 800479c:	f3af 8000 	nop.w

080047a0 <mbox1_setup>:
 * The test expects to find a consistent mailbox status after each operation.
 */

static void mbox1_setup(void) {

  chMBObjectInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
 80047a0:	4802      	ldr	r0, [pc, #8]	; (80047ac <mbox1_setup+0xc>)
 80047a2:	4903      	ldr	r1, [pc, #12]	; (80047b0 <mbox1_setup+0x10>)
 80047a4:	2205      	movs	r2, #5
 80047a6:	f7fd bd5b 	b.w	8002260 <chMBObjectInit>
 80047aa:	bf00      	nop
 80047ac:	20000834 	.word	0x20000834
 80047b0:	20001350 	.word	0x20001350
 80047b4:	f3af 8000 	nop.w
 80047b8:	f3af 8000 	nop.w
 80047bc:	f3af 8000 	nop.w

080047c0 <h3>:
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 80047c0:	2043      	movs	r0, #67	; 0x43
 80047c2:	f7fe b9bd 	b.w	8002b40 <test_emit_token>
 80047c6:	bf00      	nop
 80047c8:	f3af 8000 	nop.w
 80047cc:	f3af 8000 	nop.w

080047d0 <h2>:

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 80047d0:	2042      	movs	r0, #66	; 0x42
 80047d2:	f7fe b9b5 	b.w	8002b40 <test_emit_token>
 80047d6:	bf00      	nop
 80047d8:	f3af 8000 	nop.w
 80047dc:	f3af 8000 	nop.w

080047e0 <h1>:
static void evt1_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 80047e0:	2041      	movs	r0, #65	; 0x41
 80047e2:	f7fe b9ad 	b.w	8002b40 <test_emit_token>
 80047e6:	bf00      	nop
 80047e8:	f3af 8000 	nop.w
 80047ec:	f3af 8000 	nop.w

080047f0 <evt1_execute>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static void evt1_execute(void) {
 80047f0:	b510      	push	{r4, lr}
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)(void *)esp;
 80047f2:	4c1f      	ldr	r4, [pc, #124]	; (8004870 <evt1_execute+0x80>)
 80047f4:	b08a      	sub	sp, #40	; 0x28
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventflags_t events) {

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 80047f6:	4620      	mov	r0, r4
 80047f8:	4669      	mov	r1, sp
 80047fa:	2201      	movs	r2, #1
 80047fc:	f04f 33ff 	mov.w	r3, #4294967295
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)(void *)esp;
 8004800:	6024      	str	r4, [r4, #0]
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventflags_t events) {

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 8004802:	f7fd fb45 	bl	8001e90 <chEvtRegisterMaskWithFlags>
 8004806:	4620      	mov	r0, r4
 8004808:	a905      	add	r1, sp, #20
 800480a:	2202      	movs	r2, #2
 800480c:	f04f 33ff 	mov.w	r3, #4294967295
 8004810:	f7fd fb3e 	bl	8001e90 <chEvtRegisterMaskWithFlags>
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {

  return (bool)((void *)esp != (void *)esp->es_next);
 8004814:	6821      	ldr	r1, [r4, #0]
   * Testing chEvtRegisterMask() and chEvtUnregister().
   */
  chEvtObjectInit(&es1);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es1, &el2, 2);
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
 8004816:	1b09      	subs	r1, r1, r4
 8004818:	bf18      	it	ne
 800481a:	2101      	movne	r1, #1
 800481c:	2001      	movs	r0, #1
 800481e:	f7fe f99f 	bl	8002b60 <_test_assert>
 8004822:	b108      	cbz	r0, 8004828 <evt1_execute+0x38>
  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
  test_assert_sequence(4, "ABC");
}
 8004824:	b00a      	add	sp, #40	; 0x28
 8004826:	bd10      	pop	{r4, pc}
   */
  chEvtObjectInit(&es1);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es1, &el2, 2);
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
  chEvtUnregister(&es1, &el1);
 8004828:	4669      	mov	r1, sp
 800482a:	4620      	mov	r0, r4
 800482c:	f7fd fb48 	bl	8001ec0 <chEvtUnregister>
 8004830:	6821      	ldr	r1, [r4, #0]
  test_assert(2, chEvtIsListeningI(&es1), "no listener");
 8004832:	1b09      	subs	r1, r1, r4
 8004834:	bf18      	it	ne
 8004836:	2101      	movne	r1, #1
 8004838:	2002      	movs	r0, #2
 800483a:	f7fe f991 	bl	8002b60 <_test_assert>
 800483e:	2800      	cmp	r0, #0
 8004840:	d1f0      	bne.n	8004824 <evt1_execute+0x34>
  chEvtUnregister(&es1, &el2);
 8004842:	a905      	add	r1, sp, #20
 8004844:	4620      	mov	r0, r4
 8004846:	f7fd fb3b 	bl	8001ec0 <chEvtUnregister>
  test_assert(3, !chEvtIsListeningI(&es1), "stuck listener");
 800484a:	6821      	ldr	r1, [r4, #0]
 800484c:	2003      	movs	r0, #3
 800484e:	1b09      	subs	r1, r1, r4
 8004850:	fab1 f181 	clz	r1, r1
 8004854:	0949      	lsrs	r1, r1, #5
 8004856:	f7fe f983 	bl	8002b60 <_test_assert>
 800485a:	2800      	cmp	r0, #0
 800485c:	d1e2      	bne.n	8004824 <evt1_execute+0x34>

  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
 800485e:	4805      	ldr	r0, [pc, #20]	; (8004874 <evt1_execute+0x84>)
 8004860:	2107      	movs	r1, #7
 8004862:	f7fd fbb5 	bl	8001fd0 <chEvtDispatch>
  test_assert_sequence(4, "ABC");
 8004866:	4904      	ldr	r1, [pc, #16]	; (8004878 <evt1_execute+0x88>)
 8004868:	2004      	movs	r0, #4
 800486a:	f7fe f991 	bl	8002b90 <_test_assert_sequence>
 800486e:	e7d9      	b.n	8004824 <evt1_execute+0x34>
 8004870:	2000085c 	.word	0x2000085c
 8004874:	08016710 	.word	0x08016710
 8004878:	08016530 	.word	0x08016530
 800487c:	f3af 8000 	nop.w

08004880 <evt1_setup>:
 * the associated event handlers are invoked in LSb-first order.
 */

static void evt1_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
 8004880:	f04f 30ff 	mov.w	r0, #4294967295
 8004884:	f7fd bb34 	b.w	8001ef0 <chEvtGetAndClearEvents>
 8004888:	f3af 8000 	nop.w
 800488c:	f3af 8000 	nop.w

08004890 <evt2_setup>:
 * the expected time and that there are no stuck event flags.
 */

static void evt2_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
 8004890:	f04f 30ff 	mov.w	r0, #4294967295
 8004894:	f7fd bb2c 	b.w	8001ef0 <chEvtGetAndClearEvents>
 8004898:	f3af 8000 	nop.w
 800489c:	f3af 8000 	nop.w

080048a0 <evt3_setup>:
 * After each test phase the test verifies that there are no stuck event flags.
 */

static void evt3_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
 80048a0:	f04f 30ff 	mov.w	r0, #4294967295
 80048a4:	f7fd bb24 	b.w	8001ef0 <chEvtGetAndClearEvents>
 80048a8:	f3af 8000 	nop.w
 80048ac:	f3af 8000 	nop.w

080048b0 <evt2_execute>:
  chThdSleepMilliseconds(50);
  chEvtBroadcast(&es2);
  return 0;
}

static void evt2_execute(void) {
 80048b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  systime_t target_time;

  /*
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
 80048b4:	2007      	movs	r0, #7
  chThdSleepMilliseconds(50);
  chEvtBroadcast(&es2);
  return 0;
}

static void evt2_execute(void) {
 80048b6:	b08d      	sub	sp, #52	; 0x34
  systime_t target_time;

  /*
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
 80048b8:	f7fd fb2a 	bl	8001f10 <chEvtAddEvents>
  m = chEvtWaitOne(ALL_EVENTS);
 80048bc:	f04f 30ff 	mov.w	r0, #4294967295
 80048c0:	f7fd fba6 	bl	8002010 <chEvtWaitOne>
  test_assert(1, m == 1, "single event error");
 80048c4:	f1a0 0101 	sub.w	r1, r0, #1
 80048c8:	2001      	movs	r0, #1
 80048ca:	fab1 f181 	clz	r1, r1
 80048ce:	0949      	lsrs	r1, r1, #5
 80048d0:	f7fe f946 	bl	8002b60 <_test_assert>
 80048d4:	b110      	cbz	r0, 80048dc <evt2_execute+0x2c>
  test_wait_threads();
  chEvtUnregister(&es1, &el1);
  chEvtUnregister(&es2, &el2);
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
}
 80048d6:	b00d      	add	sp, #52	; 0x34
 80048d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
  m = chEvtWaitOne(ALL_EVENTS);
  test_assert(1, m == 1, "single event error");
  m = chEvtWaitOne(ALL_EVENTS);
 80048dc:	f04f 30ff 	mov.w	r0, #4294967295
 80048e0:	f7fd fb96 	bl	8002010 <chEvtWaitOne>
  test_assert(2, m == 2, "single event error");
 80048e4:	f1a0 0102 	sub.w	r1, r0, #2
 80048e8:	2002      	movs	r0, #2
 80048ea:	fab1 f181 	clz	r1, r1
 80048ee:	0949      	lsrs	r1, r1, #5
 80048f0:	f7fe f936 	bl	8002b60 <_test_assert>
 80048f4:	2800      	cmp	r0, #0
 80048f6:	d1ee      	bne.n	80048d6 <evt2_execute+0x26>
  m = chEvtWaitOne(ALL_EVENTS);
 80048f8:	f04f 30ff 	mov.w	r0, #4294967295
 80048fc:	f7fd fb88 	bl	8002010 <chEvtWaitOne>
  test_assert(3, m == 4, "single event error");
 8004900:	f1a0 0104 	sub.w	r1, r0, #4
 8004904:	2003      	movs	r0, #3
 8004906:	fab1 f181 	clz	r1, r1
 800490a:	0949      	lsrs	r1, r1, #5
 800490c:	f7fe f928 	bl	8002b60 <_test_assert>
 8004910:	2800      	cmp	r0, #0
 8004912:	d1e0      	bne.n	80048d6 <evt2_execute+0x26>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8004914:	f04f 30ff 	mov.w	r0, #4294967295
 8004918:	f7fd faea 	bl	8001ef0 <chEvtGetAndClearEvents>
  test_assert(4, m == 0, "stuck event");
 800491c:	fab0 f180 	clz	r1, r0
 8004920:	2004      	movs	r0, #4
 8004922:	0949      	lsrs	r1, r1, #5
 8004924:	f7fe f91c 	bl	8002b60 <_test_assert>
 8004928:	4604      	mov	r4, r0
 800492a:	2800      	cmp	r0, #0
 800492c:	d1d3      	bne.n	80048d6 <evt2_execute+0x26>

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
 800492e:	f7fe f99f 	bl	8002c70 <test_wait_tick>
 8004932:	f04f 0920 	mov.w	r9, #32
 8004936:	f389 8811 	msr	BASEPRI, r9
 800493a:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
 800493e:	f8d8 5024 	ldr.w	r5, [r8, #36]	; 0x24
 8004942:	f384 8811 	msr	BASEPRI, r4
 8004946:	4f76      	ldr	r7, [pc, #472]	; (8004b20 <evt2_execute+0x270>)
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8004948:	f8df a1f0 	ldr.w	sl, [pc, #496]	; 8004b3c <evt2_execute+0x28c>
 800494c:	69b9      	ldr	r1, [r7, #24]
 800494e:	f8da 6000 	ldr.w	r6, [sl]
 8004952:	688a      	ldr	r2, [r1, #8]
 8004954:	4b73      	ldr	r3, [pc, #460]	; (8004b24 <evt2_execute+0x274>)
 8004956:	9100      	str	r1, [sp, #0]
 8004958:	3a01      	subs	r2, #1
 800495a:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800495e:	4630      	mov	r0, r6
 8004960:	f7fc fdc6 	bl	80014f0 <chThdCreateStatic>
 8004964:	4c70      	ldr	r4, [pc, #448]	; (8004b28 <evt2_execute+0x278>)
 8004966:	6020      	str	r0, [r4, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 8004968:	f04f 30ff 	mov.w	r0, #4294967295
 800496c:	f7fd fb50 	bl	8002010 <chEvtWaitOne>
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 8004970:	f505 71fa 	add.w	r1, r5, #500	; 0x1f4
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 8004974:	4683      	mov	fp, r0
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 8004976:	f205 2226 	addw	r2, r5, #550	; 0x226
 800497a:	2005      	movs	r0, #5
 800497c:	f7fe f930 	bl	8002be0 <_test_assert_time_window>
 8004980:	2800      	cmp	r0, #0
 8004982:	d1a8      	bne.n	80048d6 <evt2_execute+0x26>
  test_assert(6, m == 1, "single event error");
 8004984:	f1ab 0101 	sub.w	r1, fp, #1
 8004988:	2006      	movs	r0, #6
 800498a:	fab1 f181 	clz	r1, r1
 800498e:	0949      	lsrs	r1, r1, #5
 8004990:	f7fe f8e6 	bl	8002b60 <_test_assert>
 8004994:	2800      	cmp	r0, #0
 8004996:	d19e      	bne.n	80048d6 <evt2_execute+0x26>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8004998:	f04f 30ff 	mov.w	r0, #4294967295
 800499c:	f7fd faa8 	bl	8001ef0 <chEvtGetAndClearEvents>
  test_assert(7, m == 0, "stuck event");
 80049a0:	fab0 f180 	clz	r1, r0
 80049a4:	2007      	movs	r0, #7
 80049a6:	0949      	lsrs	r1, r1, #5
 80049a8:	f7fe f8da 	bl	8002b60 <_test_assert>
 80049ac:	2800      	cmp	r0, #0
 80049ae:	d192      	bne.n	80048d6 <evt2_execute+0x26>
  test_wait_threads();
 80049b0:	f7fe f946 	bl	8002c40 <test_wait_threads>

  /*
   * Test on chEvtWaitAny() without wait.
   */
  chEvtAddEvents(5);
 80049b4:	2005      	movs	r0, #5
 80049b6:	f7fd faab 	bl	8001f10 <chEvtAddEvents>
  m = chEvtWaitAny(ALL_EVENTS);
 80049ba:	f04f 30ff 	mov.w	r0, #4294967295
 80049be:	f7fd fb47 	bl	8002050 <chEvtWaitAny>
  test_assert(8, m == 5, "unexpected pending bit");
 80049c2:	1f45      	subs	r5, r0, #5
 80049c4:	4269      	negs	r1, r5
 80049c6:	4169      	adcs	r1, r5
 80049c8:	2008      	movs	r0, #8
 80049ca:	f7fe f8c9 	bl	8002b60 <_test_assert>
 80049ce:	2800      	cmp	r0, #0
 80049d0:	d181      	bne.n	80048d6 <evt2_execute+0x26>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 80049d2:	f04f 30ff 	mov.w	r0, #4294967295
 80049d6:	f7fd fa8b 	bl	8001ef0 <chEvtGetAndClearEvents>
  test_assert(9, m == 0, "stuck event");
 80049da:	fab0 f180 	clz	r1, r0
 80049de:	2009      	movs	r0, #9
 80049e0:	0949      	lsrs	r1, r1, #5
 80049e2:	f7fe f8bd 	bl	8002b60 <_test_assert>
 80049e6:	4683      	mov	fp, r0
 80049e8:	2800      	cmp	r0, #0
 80049ea:	f47f af74 	bne.w	80048d6 <evt2_execute+0x26>

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
 80049ee:	f7fe f93f 	bl	8002c70 <test_wait_tick>
 80049f2:	f389 8811 	msr	BASEPRI, r9
 80049f6:	f8d8 5024 	ldr.w	r5, [r8, #36]	; 0x24
 80049fa:	f38b 8811 	msr	BASEPRI, fp
 80049fe:	69b9      	ldr	r1, [r7, #24]
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8004a00:	4b48      	ldr	r3, [pc, #288]	; (8004b24 <evt2_execute+0x274>)
 8004a02:	688a      	ldr	r2, [r1, #8]
 8004a04:	9100      	str	r1, [sp, #0]
 8004a06:	3a01      	subs	r2, #1
 8004a08:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8004a0c:	4630      	mov	r0, r6
 8004a0e:	f7fc fd6f 	bl	80014f0 <chThdCreateStatic>
 8004a12:	6020      	str	r0, [r4, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 8004a14:	f04f 30ff 	mov.w	r0, #4294967295
 8004a18:	f7fd fb1a 	bl	8002050 <chEvtWaitAny>
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 8004a1c:	f505 71fa 	add.w	r1, r5, #500	; 0x1f4
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 8004a20:	4606      	mov	r6, r0
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 8004a22:	f205 2226 	addw	r2, r5, #550	; 0x226
 8004a26:	200a      	movs	r0, #10
 8004a28:	f7fe f8da 	bl	8002be0 <_test_assert_time_window>
 8004a2c:	2800      	cmp	r0, #0
 8004a2e:	f47f af52 	bne.w	80048d6 <evt2_execute+0x26>
  test_assert(11, m == 1, "single event error");
 8004a32:	1e70      	subs	r0, r6, #1
 8004a34:	4241      	negs	r1, r0
 8004a36:	4141      	adcs	r1, r0
 8004a38:	200b      	movs	r0, #11
 8004a3a:	f7fe f891 	bl	8002b60 <_test_assert>
 8004a3e:	2800      	cmp	r0, #0
 8004a40:	f47f af49 	bne.w	80048d6 <evt2_execute+0x26>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8004a44:	f04f 30ff 	mov.w	r0, #4294967295
 8004a48:	f7fd fa52 	bl	8001ef0 <chEvtGetAndClearEvents>
  test_assert(12, m == 0, "stuck event");
 8004a4c:	fab0 f180 	clz	r1, r0
 8004a50:	200c      	movs	r0, #12
 8004a52:	0949      	lsrs	r1, r1, #5
 8004a54:	f7fe f884 	bl	8002b60 <_test_assert>
 8004a58:	4681      	mov	r9, r0
 8004a5a:	2800      	cmp	r0, #0
 8004a5c:	f47f af3b 	bne.w	80048d6 <evt2_execute+0x26>
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)(void *)esp;
 8004a60:	4e32      	ldr	r6, [pc, #200]	; (8004b2c <evt2_execute+0x27c>)
 8004a62:	4d33      	ldr	r5, [pc, #204]	; (8004b30 <evt2_execute+0x280>)
  test_wait_threads();
 8004a64:	f7fe f8ec 	bl	8002c40 <test_wait_threads>
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventflags_t events) {

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 8004a68:	4630      	mov	r0, r6
 8004a6a:	a902      	add	r1, sp, #8
 8004a6c:	2201      	movs	r2, #1
 8004a6e:	f04f 33ff 	mov.w	r3, #4294967295
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)(void *)esp;
 8004a72:	6036      	str	r6, [r6, #0]
 8004a74:	602d      	str	r5, [r5, #0]
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventflags_t events) {

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 8004a76:	f7fd fa0b 	bl	8001e90 <chEvtRegisterMaskWithFlags>
 8004a7a:	4628      	mov	r0, r5
 8004a7c:	a907      	add	r1, sp, #28
 8004a7e:	2204      	movs	r2, #4
 8004a80:	f04f 33ff 	mov.w	r3, #4294967295
 8004a84:	f7fd fa04 	bl	8001e90 <chEvtRegisterMaskWithFlags>
   */
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es2, &el2, 4);
  test_wait_tick();
 8004a88:	f7fe f8f2 	bl	8002c70 <test_wait_tick>
 8004a8c:	2320      	movs	r3, #32
 8004a8e:	f383 8811 	msr	BASEPRI, r3
 8004a92:	f8d8 8024 	ldr.w	r8, [r8, #36]	; 0x24
 8004a96:	f389 8811 	msr	BASEPRI, r9
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8004a9a:	69ba      	ldr	r2, [r7, #24]
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8004a9c:	4b25      	ldr	r3, [pc, #148]	; (8004b34 <evt2_execute+0x284>)
 8004a9e:	6892      	ldr	r2, [r2, #8]
 8004aa0:	f8da 0000 	ldr.w	r0, [sl]
 8004aa4:	9300      	str	r3, [sp, #0]
 8004aa6:	3a01      	subs	r2, #1
 8004aa8:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8004aac:	4b22      	ldr	r3, [pc, #136]	; (8004b38 <evt2_execute+0x288>)
 8004aae:	f7fc fd1f 	bl	80014f0 <chThdCreateStatic>
 8004ab2:	6020      	str	r0, [r4, #0]
                                 thread2, "A");
  m = chEvtWaitAll(5);
 8004ab4:	2005      	movs	r0, #5
 8004ab6:	f7fd faeb 	bl	8002090 <chEvtWaitAll>
  test_assert_time_window(13, target_time, target_time + ALLOWED_DELAY);
 8004aba:	f508 71fa 	add.w	r1, r8, #500	; 0x1f4
 8004abe:	f208 2226 	addw	r2, r8, #550	; 0x226
 8004ac2:	200d      	movs	r0, #13
 8004ac4:	f7fe f88c 	bl	8002be0 <_test_assert_time_window>
 8004ac8:	2800      	cmp	r0, #0
 8004aca:	f47f af04 	bne.w	80048d6 <evt2_execute+0x26>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8004ace:	f04f 30ff 	mov.w	r0, #4294967295
 8004ad2:	f7fd fa0d 	bl	8001ef0 <chEvtGetAndClearEvents>
  test_assert(14, m == 0, "stuck event");
 8004ad6:	fab0 f180 	clz	r1, r0
 8004ada:	200e      	movs	r0, #14
 8004adc:	0949      	lsrs	r1, r1, #5
 8004ade:	f7fe f83f 	bl	8002b60 <_test_assert>
 8004ae2:	2800      	cmp	r0, #0
 8004ae4:	f47f aef7 	bne.w	80048d6 <evt2_execute+0x26>
  test_wait_threads();
 8004ae8:	f7fe f8aa 	bl	8002c40 <test_wait_threads>
  chEvtUnregister(&es1, &el1);
 8004aec:	4630      	mov	r0, r6
 8004aee:	a902      	add	r1, sp, #8
 8004af0:	f7fd f9e6 	bl	8001ec0 <chEvtUnregister>
  chEvtUnregister(&es2, &el2);
 8004af4:	4628      	mov	r0, r5
 8004af6:	a907      	add	r1, sp, #28
 8004af8:	f7fd f9e2 	bl	8001ec0 <chEvtUnregister>
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
 8004afc:	6831      	ldr	r1, [r6, #0]
 8004afe:	1b8a      	subs	r2, r1, r6
 8004b00:	4251      	negs	r1, r2
 8004b02:	4151      	adcs	r1, r2
 8004b04:	200f      	movs	r0, #15
 8004b06:	f7fe f82b 	bl	8002b60 <_test_assert>
 8004b0a:	2800      	cmp	r0, #0
 8004b0c:	f47f aee3 	bne.w	80048d6 <evt2_execute+0x26>
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
 8004b10:	6829      	ldr	r1, [r5, #0]
 8004b12:	1b4b      	subs	r3, r1, r5
 8004b14:	4259      	negs	r1, r3
 8004b16:	4159      	adcs	r1, r3
 8004b18:	2010      	movs	r0, #16
 8004b1a:	f7fe f821 	bl	8002b60 <_test_assert>
 8004b1e:	e6da      	b.n	80048d6 <evt2_execute+0x26>
 8004b20:	20001150 	.word	0x20001150
 8004b24:	08004b71 	.word	0x08004b71
 8004b28:	20001c84 	.word	0x20001c84
 8004b2c:	2000085c 	.word	0x2000085c
 8004b30:	20000860 	.word	0x20000860
 8004b34:	080163a8 	.word	0x080163a8
 8004b38:	08004b41 	.word	0x08004b41
 8004b3c:	080160d0 	.word	0x080160d0

08004b40 <thread2>:
  chThdSleepMilliseconds(50);
  chEvtSignal((thread_t *)p, 1);
  return 0;
}

static msg_t thread2(void *p) {
 8004b40:	b508      	push	{r3, lr}
 *
 * @api
 */
static inline void chEvtBroadcast(event_source_t *esp) {

  chEvtBroadcastFlags(esp, 0);
 8004b42:	2100      	movs	r1, #0
 8004b44:	4806      	ldr	r0, [pc, #24]	; (8004b60 <thread2+0x20>)
 8004b46:	f7fd fa33 	bl	8001fb0 <chEvtBroadcastFlags>

  (void)p;
  chEvtBroadcast(&es1);
  chThdSleepMilliseconds(50);
 8004b4a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8004b4e:	f7fc fd47 	bl	80015e0 <chThdSleep>
 8004b52:	4804      	ldr	r0, [pc, #16]	; (8004b64 <thread2+0x24>)
 8004b54:	2100      	movs	r1, #0
 8004b56:	f7fd fa2b 	bl	8001fb0 <chEvtBroadcastFlags>
  chEvtBroadcast(&es2);
  return 0;
}
 8004b5a:	2000      	movs	r0, #0
 8004b5c:	bd08      	pop	{r3, pc}
 8004b5e:	bf00      	nop
 8004b60:	2000085c 	.word	0x2000085c
 8004b64:	20000860 	.word	0x20000860
 8004b68:	f3af 8000 	nop.w
 8004b6c:	f3af 8000 	nop.w

08004b70 <thread1>:
static void evt2_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static msg_t thread1(void *p) {
 8004b70:	b510      	push	{r4, lr}
 8004b72:	4604      	mov	r4, r0

  chThdSleepMilliseconds(50);
 8004b74:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8004b78:	f7fc fd32 	bl	80015e0 <chThdSleep>
  chEvtSignal((thread_t *)p, 1);
 8004b7c:	4620      	mov	r0, r4
 8004b7e:	2101      	movs	r1, #1
 8004b80:	f7fd fa06 	bl	8001f90 <chEvtSignal>
  return 0;
}
 8004b84:	2000      	movs	r0, #0
 8004b86:	bd10      	pop	{r4, pc}
 8004b88:	f3af 8000 	nop.w
 8004b8c:	f3af 8000 	nop.w

08004b90 <evt3_execute>:
static void evt3_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void evt3_execute(void) {
 8004b90:	b508      	push	{r3, lr}
  eventmask_t m;

  /*
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8004b92:	2100      	movs	r1, #0
 8004b94:	f04f 30ff 	mov.w	r0, #4294967295
 8004b98:	f7fd fa9a 	bl	80020d0 <chEvtWaitOneTimeout>
  test_assert(1, m == 0, "spurious event");
 8004b9c:	fab0 f180 	clz	r1, r0
 8004ba0:	2001      	movs	r0, #1
 8004ba2:	0949      	lsrs	r1, r1, #5
 8004ba4:	f7fd ffdc 	bl	8002b60 <_test_assert>
 8004ba8:	b100      	cbz	r0, 8004bac <evt3_execute+0x1c>
 8004baa:	bd08      	pop	{r3, pc}
  m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8004bac:	4601      	mov	r1, r0
 8004bae:	f04f 30ff 	mov.w	r0, #4294967295
 8004bb2:	f7fd fab5 	bl	8002120 <chEvtWaitAnyTimeout>
  test_assert(2, m == 0, "spurious event");
 8004bb6:	fab0 f180 	clz	r1, r0
 8004bba:	2002      	movs	r0, #2
 8004bbc:	0949      	lsrs	r1, r1, #5
 8004bbe:	f7fd ffcf 	bl	8002b60 <_test_assert>
 8004bc2:	2800      	cmp	r0, #0
 8004bc4:	d1f1      	bne.n	8004baa <evt3_execute+0x1a>
  m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8004bc6:	4601      	mov	r1, r0
 8004bc8:	f04f 30ff 	mov.w	r0, #4294967295
 8004bcc:	f7fd fad0 	bl	8002170 <chEvtWaitAllTimeout>
  test_assert(3, m == 0, "spurious event");
 8004bd0:	fab0 f180 	clz	r1, r0
 8004bd4:	2003      	movs	r0, #3
 8004bd6:	0949      	lsrs	r1, r1, #5
 8004bd8:	f7fd ffc2 	bl	8002b60 <_test_assert>
 8004bdc:	2800      	cmp	r0, #0
 8004bde:	d1e4      	bne.n	8004baa <evt3_execute+0x1a>
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
 8004be0:	210a      	movs	r1, #10
 8004be2:	f04f 30ff 	mov.w	r0, #4294967295
 8004be6:	f7fd fa73 	bl	80020d0 <chEvtWaitOneTimeout>
  test_assert(4, m == 0, "spurious event");
 8004bea:	fab0 f180 	clz	r1, r0
 8004bee:	2004      	movs	r0, #4
 8004bf0:	0949      	lsrs	r1, r1, #5
 8004bf2:	f7fd ffb5 	bl	8002b60 <_test_assert>
 8004bf6:	2800      	cmp	r0, #0
 8004bf8:	d1d7      	bne.n	8004baa <evt3_execute+0x1a>
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
 8004bfa:	210a      	movs	r1, #10
 8004bfc:	f04f 30ff 	mov.w	r0, #4294967295
 8004c00:	f7fd fa8e 	bl	8002120 <chEvtWaitAnyTimeout>
  test_assert(5, m == 0, "spurious event");
 8004c04:	fab0 f180 	clz	r1, r0
 8004c08:	2005      	movs	r0, #5
 8004c0a:	0949      	lsrs	r1, r1, #5
 8004c0c:	f7fd ffa8 	bl	8002b60 <_test_assert>
 8004c10:	2800      	cmp	r0, #0
 8004c12:	d1ca      	bne.n	8004baa <evt3_execute+0x1a>
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
 8004c14:	210a      	movs	r1, #10
 8004c16:	f04f 30ff 	mov.w	r0, #4294967295
 8004c1a:	f7fd faa9 	bl	8002170 <chEvtWaitAllTimeout>
  test_assert(6, m == 0, "spurious event");
}
 8004c1e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
  test_assert(4, m == 0, "spurious event");
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
  test_assert(5, m == 0, "spurious event");
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
  test_assert(6, m == 0, "spurious event");
 8004c22:	fab0 f180 	clz	r1, r0
 8004c26:	2006      	movs	r0, #6
 8004c28:	0949      	lsrs	r1, r1, #5
 8004c2a:	f7fd bf99 	b.w	8002b60 <_test_assert>
 8004c2e:	bf00      	nop

08004c30 <heap1_execute>:
static void heap1_setup(void) {

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
}

static void heap1_execute(void) {
 8004c30:	b570      	push	{r4, r5, r6, lr}
 8004c32:	b082      	sub	sp, #8
  void *p1, *p2, *p3;
  size_t n, sz;

  /* Unrelated, for coverage only.*/
  (void)chCoreGetStatusX();
 8004c34:	f7fd fdcc 	bl	80027d0 <chCoreGetStatusX>

  /*
   * Test on the default heap in order to cover the core allocator at
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
 8004c38:	a901      	add	r1, sp, #4
 8004c3a:	2000      	movs	r0, #0
 8004c3c:	f7fd fe90 	bl	8002960 <chHeapStatus>
  p1 = chHeapAlloc(NULL, SIZE);
 8004c40:	2110      	movs	r1, #16
 8004c42:	2000      	movs	r0, #0
 8004c44:	f7fd fdf4 	bl	8002830 <chHeapAlloc>
  test_assert(1, p1 != NULL, "allocation failed");
 8004c48:	1c01      	adds	r1, r0, #0
 8004c4a:	4605      	mov	r5, r0
 8004c4c:	bf18      	it	ne
 8004c4e:	2101      	movne	r1, #1
 8004c50:	2001      	movs	r0, #1
 8004c52:	f7fd ff85 	bl	8002b60 <_test_assert>
 8004c56:	4604      	mov	r4, r0
 8004c58:	b108      	cbz	r0, 8004c5e <heap1_execute+0x2e>
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
  chHeapFree(p1);

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
  test_assert(12, n == sz, "size changed");
}
 8004c5a:	b002      	add	sp, #8
 8004c5c:	bd70      	pop	{r4, r5, r6, pc}
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
  p1 = chHeapAlloc(NULL, SIZE);
  test_assert(1, p1 != NULL, "allocation failed");
  chHeapFree(p1);
 8004c5e:	4628      	mov	r0, r5
 8004c60:	f7fd fe2e 	bl	80028c0 <chHeapFree>
  p1 = chHeapAlloc(NULL, (size_t)-256);
 8004c64:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 8004c68:	4620      	mov	r0, r4
 8004c6a:	f7fd fde1 	bl	8002830 <chHeapAlloc>
  test_assert(2, p1 == NULL, "allocation not failed");
 8004c6e:	fab0 f180 	clz	r1, r0
 8004c72:	2002      	movs	r0, #2
 8004c74:	0949      	lsrs	r1, r1, #5
 8004c76:	f7fd ff73 	bl	8002b60 <_test_assert>
 8004c7a:	2800      	cmp	r0, #0
 8004c7c:	d1ed      	bne.n	8004c5a <heap1_execute+0x2a>

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);
 8004c7e:	a901      	add	r1, sp, #4
 8004c80:	487b      	ldr	r0, [pc, #492]	; (8004e70 <heap1_execute+0x240>)
 8004c82:	f7fd fe6d 	bl	8002960 <chHeapStatus>

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8004c86:	2110      	movs	r1, #16
 8004c88:	4879      	ldr	r0, [pc, #484]	; (8004e70 <heap1_execute+0x240>)
 8004c8a:	f7fd fdd1 	bl	8002830 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004c8e:	2110      	movs	r1, #16

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8004c90:	4606      	mov	r6, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004c92:	4877      	ldr	r0, [pc, #476]	; (8004e70 <heap1_execute+0x240>)
 8004c94:	f7fd fdcc 	bl	8002830 <chHeapAlloc>
  p3 = chHeapAlloc(&test_heap, SIZE);
 8004c98:	2110      	movs	r1, #16
  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004c9a:	4605      	mov	r5, r0
  p3 = chHeapAlloc(&test_heap, SIZE);
 8004c9c:	4874      	ldr	r0, [pc, #464]	; (8004e70 <heap1_execute+0x240>)
 8004c9e:	f7fd fdc7 	bl	8002830 <chHeapAlloc>
 8004ca2:	4604      	mov	r4, r0
  chHeapFree(p1);                               /* Does not merge.*/
 8004ca4:	4630      	mov	r0, r6
 8004ca6:	f7fd fe0b 	bl	80028c0 <chHeapFree>
  chHeapFree(p2);                               /* Merges backward.*/
 8004caa:	4628      	mov	r0, r5
 8004cac:	f7fd fe08 	bl	80028c0 <chHeapFree>
  chHeapFree(p3);                               /* Merges both sides.*/
 8004cb0:	4620      	mov	r0, r4
 8004cb2:	f7fd fe05 	bl	80028c0 <chHeapFree>
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8004cb6:	4669      	mov	r1, sp
 8004cb8:	486d      	ldr	r0, [pc, #436]	; (8004e70 <heap1_execute+0x240>)
 8004cba:	f7fd fe51 	bl	8002960 <chHeapStatus>
 8004cbe:	f1a0 0101 	sub.w	r1, r0, #1
 8004cc2:	2003      	movs	r0, #3
 8004cc4:	fab1 f181 	clz	r1, r1
 8004cc8:	0949      	lsrs	r1, r1, #5
 8004cca:	f7fd ff49 	bl	8002b60 <_test_assert>
 8004cce:	2800      	cmp	r0, #0
 8004cd0:	d1c3      	bne.n	8004c5a <heap1_execute+0x2a>

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8004cd2:	2110      	movs	r1, #16
 8004cd4:	4866      	ldr	r0, [pc, #408]	; (8004e70 <heap1_execute+0x240>)
 8004cd6:	f7fd fdab 	bl	8002830 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004cda:	2110      	movs	r1, #16
  chHeapFree(p2);                               /* Merges backward.*/
  chHeapFree(p3);                               /* Merges both sides.*/
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8004cdc:	4604      	mov	r4, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004cde:	4864      	ldr	r0, [pc, #400]	; (8004e70 <heap1_execute+0x240>)
 8004ce0:	f7fd fda6 	bl	8002830 <chHeapAlloc>
  p3 = chHeapAlloc(&test_heap, SIZE);
 8004ce4:	2110      	movs	r1, #16
  chHeapFree(p3);                               /* Merges both sides.*/
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004ce6:	4605      	mov	r5, r0
  p3 = chHeapAlloc(&test_heap, SIZE);
 8004ce8:	4861      	ldr	r0, [pc, #388]	; (8004e70 <heap1_execute+0x240>)
 8004cea:	f7fd fda1 	bl	8002830 <chHeapAlloc>
  chHeapFree(p3);                               /* Merges forward.*/
 8004cee:	f7fd fde7 	bl	80028c0 <chHeapFree>
  chHeapFree(p2);                               /* Merges forward.*/
 8004cf2:	4628      	mov	r0, r5
 8004cf4:	f7fd fde4 	bl	80028c0 <chHeapFree>
  chHeapFree(p1);                               /* Merges forward.*/
 8004cf8:	4620      	mov	r0, r4
 8004cfa:	f7fd fde1 	bl	80028c0 <chHeapFree>
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8004cfe:	4669      	mov	r1, sp
 8004d00:	485b      	ldr	r0, [pc, #364]	; (8004e70 <heap1_execute+0x240>)
 8004d02:	f7fd fe2d 	bl	8002960 <chHeapStatus>
 8004d06:	f1a0 0101 	sub.w	r1, r0, #1
 8004d0a:	2004      	movs	r0, #4
 8004d0c:	fab1 f181 	clz	r1, r1
 8004d10:	0949      	lsrs	r1, r1, #5
 8004d12:	f7fd ff25 	bl	8002b60 <_test_assert>
 8004d16:	2800      	cmp	r0, #0
 8004d18:	d19f      	bne.n	8004c5a <heap1_execute+0x2a>

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 8004d1a:	2111      	movs	r1, #17
 8004d1c:	4854      	ldr	r0, [pc, #336]	; (8004e70 <heap1_execute+0x240>)
 8004d1e:	f7fd fd87 	bl	8002830 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004d22:	2110      	movs	r1, #16
  chHeapFree(p2);                               /* Merges forward.*/
  chHeapFree(p1);                               /* Merges forward.*/
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 8004d24:	4604      	mov	r4, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004d26:	4852      	ldr	r0, [pc, #328]	; (8004e70 <heap1_execute+0x240>)
 8004d28:	f7fd fd82 	bl	8002830 <chHeapAlloc>
 8004d2c:	4605      	mov	r5, r0
  chHeapFree(p1);
 8004d2e:	4620      	mov	r0, r4
 8004d30:	f7fd fdc6 	bl	80028c0 <chHeapFree>
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 8004d34:	4669      	mov	r1, sp
 8004d36:	484e      	ldr	r0, [pc, #312]	; (8004e70 <heap1_execute+0x240>)
 8004d38:	f7fd fe12 	bl	8002960 <chHeapStatus>
 8004d3c:	f1a0 0102 	sub.w	r1, r0, #2
 8004d40:	2005      	movs	r0, #5
 8004d42:	fab1 f181 	clz	r1, r1
 8004d46:	0949      	lsrs	r1, r1, #5
 8004d48:	f7fd ff0a 	bl	8002b60 <_test_assert>
 8004d4c:	2800      	cmp	r0, #0
 8004d4e:	d184      	bne.n	8004c5a <heap1_execute+0x2a>
  p1 = chHeapAlloc(&test_heap, SIZE);
 8004d50:	2110      	movs	r1, #16
 8004d52:	4847      	ldr	r0, [pc, #284]	; (8004e70 <heap1_execute+0x240>)
 8004d54:	f7fd fd6c 	bl	8002830 <chHeapAlloc>
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 8004d58:	4669      	mov	r1, sp
  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
  p2 = chHeapAlloc(&test_heap, SIZE);
  chHeapFree(p1);
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
  p1 = chHeapAlloc(&test_heap, SIZE);
 8004d5a:	4604      	mov	r4, r0
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 8004d5c:	4844      	ldr	r0, [pc, #272]	; (8004e70 <heap1_execute+0x240>)
 8004d5e:	f7fd fdff 	bl	8002960 <chHeapStatus>
 8004d62:	2801      	cmp	r0, #1
 8004d64:	f000 8081 	beq.w	8004e6a <heap1_execute+0x23a>
 8004d68:	4669      	mov	r1, sp
 8004d6a:	4841      	ldr	r0, [pc, #260]	; (8004e70 <heap1_execute+0x240>)
 8004d6c:	f7fd fdf8 	bl	8002960 <chHeapStatus>
 8004d70:	f1a0 0102 	sub.w	r1, r0, #2
 8004d74:	fab1 f181 	clz	r1, r1
 8004d78:	0949      	lsrs	r1, r1, #5
 8004d7a:	2006      	movs	r0, #6
 8004d7c:	f7fd fef0 	bl	8002b60 <_test_assert>
 8004d80:	2800      	cmp	r0, #0
 8004d82:	f47f af6a 	bne.w	8004c5a <heap1_execute+0x2a>
                 (chHeapStatus(&test_heap, &n) == 2), "heap fragmented");
  chHeapFree(p2);
 8004d86:	4628      	mov	r0, r5
 8004d88:	f7fd fd9a 	bl	80028c0 <chHeapFree>
  chHeapFree(p1);
 8004d8c:	4620      	mov	r0, r4
 8004d8e:	f7fd fd97 	bl	80028c0 <chHeapFree>
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8004d92:	4669      	mov	r1, sp
 8004d94:	4836      	ldr	r0, [pc, #216]	; (8004e70 <heap1_execute+0x240>)
 8004d96:	f7fd fde3 	bl	8002960 <chHeapStatus>
 8004d9a:	1e46      	subs	r6, r0, #1
 8004d9c:	4271      	negs	r1, r6
 8004d9e:	4171      	adcs	r1, r6
 8004da0:	2007      	movs	r0, #7
 8004da2:	f7fd fedd 	bl	8002b60 <_test_assert>
 8004da6:	2800      	cmp	r0, #0
 8004da8:	f47f af57 	bne.w	8004c5a <heap1_execute+0x2a>

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8004dac:	2110      	movs	r1, #16
 8004dae:	4830      	ldr	r0, [pc, #192]	; (8004e70 <heap1_execute+0x240>)
 8004db0:	f7fd fd3e 	bl	8002830 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004db4:	2110      	movs	r1, #16
  chHeapFree(p2);
  chHeapFree(p1);
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8004db6:	4605      	mov	r5, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004db8:	482d      	ldr	r0, [pc, #180]	; (8004e70 <heap1_execute+0x240>)
 8004dba:	f7fd fd39 	bl	8002830 <chHeapAlloc>
 8004dbe:	4604      	mov	r4, r0
  chHeapFree(p1);
 8004dc0:	4628      	mov	r0, r5
 8004dc2:	f7fd fd7d 	bl	80028c0 <chHeapFree>
  test_assert(8, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 8004dc6:	4669      	mov	r1, sp
 8004dc8:	4829      	ldr	r0, [pc, #164]	; (8004e70 <heap1_execute+0x240>)
 8004dca:	f7fd fdc9 	bl	8002960 <chHeapStatus>
 8004dce:	1e85      	subs	r5, r0, #2
 8004dd0:	4269      	negs	r1, r5
 8004dd2:	4169      	adcs	r1, r5
 8004dd4:	2008      	movs	r0, #8
 8004dd6:	f7fd fec3 	bl	8002b60 <_test_assert>
 8004dda:	2800      	cmp	r0, #0
 8004ddc:	f47f af3d 	bne.w	8004c5a <heap1_execute+0x2a>
  p1 = chHeapAlloc(&test_heap, SIZE * 2);       /* Skips first fragment.*/
 8004de0:	2120      	movs	r1, #32
 8004de2:	4823      	ldr	r0, [pc, #140]	; (8004e70 <heap1_execute+0x240>)
 8004de4:	f7fd fd24 	bl	8002830 <chHeapAlloc>
  chHeapFree(p1);
 8004de8:	f7fd fd6a 	bl	80028c0 <chHeapFree>
  chHeapFree(p2);
 8004dec:	4620      	mov	r0, r4
 8004dee:	f7fd fd67 	bl	80028c0 <chHeapFree>
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8004df2:	4669      	mov	r1, sp
 8004df4:	481e      	ldr	r0, [pc, #120]	; (8004e70 <heap1_execute+0x240>)
 8004df6:	f7fd fdb3 	bl	8002960 <chHeapStatus>
 8004dfa:	3801      	subs	r0, #1
 8004dfc:	4241      	negs	r1, r0
 8004dfe:	4141      	adcs	r1, r0
 8004e00:	2009      	movs	r0, #9
 8004e02:	f7fd fead 	bl	8002b60 <_test_assert>
 8004e06:	2800      	cmp	r0, #0
 8004e08:	f47f af27 	bne.w	8004c5a <heap1_execute+0x2a>

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
 8004e0c:	4669      	mov	r1, sp
 8004e0e:	4818      	ldr	r0, [pc, #96]	; (8004e70 <heap1_execute+0x240>)
 8004e10:	f7fd fda6 	bl	8002960 <chHeapStatus>
  p1 = chHeapAlloc(&test_heap, n);
 8004e14:	9900      	ldr	r1, [sp, #0]
 8004e16:	4816      	ldr	r0, [pc, #88]	; (8004e70 <heap1_execute+0x240>)
 8004e18:	f7fd fd0a 	bl	8002830 <chHeapAlloc>
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 8004e1c:	4669      	mov	r1, sp
  chHeapFree(p2);
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
  p1 = chHeapAlloc(&test_heap, n);
 8004e1e:	4604      	mov	r4, r0
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 8004e20:	4813      	ldr	r0, [pc, #76]	; (8004e70 <heap1_execute+0x240>)
 8004e22:	f7fd fd9d 	bl	8002960 <chHeapStatus>
 8004e26:	fab0 f180 	clz	r1, r0
 8004e2a:	200a      	movs	r0, #10
 8004e2c:	0949      	lsrs	r1, r1, #5
 8004e2e:	f7fd fe97 	bl	8002b60 <_test_assert>
 8004e32:	2800      	cmp	r0, #0
 8004e34:	f47f af11 	bne.w	8004c5a <heap1_execute+0x2a>
  chHeapFree(p1);
 8004e38:	4620      	mov	r0, r4
 8004e3a:	f7fd fd41 	bl	80028c0 <chHeapFree>

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8004e3e:	4669      	mov	r1, sp
 8004e40:	480b      	ldr	r0, [pc, #44]	; (8004e70 <heap1_execute+0x240>)
 8004e42:	f7fd fd8d 	bl	8002960 <chHeapStatus>
 8004e46:	1e42      	subs	r2, r0, #1
 8004e48:	4251      	negs	r1, r2
 8004e4a:	4151      	adcs	r1, r2
 8004e4c:	200b      	movs	r0, #11
 8004e4e:	f7fd fe87 	bl	8002b60 <_test_assert>
 8004e52:	2800      	cmp	r0, #0
 8004e54:	f47f af01 	bne.w	8004c5a <heap1_execute+0x2a>
  test_assert(12, n == sz, "size changed");
 8004e58:	e89d 000a 	ldmia.w	sp, {r1, r3}
 8004e5c:	1acb      	subs	r3, r1, r3
 8004e5e:	4259      	negs	r1, r3
 8004e60:	4159      	adcs	r1, r3
 8004e62:	200c      	movs	r0, #12
 8004e64:	f7fd fe7c 	bl	8002b60 <_test_assert>
 8004e68:	e6f7      	b.n	8004c5a <heap1_execute+0x2a>
 8004e6a:	4601      	mov	r1, r0
 8004e6c:	e785      	b.n	8004d7a <heap1_execute+0x14a>
 8004e6e:	bf00      	nop
 8004e70:	20001cb0 	.word	0x20001cb0
 8004e74:	f3af 8000 	nop.w
 8004e78:	f3af 8000 	nop.w
 8004e7c:	f3af 8000 	nop.w

08004e80 <heap1_setup>:
 * sequence.
 */

static void heap1_setup(void) {

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
 8004e80:	4802      	ldr	r0, [pc, #8]	; (8004e8c <heap1_setup+0xc>)
 8004e82:	4903      	ldr	r1, [pc, #12]	; (8004e90 <heap1_setup+0x10>)
 8004e84:	f44f 6211 	mov.w	r2, #2320	; 0x910
 8004e88:	f7fd bcc2 	b.w	8002810 <chHeapObjectInit>
 8004e8c:	20001cb0 	.word	0x20001cb0
 8004e90:	20001350 	.word	0x20001350
 8004e94:	f3af 8000 	nop.w
 8004e98:	f3af 8000 	nop.w
 8004e9c:	f3af 8000 	nop.w

08004ea0 <null_provider>:

static void *null_provider(size_t size) {

  (void)size;
  return NULL;
}
 8004ea0:	2000      	movs	r0, #0
 8004ea2:	4770      	bx	lr
 8004ea4:	f3af 8000 	nop.w
 8004ea8:	f3af 8000 	nop.w
 8004eac:	f3af 8000 	nop.w

08004eb0 <pools1_setup>:

static void pools1_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 8004eb0:	4802      	ldr	r0, [pc, #8]	; (8004ebc <pools1_setup+0xc>)
 8004eb2:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8004eb6:	2200      	movs	r2, #0
 8004eb8:	f7fd bd7a 	b.w	80029b0 <chPoolObjectInit>
 8004ebc:	20000864 	.word	0x20000864

08004ec0 <pools1_execute>:
}

static void pools1_execute(void) {
 8004ec0:	b538      	push	{r3, r4, r5, lr}
  int i;

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);
 8004ec2:	4b2b      	ldr	r3, [pc, #172]	; (8004f70 <pools1_execute+0xb0>)
 8004ec4:	482b      	ldr	r0, [pc, #172]	; (8004f74 <pools1_execute+0xb4>)
 8004ec6:	681d      	ldr	r5, [r3, #0]
 8004ec8:	2205      	movs	r2, #5
 8004eca:	4629      	mov	r1, r5
 8004ecc:	f7fd fd78 	bl	80029c0 <chPoolLoadArray>
 8004ed0:	2405      	movs	r4, #5

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");
 8004ed2:	4828      	ldr	r0, [pc, #160]	; (8004f74 <pools1_execute+0xb4>)
 8004ed4:	f7fd fd8c 	bl	80029f0 <chPoolAlloc>
 8004ed8:	1c01      	adds	r1, r0, #0
 8004eda:	bf18      	it	ne
 8004edc:	2101      	movne	r1, #1
 8004ede:	2001      	movs	r0, #1
 8004ee0:	f7fd fe3e 	bl	8002b60 <_test_assert>
 8004ee4:	bb90      	cbnz	r0, 8004f4c <pools1_execute+0x8c>

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
 8004ee6:	3c01      	subs	r4, #1
 8004ee8:	d1f3      	bne.n	8004ed2 <pools1_execute+0x12>
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");
 8004eea:	4822      	ldr	r0, [pc, #136]	; (8004f74 <pools1_execute+0xb4>)
 8004eec:	f7fd fd80 	bl	80029f0 <chPoolAlloc>
 8004ef0:	fab0 f180 	clz	r1, r0
 8004ef4:	2002      	movs	r0, #2
 8004ef6:	0949      	lsrs	r1, r1, #5
 8004ef8:	f7fd fe32 	bl	8002b60 <_test_assert>
 8004efc:	bb30      	cbnz	r0, 8004f4c <pools1_execute+0x8c>
 8004efe:	4c1c      	ldr	r4, [pc, #112]	; (8004f70 <pools1_execute+0xb0>)

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);
 8004f00:	481c      	ldr	r0, [pc, #112]	; (8004f74 <pools1_execute+0xb4>)
  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");
 8004f02:	4629      	mov	r1, r5
 8004f04:	f104 0510 	add.w	r5, r4, #16

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);
 8004f08:	f7fd fd8a 	bl	8002a20 <chPoolFree>

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 8004f0c:	42ac      	cmp	r4, r5
 8004f0e:	d006      	beq.n	8004f1e <pools1_execute+0x5e>
 8004f10:	f854 1f04 	ldr.w	r1, [r4, #4]!
    chPoolFree(&mp1, wa[i]);
 8004f14:	4817      	ldr	r0, [pc, #92]	; (8004f74 <pools1_execute+0xb4>)
 8004f16:	f7fd fd83 	bl	8002a20 <chPoolFree>

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 8004f1a:	42ac      	cmp	r4, r5
 8004f1c:	d1f8      	bne.n	8004f10 <pools1_execute+0x50>
 8004f1e:	2405      	movs	r4, #5
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");
 8004f20:	4814      	ldr	r0, [pc, #80]	; (8004f74 <pools1_execute+0xb4>)
 8004f22:	f7fd fd65 	bl	80029f0 <chPoolAlloc>
 8004f26:	1c01      	adds	r1, r0, #0
 8004f28:	bf18      	it	ne
 8004f2a:	2101      	movne	r1, #1
 8004f2c:	2003      	movs	r0, #3
 8004f2e:	f7fd fe17 	bl	8002b60 <_test_assert>
 8004f32:	b958      	cbnz	r0, 8004f4c <pools1_execute+0x8c>
  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
 8004f34:	3c01      	subs	r4, #1
 8004f36:	d1f3      	bne.n	8004f20 <pools1_execute+0x60>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");
 8004f38:	480e      	ldr	r0, [pc, #56]	; (8004f74 <pools1_execute+0xb4>)
 8004f3a:	f7fd fd59 	bl	80029f0 <chPoolAlloc>
 8004f3e:	fab0 f180 	clz	r1, r0
 8004f42:	2004      	movs	r0, #4
 8004f44:	0949      	lsrs	r1, r1, #5
 8004f46:	f7fd fe0b 	bl	8002b60 <_test_assert>
 8004f4a:	b100      	cbz	r0, 8004f4e <pools1_execute+0x8e>
 8004f4c:	bd38      	pop	{r3, r4, r5, pc}

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
 8004f4e:	2110      	movs	r1, #16
 8004f50:	4808      	ldr	r0, [pc, #32]	; (8004f74 <pools1_execute+0xb4>)
 8004f52:	4a09      	ldr	r2, [pc, #36]	; (8004f78 <pools1_execute+0xb8>)
 8004f54:	f7fd fd2c 	bl	80029b0 <chPoolObjectInit>
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8004f58:	4806      	ldr	r0, [pc, #24]	; (8004f74 <pools1_execute+0xb4>)
 8004f5a:	f7fd fd49 	bl	80029f0 <chPoolAlloc>
}
 8004f5e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8004f62:	fab0 f180 	clz	r1, r0
 8004f66:	2005      	movs	r0, #5
 8004f68:	0949      	lsrs	r1, r1, #5
 8004f6a:	f7fd bdf9 	b.w	8002b60 <_test_assert>
 8004f6e:	bf00      	nop
 8004f70:	080160d0 	.word	0x080160d0
 8004f74:	20000864 	.word	0x20000864
 8004f78:	08004ea1 	.word	0x08004ea1
 8004f7c:	f3af 8000 	nop.w

08004f80 <dyn1_execute>:
static void dyn1_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn1_execute(void) {
 8004f80:	b570      	push	{r4, r5, r6, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004f82:	4b34      	ldr	r3, [pc, #208]	; (8005054 <dyn1_execute+0xd4>)
  size_t n, sz;
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
 8004f84:	4834      	ldr	r0, [pc, #208]	; (8005058 <dyn1_execute+0xd8>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8004f86:	699b      	ldr	r3, [r3, #24]
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 8004f88:	4c34      	ldr	r4, [pc, #208]	; (800505c <dyn1_execute+0xdc>)
 8004f8a:	689d      	ldr	r5, [r3, #8]
static void dyn1_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn1_execute(void) {
 8004f8c:	b084      	sub	sp, #16
  size_t n, sz;
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
 8004f8e:	a903      	add	r1, sp, #12
 8004f90:	f7fd fce6 	bl	8002960 <chHeapStatus>
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 8004f94:	4b32      	ldr	r3, [pc, #200]	; (8005060 <dyn1_execute+0xe0>)
 8004f96:	9300      	str	r3, [sp, #0]
 8004f98:	1e6a      	subs	r2, r5, #1
 8004f9a:	4b32      	ldr	r3, [pc, #200]	; (8005064 <dyn1_execute+0xe4>)
 8004f9c:	482e      	ldr	r0, [pc, #184]	; (8005058 <dyn1_execute+0xd8>)
 8004f9e:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8004fa2:	f7fc fc15 	bl	80017d0 <chThdCreateFromHeap>
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 8004fa6:	4b30      	ldr	r3, [pc, #192]	; (8005068 <dyn1_execute+0xe8>)
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 8004fa8:	6020      	str	r0, [r4, #0]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 8004faa:	1eaa      	subs	r2, r5, #2
 8004fac:	9300      	str	r3, [sp, #0]
 8004fae:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8004fb2:	4b2c      	ldr	r3, [pc, #176]	; (8005064 <dyn1_execute+0xe4>)
 8004fb4:	4828      	ldr	r0, [pc, #160]	; (8005058 <dyn1_execute+0xd8>)
 8004fb6:	f7fc fc0b 	bl	80017d0 <chThdCreateFromHeap>
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 8004fba:	a902      	add	r1, sp, #8
  (void)chHeapStatus(&heap1, &sz);
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 8004fbc:	6060      	str	r0, [r4, #4]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 8004fbe:	4826      	ldr	r0, [pc, #152]	; (8005058 <dyn1_execute+0xd8>)
 8004fc0:	f7fd fcce 	bl	8002960 <chHeapStatus>
  p1 = chHeapAlloc(&heap1, n);
 8004fc4:	9902      	ldr	r1, [sp, #8]
 8004fc6:	4824      	ldr	r0, [pc, #144]	; (8005058 <dyn1_execute+0xd8>)
 8004fc8:	f7fd fc32 	bl	8002830 <chHeapAlloc>
  threads[2] = chThdCreateFromHeap(&heap1,
 8004fcc:	4b27      	ldr	r3, [pc, #156]	; (800506c <dyn1_execute+0xec>)
 8004fce:	9300      	str	r3, [sp, #0]
 8004fd0:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
  threads[1] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
  p1 = chHeapAlloc(&heap1, n);
 8004fd4:	4606      	mov	r6, r0
  threads[2] = chThdCreateFromHeap(&heap1,
 8004fd6:	1eea      	subs	r2, r5, #3
 8004fd8:	4b22      	ldr	r3, [pc, #136]	; (8005064 <dyn1_execute+0xe4>)
 8004fda:	481f      	ldr	r0, [pc, #124]	; (8005058 <dyn1_execute+0xd8>)
 8004fdc:	f7fc fbf8 	bl	80017d0 <chThdCreateFromHeap>
 8004fe0:	60a0      	str	r0, [r4, #8]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);
 8004fe2:	4630      	mov	r0, r6
 8004fe4:	f7fd fc6c 	bl	80028c0 <chHeapFree>

  test_assert(1, (threads[0] != NULL) &&
 8004fe8:	6821      	ldr	r1, [r4, #0]
 8004fea:	b121      	cbz	r1, 8004ff6 <dyn1_execute+0x76>
 8004fec:	6861      	ldr	r1, [r4, #4]
 8004fee:	b111      	cbz	r1, 8004ff6 <dyn1_execute+0x76>
 8004ff0:	68a1      	ldr	r1, [r4, #8]
 8004ff2:	b331      	cbz	r1, 8005042 <dyn1_execute+0xc2>
 8004ff4:	2100      	movs	r1, #0
 8004ff6:	2001      	movs	r0, #1
 8004ff8:	f7fd fdb2 	bl	8002b60 <_test_assert>
 8004ffc:	b108      	cbz	r0, 8005002 <dyn1_execute+0x82>
  test_assert_sequence(2, "AB");

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
  test_assert(4, n == sz, "heap size changed");
}
 8004ffe:	b004      	add	sp, #16
 8005000:	bd70      	pop	{r4, r5, r6, pc}
                 (threads[3] == NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 8005002:	f7fd fe1d 	bl	8002c40 <test_wait_threads>
  test_assert_sequence(2, "AB");
 8005006:	2002      	movs	r0, #2
 8005008:	4919      	ldr	r1, [pc, #100]	; (8005070 <dyn1_execute+0xf0>)
 800500a:	f7fd fdc1 	bl	8002b90 <_test_assert_sequence>
 800500e:	2800      	cmp	r0, #0
 8005010:	d1f5      	bne.n	8004ffe <dyn1_execute+0x7e>

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
 8005012:	a902      	add	r1, sp, #8
 8005014:	4810      	ldr	r0, [pc, #64]	; (8005058 <dyn1_execute+0xd8>)
 8005016:	f7fd fca3 	bl	8002960 <chHeapStatus>
 800501a:	f1a0 0101 	sub.w	r1, r0, #1
 800501e:	2003      	movs	r0, #3
 8005020:	fab1 f181 	clz	r1, r1
 8005024:	0949      	lsrs	r1, r1, #5
 8005026:	f7fd fd9b 	bl	8002b60 <_test_assert>
 800502a:	2800      	cmp	r0, #0
 800502c:	d1e7      	bne.n	8004ffe <dyn1_execute+0x7e>
  test_assert(4, n == sz, "heap size changed");
 800502e:	9902      	ldr	r1, [sp, #8]
 8005030:	9b03      	ldr	r3, [sp, #12]
 8005032:	2004      	movs	r0, #4
 8005034:	1ac9      	subs	r1, r1, r3
 8005036:	fab1 f181 	clz	r1, r1
 800503a:	0949      	lsrs	r1, r1, #5
 800503c:	f7fd fd90 	bl	8002b60 <_test_assert>
 8005040:	e7dd      	b.n	8004ffe <dyn1_execute+0x7e>
  threads[2] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);

  test_assert(1, (threads[0] != NULL) &&
 8005042:	68e3      	ldr	r3, [r4, #12]
 8005044:	2b00      	cmp	r3, #0
 8005046:	d1d6      	bne.n	8004ff6 <dyn1_execute+0x76>
 8005048:	6921      	ldr	r1, [r4, #16]
 800504a:	fab1 f181 	clz	r1, r1
 800504e:	0949      	lsrs	r1, r1, #5
 8005050:	e7d1      	b.n	8004ff6 <dyn1_execute+0x76>
 8005052:	bf00      	nop
 8005054:	20001150 	.word	0x20001150
 8005058:	20001ce0 	.word	0x20001ce0
 800505c:	20001c84 	.word	0x20001c84
 8005060:	080163a8 	.word	0x080163a8
 8005064:	08005081 	.word	0x08005081
 8005068:	080163a4 	.word	0x080163a4
 800506c:	080163a0 	.word	0x080163a0
 8005070:	080167f0 	.word	0x080167f0
 8005074:	f3af 8000 	nop.w
 8005078:	f3af 8000 	nop.w
 800507c:	f3af 8000 	nop.w

08005080 <thread>:
 * is attempted.<br>
 * The test expects the first two threads to successfully start and the last
 * one to fail.
 */

static msg_t thread(void *p) {
 8005080:	b508      	push	{r3, lr}

  test_emit_token(*(char *)p);
 8005082:	7800      	ldrb	r0, [r0, #0]
 8005084:	f7fd fd5c 	bl	8002b40 <test_emit_token>
  return 0;
}
 8005088:	2000      	movs	r0, #0
 800508a:	bd08      	pop	{r3, pc}
 800508c:	f3af 8000 	nop.w

08005090 <dyn1_setup>:

#if (CH_CFG_USE_HEAP && !CH_CFG_USE_MALLOC_HEAP) || defined(__DOXYGEN__)
static void dyn1_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
 8005090:	4802      	ldr	r0, [pc, #8]	; (800509c <dyn1_setup+0xc>)
 8005092:	4903      	ldr	r1, [pc, #12]	; (80050a0 <dyn1_setup+0x10>)
 8005094:	f44f 6211 	mov.w	r2, #2320	; 0x910
 8005098:	f7fd bbba 	b.w	8002810 <chHeapObjectInit>
 800509c:	20001ce0 	.word	0x20001ce0
 80050a0:	20001350 	.word	0x20001350
 80050a4:	f3af 8000 	nop.w
 80050a8:	f3af 8000 	nop.w
 80050ac:	f3af 8000 	nop.w

080050b0 <dyn3_setup>:
  return found;
}

static void dyn3_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
 80050b0:	4802      	ldr	r0, [pc, #8]	; (80050bc <dyn3_setup+0xc>)
 80050b2:	4903      	ldr	r1, [pc, #12]	; (80050c0 <dyn3_setup+0x10>)
 80050b4:	f44f 6211 	mov.w	r2, #2320	; 0x910
 80050b8:	f7fd bbaa 	b.w	8002810 <chHeapObjectInit>
 80050bc:	20001ce0 	.word	0x20001ce0
 80050c0:	20001350 	.word	0x20001350
 80050c4:	f3af 8000 	nop.w
 80050c8:	f3af 8000 	nop.w
 80050cc:	f3af 8000 	nop.w

080050d0 <dyn2_execute>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80050d0:	4b31      	ldr	r3, [pc, #196]	; (8005198 <dyn2_execute+0xc8>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80050d2:	699b      	ldr	r3, [r3, #24]
static void dyn2_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}

static void dyn2_execute(void) {
 80050d4:	b570      	push	{r4, r5, r6, lr}
 80050d6:	4c31      	ldr	r4, [pc, #196]	; (800519c <dyn2_execute+0xcc>)
 80050d8:	689d      	ldr	r5, [r3, #8]
 80050da:	f104 0610 	add.w	r6, r4, #16
  int i;
  tprio_t prio = chThdGetPriorityX();

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);
 80050de:	f854 1b04 	ldr.w	r1, [r4], #4
 80050e2:	482f      	ldr	r0, [pc, #188]	; (80051a0 <dyn2_execute+0xd0>)
 80050e4:	f7fd fc9c 	bl	8002a20 <chPoolFree>
static void dyn2_execute(void) {
  int i;
  tprio_t prio = chThdGetPriorityX();

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
 80050e8:	42b4      	cmp	r4, r6
 80050ea:	d1f8      	bne.n	80050de <dyn2_execute+0xe>
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 80050ec:	4a2d      	ldr	r2, [pc, #180]	; (80051a4 <dyn2_execute+0xd4>)
 80050ee:	4b2e      	ldr	r3, [pc, #184]	; (80051a8 <dyn2_execute+0xd8>)
 80050f0:	482b      	ldr	r0, [pc, #172]	; (80051a0 <dyn2_execute+0xd0>)
 80050f2:	4c2e      	ldr	r4, [pc, #184]	; (80051ac <dyn2_execute+0xdc>)
 80050f4:	1e69      	subs	r1, r5, #1
 80050f6:	f7fc fb8b 	bl	8001810 <chThdCreateFromMemoryPool>
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 80050fa:	1ea9      	subs	r1, r5, #2
  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 80050fc:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 80050fe:	4a29      	ldr	r2, [pc, #164]	; (80051a4 <dyn2_execute+0xd4>)
 8005100:	4b2b      	ldr	r3, [pc, #172]	; (80051b0 <dyn2_execute+0xe0>)
 8005102:	4827      	ldr	r0, [pc, #156]	; (80051a0 <dyn2_execute+0xd0>)
 8005104:	f7fc fb84 	bl	8001810 <chThdCreateFromMemoryPool>
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8005108:	1ee9      	subs	r1, r5, #3
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 800510a:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 800510c:	4a25      	ldr	r2, [pc, #148]	; (80051a4 <dyn2_execute+0xd4>)
 800510e:	4b29      	ldr	r3, [pc, #164]	; (80051b4 <dyn2_execute+0xe4>)
 8005110:	4823      	ldr	r0, [pc, #140]	; (80051a0 <dyn2_execute+0xd0>)
 8005112:	f7fc fb7d 	bl	8001810 <chThdCreateFromMemoryPool>
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8005116:	1f29      	subs	r1, r5, #4
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8005118:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 800511a:	4a22      	ldr	r2, [pc, #136]	; (80051a4 <dyn2_execute+0xd4>)
 800511c:	4b26      	ldr	r3, [pc, #152]	; (80051b8 <dyn2_execute+0xe8>)
 800511e:	4820      	ldr	r0, [pc, #128]	; (80051a0 <dyn2_execute+0xd0>)
 8005120:	f7fc fb76 	bl	8001810 <chThdCreateFromMemoryPool>
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8005124:	1f69      	subs	r1, r5, #5

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8005126:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8005128:	4a1e      	ldr	r2, [pc, #120]	; (80051a4 <dyn2_execute+0xd4>)
 800512a:	481d      	ldr	r0, [pc, #116]	; (80051a0 <dyn2_execute+0xd0>)
 800512c:	4b23      	ldr	r3, [pc, #140]	; (80051bc <dyn2_execute+0xec>)
 800512e:	f7fc fb6f 	bl	8001810 <chThdCreateFromMemoryPool>

  test_assert(1, (threads[0] != NULL) &&
 8005132:	6821      	ldr	r1, [r4, #0]
  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8005134:	6120      	str	r0, [r4, #16]

  test_assert(1, (threads[0] != NULL) &&
 8005136:	b141      	cbz	r1, 800514a <dyn2_execute+0x7a>
 8005138:	6861      	ldr	r1, [r4, #4]
 800513a:	b131      	cbz	r1, 800514a <dyn2_execute+0x7a>
 800513c:	68a1      	ldr	r1, [r4, #8]
 800513e:	b121      	cbz	r1, 800514a <dyn2_execute+0x7a>
 8005140:	68e1      	ldr	r1, [r4, #12]
 8005142:	b111      	cbz	r1, 800514a <dyn2_execute+0x7a>
 8005144:	fab0 f180 	clz	r1, r0
 8005148:	0949      	lsrs	r1, r1, #5
 800514a:	2001      	movs	r0, #1
 800514c:	f7fd fd08 	bl	8002b60 <_test_assert>
 8005150:	b100      	cbz	r0, 8005154 <dyn2_execute+0x84>
 8005152:	bd70      	pop	{r4, r5, r6, pc}
                 (threads[3] != NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 8005154:	f7fd fd74 	bl	8002c40 <test_wait_threads>
  test_assert_sequence(2, "ABCD");
 8005158:	2002      	movs	r0, #2
 800515a:	4919      	ldr	r1, [pc, #100]	; (80051c0 <dyn2_execute+0xf0>)
 800515c:	f7fd fd18 	bl	8002b90 <_test_assert_sequence>
 8005160:	2800      	cmp	r0, #0
 8005162:	d1f6      	bne.n	8005152 <dyn2_execute+0x82>
 8005164:	2404      	movs	r4, #4

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
 8005166:	480e      	ldr	r0, [pc, #56]	; (80051a0 <dyn2_execute+0xd0>)
 8005168:	f7fd fc42 	bl	80029f0 <chPoolAlloc>
 800516c:	1c01      	adds	r1, r0, #0
 800516e:	bf18      	it	ne
 8005170:	2101      	movne	r1, #1
 8005172:	2003      	movs	r0, #3
 8005174:	f7fd fcf4 	bl	8002b60 <_test_assert>
 8005178:	2800      	cmp	r0, #0
 800517a:	d1ea      	bne.n	8005152 <dyn2_execute+0x82>
  /* Claiming the memory from terminated threads. */
  test_wait_threads();
  test_assert_sequence(2, "ABCD");

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
 800517c:	3c01      	subs	r4, #1
 800517e:	d1f2      	bne.n	8005166 <dyn2_execute+0x96>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
 8005180:	4807      	ldr	r0, [pc, #28]	; (80051a0 <dyn2_execute+0xd0>)
 8005182:	f7fd fc35 	bl	80029f0 <chPoolAlloc>
}
 8005186:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  test_assert_sequence(2, "ABCD");

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
 800518a:	fab0 f180 	clz	r1, r0
 800518e:	2004      	movs	r0, #4
 8005190:	0949      	lsrs	r1, r1, #5
 8005192:	f7fd bce5 	b.w	8002b60 <_test_assert>
 8005196:	bf00      	nop
 8005198:	20001150 	.word	0x20001150
 800519c:	080160d0 	.word	0x080160d0
 80051a0:	20001cd0 	.word	0x20001cd0
 80051a4:	08005081 	.word	0x08005081
 80051a8:	080163a8 	.word	0x080163a8
 80051ac:	20001c84 	.word	0x20001c84
 80051b0:	080163a4 	.word	0x080163a4
 80051b4:	080163a0 	.word	0x080163a0
 80051b8:	08017310 	.word	0x08017310
 80051bc:	080163b0 	.word	0x080163b0
 80051c0:	080167f4 	.word	0x080167f4
 80051c4:	f3af 8000 	nop.w
 80051c8:	f3af 8000 	nop.w
 80051cc:	f3af 8000 	nop.w

080051d0 <dyn2_setup>:
 * one to fail.
 */

static void dyn2_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 80051d0:	4802      	ldr	r0, [pc, #8]	; (80051dc <dyn2_setup+0xc>)
 80051d2:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80051d6:	2200      	movs	r2, #0
 80051d8:	f7fd bbea 	b.w	80029b0 <chPoolObjectInit>
 80051dc:	20001cd0 	.word	0x20001cd0

080051e0 <regfind>:
 * <h2>Description</h2>
 * Registry and Thread References APIs are tested for functionality and
 * coverage.
 */

static bool regfind(thread_t *tp) {
 80051e0:	b538      	push	{r3, r4, r5, lr}
 80051e2:	4605      	mov	r5, r0
  thread_t *ftp;
  bool found = false;

  ftp = chRegFirstThread();
 80051e4:	f7fc fb3c 	bl	8001860 <chRegFirstThread>
 * coverage.
 */

static bool regfind(thread_t *tp) {
  thread_t *ftp;
  bool found = false;
 80051e8:	2400      	movs	r4, #0

  ftp = chRegFirstThread();
 80051ea:	4603      	mov	r3, r0
  do {
    found |= ftp == tp;
    ftp = chRegNextThread(ftp);
 80051ec:	4618      	mov	r0, r3
  thread_t *ftp;
  bool found = false;

  ftp = chRegFirstThread();
  do {
    found |= ftp == tp;
 80051ee:	42ab      	cmp	r3, r5
 80051f0:	bf08      	it	eq
 80051f2:	f044 0401 	orreq.w	r4, r4, #1
    ftp = chRegNextThread(ftp);
 80051f6:	f7fc fb43 	bl	8001880 <chRegNextThread>
  } while (ftp != NULL);
 80051fa:	4603      	mov	r3, r0
 80051fc:	2800      	cmp	r0, #0
 80051fe:	d1f5      	bne.n	80051ec <regfind+0xc>
  return found;
}
 8005200:	4620      	mov	r0, r4
 8005202:	bd38      	pop	{r3, r4, r5, pc}
 8005204:	f3af 8000 	nop.w
 8005208:	f3af 8000 	nop.w
 800520c:	f3af 8000 	nop.w

08005210 <dyn3_execute>:
static void dyn3_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn3_execute(void) {
 8005210:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8005212:	4b48      	ldr	r3, [pc, #288]	; (8005334 <dyn3_execute+0x124>)
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
 8005214:	4948      	ldr	r1, [pc, #288]	; (8005338 <dyn3_execute+0x128>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8005216:	699b      	ldr	r3, [r3, #24]
 8005218:	4848      	ldr	r0, [pc, #288]	; (800533c <dyn3_execute+0x12c>)
 800521a:	689a      	ldr	r2, [r3, #8]
 800521c:	4b48      	ldr	r3, [pc, #288]	; (8005340 <dyn3_execute+0x130>)
static void dyn3_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn3_execute(void) {
 800521e:	b082      	sub	sp, #8
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
 8005220:	3a01      	subs	r2, #1
 8005222:	9100      	str	r1, [sp, #0]
 8005224:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005228:	f7fc fad2 	bl	80017d0 <chThdCreateFromHeap>
 800522c:	4604      	mov	r4, r0
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
 800522e:	2001      	movs	r0, #1
 8005230:	7fa1      	ldrb	r1, [r4, #30]
 8005232:	1a09      	subs	r1, r1, r0
 8005234:	fab1 f181 	clz	r1, r1
 8005238:	0949      	lsrs	r1, r1, #5
 800523a:	f7fd fc91 	bl	8002b60 <_test_assert>
 800523e:	b108      	cbz	r0, 8005244 <dyn3_execute+0x34>
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
  test_assert(12, !regfind(tp), "thread still in registry");
}
 8005240:	b002      	add	sp, #8
 8005242:	bd10      	pop	{r4, pc}
  tprio_t prio = chThdGetPriorityX();

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
  chThdAddRef(tp);
 8005244:	4620      	mov	r0, r4
 8005246:	f7fc fa8b 	bl	8001760 <chThdAddRef>
  test_assert(2, tp->p_refs == 2, "references increase failure");
 800524a:	7fa1      	ldrb	r1, [r4, #30]
 800524c:	2002      	movs	r0, #2
 800524e:	1a09      	subs	r1, r1, r0
 8005250:	fab1 f181 	clz	r1, r1
 8005254:	0949      	lsrs	r1, r1, #5
 8005256:	f7fd fc83 	bl	8002b60 <_test_assert>
 800525a:	2800      	cmp	r0, #0
 800525c:	d1f0      	bne.n	8005240 <dyn3_execute+0x30>
  chThdRelease(tp);
 800525e:	4620      	mov	r0, r4
 8005260:	f7fc fa8e 	bl	8001780 <chThdRelease>
  test_assert(3, tp->p_refs == 1, "references decrease failure");
 8005264:	7fa1      	ldrb	r1, [r4, #30]
 8005266:	2003      	movs	r0, #3
 8005268:	f1a1 0101 	sub.w	r1, r1, #1
 800526c:	fab1 f181 	clz	r1, r1
 8005270:	0949      	lsrs	r1, r1, #5
 8005272:	f7fd fc75 	bl	8002b60 <_test_assert>
 8005276:	2800      	cmp	r0, #0
 8005278:	d1e2      	bne.n	8005240 <dyn3_execute+0x30>

  /* Verify the new threads count.*/
  test_assert(4, regfind(tp), "thread missing from registry");
 800527a:	4620      	mov	r0, r4
 800527c:	f7ff ffb0 	bl	80051e0 <regfind>
 8005280:	4601      	mov	r1, r0
 8005282:	2004      	movs	r0, #4
 8005284:	f7fd fc6c 	bl	8002b60 <_test_assert>
 8005288:	2800      	cmp	r0, #0
 800528a:	d1d9      	bne.n	8005240 <dyn3_execute+0x30>
  test_assert(5, regfind(tp), "thread disappeared");
 800528c:	4620      	mov	r0, r4
 800528e:	f7ff ffa7 	bl	80051e0 <regfind>
 8005292:	4601      	mov	r1, r0
 8005294:	2005      	movs	r0, #5
 8005296:	f7fd fc63 	bl	8002b60 <_test_assert>
 800529a:	2800      	cmp	r0, #0
 800529c:	d1d0      	bne.n	8005240 <dyn3_execute+0x30>

  /* Detach and let the thread execute and terminate.*/
  chThdRelease(tp);
 800529e:	4620      	mov	r0, r4
 80052a0:	f7fc fa6e 	bl	8001780 <chThdRelease>
  test_assert(6, tp->p_refs == 0, "detach failure");
 80052a4:	7fa1      	ldrb	r1, [r4, #30]
 80052a6:	fab1 f181 	clz	r1, r1
 80052aa:	2006      	movs	r0, #6
 80052ac:	0949      	lsrs	r1, r1, #5
 80052ae:	f7fd fc57 	bl	8002b60 <_test_assert>
 80052b2:	2800      	cmp	r0, #0
 80052b4:	d1c4      	bne.n	8005240 <dyn3_execute+0x30>
  test_assert(7, tp->p_state == CH_STATE_READY, "invalid state");
 80052b6:	7f21      	ldrb	r1, [r4, #28]
 80052b8:	fab1 f181 	clz	r1, r1
 80052bc:	2007      	movs	r0, #7
 80052be:	0949      	lsrs	r1, r1, #5
 80052c0:	f7fd fc4e 	bl	8002b60 <_test_assert>
 80052c4:	2800      	cmp	r0, #0
 80052c6:	d1bb      	bne.n	8005240 <dyn3_execute+0x30>
  test_assert(8, regfind(tp), "thread disappeared");
 80052c8:	4620      	mov	r0, r4
 80052ca:	f7ff ff89 	bl	80051e0 <regfind>
 80052ce:	4601      	mov	r1, r0
 80052d0:	2008      	movs	r0, #8
 80052d2:	f7fd fc45 	bl	8002b60 <_test_assert>
 80052d6:	2800      	cmp	r0, #0
 80052d8:	d1b2      	bne.n	8005240 <dyn3_execute+0x30>
  test_assert(9, regfind(tp), "thread disappeared");
 80052da:	4620      	mov	r0, r4
 80052dc:	f7ff ff80 	bl	80051e0 <regfind>
 80052e0:	4601      	mov	r1, r0
 80052e2:	2009      	movs	r0, #9
 80052e4:	f7fd fc3c 	bl	8002b60 <_test_assert>
 80052e8:	2800      	cmp	r0, #0
 80052ea:	d1a9      	bne.n	8005240 <dyn3_execute+0x30>
  chThdSleepMilliseconds(50);           /* The thread just terminates.      */
 80052ec:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80052f0:	f7fc f976 	bl	80015e0 <chThdSleep>
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");
 80052f4:	7f21      	ldrb	r1, [r4, #28]
 80052f6:	f1a1 030f 	sub.w	r3, r1, #15
 80052fa:	4259      	negs	r1, r3
 80052fc:	4159      	adcs	r1, r3
 80052fe:	200a      	movs	r0, #10
 8005300:	f7fd fc2e 	bl	8002b60 <_test_assert>
 8005304:	2800      	cmp	r0, #0
 8005306:	d19b      	bne.n	8005240 <dyn3_execute+0x30>

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
 8005308:	4620      	mov	r0, r4
 800530a:	f7ff ff69 	bl	80051e0 <regfind>
 800530e:	4601      	mov	r1, r0
 8005310:	200b      	movs	r0, #11
 8005312:	f7fd fc25 	bl	8002b60 <_test_assert>
 8005316:	2800      	cmp	r0, #0
 8005318:	d192      	bne.n	8005240 <dyn3_execute+0x30>
  test_assert(12, !regfind(tp), "thread still in registry");
 800531a:	4620      	mov	r0, r4
 800531c:	f7ff ff60 	bl	80051e0 <regfind>
 8005320:	f080 0101 	eor.w	r1, r0, #1
 8005324:	b2c9      	uxtb	r1, r1
 8005326:	200c      	movs	r0, #12
}
 8005328:	b002      	add	sp, #8
 800532a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chThdSleepMilliseconds(50);           /* The thread just terminates.      */
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
  test_assert(12, !regfind(tp), "thread still in registry");
 800532e:	f7fd bc17 	b.w	8002b60 <_test_assert>
 8005332:	bf00      	nop
 8005334:	20001150 	.word	0x20001150
 8005338:	080163a8 	.word	0x080163a8
 800533c:	20001ce0 	.word	0x20001ce0
 8005340:	08005081 	.word	0x08005081
 8005344:	f3af 8000 	nop.w
 8005348:	f3af 8000 	nop.w
 800534c:	f3af 8000 	nop.w

08005350 <notify>:

#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)

#define TEST_QUEUES_SIZE 4

static void notify(io_queue_t *qp) {
 8005350:	4770      	bx	lr
 8005352:	bf00      	nop
 8005354:	f3af 8000 	nop.w
 8005358:	f3af 8000 	nop.w
 800535c:	f3af 8000 	nop.w

08005360 <thread1>:
static void queues1_setup(void) {

  chIQObjectInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
}

static msg_t thread1(void *p) {
 8005360:	b508      	push	{r3, lr}

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
 8005362:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 8005366:	4802      	ldr	r0, [pc, #8]	; (8005370 <thread1+0x10>)
 8005368:	f7fd f8e2 	bl	8002530 <chIQGetTimeout>
  return 0;
}
 800536c:	2000      	movs	r0, #0
 800536e:	bd08      	pop	{r3, pc}
 8005370:	20000894 	.word	0x20000894
 8005374:	f3af 8000 	nop.w
 8005378:	f3af 8000 	nop.w
 800537c:	f3af 8000 	nop.w

08005380 <queues1_setup>:
 * This test case tests sysnchronos and asynchronous operations on an
 * @p InputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues1_setup(void) {
 8005380:	b500      	push	{lr}

  chIQObjectInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 8005382:	4b06      	ldr	r3, [pc, #24]	; (800539c <queues1_setup+0x1c>)
 8005384:	4806      	ldr	r0, [pc, #24]	; (80053a0 <queues1_setup+0x20>)
 8005386:	6819      	ldr	r1, [r3, #0]
 8005388:	4b06      	ldr	r3, [pc, #24]	; (80053a4 <queues1_setup+0x24>)
 * This test case tests sysnchronos and asynchronous operations on an
 * @p InputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues1_setup(void) {
 800538a:	b083      	sub	sp, #12

  chIQObjectInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 800538c:	2200      	movs	r2, #0
 800538e:	9200      	str	r2, [sp, #0]
 8005390:	2204      	movs	r2, #4
 8005392:	f7fd f88d 	bl	80024b0 <chIQObjectInit>
}
 8005396:	b003      	add	sp, #12
 8005398:	f85d fb04 	ldr.w	pc, [sp], #4
 800539c:	080160d0 	.word	0x080160d0
 80053a0:	20000894 	.word	0x20000894
 80053a4:	08005351 	.word	0x08005351
 80053a8:	f3af 8000 	nop.w
 80053ac:	f3af 8000 	nop.w

080053b0 <thread2>:
static void queues2_setup(void) {

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
}

static msg_t thread2(void *p) {
 80053b0:	b508      	push	{r3, lr}

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
 80053b2:	2100      	movs	r1, #0
 80053b4:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 80053b8:	4802      	ldr	r0, [pc, #8]	; (80053c4 <thread2+0x14>)
 80053ba:	f7fd f941 	bl	8002640 <chOQPutTimeout>
  return 0;
}
 80053be:	2000      	movs	r0, #0
 80053c0:	bd08      	pop	{r3, pc}
 80053c2:	bf00      	nop
 80053c4:	20000870 	.word	0x20000870
 80053c8:	f3af 8000 	nop.w
 80053cc:	f3af 8000 	nop.w

080053d0 <queues2_setup>:
 * This test case tests sysnchronos and asynchronous operations on an
 * @p OutputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues2_setup(void) {
 80053d0:	b500      	push	{lr}

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 80053d2:	4b06      	ldr	r3, [pc, #24]	; (80053ec <queues2_setup+0x1c>)
 80053d4:	4806      	ldr	r0, [pc, #24]	; (80053f0 <queues2_setup+0x20>)
 80053d6:	6819      	ldr	r1, [r3, #0]
 80053d8:	4b06      	ldr	r3, [pc, #24]	; (80053f4 <queues2_setup+0x24>)
 * This test case tests sysnchronos and asynchronous operations on an
 * @p OutputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues2_setup(void) {
 80053da:	b083      	sub	sp, #12

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 80053dc:	2200      	movs	r2, #0
 80053de:	9200      	str	r2, [sp, #0]
 80053e0:	2204      	movs	r2, #4
 80053e2:	f7fd f90d 	bl	8002600 <chOQObjectInit>
}
 80053e6:	b003      	add	sp, #12
 80053e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80053ec:	080160d0 	.word	0x080160d0
 80053f0:	20000870 	.word	0x20000870
 80053f4:	08005351 	.word	0x08005351
 80053f8:	f3af 8000 	nop.w
 80053fc:	f3af 8000 	nop.w

08005400 <queues1_execute>:
  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
  return 0;
}

static void queues1_execute(void) {
 8005400:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005404:	2420      	movs	r4, #32
 8005406:	b082      	sub	sp, #8
 8005408:	f384 8811 	msr	BASEPRI, r4
 800540c:	4b90      	ldr	r3, [pc, #576]	; (8005650 <queues1_execute+0x250>)
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");
 800540e:	2001      	movs	r0, #1
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) <= 0);
 8005410:	6899      	ldr	r1, [r3, #8]
 8005412:	fab1 f181 	clz	r1, r1
 8005416:	0949      	lsrs	r1, r1, #5
 8005418:	f7fd fba2 	bl	8002b60 <_test_assert>
 800541c:	4606      	mov	r6, r0
 800541e:	b9e8      	cbnz	r0, 800545c <queues1_execute+0x5c>
 8005420:	f380 8811 	msr	BASEPRI, r0
 8005424:	f384 8811 	msr	BASEPRI, r4
 8005428:	2441      	movs	r4, #65	; 0x41

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 800542a:	4d89      	ldr	r5, [pc, #548]	; (8005650 <queues1_execute+0x250>)
 800542c:	4621      	mov	r1, r4
 800542e:	3401      	adds	r4, #1
 8005430:	4628      	mov	r0, r5
 8005432:	b2e4      	uxtb	r4, r4
 8005434:	f7fd f85c 	bl	80024f0 <chIQPutI>
  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8005438:	2c45      	cmp	r4, #69	; 0x45
 800543a:	d1f6      	bne.n	800542a <queues1_execute+0x2a>
 800543c:	2300      	movs	r3, #0
 800543e:	f383 8811 	msr	BASEPRI, r3
 8005442:	2320      	movs	r3, #32
 8005444:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0));
 8005448:	69aa      	ldr	r2, [r5, #24]
 800544a:	696b      	ldr	r3, [r5, #20]
 800544c:	429a      	cmp	r2, r3
 800544e:	d03a      	beq.n	80054c6 <queues1_execute+0xc6>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
 8005450:	4631      	mov	r1, r6
 8005452:	2002      	movs	r0, #2
 8005454:	f7fd fb84 	bl	8002b60 <_test_assert>
 8005458:	4604      	mov	r4, r0
 800545a:	b128      	cbz	r0, 8005468 <queues1_execute+0x68>
 800545c:	2300      	movs	r3, #0
 800545e:	f383 8811 	msr	BASEPRI, r3
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
  test_wait_threads();

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
}
 8005462:	b002      	add	sp, #8
 8005464:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005468:	f380 8811 	msr	BASEPRI, r0
 800546c:	2320      	movs	r3, #32
 800546e:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");
 8005472:	4877      	ldr	r0, [pc, #476]	; (8005650 <queues1_execute+0x250>)
 8005474:	4621      	mov	r1, r4
 8005476:	f7fd f83b 	bl	80024f0 <chIQPutI>
 800547a:	3004      	adds	r0, #4
 800547c:	bf14      	ite	ne
 800547e:	2100      	movne	r1, #0
 8005480:	2101      	moveq	r1, #1
 8005482:	2003      	movs	r0, #3
 8005484:	f7fd fb6c 	bl	8002b60 <_test_assert>
 8005488:	b9c0      	cbnz	r0, 80054bc <queues1_execute+0xbc>
 800548a:	f380 8811 	msr	BASEPRI, r0
 800548e:	2404      	movs	r4, #4
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {

  return chIQGetTimeout(iqp, TIME_INFINITE);
 8005490:	4d6f      	ldr	r5, [pc, #444]	; (8005650 <queues1_execute+0x250>)
 8005492:	f04f 31ff 	mov.w	r1, #4294967295
 8005496:	4628      	mov	r0, r5
 8005498:	f7fd f84a 	bl	8002530 <chIQGetTimeout>

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    test_emit_token(chIQGet(&iq));
 800549c:	b2c0      	uxtb	r0, r0
 800549e:	f7fd fb4f 	bl	8002b40 <test_emit_token>
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 80054a2:	3c01      	subs	r4, #1
 80054a4:	d1f4      	bne.n	8005490 <queues1_execute+0x90>
 80054a6:	2620      	movs	r6, #32
 80054a8:	f386 8811 	msr	BASEPRI, r6
    test_emit_token(chIQGet(&iq));
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
 80054ac:	2004      	movs	r0, #4
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) <= 0);
 80054ae:	68a9      	ldr	r1, [r5, #8]
 80054b0:	fab1 f181 	clz	r1, r1
 80054b4:	0949      	lsrs	r1, r1, #5
 80054b6:	f7fd fb53 	bl	8002b60 <_test_assert>
 80054ba:	b148      	cbz	r0, 80054d0 <queues1_execute+0xd0>
 80054bc:	f384 8811 	msr	BASEPRI, r4
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
  test_wait_threads();

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
}
 80054c0:	b002      	add	sp, #8
 80054c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0));
 80054c6:	68ae      	ldr	r6, [r5, #8]
 80054c8:	3600      	adds	r6, #0
 80054ca:	bf18      	it	ne
 80054cc:	2601      	movne	r6, #1
 80054ce:	e7bf      	b.n	8005450 <queues1_execute+0x50>
 80054d0:	f384 8811 	msr	BASEPRI, r4

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    test_emit_token(chIQGet(&iq));
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
  test_assert_sequence(5, "ABCD");
 80054d4:	2005      	movs	r0, #5
 80054d6:	495f      	ldr	r1, [pc, #380]	; (8005654 <queues1_execute+0x254>)
 80054d8:	f7fd fb5a 	bl	8002b90 <_test_assert_sequence>
 80054dc:	2800      	cmp	r0, #0
 80054de:	d1c0      	bne.n	8005462 <queues1_execute+0x62>
 80054e0:	f386 8811 	msr	BASEPRI, r6
 80054e4:	2441      	movs	r4, #65	; 0x41

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 80054e6:	4d5a      	ldr	r5, [pc, #360]	; (8005650 <queues1_execute+0x250>)
 80054e8:	4621      	mov	r1, r4
 80054ea:	3401      	adds	r4, #1
 80054ec:	4628      	mov	r0, r5
 80054ee:	b2e4      	uxtb	r4, r4
 80054f0:	f7fc fffe 	bl	80024f0 <chIQPutI>
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
  test_assert_sequence(5, "ABCD");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 80054f4:	2c45      	cmp	r4, #69	; 0x45
 80054f6:	d1f6      	bne.n	80054e6 <queues1_execute+0xe6>
 80054f8:	2300      	movs	r3, #0
 80054fa:	f383 8811 	msr	BASEPRI, r3
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();

  /* Reading the whole thing */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 80054fe:	4e56      	ldr	r6, [pc, #344]	; (8005658 <queues1_execute+0x258>)
 8005500:	2208      	movs	r2, #8
 8005502:	6871      	ldr	r1, [r6, #4]
 8005504:	4628      	mov	r0, r5
 8005506:	f7fd f83b 	bl	8002580 <chIQReadTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 800550a:	f1a0 0104 	sub.w	r1, r0, #4
 800550e:	2006      	movs	r0, #6
 8005510:	fab1 f181 	clz	r1, r1
 8005514:	0949      	lsrs	r1, r1, #5
 8005516:	f7fd fb23 	bl	8002b60 <_test_assert>
 800551a:	4604      	mov	r4, r0
 800551c:	2800      	cmp	r0, #0
 800551e:	d1a0      	bne.n	8005462 <queues1_execute+0x62>
 8005520:	2720      	movs	r7, #32
 8005522:	f387 8811 	msr	BASEPRI, r7
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");
 8005526:	2007      	movs	r0, #7
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) <= 0);
 8005528:	68a9      	ldr	r1, [r5, #8]
 800552a:	fab1 f181 	clz	r1, r1
 800552e:	0949      	lsrs	r1, r1, #5
 8005530:	f7fd fb16 	bl	8002b60 <_test_assert>
 8005534:	2800      	cmp	r0, #0
 8005536:	d1c1      	bne.n	80054bc <queues1_execute+0xbc>
 8005538:	f380 8811 	msr	BASEPRI, r0
 800553c:	f387 8811 	msr	BASEPRI, r7
 8005540:	2441      	movs	r4, #65	; 0x41

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 8005542:	4d43      	ldr	r5, [pc, #268]	; (8005650 <queues1_execute+0x250>)
 8005544:	4621      	mov	r1, r4
 8005546:	3401      	adds	r4, #1
 8005548:	4628      	mov	r0, r5
 800554a:	b2e4      	uxtb	r4, r4
 800554c:	f7fc ffd0 	bl	80024f0 <chIQPutI>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8005550:	2c45      	cmp	r4, #69	; 0x45
 8005552:	d1f6      	bne.n	8005542 <queues1_execute+0x142>
 8005554:	2300      	movs	r3, #0
 8005556:	f383 8811 	msr	BASEPRI, r3
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();

  /* Partial reads */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800555a:	6874      	ldr	r4, [r6, #4]
 800555c:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 8005658 <queues1_execute+0x258>
 8005560:	4621      	mov	r1, r4
 8005562:	4628      	mov	r0, r5
 8005564:	2202      	movs	r2, #2
 8005566:	f7fd f80b 	bl	8002580 <chIQReadTimeout>
  test_assert(8, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800556a:	f1a0 0102 	sub.w	r1, r0, #2
 800556e:	2008      	movs	r0, #8
 8005570:	fab1 f181 	clz	r1, r1
 8005574:	0949      	lsrs	r1, r1, #5
 8005576:	f7fd faf3 	bl	8002b60 <_test_assert>
 800557a:	2800      	cmp	r0, #0
 800557c:	f47f af71 	bne.w	8005462 <queues1_execute+0x62>
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8005580:	4603      	mov	r3, r0
 8005582:	4621      	mov	r1, r4
 8005584:	2202      	movs	r2, #2
 8005586:	4628      	mov	r0, r5
 8005588:	f7fc fffa 	bl	8002580 <chIQReadTimeout>
  test_assert(9, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800558c:	f1a0 0102 	sub.w	r1, r0, #2
 8005590:	2009      	movs	r0, #9
 8005592:	fab1 f181 	clz	r1, r1
 8005596:	0949      	lsrs	r1, r1, #5
 8005598:	f7fd fae2 	bl	8002b60 <_test_assert>
 800559c:	4606      	mov	r6, r0
 800559e:	2800      	cmp	r0, #0
 80055a0:	f47f af5f 	bne.w	8005462 <queues1_execute+0x62>
 80055a4:	2720      	movs	r7, #32
 80055a6:	f387 8811 	msr	BASEPRI, r7
  test_assert_lock(10, chIQIsEmptyI(&iq), "still full");
 80055aa:	200a      	movs	r0, #10
 80055ac:	68a9      	ldr	r1, [r5, #8]
 80055ae:	fab1 f181 	clz	r1, r1
 80055b2:	0949      	lsrs	r1, r1, #5
 80055b4:	f7fd fad4 	bl	8002b60 <_test_assert>
 80055b8:	4604      	mov	r4, r0
 80055ba:	b110      	cbz	r0, 80055c2 <queues1_execute+0x1c2>
 80055bc:	f386 8811 	msr	BASEPRI, r6
 80055c0:	e74f      	b.n	8005462 <queues1_execute+0x62>
 80055c2:	f380 8811 	msr	BASEPRI, r0
 80055c6:	f387 8811 	msr	BASEPRI, r7

  /* Testing reset */
  chSysLock();
  chIQPutI(&iq, 0);
 80055ca:	4621      	mov	r1, r4
 80055cc:	4628      	mov	r0, r5
 80055ce:	f7fc ff8f 	bl	80024f0 <chIQPutI>
  chIQResetI(&iq);
 80055d2:	4628      	mov	r0, r5
 80055d4:	f7fc ff7c 	bl	80024d0 <chIQResetI>
 80055d8:	f384 8811 	msr	BASEPRI, r4
 80055dc:	f387 8811 	msr	BASEPRI, r7
  chSysUnlock();
  test_assert_lock(11, chIQGetFullI(&iq) == 0, "still full");
 80055e0:	200b      	movs	r0, #11
 80055e2:	68a9      	ldr	r1, [r5, #8]
 80055e4:	fab1 f181 	clz	r1, r1
 80055e8:	0949      	lsrs	r1, r1, #5
 80055ea:	f7fd fab9 	bl	8002b60 <_test_assert>
 80055ee:	4606      	mov	r6, r0
 80055f0:	2800      	cmp	r0, #0
 80055f2:	f47f af63 	bne.w	80054bc <queues1_execute+0xbc>
 80055f6:	f380 8811 	msr	BASEPRI, r0
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80055fa:	4b18      	ldr	r3, [pc, #96]	; (800565c <queues1_execute+0x25c>)
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, NULL);
 80055fc:	f8d8 0000 	ldr.w	r0, [r8]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8005600:	699a      	ldr	r2, [r3, #24]
 8005602:	4b17      	ldr	r3, [pc, #92]	; (8005660 <queues1_execute+0x260>)
 8005604:	6892      	ldr	r2, [r2, #8]
 8005606:	9600      	str	r6, [sp, #0]
 8005608:	3201      	adds	r2, #1
 800560a:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800560e:	f7fb ff6f 	bl	80014f0 <chThdCreateStatic>
 8005612:	4b14      	ldr	r3, [pc, #80]	; (8005664 <queues1_execute+0x264>)
 8005614:	6018      	str	r0, [r3, #0]
 8005616:	f387 8811 	msr	BASEPRI, r7
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
 800561a:	200c      	movs	r0, #12
 800561c:	68a9      	ldr	r1, [r5, #8]
 800561e:	fab1 f181 	clz	r1, r1
 8005622:	0949      	lsrs	r1, r1, #5
 8005624:	f7fd fa9c 	bl	8002b60 <_test_assert>
 8005628:	2800      	cmp	r0, #0
 800562a:	d1c7      	bne.n	80055bc <queues1_execute+0x1bc>
 800562c:	f380 8811 	msr	BASEPRI, r0
  test_wait_threads();
 8005630:	f7fd fb06 	bl	8002c40 <test_wait_threads>

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
 8005634:	4628      	mov	r0, r5
 8005636:	210a      	movs	r1, #10
 8005638:	f7fc ff7a 	bl	8002530 <chIQGetTimeout>
 800563c:	1c43      	adds	r3, r0, #1
 800563e:	4259      	negs	r1, r3
 8005640:	4159      	adcs	r1, r3
 8005642:	200d      	movs	r0, #13
}
 8005644:	b002      	add	sp, #8
 8005646:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, NULL);
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
  test_wait_threads();

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
 800564a:	f7fd ba89 	b.w	8002b60 <_test_assert>
 800564e:	bf00      	nop
 8005650:	20000894 	.word	0x20000894
 8005654:	080167f4 	.word	0x080167f4
 8005658:	080160d0 	.word	0x080160d0
 800565c:	20001150 	.word	0x20001150
 8005660:	08005361 	.word	0x08005361
 8005664:	20001c84 	.word	0x20001c84
 8005668:	f3af 8000 	nop.w
 800566c:	f3af 8000 	nop.w

08005670 <queues2_execute>:
  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
  return 0;
}

static void queues2_execute(void) {
 8005670:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8005674:	2320      	movs	r3, #32
 8005676:	b083      	sub	sp, #12
 8005678:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0));
 800567c:	4b85      	ldr	r3, [pc, #532]	; (8005894 <queues2_execute+0x224>)
 800567e:	6959      	ldr	r1, [r3, #20]
 8005680:	699a      	ldr	r2, [r3, #24]
 8005682:	4291      	cmp	r1, r2
 8005684:	d05d      	beq.n	8005742 <queues2_execute+0xd2>
 8005686:	2100      	movs	r1, #0
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");
 8005688:	2001      	movs	r0, #1
 800568a:	f7fd fa69 	bl	8002b60 <_test_assert>
 800568e:	bbb8      	cbnz	r0, 8005700 <queues2_execute+0x90>
 8005690:	f380 8811 	msr	BASEPRI, r0
 8005694:	2441      	movs	r4, #65	; 0x41
 *
 * @api
 */
static inline msg_t chOQPut(output_queue_t *oqp, uint8_t b) {

  return chOQPutTimeout(oqp, b, TIME_INFINITE);
 8005696:	4d7f      	ldr	r5, [pc, #508]	; (8005894 <queues2_execute+0x224>)
 8005698:	4621      	mov	r1, r4
 800569a:	3401      	adds	r4, #1
 800569c:	4628      	mov	r0, r5
 800569e:	f04f 32ff 	mov.w	r2, #4294967295
 80056a2:	b2e4      	uxtb	r4, r4
 80056a4:	f7fc ffcc 	bl	8002640 <chOQPutTimeout>

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 80056a8:	2c45      	cmp	r4, #69	; 0x45
 80056aa:	d1f4      	bne.n	8005696 <queues2_execute+0x26>
 80056ac:	2620      	movs	r6, #32
 80056ae:	f386 8811 	msr	BASEPRI, r6
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");
 80056b2:	2002      	movs	r0, #2
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) <= 0);
 80056b4:	68a9      	ldr	r1, [r5, #8]
 80056b6:	fab1 f181 	clz	r1, r1
 80056ba:	0949      	lsrs	r1, r1, #5
 80056bc:	f7fd fa50 	bl	8002b60 <_test_assert>
 80056c0:	4607      	mov	r7, r0
 80056c2:	b9e8      	cbnz	r0, 8005700 <queues2_execute+0x90>
 80056c4:	f380 8811 	msr	BASEPRI, r0
 80056c8:	2404      	movs	r4, #4
 80056ca:	4681      	mov	r9, r0
 80056cc:	f04f 0820 	mov.w	r8, #32
 80056d0:	f386 8811 	msr	BASEPRI, r6
  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
    char c;

    chSysLock();
    c = chOQGetI(&oq);
 80056d4:	4d6f      	ldr	r5, [pc, #444]	; (8005894 <queues2_execute+0x224>)
 80056d6:	4628      	mov	r0, r5
 80056d8:	f7fc ffda 	bl	8002690 <chOQGetI>
 80056dc:	f389 8811 	msr	BASEPRI, r9
    chSysUnlock();
    test_emit_token(c);
 80056e0:	b2c0      	uxtb	r0, r0
 80056e2:	f7fd fa2d 	bl	8002b40 <test_emit_token>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
 80056e6:	3c01      	subs	r4, #1
 80056e8:	d1f0      	bne.n	80056cc <queues2_execute+0x5c>
 80056ea:	f388 8811 	msr	BASEPRI, r8
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0));
 80056ee:	696a      	ldr	r2, [r5, #20]
 80056f0:	69ab      	ldr	r3, [r5, #24]
 80056f2:	429a      	cmp	r2, r3
 80056f4:	d02a      	beq.n	800574c <queues2_execute+0xdc>
    chSysLock();
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
 80056f6:	4639      	mov	r1, r7
 80056f8:	2003      	movs	r0, #3
 80056fa:	f7fd fa31 	bl	8002b60 <_test_assert>
 80056fe:	b128      	cbz	r0, 800570c <queues2_execute+0x9c>
 8005700:	2300      	movs	r3, #0
 8005702:	f383 8811 	msr	BASEPRI, r3
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  test_assert_lock(12, chOQIsFullI(&oq), "not full");

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
}
 8005706:	b003      	add	sp, #12
 8005708:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800570c:	f380 8811 	msr	BASEPRI, r0
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
  test_assert_sequence(4, "ABCD");
 8005710:	2004      	movs	r0, #4
 8005712:	4961      	ldr	r1, [pc, #388]	; (8005898 <queues2_execute+0x228>)
 8005714:	f7fd fa3c 	bl	8002b90 <_test_assert_sequence>
 8005718:	4604      	mov	r4, r0
 800571a:	2800      	cmp	r0, #0
 800571c:	d1f3      	bne.n	8005706 <queues2_execute+0x96>
 800571e:	2620      	movs	r6, #32
 8005720:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(5, chOQGetI(&oq) == Q_EMPTY, "failed to report Q_EMPTY");
 8005724:	4d5b      	ldr	r5, [pc, #364]	; (8005894 <queues2_execute+0x224>)
 8005726:	4628      	mov	r0, r5
 8005728:	f7fc ffb2 	bl	8002690 <chOQGetI>
 800572c:	3003      	adds	r0, #3
 800572e:	bf14      	ite	ne
 8005730:	2100      	movne	r1, #0
 8005732:	2101      	moveq	r1, #1
 8005734:	2005      	movs	r0, #5
 8005736:	f7fd fa13 	bl	8002b60 <_test_assert>
 800573a:	b160      	cbz	r0, 8005756 <queues2_execute+0xe6>
 800573c:	f384 8811 	msr	BASEPRI, r4
 8005740:	e7e1      	b.n	8005706 <queues2_execute+0x96>
 8005742:	6899      	ldr	r1, [r3, #8]
 8005744:	3100      	adds	r1, #0
 8005746:	bf18      	it	ne
 8005748:	2101      	movne	r1, #1
 800574a:	e79d      	b.n	8005688 <queues2_execute+0x18>
 800574c:	68af      	ldr	r7, [r5, #8]
 800574e:	3700      	adds	r7, #0
 8005750:	bf18      	it	ne
 8005752:	2701      	movne	r7, #1
 8005754:	e7cf      	b.n	80056f6 <queues2_execute+0x86>
 8005756:	f380 8811 	msr	BASEPRI, r0

  /* Writing the whole thing */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 800575a:	4f50      	ldr	r7, [pc, #320]	; (800589c <queues2_execute+0x22c>)
 800575c:	687c      	ldr	r4, [r7, #4]
 800575e:	4603      	mov	r3, r0
 8005760:	4621      	mov	r1, r4
 8005762:	2208      	movs	r2, #8
 8005764:	4628      	mov	r0, r5
 8005766:	f7fc ffb3 	bl	80026d0 <chOQWriteTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 800576a:	f1a0 0104 	sub.w	r1, r0, #4
 800576e:	2006      	movs	r0, #6
 8005770:	fab1 f181 	clz	r1, r1
 8005774:	0949      	lsrs	r1, r1, #5
 8005776:	f7fd f9f3 	bl	8002b60 <_test_assert>
 800577a:	4680      	mov	r8, r0
 800577c:	2800      	cmp	r0, #0
 800577e:	d1c2      	bne.n	8005706 <queues2_execute+0x96>
 8005780:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(7, chOQIsFullI(&oq), "not full");
 8005784:	2007      	movs	r0, #7
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) <= 0);
 8005786:	68a9      	ldr	r1, [r5, #8]
 8005788:	fab1 f181 	clz	r1, r1
 800578c:	0949      	lsrs	r1, r1, #5
 800578e:	f7fd f9e7 	bl	8002b60 <_test_assert>
 8005792:	4681      	mov	r9, r0
 8005794:	b110      	cbz	r0, 800579c <queues2_execute+0x12c>
 8005796:	f388 8811 	msr	BASEPRI, r8
 800579a:	e7b4      	b.n	8005706 <queues2_execute+0x96>
 800579c:	f380 8811 	msr	BASEPRI, r0
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80057a0:	4b3f      	ldr	r3, [pc, #252]	; (80058a0 <queues2_execute+0x230>)
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 80057a2:	6838      	ldr	r0, [r7, #0]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80057a4:	699a      	ldr	r2, [r3, #24]
 80057a6:	4b3f      	ldr	r3, [pc, #252]	; (80058a4 <queues2_execute+0x234>)
 80057a8:	6892      	ldr	r2, [r2, #8]
 80057aa:	f8cd 9000 	str.w	r9, [sp]
 80057ae:	3201      	adds	r2, #1
 80057b0:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80057b4:	f7fb fe9c 	bl	80014f0 <chThdCreateStatic>
 80057b8:	4b3b      	ldr	r3, [pc, #236]	; (80058a8 <queues2_execute+0x238>)
 80057ba:	6018      	str	r0, [r3, #0]
 80057bc:	f386 8811 	msr	BASEPRI, r6
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeI(oqp) - chQSpaceI(oqp));
 80057c0:	68e9      	ldr	r1, [r5, #12]
 80057c2:	692b      	ldr	r3, [r5, #16]
 80057c4:	68aa      	ldr	r2, [r5, #8]
 80057c6:	1a5b      	subs	r3, r3, r1
 80057c8:	1a99      	subs	r1, r3, r2
  test_assert_lock(8, chOQGetFullI(&oq) == TEST_QUEUES_SIZE, "not empty");
 80057ca:	f1a1 0104 	sub.w	r1, r1, #4
 80057ce:	2008      	movs	r0, #8
 80057d0:	fab1 f181 	clz	r1, r1
 80057d4:	0949      	lsrs	r1, r1, #5
 80057d6:	f7fd f9c3 	bl	8002b60 <_test_assert>
 80057da:	4607      	mov	r7, r0
 80057dc:	b110      	cbz	r0, 80057e4 <queues2_execute+0x174>
 80057de:	f389 8811 	msr	BASEPRI, r9
 80057e2:	e790      	b.n	8005706 <queues2_execute+0x96>
 80057e4:	f380 8811 	msr	BASEPRI, r0
  test_wait_threads();
 80057e8:	f7fd fa2a 	bl	8002c40 <test_wait_threads>
 80057ec:	f386 8811 	msr	BASEPRI, r6

  /* Testing reset */
  chSysLock();
  chOQResetI(&oq);
 80057f0:	4628      	mov	r0, r5
 80057f2:	f7fc ff15 	bl	8002620 <chOQResetI>
 80057f6:	f387 8811 	msr	BASEPRI, r7
 80057fa:	f386 8811 	msr	BASEPRI, r6
  chSysUnlock();
  test_assert_lock(9, chOQGetFullI(&oq) == 0, "still full");
 80057fe:	f105 0108 	add.w	r1, r5, #8
 8005802:	c90e      	ldmia	r1, {r1, r2, r3}
 8005804:	1a9b      	subs	r3, r3, r2
 8005806:	1a59      	subs	r1, r3, r1
 8005808:	2009      	movs	r0, #9
 800580a:	fab1 f181 	clz	r1, r1
 800580e:	0949      	lsrs	r1, r1, #5
 8005810:	f7fd f9a6 	bl	8002b60 <_test_assert>
 8005814:	4603      	mov	r3, r0
 8005816:	b110      	cbz	r0, 800581e <queues2_execute+0x1ae>
 8005818:	f387 8811 	msr	BASEPRI, r7
 800581c:	e773      	b.n	8005706 <queues2_execute+0x96>
 800581e:	f380 8811 	msr	BASEPRI, r0

  /* Partial writes */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8005822:	2202      	movs	r2, #2
 8005824:	4621      	mov	r1, r4
 8005826:	4628      	mov	r0, r5
 8005828:	f7fc ff52 	bl	80026d0 <chOQWriteTimeout>
  test_assert(10, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800582c:	3802      	subs	r0, #2
 800582e:	4241      	negs	r1, r0
 8005830:	4141      	adcs	r1, r0
 8005832:	200a      	movs	r0, #10
 8005834:	f7fd f994 	bl	8002b60 <_test_assert>
 8005838:	4603      	mov	r3, r0
 800583a:	2800      	cmp	r0, #0
 800583c:	f47f af63 	bne.w	8005706 <queues2_execute+0x96>
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8005840:	4621      	mov	r1, r4
 8005842:	2202      	movs	r2, #2
 8005844:	4628      	mov	r0, r5
 8005846:	f7fc ff43 	bl	80026d0 <chOQWriteTimeout>
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800584a:	1e82      	subs	r2, r0, #2
 800584c:	4251      	negs	r1, r2
 800584e:	4151      	adcs	r1, r2
 8005850:	200b      	movs	r0, #11
 8005852:	f7fd f985 	bl	8002b60 <_test_assert>
 8005856:	2800      	cmp	r0, #0
 8005858:	f47f af55 	bne.w	8005706 <queues2_execute+0x96>
 800585c:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(12, chOQIsFullI(&oq), "not full");
 8005860:	200c      	movs	r0, #12
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) <= 0);
 8005862:	68a9      	ldr	r1, [r5, #8]
 8005864:	fab1 f181 	clz	r1, r1
 8005868:	0949      	lsrs	r1, r1, #5
 800586a:	f7fd f979 	bl	8002b60 <_test_assert>
 800586e:	2800      	cmp	r0, #0
 8005870:	f47f af46 	bne.w	8005700 <queues2_execute+0x90>
 8005874:	2100      	movs	r1, #0
 8005876:	f381 8811 	msr	BASEPRI, r1

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
 800587a:	220a      	movs	r2, #10
 800587c:	4805      	ldr	r0, [pc, #20]	; (8005894 <queues2_execute+0x224>)
 800587e:	f7fc fedf 	bl	8002640 <chOQPutTimeout>
 8005882:	1c43      	adds	r3, r0, #1
 8005884:	4259      	negs	r1, r3
 8005886:	4159      	adcs	r1, r3
 8005888:	200d      	movs	r0, #13
}
 800588a:	b003      	add	sp, #12
 800588c:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  test_assert_lock(12, chOQIsFullI(&oq), "not full");

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
 8005890:	f7fd b966 	b.w	8002b60 <_test_assert>
 8005894:	20000870 	.word	0x20000870
 8005898:	080167f4 	.word	0x080167f4
 800589c:	080160d0 	.word	0x080160d0
 80058a0:	20001150 	.word	0x20001150
 80058a4:	080053b1 	.word	0x080053b1
 80058a8:	20001c84 	.word	0x20001c84
 80058ac:	f3af 8000 	nop.w

080058b0 <thread1>:
#endif

static msg_t thread1(void *p) {

  return (msg_t)p;
}
 80058b0:	4770      	bx	lr
 80058b2:	bf00      	nop
 80058b4:	f3af 8000 	nop.w
 80058b8:	f3af 8000 	nop.w
 80058bc:	f3af 8000 	nop.w

080058c0 <tmo>:
 * A virtual timer is set and immediately reset into a continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}
 80058c0:	4770      	bx	lr
 80058c2:	bf00      	nop
 80058c4:	f3af 8000 	nop.w
 80058c8:	f3af 8000 	nop.w
 80058cc:	f3af 8000 	nop.w

080058d0 <bmk13_execute>:
 *
 * <h2>Description</h2>
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {
 80058d0:	b510      	push	{r4, lr}

  test_print("--- System: ");
 80058d2:	482f      	ldr	r0, [pc, #188]	; (8005990 <bmk13_execute+0xc0>)
  test_printn(sizeof(ch_system_t));
  test_println(" bytes");
 80058d4:	4c2f      	ldr	r4, [pc, #188]	; (8005994 <bmk13_execute+0xc4>)
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {

  test_print("--- System: ");
 80058d6:	f7fd f903 	bl	8002ae0 <test_print>
  test_printn(sizeof(ch_system_t));
 80058da:	f44f 70ec 	mov.w	r0, #472	; 0x1d8
 80058de:	f7fd f8cf 	bl	8002a80 <test_printn>
  test_println(" bytes");
 80058e2:	4620      	mov	r0, r4
 80058e4:	f7fd f90c 	bl	8002b00 <test_println>
  test_print("--- Thread: ");
 80058e8:	482b      	ldr	r0, [pc, #172]	; (8005998 <bmk13_execute+0xc8>)
 80058ea:	f7fd f8f9 	bl	8002ae0 <test_print>
  test_printn(sizeof(thread_t));
 80058ee:	2044      	movs	r0, #68	; 0x44
 80058f0:	f7fd f8c6 	bl	8002a80 <test_printn>
  test_println(" bytes");
 80058f4:	4620      	mov	r0, r4
 80058f6:	f7fd f903 	bl	8002b00 <test_println>
  test_print("--- Timer : ");
 80058fa:	4828      	ldr	r0, [pc, #160]	; (800599c <bmk13_execute+0xcc>)
 80058fc:	f7fd f8f0 	bl	8002ae0 <test_print>
  test_printn(sizeof(virtual_timer_t));
 8005900:	2014      	movs	r0, #20
 8005902:	f7fd f8bd 	bl	8002a80 <test_printn>
  test_println(" bytes");
 8005906:	4620      	mov	r0, r4
 8005908:	f7fd f8fa 	bl	8002b00 <test_println>
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
  test_print("--- Semaph: ");
 800590c:	4824      	ldr	r0, [pc, #144]	; (80059a0 <bmk13_execute+0xd0>)
 800590e:	f7fd f8e7 	bl	8002ae0 <test_print>
  test_printn(sizeof(semaphore_t));
 8005912:	200c      	movs	r0, #12
 8005914:	f7fd f8b4 	bl	8002a80 <test_printn>
  test_println(" bytes");
 8005918:	4620      	mov	r0, r4
 800591a:	f7fd f8f1 	bl	8002b00 <test_println>
#endif
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
  test_print("--- EventS: ");
 800591e:	4821      	ldr	r0, [pc, #132]	; (80059a4 <bmk13_execute+0xd4>)
 8005920:	f7fd f8de 	bl	8002ae0 <test_print>
  test_printn(sizeof(event_source_t));
 8005924:	2004      	movs	r0, #4
 8005926:	f7fd f8ab 	bl	8002a80 <test_printn>
  test_println(" bytes");
 800592a:	4620      	mov	r0, r4
 800592c:	f7fd f8e8 	bl	8002b00 <test_println>
  test_print("--- EventL: ");
 8005930:	481d      	ldr	r0, [pc, #116]	; (80059a8 <bmk13_execute+0xd8>)
 8005932:	f7fd f8d5 	bl	8002ae0 <test_print>
  test_printn(sizeof(event_listener_t));
 8005936:	2014      	movs	r0, #20
 8005938:	f7fd f8a2 	bl	8002a80 <test_printn>
  test_println(" bytes");
 800593c:	4620      	mov	r0, r4
 800593e:	f7fd f8df 	bl	8002b00 <test_println>
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  test_print("--- Mutex : ");
 8005942:	481a      	ldr	r0, [pc, #104]	; (80059ac <bmk13_execute+0xdc>)
 8005944:	f7fd f8cc 	bl	8002ae0 <test_print>
  test_printn(sizeof(mutex_t));
 8005948:	2010      	movs	r0, #16
 800594a:	f7fd f899 	bl	8002a80 <test_printn>
  test_println(" bytes");
 800594e:	4620      	mov	r0, r4
 8005950:	f7fd f8d6 	bl	8002b00 <test_println>
#endif
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
  test_print("--- CondV.: ");
 8005954:	4816      	ldr	r0, [pc, #88]	; (80059b0 <bmk13_execute+0xe0>)
 8005956:	f7fd f8c3 	bl	8002ae0 <test_print>
  test_printn(sizeof(condition_variable_t));
 800595a:	2008      	movs	r0, #8
 800595c:	f7fd f890 	bl	8002a80 <test_printn>
  test_println(" bytes");
 8005960:	4620      	mov	r0, r4
 8005962:	f7fd f8cd 	bl	8002b00 <test_println>
#endif
#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)
  test_print("--- Queue : ");
 8005966:	4813      	ldr	r0, [pc, #76]	; (80059b4 <bmk13_execute+0xe4>)
 8005968:	f7fd f8ba 	bl	8002ae0 <test_print>
  test_printn(sizeof(io_queue_t));
 800596c:	2024      	movs	r0, #36	; 0x24
 800596e:	f7fd f887 	bl	8002a80 <test_printn>
  test_println(" bytes");
 8005972:	4620      	mov	r0, r4
 8005974:	f7fd f8c4 	bl	8002b00 <test_println>
#endif
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
 8005978:	480f      	ldr	r0, [pc, #60]	; (80059b8 <bmk13_execute+0xe8>)
 800597a:	f7fd f8b1 	bl	8002ae0 <test_print>
  test_printn(sizeof(mailbox_t));
 800597e:	2028      	movs	r0, #40	; 0x28
 8005980:	f7fd f87e 	bl	8002a80 <test_printn>
  test_println(" bytes");
 8005984:	4620      	mov	r0, r4
#endif
}
 8005986:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_println(" bytes");
#endif
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
  test_printn(sizeof(mailbox_t));
  test_println(" bytes");
 800598a:	f7fd b8b9 	b.w	8002b00 <test_println>
 800598e:	bf00      	nop
 8005990:	08016980 	.word	0x08016980
 8005994:	08016990 	.word	0x08016990
 8005998:	08016998 	.word	0x08016998
 800599c:	080169a8 	.word	0x080169a8
 80059a0:	080169b8 	.word	0x080169b8
 80059a4:	080169c8 	.word	0x080169c8
 80059a8:	080169d8 	.word	0x080169d8
 80059ac:	080169e8 	.word	0x080169e8
 80059b0:	080169f8 	.word	0x080169f8
 80059b4:	08016a08 	.word	0x08016a08
 80059b8:	08016a18 	.word	0x08016a18
 80059bc:	f3af 8000 	nop.w

080059c0 <thread2>:

  return (msg_t)p;
}

#if CH_CFG_USE_MESSAGES || defined(__DOXYGEN__)
static msg_t thread2(void *p) {
 80059c0:	b510      	push	{r4, lr}
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 80059c2:	f7fc fc1d 	bl	8002200 <chMsgWait>
 80059c6:	6b04      	ldr	r4, [r0, #48]	; 0x30
    msg = chMsgGet(tp);
    chMsgRelease(tp, msg);
 80059c8:	4621      	mov	r1, r4
 80059ca:	f7fc fc39 	bl	8002240 <chMsgRelease>
  } while (msg);
 80059ce:	2c00      	cmp	r4, #0
 80059d0:	d1f7      	bne.n	80059c2 <thread2+0x2>
  return 0;
}
 80059d2:	4620      	mov	r0, r4
 80059d4:	bd10      	pop	{r4, pc}
 80059d6:	bf00      	nop
 80059d8:	f3af 8000 	nop.w
 80059dc:	f3af 8000 	nop.w

080059e0 <bmk6_execute>:
 * terminate.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk6_execute(void) {
 80059e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80059e4:	4b14      	ldr	r3, [pc, #80]	; (8005a38 <bmk6_execute+0x58>)

  uint32_t n = 0;
  void *wap = wa[0];
 80059e6:	4a15      	ldr	r2, [pc, #84]	; (8005a3c <bmk6_execute+0x5c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80059e8:	699b      	ldr	r3, [r3, #24]
 80059ea:	f8d2 8000 	ldr.w	r8, [r2]
  tprio_t prio = chThdGetPriorityX() + 1;
 80059ee:	689d      	ldr	r5, [r3, #8]
 80059f0:	4f13      	ldr	r7, [pc, #76]	; (8005a40 <bmk6_execute+0x60>)
 * terminate.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk6_execute(void) {
 80059f2:	b082      	sub	sp, #8

  uint32_t n = 0;
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() + 1;
  test_wait_tick();
 80059f4:	f7fd f93c 	bl	8002c70 <test_wait_tick>
  test_start_timer(1000);
 80059f8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80059fc:	f7fd f948 	bl	8002c90 <test_start_timer>
 * a second of continuous operations.
 */

static void bmk6_execute(void) {

  uint32_t n = 0;
 8005a00:	2400      	movs	r4, #0
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() + 1;
 8005a02:	3501      	adds	r5, #1
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
 8005a04:	4626      	mov	r6, r4
 8005a06:	4b0f      	ldr	r3, [pc, #60]	; (8005a44 <bmk6_execute+0x64>)
 8005a08:	9600      	str	r6, [sp, #0]
 8005a0a:	4640      	mov	r0, r8
 8005a0c:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005a10:	462a      	mov	r2, r5
 8005a12:	f7fb fd6d 	bl	80014f0 <chThdCreateStatic>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8005a16:	783b      	ldrb	r3, [r7, #0]
  tprio_t prio = chThdGetPriorityX() + 1;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
    n++;
 8005a18:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8005a1a:	2b00      	cmp	r3, #0
 8005a1c:	d0f3      	beq.n	8005a06 <bmk6_execute+0x26>
  test_print("--- Score : ");
 8005a1e:	480a      	ldr	r0, [pc, #40]	; (8005a48 <bmk6_execute+0x68>)
 8005a20:	f7fd f85e 	bl	8002ae0 <test_print>
  test_printn(n);
 8005a24:	4620      	mov	r0, r4
 8005a26:	f7fd f82b 	bl	8002a80 <test_printn>
  test_println(" threads/S");
 8005a2a:	4808      	ldr	r0, [pc, #32]	; (8005a4c <bmk6_execute+0x6c>)
}
 8005a2c:	b002      	add	sp, #8
 8005a2e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n);
  test_println(" threads/S");
 8005a32:	f7fd b865 	b.w	8002b00 <test_println>
 8005a36:	bf00      	nop
 8005a38:	20001150 	.word	0x20001150
 8005a3c:	080160d0 	.word	0x080160d0
 8005a40:	20001c65 	.word	0x20001c65
 8005a44:	080058b1 	.word	0x080058b1
 8005a48:	08016a28 	.word	0x08016a28
 8005a4c:	08016a38 	.word	0x08016a38

08005a50 <msg_loop_test>:
}

#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {
 8005a50:	b570      	push	{r4, r5, r6, lr}
 8005a52:	4605      	mov	r5, r0

  uint32_t n = 0;
  test_wait_tick();
 8005a54:	f7fd f90c 	bl	8002c70 <test_wait_tick>
  test_start_timer(1000);
 8005a58:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8005a5c:	f7fd f918 	bl	8002c90 <test_start_timer>
 8005a60:	4e07      	ldr	r6, [pc, #28]	; (8005a80 <msg_loop_test+0x30>)
#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {

  uint32_t n = 0;
 8005a62:	2400      	movs	r4, #0
  test_wait_tick();
  test_start_timer(1000);
  do {
    (void)chMsgSend(tp, 1);
 8005a64:	4628      	mov	r0, r5
 8005a66:	2101      	movs	r1, #1
 8005a68:	f7fc fbaa 	bl	80021c0 <chMsgSend>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8005a6c:	7833      	ldrb	r3, [r6, #0]
  uint32_t n = 0;
  test_wait_tick();
  test_start_timer(1000);
  do {
    (void)chMsgSend(tp, 1);
    n++;
 8005a6e:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8005a70:	2b00      	cmp	r3, #0
 8005a72:	d0f7      	beq.n	8005a64 <msg_loop_test+0x14>
  (void)chMsgSend(tp, 0);
 8005a74:	4628      	mov	r0, r5
 8005a76:	2100      	movs	r1, #0
 8005a78:	f7fc fba2 	bl	80021c0 <chMsgSend>
  return n;
}
 8005a7c:	4620      	mov	r0, r4
 8005a7e:	bd70      	pop	{r4, r5, r6, pc}
 8005a80:	20001c65 	.word	0x20001c65
 8005a84:	f3af 8000 	nop.w
 8005a88:	f3af 8000 	nop.w
 8005a8c:	f3af 8000 	nop.w

08005a90 <bmk1_execute>:
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
 8005a90:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8005a92:	4b13      	ldr	r3, [pc, #76]	; (8005ae0 <bmk1_execute+0x50>)
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 8005a94:	4a13      	ldr	r2, [pc, #76]	; (8005ae4 <bmk1_execute+0x54>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8005a96:	699b      	ldr	r3, [r3, #24]
 8005a98:	6810      	ldr	r0, [r2, #0]
 8005a9a:	689a      	ldr	r2, [r3, #8]
 8005a9c:	4b12      	ldr	r3, [pc, #72]	; (8005ae8 <bmk1_execute+0x58>)
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
 8005a9e:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 8005aa0:	2100      	movs	r1, #0
 8005aa2:	3a01      	subs	r2, #1
 8005aa4:	9100      	str	r1, [sp, #0]
 8005aa6:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005aaa:	f7fb fd21 	bl	80014f0 <chThdCreateStatic>
 8005aae:	4b0f      	ldr	r3, [pc, #60]	; (8005aec <bmk1_execute+0x5c>)
 8005ab0:	6018      	str	r0, [r3, #0]
  n = msg_loop_test(threads[0]);
 8005ab2:	f7ff ffcd 	bl	8005a50 <msg_loop_test>
 8005ab6:	4604      	mov	r4, r0
  test_wait_threads();
 8005ab8:	f7fd f8c2 	bl	8002c40 <test_wait_threads>
  test_print("--- Score : ");
 8005abc:	480c      	ldr	r0, [pc, #48]	; (8005af0 <bmk1_execute+0x60>)
 8005abe:	f7fd f80f 	bl	8002ae0 <test_print>
  test_printn(n);
 8005ac2:	4620      	mov	r0, r4
 8005ac4:	f7fc ffdc 	bl	8002a80 <test_printn>
  test_print(" msgs/S, ");
 8005ac8:	480a      	ldr	r0, [pc, #40]	; (8005af4 <bmk1_execute+0x64>)
 8005aca:	f7fd f809 	bl	8002ae0 <test_print>
  test_printn(n << 1);
 8005ace:	0060      	lsls	r0, r4, #1
 8005ad0:	f7fc ffd6 	bl	8002a80 <test_printn>
  test_println(" ctxswc/S");
 8005ad4:	4808      	ldr	r0, [pc, #32]	; (8005af8 <bmk1_execute+0x68>)
}
 8005ad6:	b002      	add	sp, #8
 8005ad8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n);
  test_print(" msgs/S, ");
  test_printn(n << 1);
  test_println(" ctxswc/S");
 8005adc:	f7fd b810 	b.w	8002b00 <test_println>
 8005ae0:	20001150 	.word	0x20001150
 8005ae4:	080160d0 	.word	0x080160d0
 8005ae8:	080059c1 	.word	0x080059c1
 8005aec:	20001c84 	.word	0x20001c84
 8005af0:	08016a28 	.word	0x08016a28
 8005af4:	08016a44 	.word	0x08016a44
 8005af8:	08016a50 	.word	0x08016a50
 8005afc:	f3af 8000 	nop.w

08005b00 <bmk2_execute>:
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
 8005b00:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8005b02:	4b13      	ldr	r3, [pc, #76]	; (8005b50 <bmk2_execute+0x50>)
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8005b04:	4a13      	ldr	r2, [pc, #76]	; (8005b54 <bmk2_execute+0x54>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8005b06:	699b      	ldr	r3, [r3, #24]
 8005b08:	6810      	ldr	r0, [r2, #0]
 8005b0a:	689a      	ldr	r2, [r3, #8]
 8005b0c:	4b12      	ldr	r3, [pc, #72]	; (8005b58 <bmk2_execute+0x58>)
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
 8005b0e:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8005b10:	2100      	movs	r1, #0
 8005b12:	3201      	adds	r2, #1
 8005b14:	9100      	str	r1, [sp, #0]
 8005b16:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005b1a:	f7fb fce9 	bl	80014f0 <chThdCreateStatic>
 8005b1e:	4b0f      	ldr	r3, [pc, #60]	; (8005b5c <bmk2_execute+0x5c>)
 8005b20:	6018      	str	r0, [r3, #0]
  n = msg_loop_test(threads[0]);
 8005b22:	f7ff ff95 	bl	8005a50 <msg_loop_test>
 8005b26:	4604      	mov	r4, r0
  test_wait_threads();
 8005b28:	f7fd f88a 	bl	8002c40 <test_wait_threads>
  test_print("--- Score : ");
 8005b2c:	480c      	ldr	r0, [pc, #48]	; (8005b60 <bmk2_execute+0x60>)
 8005b2e:	f7fc ffd7 	bl	8002ae0 <test_print>
  test_printn(n);
 8005b32:	4620      	mov	r0, r4
 8005b34:	f7fc ffa4 	bl	8002a80 <test_printn>
  test_print(" msgs/S, ");
 8005b38:	480a      	ldr	r0, [pc, #40]	; (8005b64 <bmk2_execute+0x64>)
 8005b3a:	f7fc ffd1 	bl	8002ae0 <test_print>
  test_printn(n << 1);
 8005b3e:	0060      	lsls	r0, r4, #1
 8005b40:	f7fc ff9e 	bl	8002a80 <test_printn>
  test_println(" ctxswc/S");
 8005b44:	4808      	ldr	r0, [pc, #32]	; (8005b68 <bmk2_execute+0x68>)
}
 8005b46:	b002      	add	sp, #8
 8005b48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n);
  test_print(" msgs/S, ");
  test_printn(n << 1);
  test_println(" ctxswc/S");
 8005b4c:	f7fc bfd8 	b.w	8002b00 <test_println>
 8005b50:	20001150 	.word	0x20001150
 8005b54:	080160d0 	.word	0x080160d0
 8005b58:	080059c1 	.word	0x080059c1
 8005b5c:	20001c84 	.word	0x20001c84
 8005b60:	08016a28 	.word	0x08016a28
 8005b64:	08016a44 	.word	0x08016a44
 8005b68:	08016a50 	.word	0x08016a50
 8005b6c:	f3af 8000 	nop.w

08005b70 <bmk3_execute>:
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 8005b70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8005b74:	4f2c      	ldr	r7, [pc, #176]	; (8005c28 <bmk3_execute+0xb8>)
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8005b76:	4e2d      	ldr	r6, [pc, #180]	; (8005c2c <bmk3_execute+0xbc>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8005b78:	69bb      	ldr	r3, [r7, #24]
 8005b7a:	6830      	ldr	r0, [r6, #0]
 8005b7c:	689a      	ldr	r2, [r3, #8]
 8005b7e:	4b2c      	ldr	r3, [pc, #176]	; (8005c30 <bmk3_execute+0xc0>)
 8005b80:	4c2c      	ldr	r4, [pc, #176]	; (8005c34 <bmk3_execute+0xc4>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8005b82:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 8005c44 <bmk3_execute+0xd4>
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 8005b86:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8005b88:	2500      	movs	r5, #0
 8005b8a:	3201      	adds	r2, #1
 8005b8c:	9500      	str	r5, [sp, #0]
 8005b8e:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005b92:	f7fb fcad 	bl	80014f0 <chThdCreateStatic>
 8005b96:	69ba      	ldr	r2, [r7, #24]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8005b98:	6873      	ldr	r3, [r6, #4]
 8005b9a:	6892      	ldr	r2, [r2, #8]
 */

static void bmk3_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8005b9c:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8005b9e:	3a02      	subs	r2, #2
 8005ba0:	9500      	str	r5, [sp, #0]
 8005ba2:	4618      	mov	r0, r3
 8005ba4:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005ba8:	4643      	mov	r3, r8
 8005baa:	f7fb fca1 	bl	80014f0 <chThdCreateStatic>
 8005bae:	69ba      	ldr	r2, [r7, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 8005bb0:	68b3      	ldr	r3, [r6, #8]
 8005bb2:	6892      	ldr	r2, [r2, #8]

static void bmk3_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8005bb4:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 8005bb6:	3a03      	subs	r2, #3
 8005bb8:	9500      	str	r5, [sp, #0]
 8005bba:	4618      	mov	r0, r3
 8005bbc:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005bc0:	4643      	mov	r3, r8
 8005bc2:	f7fb fc95 	bl	80014f0 <chThdCreateStatic>
 8005bc6:	69ba      	ldr	r2, [r7, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 8005bc8:	68f3      	ldr	r3, [r6, #12]
 8005bca:	6892      	ldr	r2, [r2, #8]
static void bmk3_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 8005bcc:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 8005bce:	3a04      	subs	r2, #4
 8005bd0:	9500      	str	r5, [sp, #0]
 8005bd2:	4618      	mov	r0, r3
 8005bd4:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005bd8:	4643      	mov	r3, r8
 8005bda:	f7fb fc89 	bl	80014f0 <chThdCreateStatic>
 8005bde:	69ba      	ldr	r2, [r7, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
 8005be0:	6933      	ldr	r3, [r6, #16]
 8005be2:	6892      	ldr	r2, [r2, #8]
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 8005be4:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
 8005be6:	3a05      	subs	r2, #5
 8005be8:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005bec:	4618      	mov	r0, r3
 8005bee:	9500      	str	r5, [sp, #0]
 8005bf0:	4643      	mov	r3, r8
 8005bf2:	f7fb fc7d 	bl	80014f0 <chThdCreateStatic>
 8005bf6:	6120      	str	r0, [r4, #16]
  n = msg_loop_test(threads[0]);
 8005bf8:	6820      	ldr	r0, [r4, #0]
 8005bfa:	f7ff ff29 	bl	8005a50 <msg_loop_test>
 8005bfe:	4604      	mov	r4, r0
  test_wait_threads();
 8005c00:	f7fd f81e 	bl	8002c40 <test_wait_threads>
  test_print("--- Score : ");
 8005c04:	480c      	ldr	r0, [pc, #48]	; (8005c38 <bmk3_execute+0xc8>)
 8005c06:	f7fc ff6b 	bl	8002ae0 <test_print>
  test_printn(n);
 8005c0a:	4620      	mov	r0, r4
 8005c0c:	f7fc ff38 	bl	8002a80 <test_printn>
  test_print(" msgs/S, ");
 8005c10:	480a      	ldr	r0, [pc, #40]	; (8005c3c <bmk3_execute+0xcc>)
 8005c12:	f7fc ff65 	bl	8002ae0 <test_print>
  test_printn(n << 1);
 8005c16:	0060      	lsls	r0, r4, #1
 8005c18:	f7fc ff32 	bl	8002a80 <test_printn>
  test_println(" ctxswc/S");
 8005c1c:	4808      	ldr	r0, [pc, #32]	; (8005c40 <bmk3_execute+0xd0>)
}
 8005c1e:	b002      	add	sp, #8
 8005c20:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n);
  test_print(" msgs/S, ");
  test_printn(n << 1);
  test_println(" ctxswc/S");
 8005c24:	f7fc bf6c 	b.w	8002b00 <test_println>
 8005c28:	20001150 	.word	0x20001150
 8005c2c:	080160d0 	.word	0x080160d0
 8005c30:	080059c1 	.word	0x080059c1
 8005c34:	20001c84 	.word	0x20001c84
 8005c38:	08016a28 	.word	0x08016a28
 8005c3c:	08016a44 	.word	0x08016a44
 8005c40:	08016a50 	.word	0x08016a50
 8005c44:	080058b1 	.word	0x080058b1
 8005c48:	f3af 8000 	nop.w
 8005c4c:	f3af 8000 	nop.w

08005c50 <thread4>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8005c50:	4a07      	ldr	r2, [pc, #28]	; (8005c70 <thread4+0x20>)
 * the thread is awakened as fast is possible by the tester thread.<br>
 * The Context Switch performance is calculated by measuring the number of
 * iterations after a second of continuous operations.
 */

msg_t thread4(void *p) {
 8005c52:	b510      	push	{r4, lr}
 8005c54:	2320      	movs	r3, #32
 8005c56:	6994      	ldr	r4, [r2, #24]
 8005c58:	f383 8811 	msr	BASEPRI, r3
  thread_t *self = chThdGetSelfX();

  (void)p;
  chSysLock();
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 8005c5c:	2003      	movs	r0, #3
 8005c5e:	f7fb faa7 	bl	80011b0 <chSchGoSleepS>
    msg = self->p_u.rdymsg;
  } while (msg == MSG_OK);
 8005c62:	6a23      	ldr	r3, [r4, #32]
 8005c64:	2b00      	cmp	r3, #0
 8005c66:	d0f9      	beq.n	8005c5c <thread4+0xc>
 8005c68:	2000      	movs	r0, #0
 8005c6a:	f380 8811 	msr	BASEPRI, r0
  chSysUnlock();
  return 0;
}
 8005c6e:	bd10      	pop	{r4, pc}
 8005c70:	20001150 	.word	0x20001150
 8005c74:	f3af 8000 	nop.w
 8005c78:	f3af 8000 	nop.w
 8005c7c:	f3af 8000 	nop.w

08005c80 <bmk4_execute>:

static void bmk4_execute(void) {
 8005c80:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005c84:	4b26      	ldr	r3, [pc, #152]	; (8005d20 <bmk4_execute+0xa0>)
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8005c86:	4a27      	ldr	r2, [pc, #156]	; (8005d24 <bmk4_execute+0xa4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8005c88:	699b      	ldr	r3, [r3, #24]
 8005c8a:	6810      	ldr	r0, [r2, #0]
 8005c8c:	689a      	ldr	r2, [r3, #8]
 8005c8e:	4b26      	ldr	r3, [pc, #152]	; (8005d28 <bmk4_execute+0xa8>)
 8005c90:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 8005d38 <bmk4_execute+0xb8>
  } while (msg == MSG_OK);
  chSysUnlock();
  return 0;
}

static void bmk4_execute(void) {
 8005c94:	b082      	sub	sp, #8
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8005c96:	2500      	movs	r5, #0
 8005c98:	3201      	adds	r2, #1
 8005c9a:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005c9e:	9500      	str	r5, [sp, #0]
 8005ca0:	f7fb fc26 	bl	80014f0 <chThdCreateStatic>
 8005ca4:	4b21      	ldr	r3, [pc, #132]	; (8005d2c <bmk4_execute+0xac>)
 8005ca6:	4604      	mov	r4, r0
 8005ca8:	6018      	str	r0, [r3, #0]
                                      thread4, NULL);
  n = 0;
  test_wait_tick();
 8005caa:	f7fc ffe1 	bl	8002c70 <test_wait_tick>
  test_start_timer(1000);
 8005cae:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8005cb2:	f7fc ffed 	bl	8002c90 <test_start_timer>
  do {
    chSysLock();
    chSchWakeupS(tp, MSG_OK);
 8005cb6:	46aa      	mov	sl, r5
 8005cb8:	f04f 0820 	mov.w	r8, #32
 8005cbc:	2720      	movs	r7, #32
 8005cbe:	f388 8811 	msr	BASEPRI, r8
 8005cc2:	2100      	movs	r1, #0
 8005cc4:	4620      	mov	r0, r4
 8005cc6:	f7fb fab3 	bl	8001230 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8005cca:	4620      	mov	r0, r4
 8005ccc:	2100      	movs	r1, #0
 8005cce:	f7fb faaf 	bl	8001230 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8005cd2:	4620      	mov	r0, r4
 8005cd4:	2100      	movs	r1, #0
 8005cd6:	f7fb faab 	bl	8001230 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8005cda:	4620      	mov	r0, r4
 8005cdc:	2100      	movs	r1, #0
 8005cde:	f7fb faa7 	bl	8001230 <chSchWakeupS>
 8005ce2:	2600      	movs	r6, #0
 8005ce4:	f38a 8811 	msr	BASEPRI, sl
    chSysUnlock();
    n += 4;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8005ce8:	f899 3000 	ldrb.w	r3, [r9]
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSysUnlock();
    n += 4;
 8005cec:	3504      	adds	r5, #4
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8005cee:	2b00      	cmp	r3, #0
 8005cf0:	d0e4      	beq.n	8005cbc <bmk4_execute+0x3c>
 8005cf2:	f387 8811 	msr	BASEPRI, r7
  chSysLock();
  chSchWakeupS(tp, MSG_TIMEOUT);
 8005cf6:	f04f 31ff 	mov.w	r1, #4294967295
 8005cfa:	4620      	mov	r0, r4
 8005cfc:	f7fb fa98 	bl	8001230 <chSchWakeupS>
 8005d00:	f386 8811 	msr	BASEPRI, r6
  chSysUnlock();

  test_wait_threads();
 8005d04:	f7fc ff9c 	bl	8002c40 <test_wait_threads>
  test_print("--- Score : ");
 8005d08:	4809      	ldr	r0, [pc, #36]	; (8005d30 <bmk4_execute+0xb0>)
 8005d0a:	f7fc fee9 	bl	8002ae0 <test_print>
  test_printn(n * 2);
 8005d0e:	0068      	lsls	r0, r5, #1
 8005d10:	f7fc feb6 	bl	8002a80 <test_printn>
  test_println(" ctxswc/S");
 8005d14:	4807      	ldr	r0, [pc, #28]	; (8005d34 <bmk4_execute+0xb4>)
}
 8005d16:	b002      	add	sp, #8
 8005d18:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  chSysUnlock();

  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n * 2);
  test_println(" ctxswc/S");
 8005d1c:	f7fc bef0 	b.w	8002b00 <test_println>
 8005d20:	20001150 	.word	0x20001150
 8005d24:	080160d0 	.word	0x080160d0
 8005d28:	08005c51 	.word	0x08005c51
 8005d2c:	20001c84 	.word	0x20001c84
 8005d30:	08016a28 	.word	0x08016a28
 8005d34:	08016a50 	.word	0x08016a50
 8005d38:	20001c65 	.word	0x20001c65
 8005d3c:	f3af 8000 	nop.w

08005d40 <bmk5_execute>:
 * in each iteration.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk5_execute(void) {
 8005d40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8005d44:	4b15      	ldr	r3, [pc, #84]	; (8005d9c <bmk5_execute+0x5c>)

  uint32_t n = 0;
  void *wap = wa[0];
 8005d46:	4a16      	ldr	r2, [pc, #88]	; (8005da0 <bmk5_execute+0x60>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8005d48:	699b      	ldr	r3, [r3, #24]
 8005d4a:	f8d2 8000 	ldr.w	r8, [r2]
  tprio_t prio = chThdGetPriorityX() - 1;
 8005d4e:	689d      	ldr	r5, [r3, #8]
 8005d50:	4f14      	ldr	r7, [pc, #80]	; (8005da4 <bmk5_execute+0x64>)
 * in each iteration.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk5_execute(void) {
 8005d52:	b082      	sub	sp, #8

  uint32_t n = 0;
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() - 1;
  test_wait_tick();
 8005d54:	f7fc ff8c 	bl	8002c70 <test_wait_tick>
  test_start_timer(1000);
 8005d58:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8005d5c:	f7fc ff98 	bl	8002c90 <test_start_timer>
 * a second of continuous operations.
 */

static void bmk5_execute(void) {

  uint32_t n = 0;
 8005d60:	2400      	movs	r4, #0
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() - 1;
 8005d62:	3d01      	subs	r5, #1
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
 8005d64:	4626      	mov	r6, r4
 8005d66:	4b10      	ldr	r3, [pc, #64]	; (8005da8 <bmk5_execute+0x68>)
 8005d68:	9600      	str	r6, [sp, #0]
 8005d6a:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005d6e:	462a      	mov	r2, r5
 8005d70:	4640      	mov	r0, r8
 8005d72:	f7fb fbbd 	bl	80014f0 <chThdCreateStatic>
 8005d76:	f7fb fc93 	bl	80016a0 <chThdWait>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8005d7a:	783b      	ldrb	r3, [r7, #0]
  tprio_t prio = chThdGetPriorityX() - 1;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
    n++;
 8005d7c:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8005d7e:	2b00      	cmp	r3, #0
 8005d80:	d0f1      	beq.n	8005d66 <bmk5_execute+0x26>
  test_print("--- Score : ");
 8005d82:	480a      	ldr	r0, [pc, #40]	; (8005dac <bmk5_execute+0x6c>)
 8005d84:	f7fc feac 	bl	8002ae0 <test_print>
  test_printn(n);
 8005d88:	4620      	mov	r0, r4
 8005d8a:	f7fc fe79 	bl	8002a80 <test_printn>
  test_println(" threads/S");
 8005d8e:	4808      	ldr	r0, [pc, #32]	; (8005db0 <bmk5_execute+0x70>)
}
 8005d90:	b002      	add	sp, #8
 8005d92:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n);
  test_println(" threads/S");
 8005d96:	f7fc beb3 	b.w	8002b00 <test_println>
 8005d9a:	bf00      	nop
 8005d9c:	20001150 	.word	0x20001150
 8005da0:	080160d0 	.word	0x080160d0
 8005da4:	20001c65 	.word	0x20001c65
 8005da8:	080058b1 	.word	0x080058b1
 8005dac:	08016a28 	.word	0x08016a28
 8005db0:	08016a38 	.word	0x08016a38
 8005db4:	f3af 8000 	nop.w
 8005db8:	f3af 8000 	nop.w
 8005dbc:	f3af 8000 	nop.w

08005dc0 <bmk7_execute>:
static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static void bmk7_execute(void) {
 8005dc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8005dc4:	f8df 8100 	ldr.w	r8, [pc, #256]	; 8005ec8 <bmk7_execute+0x108>
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8005dc8:	4f37      	ldr	r7, [pc, #220]	; (8005ea8 <bmk7_execute+0xe8>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8005dca:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8005dce:	6838      	ldr	r0, [r7, #0]
 8005dd0:	689a      	ldr	r2, [r3, #8]
 8005dd2:	4b36      	ldr	r3, [pc, #216]	; (8005eac <bmk7_execute+0xec>)
 8005dd4:	4e36      	ldr	r6, [pc, #216]	; (8005eb0 <bmk7_execute+0xf0>)
 8005dd6:	4d37      	ldr	r5, [pc, #220]	; (8005eb4 <bmk7_execute+0xf4>)
static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static void bmk7_execute(void) {
 8005dd8:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8005dda:	2400      	movs	r4, #0
 8005ddc:	3205      	adds	r2, #5
 8005dde:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005de2:	9400      	str	r4, [sp, #0]
 8005de4:	f7fb fb84 	bl	80014f0 <chThdCreateStatic>
 8005de8:	f8d8 2018 	ldr.w	r2, [r8, #24]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8005dec:	687b      	ldr	r3, [r7, #4]
 8005dee:	6892      	ldr	r2, [r2, #8]
}

static void bmk7_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8005df0:	6030      	str	r0, [r6, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8005df2:	3204      	adds	r2, #4
 8005df4:	4618      	mov	r0, r3
 8005df6:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005dfa:	4b2c      	ldr	r3, [pc, #176]	; (8005eac <bmk7_execute+0xec>)
 8005dfc:	9400      	str	r4, [sp, #0]
 8005dfe:	f7fb fb77 	bl	80014f0 <chThdCreateStatic>
 8005e02:	f8d8 2018 	ldr.w	r2, [r8, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 8005e06:	68bb      	ldr	r3, [r7, #8]
 8005e08:	6892      	ldr	r2, [r2, #8]

static void bmk7_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8005e0a:	6070      	str	r0, [r6, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 8005e0c:	3203      	adds	r2, #3
 8005e0e:	4618      	mov	r0, r3
 8005e10:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005e14:	4b25      	ldr	r3, [pc, #148]	; (8005eac <bmk7_execute+0xec>)
 8005e16:	9400      	str	r4, [sp, #0]
 8005e18:	f7fb fb6a 	bl	80014f0 <chThdCreateStatic>
 8005e1c:	f8d8 2018 	ldr.w	r2, [r8, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 8005e20:	68fb      	ldr	r3, [r7, #12]
 8005e22:	6892      	ldr	r2, [r2, #8]
static void bmk7_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 8005e24:	60b0      	str	r0, [r6, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 8005e26:	3202      	adds	r2, #2
 8005e28:	4618      	mov	r0, r3
 8005e2a:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005e2e:	4b1f      	ldr	r3, [pc, #124]	; (8005eac <bmk7_execute+0xec>)
 8005e30:	9400      	str	r4, [sp, #0]
 8005e32:	f7fb fb5d 	bl	80014f0 <chThdCreateStatic>
 8005e36:	f8d8 2018 	ldr.w	r2, [r8, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 8005e3a:	693b      	ldr	r3, [r7, #16]
 8005e3c:	6892      	ldr	r2, [r2, #8]
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 8005e3e:	60f0      	str	r0, [r6, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 8005e40:	3201      	adds	r2, #1
 8005e42:	4618      	mov	r0, r3
 8005e44:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005e48:	4b18      	ldr	r3, [pc, #96]	; (8005eac <bmk7_execute+0xec>)
 8005e4a:	9400      	str	r4, [sp, #0]
 8005e4c:	f7fb fb50 	bl	80014f0 <chThdCreateStatic>
 8005e50:	6130      	str	r0, [r6, #16]

  n = 0;
  test_wait_tick();
 8005e52:	f7fc ff0d 	bl	8002c70 <test_wait_tick>
  test_start_timer(1000);
 8005e56:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8005e5a:	f7fc ff19 	bl	8002c90 <test_start_timer>
  do {
    chSemReset(&sem1, 0);
 8005e5e:	4816      	ldr	r0, [pc, #88]	; (8005eb8 <bmk7_execute+0xf8>)
 8005e60:	2100      	movs	r1, #0
 8005e62:	f7fb fd45 	bl	80018f0 <chSemReset>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8005e66:	782b      	ldrb	r3, [r5, #0]
  n = 0;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chSemReset(&sem1, 0);
    n++;
 8005e68:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8005e6a:	2b00      	cmp	r3, #0
 8005e6c:	d0f7      	beq.n	8005e5e <bmk7_execute+0x9e>
  test_terminate_threads();
 8005e6e:	f7fc fed7 	bl	8002c20 <test_terminate_threads>
  chSemReset(&sem1, 0);
 8005e72:	2100      	movs	r1, #0
 8005e74:	4810      	ldr	r0, [pc, #64]	; (8005eb8 <bmk7_execute+0xf8>)
 8005e76:	f7fb fd3b 	bl	80018f0 <chSemReset>
  test_wait_threads();
 8005e7a:	f7fc fee1 	bl	8002c40 <test_wait_threads>

  test_print("--- Score : ");
 8005e7e:	480f      	ldr	r0, [pc, #60]	; (8005ebc <bmk7_execute+0xfc>)
 8005e80:	f7fc fe2e 	bl	8002ae0 <test_print>
  test_printn(n);
 8005e84:	4620      	mov	r0, r4
 8005e86:	f7fc fdfb 	bl	8002a80 <test_printn>
  test_print(" reschedules/S, ");
 8005e8a:	480d      	ldr	r0, [pc, #52]	; (8005ec0 <bmk7_execute+0x100>)
 8005e8c:	f7fc fe28 	bl	8002ae0 <test_print>
  test_printn(n * 6);
 8005e90:	eb04 0044 	add.w	r0, r4, r4, lsl #1
 8005e94:	0040      	lsls	r0, r0, #1
 8005e96:	f7fc fdf3 	bl	8002a80 <test_printn>
  test_println(" ctxswc/S");
 8005e9a:	480a      	ldr	r0, [pc, #40]	; (8005ec4 <bmk7_execute+0x104>)
}
 8005e9c:	b002      	add	sp, #8
 8005e9e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}

  test_print("--- Score : ");
  test_printn(n);
  test_print(" reschedules/S, ");
  test_printn(n * 6);
  test_println(" ctxswc/S");
 8005ea2:	f7fc be2d 	b.w	8002b00 <test_println>
 8005ea6:	bf00      	nop
 8005ea8:	080160d0 	.word	0x080160d0
 8005eac:	08005ed1 	.word	0x08005ed1
 8005eb0:	20001c84 	.word	0x20001c84
 8005eb4:	20001c65 	.word	0x20001c65
 8005eb8:	20001d6c 	.word	0x20001d6c
 8005ebc:	08016a28 	.word	0x08016a28
 8005ec0:	08016a5c 	.word	0x08016a5c
 8005ec4:	08016a50 	.word	0x08016a50
 8005ec8:	20001150 	.word	0x20001150
 8005ecc:	f3af 8000 	nop.w

08005ed0 <thread3>:
 * continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static msg_t thread3(void *p) {
 8005ed0:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8005ed2:	4c07      	ldr	r4, [pc, #28]	; (8005ef0 <thread3+0x20>)
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != 0);
 8005ed4:	69a3      	ldr	r3, [r4, #24]
 8005ed6:	7f5b      	ldrb	r3, [r3, #29]

  (void)p;
  while (!chThdShouldTerminateX())
 8005ed8:	075a      	lsls	r2, r3, #29
 8005eda:	d406      	bmi.n	8005eea <thread3+0x1a>
    chSemWait(&sem1);
 8005edc:	4805      	ldr	r0, [pc, #20]	; (8005ef4 <thread3+0x24>)
 8005ede:	f7fb fd17 	bl	8001910 <chSemWait>
 8005ee2:	69a3      	ldr	r3, [r4, #24]
 8005ee4:	7f5b      	ldrb	r3, [r3, #29]
 */

static msg_t thread3(void *p) {

  (void)p;
  while (!chThdShouldTerminateX())
 8005ee6:	075b      	lsls	r3, r3, #29
 8005ee8:	d5f8      	bpl.n	8005edc <thread3+0xc>
    chSemWait(&sem1);
  return 0;
}
 8005eea:	2000      	movs	r0, #0
 8005eec:	bd10      	pop	{r4, pc}
 8005eee:	bf00      	nop
 8005ef0:	20001150 	.word	0x20001150
 8005ef4:	20001d6c 	.word	0x20001d6c
 8005ef8:	f3af 8000 	nop.w
 8005efc:	f3af 8000 	nop.w

08005f00 <bmk7_setup>:

static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
 8005f00:	4801      	ldr	r0, [pc, #4]	; (8005f08 <bmk7_setup+0x8>)
 8005f02:	2100      	movs	r1, #0
 8005f04:	f7fb bcd4 	b.w	80018b0 <chSemObjectInit>
 8005f08:	20001d6c 	.word	0x20001d6c
 8005f0c:	f3af 8000 	nop.w

08005f10 <bmk11_setup>:
 * a second of continuous operations.
 */

static void bmk11_setup(void) {

  chSemObjectInit(&sem1, 1);
 8005f10:	4801      	ldr	r0, [pc, #4]	; (8005f18 <bmk11_setup+0x8>)
 8005f12:	2101      	movs	r1, #1
 8005f14:	f7fb bccc 	b.w	80018b0 <chSemObjectInit>
 8005f18:	20001d6c 	.word	0x20001d6c
 8005f1c:	f3af 8000 	nop.w

08005f20 <bmk8_execute>:
#endif
  } while(!chThdShouldTerminateX());
  return 0;
}

static void bmk8_execute(void) {
 8005f20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005f24:	b084      	sub	sp, #16
  uint32_t n;

  n = 0;
 8005f26:	ac04      	add	r4, sp, #16
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8005f28:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 8005ff8 <bmk8_execute+0xd8>
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8005f2c:	4f2d      	ldr	r7, [pc, #180]	; (8005fe4 <bmk8_execute+0xc4>)
 8005f2e:	4e2e      	ldr	r6, [pc, #184]	; (8005fe8 <bmk8_execute+0xc8>)
 8005f30:	4d2e      	ldr	r5, [pc, #184]	; (8005fec <bmk8_execute+0xcc>)
}

static void bmk8_execute(void) {
  uint32_t n;

  n = 0;
 8005f32:	2300      	movs	r3, #0
 8005f34:	f844 3d04 	str.w	r3, [r4, #-4]!
  test_wait_tick();
 8005f38:	f7fc fe9a 	bl	8002c70 <test_wait_tick>
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8005f3c:	f8d8 3018 	ldr.w	r3, [r8, #24]

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8005f40:	6838      	ldr	r0, [r7, #0]
 8005f42:	689a      	ldr	r2, [r3, #8]
 8005f44:	9400      	str	r4, [sp, #0]
 8005f46:	4633      	mov	r3, r6
 8005f48:	3a01      	subs	r2, #1
 8005f4a:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005f4e:	f7fb facf 	bl	80014f0 <chThdCreateStatic>
 8005f52:	f8d8 2018 	ldr.w	r2, [r8, #24]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8005f56:	687b      	ldr	r3, [r7, #4]
 8005f58:	6892      	ldr	r2, [r2, #8]
  uint32_t n;

  n = 0;
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8005f5a:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8005f5c:	3a01      	subs	r2, #1
 8005f5e:	9400      	str	r4, [sp, #0]
 8005f60:	4618      	mov	r0, r3
 8005f62:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005f66:	4633      	mov	r3, r6
 8005f68:	f7fb fac2 	bl	80014f0 <chThdCreateStatic>
 8005f6c:	f8d8 2018 	ldr.w	r2, [r8, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8005f70:	68bb      	ldr	r3, [r7, #8]
 8005f72:	6892      	ldr	r2, [r2, #8]

  n = 0;
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8005f74:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8005f76:	3a01      	subs	r2, #1
 8005f78:	9400      	str	r4, [sp, #0]
 8005f7a:	4618      	mov	r0, r3
 8005f7c:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005f80:	4633      	mov	r3, r6
 8005f82:	f7fb fab5 	bl	80014f0 <chThdCreateStatic>
 8005f86:	f8d8 2018 	ldr.w	r2, [r8, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8005f8a:	68fb      	ldr	r3, [r7, #12]
 8005f8c:	6892      	ldr	r2, [r2, #8]
  n = 0;
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8005f8e:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8005f90:	3a01      	subs	r2, #1
 8005f92:	9400      	str	r4, [sp, #0]
 8005f94:	4618      	mov	r0, r3
 8005f96:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005f9a:	4633      	mov	r3, r6
 8005f9c:	f7fb faa8 	bl	80014f0 <chThdCreateStatic>
 8005fa0:	f8d8 2018 	ldr.w	r2, [r8, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8005fa4:	693b      	ldr	r3, [r7, #16]
 8005fa6:	6892      	ldr	r2, [r2, #8]
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8005fa8:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8005faa:	3a01      	subs	r2, #1
 8005fac:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005fb0:	9400      	str	r4, [sp, #0]
 8005fb2:	4618      	mov	r0, r3
 8005fb4:	4633      	mov	r3, r6
 8005fb6:	f7fb fa9b 	bl	80014f0 <chThdCreateStatic>
 8005fba:	6128      	str	r0, [r5, #16]

  chThdSleepSeconds(1);
 8005fbc:	f242 7010 	movw	r0, #10000	; 0x2710
 8005fc0:	f7fb fb0e 	bl	80015e0 <chThdSleep>
  test_terminate_threads();
 8005fc4:	f7fc fe2c 	bl	8002c20 <test_terminate_threads>
  test_wait_threads();
 8005fc8:	f7fc fe3a 	bl	8002c40 <test_wait_threads>

  test_print("--- Score : ");
 8005fcc:	4808      	ldr	r0, [pc, #32]	; (8005ff0 <bmk8_execute+0xd0>)
 8005fce:	f7fc fd87 	bl	8002ae0 <test_print>
  test_printn(n);
 8005fd2:	9803      	ldr	r0, [sp, #12]
 8005fd4:	f7fc fd54 	bl	8002a80 <test_printn>
  test_println(" ctxswc/S");
 8005fd8:	4806      	ldr	r0, [pc, #24]	; (8005ff4 <bmk8_execute+0xd4>)
 8005fda:	f7fc fd91 	bl	8002b00 <test_println>
}
 8005fde:	b004      	add	sp, #16
 8005fe0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005fe4:	080160d0 	.word	0x080160d0
 8005fe8:	08006001 	.word	0x08006001
 8005fec:	20001c84 	.word	0x20001c84
 8005ff0:	08016a28 	.word	0x08016a28
 8005ff4:	08016a50 	.word	0x08016a50
 8005ff8:	20001150 	.word	0x20001150
 8005ffc:	f3af 8000 	nop.w

08006000 <thread8>:
 * variable and yields.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static msg_t thread8(void *p) {
 8006000:	b538      	push	{r3, r4, r5, lr}
 8006002:	4d09      	ldr	r5, [pc, #36]	; (8006028 <thread8+0x28>)
 8006004:	4604      	mov	r4, r0

  do {
    chThdYield();
 8006006:	f7fb fb0b 	bl	8001620 <chThdYield>
    chThdYield();
 800600a:	f7fb fb09 	bl	8001620 <chThdYield>
    chThdYield();
 800600e:	f7fb fb07 	bl	8001620 <chThdYield>
    chThdYield();
 8006012:	f7fb fb05 	bl	8001620 <chThdYield>
    (*(uint32_t *)p) += 4;
 8006016:	6823      	ldr	r3, [r4, #0]
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != 0);
 8006018:	69aa      	ldr	r2, [r5, #24]
 800601a:	3304      	adds	r3, #4
 800601c:	6023      	str	r3, [r4, #0]
 800601e:	7f53      	ldrb	r3, [r2, #29]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 8006020:	075b      	lsls	r3, r3, #29
 8006022:	d5f0      	bpl.n	8006006 <thread8+0x6>
  return 0;
}
 8006024:	2000      	movs	r0, #0
 8006026:	bd38      	pop	{r3, r4, r5, pc}
 8006028:	20001150 	.word	0x20001150
 800602c:	f3af 8000 	nop.w

08006030 <bmk9_execute>:
 * loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk9_execute(void) {
 8006030:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006032:	b083      	sub	sp, #12
  uint32_t n;
  static uint8_t ib[16];
  static input_queue_t iq;

  chIQObjectInit(&iq, ib, sizeof(ib), NULL, NULL);
 8006034:	2400      	movs	r4, #0
 8006036:	4623      	mov	r3, r4
 8006038:	4923      	ldr	r1, [pc, #140]	; (80060c8 <bmk9_execute+0x98>)
 800603a:	4824      	ldr	r0, [pc, #144]	; (80060cc <bmk9_execute+0x9c>)
 800603c:	9400      	str	r4, [sp, #0]
 800603e:	2210      	movs	r2, #16
 8006040:	f7fc fa36 	bl	80024b0 <chIQObjectInit>
  n = 0;
  test_wait_tick();
 8006044:	f7fc fe14 	bl	8002c70 <test_wait_tick>
  test_start_timer(1000);
 8006048:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800604c:	f7fc fe20 	bl	8002c90 <test_start_timer>
 8006050:	4f1f      	ldr	r7, [pc, #124]	; (80060d0 <bmk9_execute+0xa0>)
  do {
    chSysLock();
    chIQPutI(&iq, 0);
 8006052:	4626      	mov	r6, r4
 8006054:	2520      	movs	r5, #32
 8006056:	f385 8811 	msr	BASEPRI, r5
 800605a:	2100      	movs	r1, #0
 800605c:	481b      	ldr	r0, [pc, #108]	; (80060cc <bmk9_execute+0x9c>)
 800605e:	f7fc fa47 	bl	80024f0 <chIQPutI>
    chIQPutI(&iq, 1);
 8006062:	2101      	movs	r1, #1
 8006064:	4819      	ldr	r0, [pc, #100]	; (80060cc <bmk9_execute+0x9c>)
 8006066:	f7fc fa43 	bl	80024f0 <chIQPutI>
    chIQPutI(&iq, 2);
 800606a:	2102      	movs	r1, #2
 800606c:	4817      	ldr	r0, [pc, #92]	; (80060cc <bmk9_execute+0x9c>)
 800606e:	f7fc fa3f 	bl	80024f0 <chIQPutI>
    chIQPutI(&iq, 3);
 8006072:	2103      	movs	r1, #3
 8006074:	4815      	ldr	r0, [pc, #84]	; (80060cc <bmk9_execute+0x9c>)
 8006076:	f7fc fa3b 	bl	80024f0 <chIQPutI>
 800607a:	f386 8811 	msr	BASEPRI, r6
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {

  return chIQGetTimeout(iqp, TIME_INFINITE);
 800607e:	f04f 31ff 	mov.w	r1, #4294967295
 8006082:	4812      	ldr	r0, [pc, #72]	; (80060cc <bmk9_execute+0x9c>)
 8006084:	f7fc fa54 	bl	8002530 <chIQGetTimeout>
 8006088:	f04f 31ff 	mov.w	r1, #4294967295
 800608c:	480f      	ldr	r0, [pc, #60]	; (80060cc <bmk9_execute+0x9c>)
 800608e:	f7fc fa4f 	bl	8002530 <chIQGetTimeout>
 8006092:	f04f 31ff 	mov.w	r1, #4294967295
 8006096:	480d      	ldr	r0, [pc, #52]	; (80060cc <bmk9_execute+0x9c>)
 8006098:	f7fc fa4a 	bl	8002530 <chIQGetTimeout>
 800609c:	480b      	ldr	r0, [pc, #44]	; (80060cc <bmk9_execute+0x9c>)
 800609e:	f04f 31ff 	mov.w	r1, #4294967295
 80060a2:	f7fc fa45 	bl	8002530 <chIQGetTimeout>
    (void)chIQGet(&iq);
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80060a6:	783b      	ldrb	r3, [r7, #0]
    chSysUnlock();
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    n++;
 80060a8:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80060aa:	2b00      	cmp	r3, #0
 80060ac:	d0d3      	beq.n	8006056 <bmk9_execute+0x26>
  test_print("--- Score : ");
 80060ae:	4809      	ldr	r0, [pc, #36]	; (80060d4 <bmk9_execute+0xa4>)
 80060b0:	f7fc fd16 	bl	8002ae0 <test_print>
  test_printn(n * 4);
 80060b4:	00a0      	lsls	r0, r4, #2
 80060b6:	f7fc fce3 	bl	8002a80 <test_printn>
  test_println(" bytes/S");
 80060ba:	4807      	ldr	r0, [pc, #28]	; (80060d8 <bmk9_execute+0xa8>)
}
 80060bc:	b003      	add	sp, #12
 80060be:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 4);
  test_println(" bytes/S");
 80060c2:	f7fc bd1d 	b.w	8002b00 <test_println>
 80060c6:	bf00      	nop
 80060c8:	20001d00 	.word	0x20001d00
 80060cc:	20001d10 	.word	0x20001d10
 80060d0:	20001c65 	.word	0x20001c65
 80060d4:	08016a28 	.word	0x08016a28
 80060d8:	08016a70 	.word	0x08016a70
 80060dc:	f3af 8000 	nop.w

080060e0 <bmk10_execute>:
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}

static void bmk10_execute(void) {
 80060e0:	b538      	push	{r3, r4, r5, lr}
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;

  test_wait_tick();
 80060e2:	f7fc fdc5 	bl	8002c70 <test_wait_tick>
  test_start_timer(1000);
 80060e6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80060ea:	f7fc fdd1 	bl	8002c90 <test_start_timer>
 80060ee:	4d15      	ldr	r5, [pc, #84]	; (8006144 <bmk10_execute+0x64>)

static void tmo(void *param) {(void)param;}

static void bmk10_execute(void) {
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;
 80060f0:	2400      	movs	r4, #0
 80060f2:	2320      	movs	r3, #32
 80060f4:	f383 8811 	msr	BASEPRI, r3

  test_wait_tick();
  test_start_timer(1000);
  do {
    chSysLock();
    chVTDoSetI(&vt1, 1, tmo, NULL);
 80060f8:	4813      	ldr	r0, [pc, #76]	; (8006148 <bmk10_execute+0x68>)
 80060fa:	4a14      	ldr	r2, [pc, #80]	; (800614c <bmk10_execute+0x6c>)
 80060fc:	2101      	movs	r1, #1
 80060fe:	2300      	movs	r3, #0
 8006100:	f7fb f93e 	bl	8001380 <chVTDoSetI>
    chVTDoSetI(&vt2, 10000, tmo, NULL);
 8006104:	4a11      	ldr	r2, [pc, #68]	; (800614c <bmk10_execute+0x6c>)
 8006106:	4812      	ldr	r0, [pc, #72]	; (8006150 <bmk10_execute+0x70>)
 8006108:	f242 7110 	movw	r1, #10000	; 0x2710
 800610c:	2300      	movs	r3, #0
 800610e:	f7fb f937 	bl	8001380 <chVTDoSetI>
    chVTDoResetI(&vt1);
 8006112:	480d      	ldr	r0, [pc, #52]	; (8006148 <bmk10_execute+0x68>)
 8006114:	f7fb f96c 	bl	80013f0 <chVTDoResetI>
    chVTDoResetI(&vt2);
 8006118:	480d      	ldr	r0, [pc, #52]	; (8006150 <bmk10_execute+0x70>)
 800611a:	f7fb f969 	bl	80013f0 <chVTDoResetI>
 800611e:	2300      	movs	r3, #0
 8006120:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8006124:	782b      	ldrb	r3, [r5, #0]
    chVTDoSetI(&vt1, 1, tmo, NULL);
    chVTDoSetI(&vt2, 10000, tmo, NULL);
    chVTDoResetI(&vt1);
    chVTDoResetI(&vt2);
    chSysUnlock();
    n++;
 8006126:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8006128:	2b00      	cmp	r3, #0
 800612a:	d0e2      	beq.n	80060f2 <bmk10_execute+0x12>
  test_print("--- Score : ");
 800612c:	4809      	ldr	r0, [pc, #36]	; (8006154 <bmk10_execute+0x74>)
 800612e:	f7fc fcd7 	bl	8002ae0 <test_print>
  test_printn(n * 2);
 8006132:	0060      	lsls	r0, r4, #1
 8006134:	f7fc fca4 	bl	8002a80 <test_printn>
  test_println(" timers/S");
 8006138:	4807      	ldr	r0, [pc, #28]	; (8006158 <bmk10_execute+0x78>)
}
 800613a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 2);
  test_println(" timers/S");
 800613e:	f7fc bcdf 	b.w	8002b00 <test_println>
 8006142:	bf00      	nop
 8006144:	20001c65 	.word	0x20001c65
 8006148:	20001d48 	.word	0x20001d48
 800614c:	080058c1 	.word	0x080058c1
 8006150:	20001d34 	.word	0x20001d34
 8006154:	08016a28 	.word	0x08016a28
 8006158:	08016a7c 	.word	0x08016a7c
 800615c:	f3af 8000 	nop.w

08006160 <bmk11_execute>:
static void bmk11_setup(void) {

  chSemObjectInit(&sem1, 1);
}

static void bmk11_execute(void) {
 8006160:	b538      	push	{r3, r4, r5, lr}
  uint32_t n = 0;

  test_wait_tick();
 8006162:	f7fc fd85 	bl	8002c70 <test_wait_tick>
  test_start_timer(1000);
 8006166:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800616a:	f7fc fd91 	bl	8002c90 <test_start_timer>
 800616e:	4d14      	ldr	r5, [pc, #80]	; (80061c0 <bmk11_execute+0x60>)

  chSemObjectInit(&sem1, 1);
}

static void bmk11_execute(void) {
  uint32_t n = 0;
 8006170:	2400      	movs	r4, #0

  test_wait_tick();
  test_start_timer(1000);
  do {
    chSemWait(&sem1);
 8006172:	4814      	ldr	r0, [pc, #80]	; (80061c4 <bmk11_execute+0x64>)
 8006174:	f7fb fbcc 	bl	8001910 <chSemWait>
    chSemSignal(&sem1);
 8006178:	4812      	ldr	r0, [pc, #72]	; (80061c4 <bmk11_execute+0x64>)
 800617a:	f7fb fc21 	bl	80019c0 <chSemSignal>
    chSemWait(&sem1);
 800617e:	4811      	ldr	r0, [pc, #68]	; (80061c4 <bmk11_execute+0x64>)
 8006180:	f7fb fbc6 	bl	8001910 <chSemWait>
    chSemSignal(&sem1);
 8006184:	480f      	ldr	r0, [pc, #60]	; (80061c4 <bmk11_execute+0x64>)
 8006186:	f7fb fc1b 	bl	80019c0 <chSemSignal>
    chSemWait(&sem1);
 800618a:	480e      	ldr	r0, [pc, #56]	; (80061c4 <bmk11_execute+0x64>)
 800618c:	f7fb fbc0 	bl	8001910 <chSemWait>
    chSemSignal(&sem1);
 8006190:	480c      	ldr	r0, [pc, #48]	; (80061c4 <bmk11_execute+0x64>)
 8006192:	f7fb fc15 	bl	80019c0 <chSemSignal>
    chSemWait(&sem1);
 8006196:	480b      	ldr	r0, [pc, #44]	; (80061c4 <bmk11_execute+0x64>)
 8006198:	f7fb fbba 	bl	8001910 <chSemWait>
    chSemSignal(&sem1);
 800619c:	4809      	ldr	r0, [pc, #36]	; (80061c4 <bmk11_execute+0x64>)
 800619e:	f7fb fc0f 	bl	80019c0 <chSemSignal>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80061a2:	782b      	ldrb	r3, [r5, #0]
    chSemSignal(&sem1);
    chSemWait(&sem1);
    chSemSignal(&sem1);
    chSemWait(&sem1);
    chSemSignal(&sem1);
    n++;
 80061a4:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80061a6:	2b00      	cmp	r3, #0
 80061a8:	d0e3      	beq.n	8006172 <bmk11_execute+0x12>
  test_print("--- Score : ");
 80061aa:	4807      	ldr	r0, [pc, #28]	; (80061c8 <bmk11_execute+0x68>)
 80061ac:	f7fc fc98 	bl	8002ae0 <test_print>
  test_printn(n * 4);
 80061b0:	00a0      	lsls	r0, r4, #2
 80061b2:	f7fc fc65 	bl	8002a80 <test_printn>
  test_println(" wait+signal/S");
 80061b6:	4805      	ldr	r0, [pc, #20]	; (80061cc <bmk11_execute+0x6c>)
}
 80061b8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 4);
  test_println(" wait+signal/S");
 80061bc:	f7fc bca0 	b.w	8002b00 <test_println>
 80061c0:	20001c65 	.word	0x20001c65
 80061c4:	20001d6c 	.word	0x20001d6c
 80061c8:	08016a28 	.word	0x08016a28
 80061cc:	08016a88 	.word	0x08016a88

080061d0 <bmk12_execute>:
static void bmk12_setup(void) {

  chMtxObjectInit(&mtx1);
}

static void bmk12_execute(void) {
 80061d0:	b538      	push	{r3, r4, r5, lr}
  uint32_t n = 0;

  test_wait_tick();
 80061d2:	f7fc fd4d 	bl	8002c70 <test_wait_tick>
  test_start_timer(1000);
 80061d6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80061da:	f7fc fd59 	bl	8002c90 <test_start_timer>
 80061de:	4d14      	ldr	r5, [pc, #80]	; (8006230 <bmk12_execute+0x60>)

  chMtxObjectInit(&mtx1);
}

static void bmk12_execute(void) {
  uint32_t n = 0;
 80061e0:	2400      	movs	r4, #0

  test_wait_tick();
  test_start_timer(1000);
  do {
    chMtxLock(&mtx1);
 80061e2:	4814      	ldr	r0, [pc, #80]	; (8006234 <bmk12_execute+0x64>)
 80061e4:	f7fb fcdc 	bl	8001ba0 <chMtxLock>
    chMtxUnlock(&mtx1);
 80061e8:	4812      	ldr	r0, [pc, #72]	; (8006234 <bmk12_execute+0x64>)
 80061ea:	f7fb fd01 	bl	8001bf0 <chMtxUnlock>
    chMtxLock(&mtx1);
 80061ee:	4811      	ldr	r0, [pc, #68]	; (8006234 <bmk12_execute+0x64>)
 80061f0:	f7fb fcd6 	bl	8001ba0 <chMtxLock>
    chMtxUnlock(&mtx1);
 80061f4:	480f      	ldr	r0, [pc, #60]	; (8006234 <bmk12_execute+0x64>)
 80061f6:	f7fb fcfb 	bl	8001bf0 <chMtxUnlock>
    chMtxLock(&mtx1);
 80061fa:	480e      	ldr	r0, [pc, #56]	; (8006234 <bmk12_execute+0x64>)
 80061fc:	f7fb fcd0 	bl	8001ba0 <chMtxLock>
    chMtxUnlock(&mtx1);
 8006200:	480c      	ldr	r0, [pc, #48]	; (8006234 <bmk12_execute+0x64>)
 8006202:	f7fb fcf5 	bl	8001bf0 <chMtxUnlock>
    chMtxLock(&mtx1);
 8006206:	480b      	ldr	r0, [pc, #44]	; (8006234 <bmk12_execute+0x64>)
 8006208:	f7fb fcca 	bl	8001ba0 <chMtxLock>
    chMtxUnlock(&mtx1);
 800620c:	4809      	ldr	r0, [pc, #36]	; (8006234 <bmk12_execute+0x64>)
 800620e:	f7fb fcef 	bl	8001bf0 <chMtxUnlock>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8006212:	782b      	ldrb	r3, [r5, #0]
    chMtxUnlock(&mtx1);
    chMtxLock(&mtx1);
    chMtxUnlock(&mtx1);
    chMtxLock(&mtx1);
    chMtxUnlock(&mtx1);
    n++;
 8006214:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8006216:	2b00      	cmp	r3, #0
 8006218:	d0e3      	beq.n	80061e2 <bmk12_execute+0x12>
  test_print("--- Score : ");
 800621a:	4807      	ldr	r0, [pc, #28]	; (8006238 <bmk12_execute+0x68>)
 800621c:	f7fc fc60 	bl	8002ae0 <test_print>
  test_printn(n * 4);
 8006220:	00a0      	lsls	r0, r4, #2
 8006222:	f7fc fc2d 	bl	8002a80 <test_printn>
  test_println(" lock+unlock/S");
 8006226:	4805      	ldr	r0, [pc, #20]	; (800623c <bmk12_execute+0x6c>)
}
 8006228:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 4);
  test_println(" lock+unlock/S");
 800622c:	f7fc bc68 	b.w	8002b00 <test_println>
 8006230:	20001c65 	.word	0x20001c65
 8006234:	20001d5c 	.word	0x20001d5c
 8006238:	08016a28 	.word	0x08016a28
 800623c:	08016a98 	.word	0x08016a98

08006240 <bmk12_setup>:
 * a second of continuous operations.
 */

static void bmk12_setup(void) {

  chMtxObjectInit(&mtx1);
 8006240:	4801      	ldr	r0, [pc, #4]	; (8006248 <bmk12_setup+0x8>)
 8006242:	f7fb bc3d 	b.w	8001ac0 <chMtxObjectInit>
 8006246:	bf00      	nop
 8006248:	20001d5c 	.word	0x20001d5c
 800624c:	f3af 8000 	nop.w

08006250 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8006250:	b40e      	push	{r1, r2, r3}
 8006252:	b500      	push	{lr}
 8006254:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8006256:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 8006258:	461a      	mov	r2, r3
 800625a:	4905      	ldr	r1, [pc, #20]	; (8006270 <chprintf.constprop.0+0x20>)
 800625c:	4805      	ldr	r0, [pc, #20]	; (8006274 <chprintf.constprop.0+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800625e:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8006260:	f00a fd4e 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8006264:	b002      	add	sp, #8
 8006266:	f85d eb04 	ldr.w	lr, [sp], #4
 800626a:	b003      	add	sp, #12
 800626c:	4770      	bx	lr
 800626e:	bf00      	nop
 8006270:	08017004 	.word	0x08017004
 8006274:	200180c8 	.word	0x200180c8
 8006278:	f3af 8000 	nop.w
 800627c:	f3af 8000 	nop.w

08006280 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8006280:	b538      	push	{r3, r4, r5, lr}
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
  
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "hal_lld_init");
 8006282:	4d12      	ldr	r5, [pc, #72]	; (80062cc <halInit+0x4c>)
 8006284:	4c12      	ldr	r4, [pc, #72]	; (80062d0 <halInit+0x50>)

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 8006286:	f000 fb8b 	bl	80069a0 <hal_lld_init>
  
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "hal_lld_init");
 800628a:	4621      	mov	r1, r4
 800628c:	4a11      	ldr	r2, [pc, #68]	; (80062d4 <halInit+0x54>)
 800628e:	4628      	mov	r0, r5
 8006290:	f7ff ffde 	bl	8006250 <chprintf.constprop.0>

#if HAL_USE_PAL || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8006294:	4810      	ldr	r0, [pc, #64]	; (80062d8 <halInit+0x58>)
 8006296:	f000 ff6b 	bl	8007170 <_pal_lld_init>
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "palInit");
 800629a:	4621      	mov	r1, r4
 800629c:	4a0f      	ldr	r2, [pc, #60]	; (80062dc <halInit+0x5c>)
 800629e:	4628      	mov	r0, r5
 80062a0:	f7ff ffd6 	bl	8006250 <chprintf.constprop.0>
#endif
#if HAL_USE_ICU || defined(__DOXYGEN__)
  icuInit();
#endif
#if HAL_USE_MAC || defined(__DOXYGEN__)
  macInit();
 80062a4:	f000 f824 	bl	80062f0 <macInit>
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "mac Inited...");
 80062a8:	4621      	mov	r1, r4
 80062aa:	4a0d      	ldr	r2, [pc, #52]	; (80062e0 <halInit+0x60>)
 80062ac:	4628      	mov	r0, r5
 80062ae:	f7ff ffcf 	bl	8006250 <chprintf.constprop.0>
#endif
#if HAL_USE_PWM || defined(__DOXYGEN__)
  pwmInit();
#endif
#if HAL_USE_SERIAL || defined(__DOXYGEN__)
  sdInit();
 80062b2:	f000 f915 	bl	80064e0 <sdInit>
#endif
#if HAL_USE_SPI || defined(__DOXYGEN__)
  spiInit();
#endif
#if HAL_USE_UART || defined(__DOXYGEN__)
  uartInit();
 80062b6:	f000 f98b 	bl	80065d0 <uartInit>
#endif
#if HAL_USE_SERIAL_USB || defined(__DOXYGEN__)
  sduInit();
#endif
#if HAL_USE_RTC || defined(__DOXYGEN__)
  rtcInit();
 80062ba:	f000 f8c1 	bl	8006440 <rtcInit>
#if HAL_USE_COMMUNITY || defined(__DOXYGEN__)
  halCommunityInit();
#endif

  /* Board specific initialization.*/
  boardInit();
 80062be:	f001 fa97 	bl	80077f0 <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
 80062c2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 80062c6:	f000 b963 	b.w	8006590 <stInit>
 80062ca:	bf00      	nop
 80062cc:	200180c8 	.word	0x200180c8
 80062d0:	08017004 	.word	0x08017004
 80062d4:	08016cd0 	.word	0x08016cd0
 80062d8:	08016e80 	.word	0x08016e80
 80062dc:	08016ce0 	.word	0x08016ce0
 80062e0:	08016ce8 	.word	0x08016ce8
 80062e4:	f3af 8000 	nop.w
 80062e8:	f3af 8000 	nop.w
 80062ec:	f3af 8000 	nop.w

080062f0 <macInit>:
 *
 * @init
 */
void macInit(void) {

  mac_lld_init();
 80062f0:	f000 bc76 	b.w	8006be0 <mac_lld_init>
 80062f4:	f3af 8000 	nop.w
 80062f8:	f3af 8000 	nop.w
 80062fc:	f3af 8000 	nop.w

08006300 <macObjectInit>:
 *
 * @param[out] macp     pointer to the @p MACDriver object
 *
 * @init
 */
void macObjectInit(MACDriver *macp) {
 8006300:	b430      	push	{r4, r5}

  macp->state  = MAC_STOP;
  macp->config = NULL;
  osalThreadQueueObjectInit(&macp->tdqueue);
 8006302:	f100 0208 	add.w	r2, r0, #8
 *
 * @init
 */
void macObjectInit(MACDriver *macp) {

  macp->state  = MAC_STOP;
 8006306:	2501      	movs	r5, #1
  macp->config = NULL;
 8006308:	2400      	movs	r4, #0
  osalThreadQueueObjectInit(&macp->tdqueue);
  osalThreadQueueObjectInit(&macp->rdqueue);
 800630a:	f100 0310 	add.w	r3, r0, #16
#if MAC_USE_EVENTS
  osalEventObjectInit(&macp->rdevent);
 800630e:	f100 0118 	add.w	r1, r0, #24
 *
 * @init
 */
void macObjectInit(MACDriver *macp) {

  macp->state  = MAC_STOP;
 8006312:	7005      	strb	r5, [r0, #0]
  macp->config = NULL;
 8006314:	6044      	str	r4, [r0, #4]
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)(void *)esp;
 8006316:	6181      	str	r1, [r0, #24]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8006318:	60c2      	str	r2, [r0, #12]
 800631a:	6082      	str	r2, [r0, #8]
 800631c:	6143      	str	r3, [r0, #20]
 800631e:	6103      	str	r3, [r0, #16]
  osalThreadQueueObjectInit(&macp->tdqueue);
  osalThreadQueueObjectInit(&macp->rdqueue);
#if MAC_USE_EVENTS
  osalEventObjectInit(&macp->rdevent);
#endif
}
 8006320:	bc30      	pop	{r4, r5}
 8006322:	4770      	bx	lr
 8006324:	f3af 8000 	nop.w
 8006328:	f3af 8000 	nop.w
 800632c:	f3af 8000 	nop.w

08006330 <macStart>:
 * @param[in] macp      pointer to the @p MACDriver object
 * @param[in] config    pointer to the @p MACConfig object
 *
 * @api
 */
void macStart(MACDriver *macp, const MACConfig *config) {
 8006330:	b510      	push	{r4, lr}
 8006332:	2320      	movs	r3, #32
 8006334:	4604      	mov	r4, r0
 8006336:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck((macp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert(macp->state == MAC_STOP,
                "invalid state");
  macp->config = config;
 800633a:	6041      	str	r1, [r0, #4]
  mac_lld_start(macp);
 800633c:	f000 fd58 	bl	8006df0 <mac_lld_start>
  macp->state = MAC_ACTIVE;
 8006340:	2302      	movs	r3, #2
 8006342:	7023      	strb	r3, [r4, #0]
 8006344:	2300      	movs	r3, #0
 8006346:	f383 8811 	msr	BASEPRI, r3
 800634a:	bd10      	pop	{r4, pc}
 800634c:	f3af 8000 	nop.w

08006350 <macWaitTransmitDescriptor>:
 *
 * @api
 */
msg_t macWaitTransmitDescriptor(MACDriver *macp,
                                MACTransmitDescriptor *tdp,
                                systime_t time) {
 8006350:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8006354:	4606      	mov	r6, r0
 8006356:	460f      	mov	r7, r1
 8006358:	4614      	mov	r4, r2

  while (((msg = mac_lld_get_transmit_descriptor(macp, tdp)) != MSG_OK) &&
         (time > 0)) {
    osalSysLock();
    now = osalOsGetSystemTimeX();
    msg = osalThreadEnqueueTimeoutS(&macp->tdqueue, time);
 800635a:	f100 0908 	add.w	r9, r0, #8
 800635e:	f04f 0820 	mov.w	r8, #32
 8006362:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 8006366:	e013      	b.n	8006390 <macWaitTransmitDescriptor+0x40>
  systime_t now;

  osalDbgCheck((macp != NULL) && (tdp != NULL));
  osalDbgAssert(macp->state == MAC_ACTIVE, "not active");

  while (((msg = mac_lld_get_transmit_descriptor(macp, tdp)) != MSG_OK) &&
 8006368:	b1c4      	cbz	r4, 800639c <macWaitTransmitDescriptor+0x4c>
 800636a:	f388 8811 	msr	BASEPRI, r8
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chThdEnqueueTimeoutS(tqp, time);
 800636e:	4648      	mov	r0, r9
 8006370:	4621      	mov	r1, r4
 8006372:	f8d5 a024 	ldr.w	sl, [r5, #36]	; 0x24
 8006376:	f7fb f9b3 	bl	80016e0 <chThdEnqueueTimeoutS>
         (time > 0)) {
    osalSysLock();
    now = osalOsGetSystemTimeX();
    msg = osalThreadEnqueueTimeoutS(&macp->tdqueue, time);
    if (msg == MSG_TIMEOUT) {
 800637a:	1c42      	adds	r2, r0, #1
 800637c:	d010      	beq.n	80063a0 <macWaitTransmitDescriptor+0x50>
      osalSysUnlock();
      break;
    }
    if (time != TIME_INFINITE)
 800637e:	1c63      	adds	r3, r4, #1
 8006380:	d003      	beq.n	800638a <macWaitTransmitDescriptor+0x3a>
 8006382:	6a6b      	ldr	r3, [r5, #36]	; 0x24
      time -= (osalOsGetSystemTimeX() - now);
 8006384:	ebca 0303 	rsb	r3, sl, r3
 8006388:	1ae4      	subs	r4, r4, r3
 800638a:	2300      	movs	r3, #0
 800638c:	f383 8811 	msr	BASEPRI, r3
  systime_t now;

  osalDbgCheck((macp != NULL) && (tdp != NULL));
  osalDbgAssert(macp->state == MAC_ACTIVE, "not active");

  while (((msg = mac_lld_get_transmit_descriptor(macp, tdp)) != MSG_OK) &&
 8006390:	4630      	mov	r0, r6
 8006392:	4639      	mov	r1, r7
 8006394:	f000 fdc4 	bl	8006f20 <mac_lld_get_transmit_descriptor>
 8006398:	2800      	cmp	r0, #0
 800639a:	d1e5      	bne.n	8006368 <macWaitTransmitDescriptor+0x18>
    if (time != TIME_INFINITE)
      time -= (osalOsGetSystemTimeX() - now);
    osalSysUnlock();
  }
  return msg;
}
 800639c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80063a0:	2300      	movs	r3, #0
 80063a2:	f383 8811 	msr	BASEPRI, r3
 80063a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80063aa:	bf00      	nop
 80063ac:	f3af 8000 	nop.w

080063b0 <macReleaseTransmitDescriptor>:
 */
void macReleaseTransmitDescriptor(MACTransmitDescriptor *tdp) {

  osalDbgCheck(tdp != NULL);

  mac_lld_release_transmit_descriptor(tdp);
 80063b0:	f000 bdde 	b.w	8006f70 <mac_lld_release_transmit_descriptor>
 80063b4:	f3af 8000 	nop.w
 80063b8:	f3af 8000 	nop.w
 80063bc:	f3af 8000 	nop.w

080063c0 <macWaitReceiveDescriptor>:
 *
 * @api
 */
msg_t macWaitReceiveDescriptor(MACDriver *macp,
                               MACReceiveDescriptor *rdp,
                               systime_t time) {
 80063c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80063c4:	4606      	mov	r6, r0
 80063c6:	460f      	mov	r7, r1
 80063c8:	4614      	mov	r4, r2

  while (((msg = mac_lld_get_receive_descriptor(macp, rdp)) != MSG_OK) &&
         (time > 0)) {
    osalSysLock();
    now = osalOsGetSystemTimeX();
    msg = osalThreadEnqueueTimeoutS(&macp->rdqueue, time);
 80063ca:	f100 0910 	add.w	r9, r0, #16
 80063ce:	f04f 0820 	mov.w	r8, #32
 80063d2:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 80063d6:	e013      	b.n	8006400 <macWaitReceiveDescriptor+0x40>
  systime_t now;

  osalDbgCheck((macp != NULL) && (rdp != NULL));
  osalDbgAssert(macp->state == MAC_ACTIVE, "not active");

  while (((msg = mac_lld_get_receive_descriptor(macp, rdp)) != MSG_OK) &&
 80063d8:	b1c4      	cbz	r4, 800640c <macWaitReceiveDescriptor+0x4c>
 80063da:	f388 8811 	msr	BASEPRI, r8
 80063de:	4648      	mov	r0, r9
 80063e0:	4621      	mov	r1, r4
 80063e2:	f8d5 a024 	ldr.w	sl, [r5, #36]	; 0x24
 80063e6:	f7fb f97b 	bl	80016e0 <chThdEnqueueTimeoutS>
         (time > 0)) {
    osalSysLock();
    now = osalOsGetSystemTimeX();
    msg = osalThreadEnqueueTimeoutS(&macp->rdqueue, time);
    if (msg == MSG_TIMEOUT) {
 80063ea:	1c42      	adds	r2, r0, #1
 80063ec:	d010      	beq.n	8006410 <macWaitReceiveDescriptor+0x50>
      osalSysUnlock();
      break;
    }
    if (time != TIME_INFINITE)
 80063ee:	1c63      	adds	r3, r4, #1
 80063f0:	d003      	beq.n	80063fa <macWaitReceiveDescriptor+0x3a>
 80063f2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
      time -= (osalOsGetSystemTimeX() - now);
 80063f4:	ebca 0303 	rsb	r3, sl, r3
 80063f8:	1ae4      	subs	r4, r4, r3
 80063fa:	2300      	movs	r3, #0
 80063fc:	f383 8811 	msr	BASEPRI, r3
  systime_t now;

  osalDbgCheck((macp != NULL) && (rdp != NULL));
  osalDbgAssert(macp->state == MAC_ACTIVE, "not active");

  while (((msg = mac_lld_get_receive_descriptor(macp, rdp)) != MSG_OK) &&
 8006400:	4630      	mov	r0, r6
 8006402:	4639      	mov	r1, r7
 8006404:	f000 fdd4 	bl	8006fb0 <mac_lld_get_receive_descriptor>
 8006408:	2800      	cmp	r0, #0
 800640a:	d1e5      	bne.n	80063d8 <macWaitReceiveDescriptor+0x18>
    if (time != TIME_INFINITE)
      time -= (osalOsGetSystemTimeX() - now);
    osalSysUnlock();
  }
  return msg;
}
 800640c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8006410:	2300      	movs	r3, #0
 8006412:	f383 8811 	msr	BASEPRI, r3
 8006416:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800641a:	bf00      	nop
 800641c:	f3af 8000 	nop.w

08006420 <macReleaseReceiveDescriptor>:
 */
void macReleaseReceiveDescriptor(MACReceiveDescriptor *rdp) {

  osalDbgCheck(rdp != NULL);

  mac_lld_release_receive_descriptor(rdp);
 8006420:	f000 bdfe 	b.w	8007020 <mac_lld_release_receive_descriptor>
 8006424:	f3af 8000 	nop.w
 8006428:	f3af 8000 	nop.w
 800642c:	f3af 8000 	nop.w

08006430 <macPollLinkStatus>:
bool macPollLinkStatus(MACDriver *macp) {

  osalDbgCheck(macp != NULL);
  osalDbgAssert(macp->state == MAC_ACTIVE, "not active");

  return mac_lld_poll_link_status(macp);
 8006430:	f000 be16 	b.w	8007060 <mac_lld_poll_link_status>
 8006434:	f3af 8000 	nop.w
 8006438:	f3af 8000 	nop.w
 800643c:	f3af 8000 	nop.w

08006440 <rtcInit>:
 *
 * @init
 */
void rtcInit(void) {

  rtc_lld_init();
 8006440:	f000 bf7e 	b.w	8007340 <rtc_lld_init>
 8006444:	f3af 8000 	nop.w
 8006448:	f3af 8000 	nop.w
 800644c:	f3af 8000 	nop.w

08006450 <rtcObjectInit>:
 *
 * @param[out] rtcp     pointer to RTC driver structure
 *
 * @init
 */
void rtcObjectInit(RTCDriver *rtcp) {
 8006450:	4770      	bx	lr
 8006452:	bf00      	nop
 8006454:	f3af 8000 	nop.w
 8006458:	f3af 8000 	nop.w
 800645c:	f3af 8000 	nop.w

08006460 <readt>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t time) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, time);
 8006460:	300c      	adds	r0, #12
 8006462:	f7fc b88d 	b.w	8002580 <chIQReadTimeout>
 8006466:	bf00      	nop
 8006468:	f3af 8000 	nop.w
 800646c:	f3af 8000 	nop.w

08006470 <read>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8006470:	300c      	adds	r0, #12
 8006472:	f04f 33ff 	mov.w	r3, #4294967295
 8006476:	f7fc b883 	b.w	8002580 <chIQReadTimeout>
 800647a:	bf00      	nop
 800647c:	f3af 8000 	nop.w

08006480 <writet>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t time) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
 8006480:	3030      	adds	r0, #48	; 0x30
 8006482:	f7fc b925 	b.w	80026d0 <chOQWriteTimeout>
 8006486:	bf00      	nop
 8006488:	f3af 8000 	nop.w
 800648c:	f3af 8000 	nop.w

08006490 <write>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8006490:	3030      	adds	r0, #48	; 0x30
 8006492:	f04f 33ff 	mov.w	r3, #4294967295
 8006496:	f7fc b91b 	b.w	80026d0 <chOQWriteTimeout>
 800649a:	bf00      	nop
 800649c:	f3af 8000 	nop.w

080064a0 <gett>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80064a0:	300c      	adds	r0, #12
 80064a2:	f7fc b845 	b.w	8002530 <chIQGetTimeout>
 80064a6:	bf00      	nop
 80064a8:	f3af 8000 	nop.w
 80064ac:	f3af 8000 	nop.w

080064b0 <get>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80064b0:	300c      	adds	r0, #12
 80064b2:	f04f 31ff 	mov.w	r1, #4294967295
 80064b6:	f7fc b83b 	b.w	8002530 <chIQGetTimeout>
 80064ba:	bf00      	nop
 80064bc:	f3af 8000 	nop.w

080064c0 <putt>:
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80064c0:	3030      	adds	r0, #48	; 0x30
 80064c2:	f7fc b8bd 	b.w	8002640 <chOQPutTimeout>
 80064c6:	bf00      	nop
 80064c8:	f3af 8000 	nop.w
 80064cc:	f3af 8000 	nop.w

080064d0 <put>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80064d0:	3030      	adds	r0, #48	; 0x30
 80064d2:	f04f 32ff 	mov.w	r2, #4294967295
 80064d6:	f7fc b8b3 	b.w	8002640 <chOQPutTimeout>
 80064da:	bf00      	nop
 80064dc:	f3af 8000 	nop.w

080064e0 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
 80064e0:	f001 b84e 	b.w	8007580 <sd_lld_init>
 80064e4:	f3af 8000 	nop.w
 80064e8:	f3af 8000 	nop.w
 80064ec:	f3af 8000 	nop.w

080064f0 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80064f0:	b570      	push	{r4, r5, r6, lr}

  sdp->vmt = &vmt;
 80064f2:	4b0e      	ldr	r3, [pc, #56]	; (800652c <sdObjectInit+0x3c>)
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80064f4:	4604      	mov	r4, r0
 80064f6:	b082      	sub	sp, #8

  sdp->vmt = &vmt;
 80064f8:	f840 3b04 	str.w	r3, [r0], #4
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 80064fc:	2601      	movs	r6, #1
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80064fe:	9400      	str	r4, [sp, #0]
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8006500:	460b      	mov	r3, r1
 8006502:	4615      	mov	r5, r2
 8006504:	6060      	str	r0, [r4, #4]

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8006506:	f104 0154 	add.w	r1, r4, #84	; 0x54
 800650a:	f104 000c 	add.w	r0, r4, #12
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 800650e:	7226      	strb	r6, [r4, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8006510:	2210      	movs	r2, #16
 8006512:	f7fb ffcd 	bl	80024b0 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8006516:	9400      	str	r4, [sp, #0]
 8006518:	462b      	mov	r3, r5
 800651a:	f104 0030 	add.w	r0, r4, #48	; 0x30
 800651e:	f104 0164 	add.w	r1, r4, #100	; 0x64
 8006522:	2210      	movs	r2, #16
 8006524:	f7fc f86c 	bl	8002600 <chOQObjectInit>
}
 8006528:	b002      	add	sp, #8
 800652a:	bd70      	pop	{r4, r5, r6, pc}
 800652c:	08016d00 	.word	0x08016d00

08006530 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8006530:	b510      	push	{r4, lr}
 8006532:	2320      	movs	r3, #32
 8006534:	4604      	mov	r4, r0
 8006536:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 800653a:	f001 f841 	bl	80075c0 <sd_lld_start>
  sdp->state = SD_READY;
 800653e:	2302      	movs	r3, #2
 8006540:	7223      	strb	r3, [r4, #8]
 8006542:	2300      	movs	r3, #0
 8006544:	f383 8811 	msr	BASEPRI, r3
 8006548:	bd10      	pop	{r4, pc}
 800654a:	bf00      	nop
 800654c:	f3af 8000 	nop.w

08006550 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8006550:	b538      	push	{r3, r4, r5, lr}

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8006552:	6943      	ldr	r3, [r0, #20]
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8006554:	4604      	mov	r4, r0
 8006556:	460d      	mov	r5, r1

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8006558:	b13b      	cbz	r3, 800656a <sdIncomingDataI+0x1a>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 800655a:	4629      	mov	r1, r5
 800655c:	f104 000c 	add.w	r0, r4, #12
 8006560:	f7fb ffc6 	bl	80024f0 <chIQPutI>
 8006564:	2800      	cmp	r0, #0
 8006566:	db0b      	blt.n	8006580 <sdIncomingDataI+0x30>
 8006568:	bd38      	pop	{r3, r4, r5, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800656a:	3004      	adds	r0, #4
 800656c:	2104      	movs	r1, #4
 800656e:	f7fb fcf7 	bl	8001f60 <chEvtBroadcastFlagsI>
 8006572:	4629      	mov	r1, r5
 8006574:	f104 000c 	add.w	r0, r4, #12
 8006578:	f7fb ffba 	bl	80024f0 <chIQPutI>
 800657c:	2800      	cmp	r0, #0
 800657e:	daf3      	bge.n	8006568 <sdIncomingDataI+0x18>
 8006580:	1d20      	adds	r0, r4, #4
 8006582:	2180      	movs	r1, #128	; 0x80
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
}
 8006584:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8006588:	f7fb bcea 	b.w	8001f60 <chEvtBroadcastFlagsI>
 800658c:	f3af 8000 	nop.w

08006590 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
 8006590:	f000 bf16 	b.w	80073c0 <st_lld_init>
 8006594:	f3af 8000 	nop.w
 8006598:	f3af 8000 	nop.w
 800659c:	f3af 8000 	nop.w

080065a0 <stStartAlarm>:
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80065a0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->SR     = 0;
 80065a4:	2100      	movs	r1, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80065a6:	2202      	movs	r2, #2
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80065a8:	6358      	str	r0, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80065aa:	6119      	str	r1, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80065ac:	60da      	str	r2, [r3, #12]
 80065ae:	4770      	bx	lr

080065b0 <stStopAlarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 80065b0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80065b4:	2200      	movs	r2, #0
 80065b6:	60da      	str	r2, [r3, #12]
 80065b8:	4770      	bx	lr
 80065ba:	bf00      	nop
 80065bc:	f3af 8000 	nop.w

080065c0 <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80065c0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80065c4:	6358      	str	r0, [r3, #52]	; 0x34
 80065c6:	4770      	bx	lr
 80065c8:	f3af 8000 	nop.w
 80065cc:	f3af 8000 	nop.w

080065d0 <uartInit>:
 *
 * @init
 */
void uartInit(void) {

  uart_lld_init();
 80065d0:	f001 b8ae 	b.w	8007730 <uart_lld_init>
 80065d4:	f3af 8000 	nop.w
 80065d8:	f3af 8000 	nop.w
 80065dc:	f3af 8000 	nop.w

080065e0 <uartObjectInit>:
 * @init
 */
void uartObjectInit(UARTDriver *uartp) {

  uartp->state   = UART_STOP;
  uartp->txstate = UART_TX_IDLE;
 80065e0:	2300      	movs	r3, #0
 *
 * @init
 */
void uartObjectInit(UARTDriver *uartp) {

  uartp->state   = UART_STOP;
 80065e2:	2201      	movs	r2, #1
 80065e4:	7002      	strb	r2, [r0, #0]
  uartp->txstate = UART_TX_IDLE;
 80065e6:	7043      	strb	r3, [r0, #1]
  uartp->rxstate = UART_RX_IDLE;
 80065e8:	7083      	strb	r3, [r0, #2]
  uartp->config  = NULL;
 80065ea:	6043      	str	r3, [r0, #4]
 80065ec:	4770      	bx	lr
 80065ee:	bf00      	nop

080065f0 <uartStart>:
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] config    pointer to the @p UARTConfig object
 *
 * @api
 */
void uartStart(UARTDriver *uartp, const UARTConfig *config) {
 80065f0:	b510      	push	{r4, lr}
 80065f2:	2320      	movs	r3, #32
 80065f4:	4604      	mov	r4, r0
 80065f6:	f383 8811 	msr	BASEPRI, r3

  osalSysLock();
  osalDbgAssert((uartp->state == UART_STOP) || (uartp->state == UART_READY),
                "invalid state");

  uartp->config = config;
 80065fa:	6041      	str	r1, [r0, #4]
  uart_lld_start(uartp);
 80065fc:	f001 f8a8 	bl	8007750 <uart_lld_start>
  uartp->state = UART_READY;
 8006600:	2302      	movs	r3, #2
 8006602:	7023      	strb	r3, [r4, #0]
 8006604:	2300      	movs	r3, #0
 8006606:	f383 8811 	msr	BASEPRI, r3
 800660a:	bd10      	pop	{r4, pc}
 800660c:	f3af 8000 	nop.w

08006610 <nvicEnableVector>:
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8006610:	0943      	lsrs	r3, r0, #5
 8006612:	009b      	lsls	r3, r3, #2
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8006614:	b410      	push	{r4}
 8006616:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 800661a:	f100 4460 	add.w	r4, r0, #3758096384	; 0xe0000000
 800661e:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
 8006622:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 8006626:	0109      	lsls	r1, r1, #4
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8006628:	f000 001f 	and.w	r0, r0, #31
 800662c:	2201      	movs	r2, #1
 800662e:	4082      	lsls	r2, r0
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 8006630:	b2c9      	uxtb	r1, r1
 8006632:	f884 1300 	strb.w	r1, [r4, #768]	; 0x300
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8006636:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 800663a:	601a      	str	r2, [r3, #0]
}
 800663c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006640:	4770      	bx	lr
 8006642:	bf00      	nop
 8006644:	f3af 8000 	nop.w
 8006648:	f3af 8000 	nop.w
 800664c:	f3af 8000 	nop.w

08006650 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector6C) {
 8006650:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
 8006652:	4b07      	ldr	r3, [pc, #28]	; (8006670 <Vector6C+0x20>)
  DMA1->LIFCR = flags << 0;
  if (dma_isr_redir[0].dma_func)
 8006654:	4a07      	ldr	r2, [pc, #28]	; (8006674 <Vector6C+0x24>)
OSAL_IRQ_HANDLER(Vector6C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
 8006656:	6819      	ldr	r1, [r3, #0]
 8006658:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0;
 800665c:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[0].dma_func)
 800665e:	6813      	ldr	r3, [r2, #0]
 8006660:	b10b      	cbz	r3, 8006666 <Vector6C+0x16>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 8006662:	6850      	ldr	r0, [r2, #4]
 8006664:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8006666:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 0;
  if (dma_isr_redir[0].dma_func)
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800666a:	f7fa bbf1 	b.w	8000e50 <_port_irq_epilogue>
 800666e:	bf00      	nop
 8006670:	40026000 	.word	0x40026000
 8006674:	20001d78 	.word	0x20001d78
 8006678:	f3af 8000 	nop.w
 800667c:	f3af 8000 	nop.w

08006680 <Vector70>:
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 8006680:	4b08      	ldr	r3, [pc, #32]	; (80066a4 <Vector70+0x24>)
  DMA1->LIFCR = flags << 6;
  if (dma_isr_redir[1].dma_func)
 8006682:	4809      	ldr	r0, [pc, #36]	; (80066a8 <Vector70+0x28>)
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 8006684:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 6;
  if (dma_isr_redir[1].dma_func)
 8006686:	6882      	ldr	r2, [r0, #8]
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 8006688:	0989      	lsrs	r1, r1, #6
 800668a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector70) {
 800668e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 6;
 8006690:	018c      	lsls	r4, r1, #6
 8006692:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[1].dma_func)
 8006694:	b10a      	cbz	r2, 800669a <Vector70+0x1a>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 8006696:	68c0      	ldr	r0, [r0, #12]
 8006698:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800669a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 6;
  if (dma_isr_redir[1].dma_func)
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800669e:	f7fa bbd7 	b.w	8000e50 <_port_irq_epilogue>
 80066a2:	bf00      	nop
 80066a4:	40026000 	.word	0x40026000
 80066a8:	20001d78 	.word	0x20001d78
 80066ac:	f3af 8000 	nop.w

080066b0 <Vector74>:
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 80066b0:	4b08      	ldr	r3, [pc, #32]	; (80066d4 <Vector74+0x24>)
  DMA1->LIFCR = flags << 16;
  if (dma_isr_redir[2].dma_func)
 80066b2:	4809      	ldr	r0, [pc, #36]	; (80066d8 <Vector74+0x28>)
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 80066b4:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 16;
  if (dma_isr_redir[2].dma_func)
 80066b6:	6902      	ldr	r2, [r0, #16]
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 80066b8:	0c09      	lsrs	r1, r1, #16
 80066ba:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector74) {
 80066be:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 16;
 80066c0:	040c      	lsls	r4, r1, #16
 80066c2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[2].dma_func)
 80066c4:	b10a      	cbz	r2, 80066ca <Vector74+0x1a>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 80066c6:	6940      	ldr	r0, [r0, #20]
 80066c8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 80066ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 16;
  if (dma_isr_redir[2].dma_func)
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80066ce:	f7fa bbbf 	b.w	8000e50 <_port_irq_epilogue>
 80066d2:	bf00      	nop
 80066d4:	40026000 	.word	0x40026000
 80066d8:	20001d78 	.word	0x20001d78
 80066dc:	f3af 8000 	nop.w

080066e0 <Vector78>:
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 80066e0:	4b08      	ldr	r3, [pc, #32]	; (8006704 <Vector78+0x24>)
  DMA1->LIFCR = flags << 22;
  if (dma_isr_redir[3].dma_func)
 80066e2:	4809      	ldr	r0, [pc, #36]	; (8006708 <Vector78+0x28>)
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 80066e4:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 22;
  if (dma_isr_redir[3].dma_func)
 80066e6:	6982      	ldr	r2, [r0, #24]
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 80066e8:	0d89      	lsrs	r1, r1, #22
 80066ea:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector78) {
 80066ee:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 22;
 80066f0:	058c      	lsls	r4, r1, #22
 80066f2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[3].dma_func)
 80066f4:	b10a      	cbz	r2, 80066fa <Vector78+0x1a>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 80066f6:	69c0      	ldr	r0, [r0, #28]
 80066f8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 80066fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 22;
  if (dma_isr_redir[3].dma_func)
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80066fe:	f7fa bba7 	b.w	8000e50 <_port_irq_epilogue>
 8006702:	bf00      	nop
 8006704:	40026000 	.word	0x40026000
 8006708:	20001d78 	.word	0x20001d78
 800670c:	f3af 8000 	nop.w

08006710 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector7C) {
 8006710:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 8006712:	4b07      	ldr	r3, [pc, #28]	; (8006730 <Vector7C+0x20>)
  DMA1->HIFCR = flags << 0;
  if (dma_isr_redir[4].dma_func)
 8006714:	4807      	ldr	r0, [pc, #28]	; (8006734 <Vector7C+0x24>)
OSAL_IRQ_HANDLER(Vector7C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 8006716:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 0;
  if (dma_isr_redir[4].dma_func)
 8006718:	6a02      	ldr	r2, [r0, #32]
OSAL_IRQ_HANDLER(Vector7C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 800671a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0;
 800671e:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[4].dma_func)
 8006720:	b10a      	cbz	r2, 8006726 <Vector7C+0x16>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 8006722:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8006724:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8006726:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 0;
  if (dma_isr_redir[4].dma_func)
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800672a:	f7fa bb91 	b.w	8000e50 <_port_irq_epilogue>
 800672e:	bf00      	nop
 8006730:	40026000 	.word	0x40026000
 8006734:	20001d78 	.word	0x20001d78
 8006738:	f3af 8000 	nop.w
 800673c:	f3af 8000 	nop.w

08006740 <Vector80>:
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 8006740:	4b08      	ldr	r3, [pc, #32]	; (8006764 <Vector80+0x24>)
  DMA1->HIFCR = flags << 6;
  if (dma_isr_redir[5].dma_func)
 8006742:	4809      	ldr	r0, [pc, #36]	; (8006768 <Vector80+0x28>)
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 8006744:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 6;
  if (dma_isr_redir[5].dma_func)
 8006746:	6a82      	ldr	r2, [r0, #40]	; 0x28
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 8006748:	0989      	lsrs	r1, r1, #6
 800674a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector80) {
 800674e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 6;
 8006750:	018c      	lsls	r4, r1, #6
 8006752:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[5].dma_func)
 8006754:	b10a      	cbz	r2, 800675a <Vector80+0x1a>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 8006756:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8006758:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800675a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 6;
  if (dma_isr_redir[5].dma_func)
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800675e:	f7fa bb77 	b.w	8000e50 <_port_irq_epilogue>
 8006762:	bf00      	nop
 8006764:	40026000 	.word	0x40026000
 8006768:	20001d78 	.word	0x20001d78
 800676c:	f3af 8000 	nop.w

08006770 <Vector84>:
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 8006770:	4b08      	ldr	r3, [pc, #32]	; (8006794 <Vector84+0x24>)
  DMA1->HIFCR = flags << 16;
  if (dma_isr_redir[6].dma_func)
 8006772:	4809      	ldr	r0, [pc, #36]	; (8006798 <Vector84+0x28>)
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 8006774:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 16;
  if (dma_isr_redir[6].dma_func)
 8006776:	6b02      	ldr	r2, [r0, #48]	; 0x30
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 8006778:	0c09      	lsrs	r1, r1, #16
 800677a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector84) {
 800677e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 16;
 8006780:	040c      	lsls	r4, r1, #16
 8006782:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[6].dma_func)
 8006784:	b10a      	cbz	r2, 800678a <Vector84+0x1a>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 8006786:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8006788:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800678a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 16;
  if (dma_isr_redir[6].dma_func)
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800678e:	f7fa bb5f 	b.w	8000e50 <_port_irq_epilogue>
 8006792:	bf00      	nop
 8006794:	40026000 	.word	0x40026000
 8006798:	20001d78 	.word	0x20001d78
 800679c:	f3af 8000 	nop.w

080067a0 <VectorFC>:
OSAL_IRQ_HANDLER(VectorFC) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 80067a0:	4b08      	ldr	r3, [pc, #32]	; (80067c4 <VectorFC+0x24>)
  DMA1->HIFCR = flags << 22;
  if (dma_isr_redir[7].dma_func)
 80067a2:	4809      	ldr	r0, [pc, #36]	; (80067c8 <VectorFC+0x28>)
OSAL_IRQ_HANDLER(VectorFC) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 80067a4:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 22;
  if (dma_isr_redir[7].dma_func)
 80067a6:	6b82      	ldr	r2, [r0, #56]	; 0x38
OSAL_IRQ_HANDLER(VectorFC) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 80067a8:	0d89      	lsrs	r1, r1, #22
 80067aa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorFC) {
 80067ae:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 22;
 80067b0:	058c      	lsls	r4, r1, #22
 80067b2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[7].dma_func)
 80067b4:	b10a      	cbz	r2, 80067ba <VectorFC+0x1a>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 80067b6:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 80067b8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 80067ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 22;
  if (dma_isr_redir[7].dma_func)
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80067be:	f7fa bb47 	b.w	8000e50 <_port_irq_epilogue>
 80067c2:	bf00      	nop
 80067c4:	40026000 	.word	0x40026000
 80067c8:	20001d78 	.word	0x20001d78
 80067cc:	f3af 8000 	nop.w

080067d0 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector120) {
 80067d0:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 80067d2:	4b07      	ldr	r3, [pc, #28]	; (80067f0 <Vector120+0x20>)
  DMA2->LIFCR = flags << 0;
  if (dma_isr_redir[8].dma_func)
 80067d4:	4807      	ldr	r0, [pc, #28]	; (80067f4 <Vector120+0x24>)
OSAL_IRQ_HANDLER(Vector120) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 80067d6:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 0;
  if (dma_isr_redir[8].dma_func)
 80067d8:	6c02      	ldr	r2, [r0, #64]	; 0x40
OSAL_IRQ_HANDLER(Vector120) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 80067da:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0;
 80067de:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[8].dma_func)
 80067e0:	b10a      	cbz	r2, 80067e6 <Vector120+0x16>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 80067e2:	6c40      	ldr	r0, [r0, #68]	; 0x44
 80067e4:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 80067e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 0;
  if (dma_isr_redir[8].dma_func)
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80067ea:	f7fa bb31 	b.w	8000e50 <_port_irq_epilogue>
 80067ee:	bf00      	nop
 80067f0:	40026400 	.word	0x40026400
 80067f4:	20001d78 	.word	0x20001d78
 80067f8:	f3af 8000 	nop.w
 80067fc:	f3af 8000 	nop.w

08006800 <Vector124>:
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 8006800:	4b08      	ldr	r3, [pc, #32]	; (8006824 <Vector124+0x24>)
  DMA2->LIFCR = flags << 6;
  if (dma_isr_redir[9].dma_func)
 8006802:	4809      	ldr	r0, [pc, #36]	; (8006828 <Vector124+0x28>)
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 8006804:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 6;
  if (dma_isr_redir[9].dma_func)
 8006806:	6c82      	ldr	r2, [r0, #72]	; 0x48
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 8006808:	0989      	lsrs	r1, r1, #6
 800680a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector124) {
 800680e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 6;
 8006810:	018c      	lsls	r4, r1, #6
 8006812:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[9].dma_func)
 8006814:	b10a      	cbz	r2, 800681a <Vector124+0x1a>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 8006816:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 8006818:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800681a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 6;
  if (dma_isr_redir[9].dma_func)
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800681e:	f7fa bb17 	b.w	8000e50 <_port_irq_epilogue>
 8006822:	bf00      	nop
 8006824:	40026400 	.word	0x40026400
 8006828:	20001d78 	.word	0x20001d78
 800682c:	f3af 8000 	nop.w

08006830 <Vector128>:
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 8006830:	4b08      	ldr	r3, [pc, #32]	; (8006854 <Vector128+0x24>)
  DMA2->LIFCR = flags << 16;
  if (dma_isr_redir[10].dma_func)
 8006832:	4809      	ldr	r0, [pc, #36]	; (8006858 <Vector128+0x28>)
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 8006834:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 16;
  if (dma_isr_redir[10].dma_func)
 8006836:	6d02      	ldr	r2, [r0, #80]	; 0x50
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 8006838:	0c09      	lsrs	r1, r1, #16
 800683a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector128) {
 800683e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 16;
 8006840:	040c      	lsls	r4, r1, #16
 8006842:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[10].dma_func)
 8006844:	b10a      	cbz	r2, 800684a <Vector128+0x1a>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 8006846:	6d40      	ldr	r0, [r0, #84]	; 0x54
 8006848:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800684a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 16;
  if (dma_isr_redir[10].dma_func)
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800684e:	f7fa baff 	b.w	8000e50 <_port_irq_epilogue>
 8006852:	bf00      	nop
 8006854:	40026400 	.word	0x40026400
 8006858:	20001d78 	.word	0x20001d78
 800685c:	f3af 8000 	nop.w

08006860 <Vector12C>:
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 8006860:	4b08      	ldr	r3, [pc, #32]	; (8006884 <Vector12C+0x24>)
  DMA2->LIFCR = flags << 22;
  if (dma_isr_redir[11].dma_func)
 8006862:	4809      	ldr	r0, [pc, #36]	; (8006888 <Vector12C+0x28>)
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 8006864:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 22;
  if (dma_isr_redir[11].dma_func)
 8006866:	6d82      	ldr	r2, [r0, #88]	; 0x58
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 8006868:	0d89      	lsrs	r1, r1, #22
 800686a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector12C) {
 800686e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 22;
 8006870:	058c      	lsls	r4, r1, #22
 8006872:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[11].dma_func)
 8006874:	b10a      	cbz	r2, 800687a <Vector12C+0x1a>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 8006876:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 8006878:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800687a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 22;
  if (dma_isr_redir[11].dma_func)
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800687e:	f7fa bae7 	b.w	8000e50 <_port_irq_epilogue>
 8006882:	bf00      	nop
 8006884:	40026400 	.word	0x40026400
 8006888:	20001d78 	.word	0x20001d78
 800688c:	f3af 8000 	nop.w

08006890 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector130) {
 8006890:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 8006892:	4b07      	ldr	r3, [pc, #28]	; (80068b0 <Vector130+0x20>)
  DMA2->HIFCR = flags << 0;
  if (dma_isr_redir[12].dma_func)
 8006894:	4807      	ldr	r0, [pc, #28]	; (80068b4 <Vector130+0x24>)
OSAL_IRQ_HANDLER(Vector130) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 8006896:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 0;
  if (dma_isr_redir[12].dma_func)
 8006898:	6e02      	ldr	r2, [r0, #96]	; 0x60
OSAL_IRQ_HANDLER(Vector130) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 800689a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0;
 800689e:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[12].dma_func)
 80068a0:	b10a      	cbz	r2, 80068a6 <Vector130+0x16>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 80068a2:	6e40      	ldr	r0, [r0, #100]	; 0x64
 80068a4:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 80068a6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 0;
  if (dma_isr_redir[12].dma_func)
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80068aa:	f7fa bad1 	b.w	8000e50 <_port_irq_epilogue>
 80068ae:	bf00      	nop
 80068b0:	40026400 	.word	0x40026400
 80068b4:	20001d78 	.word	0x20001d78
 80068b8:	f3af 8000 	nop.w
 80068bc:	f3af 8000 	nop.w

080068c0 <Vector150>:
OSAL_IRQ_HANDLER(Vector150) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 80068c0:	4b08      	ldr	r3, [pc, #32]	; (80068e4 <Vector150+0x24>)
  DMA2->HIFCR = flags << 6;
  if (dma_isr_redir[13].dma_func)
 80068c2:	4809      	ldr	r0, [pc, #36]	; (80068e8 <Vector150+0x28>)
OSAL_IRQ_HANDLER(Vector150) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 80068c4:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 6;
  if (dma_isr_redir[13].dma_func)
 80068c6:	6e82      	ldr	r2, [r0, #104]	; 0x68
OSAL_IRQ_HANDLER(Vector150) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 80068c8:	0989      	lsrs	r1, r1, #6
 80068ca:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector150) {
 80068ce:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 6;
 80068d0:	018c      	lsls	r4, r1, #6
 80068d2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[13].dma_func)
 80068d4:	b10a      	cbz	r2, 80068da <Vector150+0x1a>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 80068d6:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 80068d8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 80068da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 6;
  if (dma_isr_redir[13].dma_func)
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80068de:	f7fa bab7 	b.w	8000e50 <_port_irq_epilogue>
 80068e2:	bf00      	nop
 80068e4:	40026400 	.word	0x40026400
 80068e8:	20001d78 	.word	0x20001d78
 80068ec:	f3af 8000 	nop.w

080068f0 <Vector154>:
OSAL_IRQ_HANDLER(Vector154) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 80068f0:	4b08      	ldr	r3, [pc, #32]	; (8006914 <Vector154+0x24>)
  DMA2->HIFCR = flags << 16;
  if (dma_isr_redir[14].dma_func)
 80068f2:	4809      	ldr	r0, [pc, #36]	; (8006918 <Vector154+0x28>)
OSAL_IRQ_HANDLER(Vector154) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 80068f4:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 16;
  if (dma_isr_redir[14].dma_func)
 80068f6:	6f02      	ldr	r2, [r0, #112]	; 0x70
OSAL_IRQ_HANDLER(Vector154) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 80068f8:	0c09      	lsrs	r1, r1, #16
 80068fa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector154) {
 80068fe:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 16;
 8006900:	040c      	lsls	r4, r1, #16
 8006902:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[14].dma_func)
 8006904:	b10a      	cbz	r2, 800690a <Vector154+0x1a>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 8006906:	6f40      	ldr	r0, [r0, #116]	; 0x74
 8006908:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800690a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 16;
  if (dma_isr_redir[14].dma_func)
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800690e:	f7fa ba9f 	b.w	8000e50 <_port_irq_epilogue>
 8006912:	bf00      	nop
 8006914:	40026400 	.word	0x40026400
 8006918:	20001d78 	.word	0x20001d78
 800691c:	f3af 8000 	nop.w

08006920 <Vector158>:
OSAL_IRQ_HANDLER(Vector158) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 8006920:	4b08      	ldr	r3, [pc, #32]	; (8006944 <Vector158+0x24>)
  DMA2->HIFCR = flags << 22;
  if (dma_isr_redir[15].dma_func)
 8006922:	4809      	ldr	r0, [pc, #36]	; (8006948 <Vector158+0x28>)
OSAL_IRQ_HANDLER(Vector158) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 8006924:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 22;
  if (dma_isr_redir[15].dma_func)
 8006926:	6f82      	ldr	r2, [r0, #120]	; 0x78
OSAL_IRQ_HANDLER(Vector158) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 8006928:	0d89      	lsrs	r1, r1, #22
 800692a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector158) {
 800692e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 22;
 8006930:	058c      	lsls	r4, r1, #22
 8006932:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[15].dma_func)
 8006934:	b10a      	cbz	r2, 800693a <Vector158+0x1a>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 8006936:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 8006938:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800693a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 22;
  if (dma_isr_redir[15].dma_func)
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800693e:	f7fa ba87 	b.w	8000e50 <_port_irq_epilogue>
 8006942:	bf00      	nop
 8006944:	40026400 	.word	0x40026400
 8006948:	20001d78 	.word	0x20001d78
 800694c:	f3af 8000 	nop.w

08006950 <dmaInit>:
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
 8006950:	4b0d      	ldr	r3, [pc, #52]	; (8006988 <dmaInit+0x38>)
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8006952:	b430      	push	{r4, r5}
  int i;

  dma_streams_mask = 0;
 8006954:	2200      	movs	r2, #0
 8006956:	4d0d      	ldr	r5, [pc, #52]	; (800698c <dmaInit+0x3c>)
 8006958:	4c0d      	ldr	r4, [pc, #52]	; (8006990 <dmaInit+0x40>)
 800695a:	601a      	str	r2, [r3, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0;
 800695c:	4611      	mov	r1, r2
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800695e:	4613      	mov	r3, r2
    _stm32_dma_streams[i].stream->CR = 0;
 8006960:	58a8      	ldr	r0, [r5, r2]
 8006962:	6001      	str	r1, [r0, #0]
    dma_isr_redir[i].dma_func = NULL;
 8006964:	f844 1033 	str.w	r1, [r4, r3, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8006968:	3301      	adds	r3, #1
 800696a:	2b10      	cmp	r3, #16
 800696c:	f102 020c 	add.w	r2, r2, #12
 8006970:	d1f6      	bne.n	8006960 <dmaInit+0x10>
    _stm32_dma_streams[i].stream->CR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFF;
 8006972:	4908      	ldr	r1, [pc, #32]	; (8006994 <dmaInit+0x44>)
  DMA1->HIFCR = 0xFFFFFFFF;
  DMA2->LIFCR = 0xFFFFFFFF;
 8006974:	4a08      	ldr	r2, [pc, #32]	; (8006998 <dmaInit+0x48>)
  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFF;
 8006976:	f04f 33ff 	mov.w	r3, #4294967295
 800697a:	608b      	str	r3, [r1, #8]
  DMA1->HIFCR = 0xFFFFFFFF;
  DMA2->LIFCR = 0xFFFFFFFF;
  DMA2->HIFCR = 0xFFFFFFFF;
}
 800697c:	bc30      	pop	{r4, r5}
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFF;
  DMA1->HIFCR = 0xFFFFFFFF;
 800697e:	60cb      	str	r3, [r1, #12]
  DMA2->LIFCR = 0xFFFFFFFF;
 8006980:	6093      	str	r3, [r2, #8]
  DMA2->HIFCR = 0xFFFFFFFF;
 8006982:	60d3      	str	r3, [r2, #12]
}
 8006984:	4770      	bx	lr
 8006986:	bf00      	nop
 8006988:	20001df8 	.word	0x20001df8
 800698c:	08016d20 	.word	0x08016d20
 8006990:	20001d78 	.word	0x20001d78
 8006994:	40026000 	.word	0x40026000
 8006998:	40026400 	.word	0x40026400
 800699c:	f3af 8000 	nop.w

080069a0 <hal_lld_init>:
 */
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 80069a0:	4b1d      	ldr	r3, [pc, #116]	; (8006a18 <hal_lld_init+0x78>)
 80069a2:	f04f 31ff 	mov.w	r1, #4294967295
 80069a6:	691a      	ldr	r2, [r3, #16]
 80069a8:	2200      	movs	r2, #0
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80069aa:	b410      	push	{r4}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 80069ac:	6119      	str	r1, [r3, #16]
 80069ae:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 80069b0:	6958      	ldr	r0, [r3, #20]
 80069b2:	6159      	str	r1, [r3, #20]
 80069b4:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 80069b6:	6a18      	ldr	r0, [r3, #32]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80069b8:	4c18      	ldr	r4, [pc, #96]	; (8006a1c <hal_lld_init+0x7c>)

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
  rccResetAHB2(~0);
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 80069ba:	f060 5080 	orn	r0, r0, #268435456	; 0x10000000
 80069be:	6218      	str	r0, [r3, #32]
 80069c0:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 80069c2:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80069c4:	6259      	str	r1, [r3, #36]	; 0x24
 80069c6:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80069c8:	6c19      	ldr	r1, [r3, #64]	; 0x40
 80069ca:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 80069ce:	6419      	str	r1, [r3, #64]	; 0x40
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80069d0:	6821      	ldr	r1, [r4, #0]
 80069d2:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 80069d6:	6021      	str	r1, [r4, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 80069d8:	6f19      	ldr	r1, [r3, #112]	; 0x70
 80069da:	f401 7140 	and.w	r1, r1, #768	; 0x300
 80069de:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 80069e2:	d003      	beq.n	80069ec <hal_lld_init+0x4c>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 80069e4:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 80069e8:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 80069ea:	671a      	str	r2, [r3, #112]	; 0x70
#endif

#if HAL_USE_RTC
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 80069ec:	4b0a      	ldr	r3, [pc, #40]	; (8006a18 <hal_lld_init+0x78>)
 80069ee:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80069f0:	0412      	lsls	r2, r2, #16
 80069f2:	d407      	bmi.n	8006a04 <hal_lld_init+0x64>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 80069f4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80069f6:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80069fa:	671a      	str	r2, [r3, #112]	; 0x70

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 80069fc:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80069fe:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8006a02:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8006a04:	4a05      	ldr	r2, [pc, #20]	; (8006a1c <hal_lld_init+0x7c>)

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 8006a06:	f85d 4b04 	ldr.w	r4, [sp], #4

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8006a0a:	6853      	ldr	r3, [r2, #4]
 8006a0c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8006a10:	6053      	str	r3, [r2, #4]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8006a12:	f7ff bf9d 	b.w	8006950 <dmaInit>
 8006a16:	bf00      	nop
 8006a18:	40023800 	.word	0x40023800
 8006a1c:	40007000 	.word	0x40007000

08006a20 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8006a20:	492c      	ldr	r1, [pc, #176]	; (8006ad4 <stm32_clock_init+0xb4>)

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8006a22:	4b2d      	ldr	r3, [pc, #180]	; (8006ad8 <stm32_clock_init+0xb8>)
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8006a24:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8006a28:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8006a2c:	6408      	str	r0, [r1, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8006a2e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8006a30:	680b      	ldr	r3, [r1, #0]
 8006a32:	f043 0301 	orr.w	r3, r3, #1
 8006a36:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8006a38:	680a      	ldr	r2, [r1, #0]
 8006a3a:	4b26      	ldr	r3, [pc, #152]	; (8006ad4 <stm32_clock_init+0xb4>)
 8006a3c:	0790      	lsls	r0, r2, #30
 8006a3e:	d5fb      	bpl.n	8006a38 <stm32_clock_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8006a40:	689a      	ldr	r2, [r3, #8]
 8006a42:	f022 0203 	bic.w	r2, r2, #3
 8006a46:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8006a48:	689a      	ldr	r2, [r3, #8]
 8006a4a:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8006a4c:	4619      	mov	r1, r3
 8006a4e:	688b      	ldr	r3, [r1, #8]
 8006a50:	4a20      	ldr	r2, [pc, #128]	; (8006ad4 <stm32_clock_init+0xb4>)
 8006a52:	f013 030c 	ands.w	r3, r3, #12
 8006a56:	d1fa      	bne.n	8006a4e <stm32_clock_init+0x2e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8006a58:	6811      	ldr	r1, [r2, #0]
 8006a5a:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 8006a5e:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8006a60:	6093      	str	r3, [r2, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 8006a62:	6813      	ldr	r3, [r2, #0]
 8006a64:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8006a68:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8006a6a:	6811      	ldr	r1, [r2, #0]
 8006a6c:	4b19      	ldr	r3, [pc, #100]	; (8006ad4 <stm32_clock_init+0xb4>)
 8006a6e:	0389      	lsls	r1, r1, #14
 8006a70:	d5fb      	bpl.n	8006a6a <stm32_clock_init+0x4a>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8006a72:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8006a74:	f042 0201 	orr.w	r2, r2, #1
 8006a78:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8006a7a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8006a7c:	4915      	ldr	r1, [pc, #84]	; (8006ad4 <stm32_clock_init+0xb4>)
 8006a7e:	0790      	lsls	r0, r2, #30
 8006a80:	d5fb      	bpl.n	8006a7a <stm32_clock_init+0x5a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8006a82:	4b16      	ldr	r3, [pc, #88]	; (8006adc <stm32_clock_init+0xbc>)
 8006a84:	604b      	str	r3, [r1, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8006a86:	680b      	ldr	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8006a88:	4a13      	ldr	r2, [pc, #76]	; (8006ad8 <stm32_clock_init+0xb8>)

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8006a8a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8006a8e:	600b      	str	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8006a90:	6853      	ldr	r3, [r2, #4]
 8006a92:	0459      	lsls	r1, r3, #17
 8006a94:	d5fc      	bpl.n	8006a90 <stm32_clock_init+0x70>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8006a96:	490f      	ldr	r1, [pc, #60]	; (8006ad4 <stm32_clock_init+0xb4>)
 8006a98:	680a      	ldr	r2, [r1, #0]
 8006a9a:	4b0e      	ldr	r3, [pc, #56]	; (8006ad4 <stm32_clock_init+0xb4>)
 8006a9c:	0192      	lsls	r2, r2, #6
 8006a9e:	d5fb      	bpl.n	8006a98 <stm32_clock_init+0x78>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8006aa0:	4a0f      	ldr	r2, [pc, #60]	; (8006ae0 <stm32_clock_init+0xc0>)
  while (!(RCC->CR & RCC_CR_PLLI2SRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8006aa2:	4910      	ldr	r1, [pc, #64]	; (8006ae4 <stm32_clock_init+0xc4>)
 8006aa4:	6099      	str	r1, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8006aa6:	f240 7104 	movw	r1, #1796	; 0x704
 8006aaa:	6011      	str	r1, [r2, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8006aac:	689a      	ldr	r2, [r3, #8]
 8006aae:	f042 0202 	orr.w	r2, r2, #2
 8006ab2:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8006ab4:	461a      	mov	r2, r3
 8006ab6:	6893      	ldr	r3, [r2, #8]
 8006ab8:	4906      	ldr	r1, [pc, #24]	; (8006ad4 <stm32_clock_init+0xb4>)
 8006aba:	f003 030c 	and.w	r3, r3, #12
 8006abe:	2b08      	cmp	r3, #8
 8006ac0:	d1f9      	bne.n	8006ab6 <stm32_clock_init+0x96>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8006ac2:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 8006ac4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8006ac8:	644b      	str	r3, [r1, #68]	; 0x44
 8006aca:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 8006acc:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8006ad0:	664b      	str	r3, [r1, #100]	; 0x64
 8006ad2:	4770      	bx	lr
 8006ad4:	40023800 	.word	0x40023800
 8006ad8:	40007000 	.word	0x40007000
 8006adc:	07404b19 	.word	0x07404b19
 8006ae0:	40023c00 	.word	0x40023c00
 8006ae4:	3d689400 	.word	0x3d689400
 8006ae8:	f3af 8000 	nop.w
 8006aec:	f3af 8000 	nop.w

08006af0 <mac_lld_set_address>:
 * @brief   MAC address setup.
 *
 * @param[in] p         pointer to a six bytes buffer containing the MAC
 *                      address
 */
static void mac_lld_set_address(const uint8_t *p) {
 8006af0:	b430      	push	{r4, r5}

  /* MAC address configuration, only a single address comparator is used,
     hash table not used.*/
  ETH->MACA0HR   = ((uint32_t)p[5] << 8) |
 8006af2:	7941      	ldrb	r1, [r0, #5]
                   ((uint32_t)p[4] << 0);
 8006af4:	7902      	ldrb	r2, [r0, #4]
 */
static void mac_lld_set_address(const uint8_t *p) {

  /* MAC address configuration, only a single address comparator is used,
     hash table not used.*/
  ETH->MACA0HR   = ((uint32_t)p[5] << 8) |
 8006af6:	4b0f      	ldr	r3, [pc, #60]	; (8006b34 <mac_lld_set_address+0x44>)
 8006af8:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8006afc:	641a      	str	r2, [r3, #64]	; 0x40
                   ((uint32_t)p[4] << 0);
  ETH->MACA0LR   = ((uint32_t)p[3] << 24) |
                   ((uint32_t)p[2] << 16) |
 8006afe:	7884      	ldrb	r4, [r0, #2]

  /* MAC address configuration, only a single address comparator is used,
     hash table not used.*/
  ETH->MACA0HR   = ((uint32_t)p[5] << 8) |
                   ((uint32_t)p[4] << 0);
  ETH->MACA0LR   = ((uint32_t)p[3] << 24) |
 8006b00:	78c2      	ldrb	r2, [r0, #3]
                   ((uint32_t)p[2] << 16) |
                   ((uint32_t)p[1] << 8) |
                   ((uint32_t)p[0] << 0);
 8006b02:	7801      	ldrb	r1, [r0, #0]
     hash table not used.*/
  ETH->MACA0HR   = ((uint32_t)p[5] << 8) |
                   ((uint32_t)p[4] << 0);
  ETH->MACA0LR   = ((uint32_t)p[3] << 24) |
                   ((uint32_t)p[2] << 16) |
                   ((uint32_t)p[1] << 8) |
 8006b04:	7845      	ldrb	r5, [r0, #1]
  /* MAC address configuration, only a single address comparator is used,
     hash table not used.*/
  ETH->MACA0HR   = ((uint32_t)p[5] << 8) |
                   ((uint32_t)p[4] << 0);
  ETH->MACA0LR   = ((uint32_t)p[3] << 24) |
                   ((uint32_t)p[2] << 16) |
 8006b06:	0420      	lsls	r0, r4, #16

  /* MAC address configuration, only a single address comparator is used,
     hash table not used.*/
  ETH->MACA0HR   = ((uint32_t)p[5] << 8) |
                   ((uint32_t)p[4] << 0);
  ETH->MACA0LR   = ((uint32_t)p[3] << 24) |
 8006b08:	ea40 6202 	orr.w	r2, r0, r2, lsl #24
 8006b0c:	430a      	orrs	r2, r1
                   ((uint32_t)p[2] << 16) |
                   ((uint32_t)p[1] << 8) |
                   ((uint32_t)p[0] << 0);
  ETH->MACA1HR   = 0x0000FFFF;
 8006b0e:	f64f 70ff 	movw	r0, #65535	; 0xffff
  ETH->MACA1LR   = 0xFFFFFFFF;
 8006b12:	f04f 31ff 	mov.w	r1, #4294967295
  ETH->MACA2HR   = 0x0000FFFF;
  ETH->MACA2LR   = 0xFFFFFFFF;
  ETH->MACA3HR   = 0x0000FFFF;
  ETH->MACA3LR   = 0xFFFFFFFF;
  ETH->MACHTHR   = 0;
 8006b16:	2400      	movs	r4, #0
     hash table not used.*/
  ETH->MACA0HR   = ((uint32_t)p[5] << 8) |
                   ((uint32_t)p[4] << 0);
  ETH->MACA0LR   = ((uint32_t)p[3] << 24) |
                   ((uint32_t)p[2] << 16) |
                   ((uint32_t)p[1] << 8) |
 8006b18:	ea42 2205 	orr.w	r2, r2, r5, lsl #8

  /* MAC address configuration, only a single address comparator is used,
     hash table not used.*/
  ETH->MACA0HR   = ((uint32_t)p[5] << 8) |
                   ((uint32_t)p[4] << 0);
  ETH->MACA0LR   = ((uint32_t)p[3] << 24) |
 8006b1c:	645a      	str	r2, [r3, #68]	; 0x44
                   ((uint32_t)p[2] << 16) |
                   ((uint32_t)p[1] << 8) |
                   ((uint32_t)p[0] << 0);
  ETH->MACA1HR   = 0x0000FFFF;
 8006b1e:	6498      	str	r0, [r3, #72]	; 0x48
  ETH->MACA1LR   = 0xFFFFFFFF;
 8006b20:	64d9      	str	r1, [r3, #76]	; 0x4c
  ETH->MACA2HR   = 0x0000FFFF;
 8006b22:	6518      	str	r0, [r3, #80]	; 0x50
  ETH->MACA2LR   = 0xFFFFFFFF;
 8006b24:	6559      	str	r1, [r3, #84]	; 0x54
  ETH->MACA3HR   = 0x0000FFFF;
 8006b26:	6598      	str	r0, [r3, #88]	; 0x58
  ETH->MACA3LR   = 0xFFFFFFFF;
 8006b28:	65d9      	str	r1, [r3, #92]	; 0x5c
  ETH->MACHTHR   = 0;
 8006b2a:	609c      	str	r4, [r3, #8]
  ETH->MACHTLR   = 0;
 8006b2c:	60dc      	str	r4, [r3, #12]
}
 8006b2e:	bc30      	pop	{r4, r5}
 8006b30:	4770      	bx	lr
 8006b32:	bf00      	nop
 8006b34:	40028000 	.word	0x40028000
 8006b38:	f3af 8000 	nop.w
 8006b3c:	f3af 8000 	nop.w

08006b40 <chprintf.constprop.2>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8006b40:	b40e      	push	{r1, r2, r3}
 8006b42:	b500      	push	{lr}
 8006b44:	b082      	sub	sp, #8
 8006b46:	aa03      	add	r2, sp, #12
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
 8006b48:	4805      	ldr	r0, [pc, #20]	; (8006b60 <chprintf.constprop.2+0x20>)
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8006b4a:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8006b4e:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8006b50:	f00a f8d6 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8006b54:	b002      	add	sp, #8
 8006b56:	f85d eb04 	ldr.w	lr, [sp], #4
 8006b5a:	b003      	add	sp, #12
 8006b5c:	4770      	bx	lr
 8006b5e:	bf00      	nop
 8006b60:	200180c8 	.word	0x200180c8
 8006b64:	f3af 8000 	nop.w
 8006b68:	f3af 8000 	nop.w
 8006b6c:	f3af 8000 	nop.w

08006b70 <Vector134>:
OSAL_IRQ_HANDLER(ETH_IRQHandler) {
  uint32_t dmasr;

  OSAL_IRQ_PROLOGUE();

  dmasr = ETH->DMASR;
 8006b70:	4a14      	ldr	r2, [pc, #80]	; (8006bc4 <Vector134+0x54>)
 8006b72:	f241 0314 	movw	r3, #4116	; 0x1014

/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

OSAL_IRQ_HANDLER(ETH_IRQHandler) {
 8006b76:	b510      	push	{r4, lr}
  uint32_t dmasr;

  OSAL_IRQ_PROLOGUE();

  dmasr = ETH->DMASR;
 8006b78:	58d4      	ldr	r4, [r2, r3]
  ETH->DMASR = dmasr; /* Clear status bits.*/
 8006b7a:	50d4      	str	r4, [r2, r3]

  if (dmasr & ETH_DMASR_RS) {
 8006b7c:	0662      	lsls	r2, r4, #25
 8006b7e:	d410      	bmi.n	8006ba2 <Vector134+0x32>
    osalEventBroadcastFlagsI(&ETHD1.rdevent, 0);
#endif
    osalSysUnlockFromISR();
  }

  if (dmasr & ETH_DMASR_TS) {
 8006b80:	07e3      	lsls	r3, r4, #31
 8006b82:	d50a      	bpl.n	8006b9a <Vector134+0x2a>
 8006b84:	2320      	movs	r3, #32
 8006b86:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 8006b8a:	480f      	ldr	r0, [pc, #60]	; (8006bc8 <Vector134+0x58>)
 8006b8c:	f06f 0101 	mvn.w	r1, #1
 8006b90:	f7fa fdce 	bl	8001730 <chThdDequeueAllI>
 8006b94:	2300      	movs	r3, #0
 8006b96:	f383 8811 	msr	BASEPRI, r3
    osalThreadDequeueAllI(&ETHD1.tdqueue, MSG_RESET);
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 8006b9a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    osalSysLockFromISR();
    osalThreadDequeueAllI(&ETHD1.tdqueue, MSG_RESET);
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8006b9e:	f7fa b957 	b.w	8000e50 <_port_irq_epilogue>
 8006ba2:	2320      	movs	r3, #32
 8006ba4:	f383 8811 	msr	BASEPRI, r3
 8006ba8:	4808      	ldr	r0, [pc, #32]	; (8006bcc <Vector134+0x5c>)
 8006baa:	f06f 0101 	mvn.w	r1, #1
 8006bae:	f7fa fdbf 	bl	8001730 <chThdDequeueAllI>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8006bb2:	4807      	ldr	r0, [pc, #28]	; (8006bd0 <Vector134+0x60>)
 8006bb4:	2100      	movs	r1, #0
 8006bb6:	f7fb f9d3 	bl	8001f60 <chEvtBroadcastFlagsI>
 8006bba:	2300      	movs	r3, #0
 8006bbc:	f383 8811 	msr	BASEPRI, r3
 8006bc0:	e7de      	b.n	8006b80 <Vector134+0x10>
 8006bc2:	bf00      	nop
 8006bc4:	40028000 	.word	0x40028000
 8006bc8:	20001e04 	.word	0x20001e04
 8006bcc:	20001e0c 	.word	0x20001e0c
 8006bd0:	20001e14 	.word	0x20001e14
 8006bd4:	f3af 8000 	nop.w
 8006bd8:	f3af 8000 	nop.w
 8006bdc:	f3af 8000 	nop.w

08006be0 <mac_lld_init>:
/**
 * @brief   Low level MAC initialization.
 *
 * @notapi
 */
void mac_lld_init(void) {
 8006be0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  unsigned i;

  macObjectInit(&ETHD1);
 8006be4:	4d6d      	ldr	r5, [pc, #436]	; (8006d9c <mac_lld_init+0x1bc>)
    rd[i].rdes2 = (uint32_t)rb[i];
    rd[i].rdes3 = (uint32_t)&rd[(i + 1) % STM32_MAC_RECEIVE_BUFFERS];
  }
  for (i = 0; i < STM32_MAC_TRANSMIT_BUFFERS; i++) {
    td[i].tdes1 = 0;
    td[i].tdes2 = (uint32_t)tb[i];
 8006be6:	f8df 91ec 	ldr.w	r9, [pc, #492]	; 8006dd4 <mac_lld_init+0x1f4>
#else
  AFIO->MAPR &= ~AFIO_MAPR_MII_RMII_SEL;
#endif
#elif defined(STM32F2XX) || defined(STM32F4XX)
#if defined(BOARD_PHY_RMII)
  SYSCFG->PMC |= SYSCFG_PMC_MII_RMII_SEL;
 8006bea:	f8df 81ec 	ldr.w	r8, [pc, #492]	; 8006dd8 <mac_lld_init+0x1f8>

  /* Descriptor tables are initialized in chained mode, note that the first
     word is not initialized here but in mac_lld_start().*/
  for (i = 0; i < STM32_MAC_RECEIVE_BUFFERS; i++) {
    rd[i].rdes1 = STM32_RDES1_RCH | STM32_MAC_BUFFERS_SIZE;
    rd[i].rdes2 = (uint32_t)rb[i];
 8006bee:	f8df a1ec 	ldr.w	sl, [pc, #492]	; 8006ddc <mac_lld_init+0x1fc>
static void mii_find_phy(MACDriver *macp) {
  uint32_t i;

#if STM32_MAC_PHY_TIMEOUT > 0
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t timeout  = start + MS2RTC(STM32_HCLK,STM32_MAC_PHY_TIMEOUT);
 8006bf2:	4f6b      	ldr	r7, [pc, #428]	; (8006da0 <mac_lld_init+0x1c0>)
  rtcnt_t time = start;
  while (chSysIsCounterWithinX(time, start, timeout)) {
#endif
    for (i = 0; i < 31; i++) {
      macp->phyaddr = i << 11;
      ETH->MACMIIDR = (i << 6) | MACMIIDR_CR;
 8006bf4:	4c6b      	ldr	r4, [pc, #428]	; (8006da4 <mac_lld_init+0x1c4>)
 * @notapi
 */
void mac_lld_init(void) {
  unsigned i;

  macObjectInit(&ETHD1);
 8006bf6:	4628      	mov	r0, r5
 8006bf8:	f7ff fb82 	bl	8006300 <macObjectInit>
  ETHD1.link_up = false;
 8006bfc:	2600      	movs	r6, #0
  
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "NIC no link up");
 8006bfe:	496a      	ldr	r1, [pc, #424]	; (8006da8 <mac_lld_init+0x1c8>)
 8006c00:	4a6a      	ldr	r2, [pc, #424]	; (8006dac <mac_lld_init+0x1cc>)
 8006c02:	486b      	ldr	r0, [pc, #428]	; (8006db0 <mac_lld_init+0x1d0>)
 */
void mac_lld_init(void) {
  unsigned i;

  macObjectInit(&ETHD1);
  ETHD1.link_up = false;
 8006c04:	772e      	strb	r6, [r5, #28]
  
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "NIC no link up");
 8006c06:	f7ff ff9b 	bl	8006b40 <chprintf.constprop.2>

  /* Descriptor tables are initialized in chained mode, note that the first
     word is not initialized here but in mac_lld_start().*/
  for (i = 0; i < STM32_MAC_RECEIVE_BUFFERS; i++) {
    rd[i].rdes1 = STM32_RDES1_RCH | STM32_MAC_BUFFERS_SIZE;
 8006c0a:	4b6a      	ldr	r3, [pc, #424]	; (8006db4 <mac_lld_init+0x1d4>)
    rd[i].rdes2 = (uint32_t)rb[i];
 8006c0c:	f8df e1d0 	ldr.w	lr, [pc, #464]	; 8006de0 <mac_lld_init+0x200>
    rd[i].rdes3 = (uint32_t)&rd[(i + 1) % STM32_MAC_RECEIVE_BUFFERS];
  }
  for (i = 0; i < STM32_MAC_TRANSMIT_BUFFERS; i++) {
    td[i].tdes1 = 0;
 8006c10:	4a69      	ldr	r2, [pc, #420]	; (8006db8 <mac_lld_init+0x1d8>)
#else
#error "unsupported STM32 platform for MAC driver"
#endif

  /* Reset of the MAC core.*/
  rccResetETH();
 8006c12:	496a      	ldr	r1, [pc, #424]	; (8006dbc <mac_lld_init+0x1dc>)
 8006c14:	486a      	ldr	r0, [pc, #424]	; (8006dc0 <mac_lld_init+0x1e0>)
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "NIC no link up");

  /* Descriptor tables are initialized in chained mode, note that the first
     word is not initialized here but in mac_lld_start().*/
  for (i = 0; i < STM32_MAC_RECEIVE_BUFFERS; i++) {
    rd[i].rdes1 = STM32_RDES1_RCH | STM32_MAC_BUFFERS_SIZE;
 8006c16:	f244 5cf2 	movw	ip, #17906	; 0x45f2
    rd[i].rdes2 = (uint32_t)rb[i];
    rd[i].rdes3 = (uint32_t)&rd[(i + 1) % STM32_MAC_RECEIVE_BUFFERS];
 8006c1a:	f103 0b10 	add.w	fp, r3, #16
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "NIC no link up");

  /* Descriptor tables are initialized in chained mode, note that the first
     word is not initialized here but in mac_lld_start().*/
  for (i = 0; i < STM32_MAC_RECEIVE_BUFFERS; i++) {
    rd[i].rdes1 = STM32_RDES1_RCH | STM32_MAC_BUFFERS_SIZE;
 8006c1e:	f8c3 c004 	str.w	ip, [r3, #4]
    rd[i].rdes2 = (uint32_t)rb[i];
 8006c22:	f8c3 e008 	str.w	lr, [r3, #8]
    rd[i].rdes3 = (uint32_t)&rd[(i + 1) % STM32_MAC_RECEIVE_BUFFERS];
 8006c26:	f8c3 b00c 	str.w	fp, [r3, #12]

  /* Descriptor tables are initialized in chained mode, note that the first
     word is not initialized here but in mac_lld_start().*/
  for (i = 0; i < STM32_MAC_RECEIVE_BUFFERS; i++) {
    rd[i].rdes1 = STM32_RDES1_RCH | STM32_MAC_BUFFERS_SIZE;
    rd[i].rdes2 = (uint32_t)rb[i];
 8006c2a:	f20e 5bf4 	addw	fp, lr, #1524	; 0x5f4
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "NIC no link up");

  /* Descriptor tables are initialized in chained mode, note that the first
     word is not initialized here but in mac_lld_start().*/
  for (i = 0; i < STM32_MAC_RECEIVE_BUFFERS; i++) {
    rd[i].rdes1 = STM32_RDES1_RCH | STM32_MAC_BUFFERS_SIZE;
 8006c2e:	f8c3 c014 	str.w	ip, [r3, #20]
    rd[i].rdes2 = (uint32_t)rb[i];
 8006c32:	f8c3 b018 	str.w	fp, [r3, #24]
    rd[i].rdes3 = (uint32_t)&rd[(i + 1) % STM32_MAC_RECEIVE_BUFFERS];
 8006c36:	f103 0b20 	add.w	fp, r3, #32
 8006c3a:	f8c3 b01c 	str.w	fp, [r3, #28]

  /* Descriptor tables are initialized in chained mode, note that the first
     word is not initialized here but in mac_lld_start().*/
  for (i = 0; i < STM32_MAC_RECEIVE_BUFFERS; i++) {
    rd[i].rdes1 = STM32_RDES1_RCH | STM32_MAC_BUFFERS_SIZE;
    rd[i].rdes2 = (uint32_t)rb[i];
 8006c3e:	f60e 3ee8 	addw	lr, lr, #3048	; 0xbe8
    rd[i].rdes3 = (uint32_t)&rd[(i + 1) % STM32_MAC_RECEIVE_BUFFERS];
 8006c42:	f103 0b30 	add.w	fp, r3, #48	; 0x30
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "NIC no link up");

  /* Descriptor tables are initialized in chained mode, note that the first
     word is not initialized here but in mac_lld_start().*/
  for (i = 0; i < STM32_MAC_RECEIVE_BUFFERS; i++) {
    rd[i].rdes1 = STM32_RDES1_RCH | STM32_MAC_BUFFERS_SIZE;
 8006c46:	f8c3 c024 	str.w	ip, [r3, #36]	; 0x24
    rd[i].rdes2 = (uint32_t)rb[i];
 8006c4a:	f8c3 e028 	str.w	lr, [r3, #40]	; 0x28
    rd[i].rdes3 = (uint32_t)&rd[(i + 1) % STM32_MAC_RECEIVE_BUFFERS];
 8006c4e:	f8c3 b02c 	str.w	fp, [r3, #44]	; 0x2c
  }
  for (i = 0; i < STM32_MAC_TRANSMIT_BUFFERS; i++) {
    td[i].tdes1 = 0;
    td[i].tdes2 = (uint32_t)tb[i];
    td[i].tdes3 = (uint32_t)&td[(i + 1) % STM32_MAC_TRANSMIT_BUFFERS];
 8006c52:	f102 0e10 	add.w	lr, r2, #16
    rd[i].rdes2 = (uint32_t)rb[i];
    rd[i].rdes3 = (uint32_t)&rd[(i + 1) % STM32_MAC_RECEIVE_BUFFERS];
  }
  for (i = 0; i < STM32_MAC_TRANSMIT_BUFFERS; i++) {
    td[i].tdes1 = 0;
    td[i].tdes2 = (uint32_t)tb[i];
 8006c56:	f209 5bf4 	addw	fp, r9, #1524	; 0x5f4
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "NIC no link up");

  /* Descriptor tables are initialized in chained mode, note that the first
     word is not initialized here but in mac_lld_start().*/
  for (i = 0; i < STM32_MAC_RECEIVE_BUFFERS; i++) {
    rd[i].rdes1 = STM32_RDES1_RCH | STM32_MAC_BUFFERS_SIZE;
 8006c5a:	f8c3 c034 	str.w	ip, [r3, #52]	; 0x34
    rd[i].rdes2 = (uint32_t)rb[i];
 8006c5e:	f8c3 a038 	str.w	sl, [r3, #56]	; 0x38
    rd[i].rdes3 = (uint32_t)&rd[(i + 1) % STM32_MAC_RECEIVE_BUFFERS];
 8006c62:	63db      	str	r3, [r3, #60]	; 0x3c
  }
  for (i = 0; i < STM32_MAC_TRANSMIT_BUFFERS; i++) {
    td[i].tdes1 = 0;
 8006c64:	6056      	str	r6, [r2, #4]
    td[i].tdes2 = (uint32_t)tb[i];
 8006c66:	f8c2 9008 	str.w	r9, [r2, #8]
    td[i].tdes3 = (uint32_t)&td[(i + 1) % STM32_MAC_TRANSMIT_BUFFERS];
 8006c6a:	f8c2 e00c 	str.w	lr, [r2, #12]
    rd[i].rdes1 = STM32_RDES1_RCH | STM32_MAC_BUFFERS_SIZE;
    rd[i].rdes2 = (uint32_t)rb[i];
    rd[i].rdes3 = (uint32_t)&rd[(i + 1) % STM32_MAC_RECEIVE_BUFFERS];
  }
  for (i = 0; i < STM32_MAC_TRANSMIT_BUFFERS; i++) {
    td[i].tdes1 = 0;
 8006c6e:	6156      	str	r6, [r2, #20]
    td[i].tdes2 = (uint32_t)tb[i];
 8006c70:	f8c2 b018 	str.w	fp, [r2, #24]
    td[i].tdes3 = (uint32_t)&td[(i + 1) % STM32_MAC_TRANSMIT_BUFFERS];
 8006c74:	61d2      	str	r2, [r2, #28]
#else
  AFIO->MAPR &= ~AFIO_MAPR_MII_RMII_SEL;
#endif
#elif defined(STM32F2XX) || defined(STM32F4XX)
#if defined(BOARD_PHY_RMII)
  SYSCFG->PMC |= SYSCFG_PMC_MII_RMII_SEL;
 8006c76:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8006c7a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8006c7e:	f8c8 3004 	str.w	r3, [r8, #4]
#else
#error "unsupported STM32 platform for MAC driver"
#endif

  /* Reset of the MAC core.*/
  rccResetETH();
 8006c82:	690b      	ldr	r3, [r1, #16]
 8006c84:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8006c88:	610b      	str	r3, [r1, #16]
 8006c8a:	610e      	str	r6, [r1, #16]

  /* MAC clocks temporary activation.*/
  rccEnableETH(false);
 8006c8c:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 8006c8e:	f043 6360 	orr.w	r3, r3, #234881024	; 0xe000000
 8006c92:	630b      	str	r3, [r1, #48]	; 0x30
 8006c94:	f8d0 9004 	ldr.w	r9, [r0, #4]
static void mii_find_phy(MACDriver *macp) {
  uint32_t i;

#if STM32_MAC_PHY_TIMEOUT > 0
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t timeout  = start + MS2RTC(STM32_HCLK,STM32_MAC_PHY_TIMEOUT);
 8006c98:	444f      	add	r7, r9
  rtcnt_t time = start;
 8006c9a:	4648      	mov	r0, r9
  while (chSysIsCounterWithinX(time, start, timeout)) {
 8006c9c:	4649      	mov	r1, r9
 8006c9e:	463a      	mov	r2, r7
 * @notapi
 */
uint32_t mii_read(MACDriver *macp, uint32_t reg) {

  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR | ETH_MACMIIAR_MB;
  while ((ETH->MACMIIAR & ETH_MACMIIAR_MB) != 0)
 8006ca0:	46a0      	mov	r8, r4

#if STM32_MAC_PHY_TIMEOUT > 0
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t timeout  = start + MS2RTC(STM32_HCLK,STM32_MAC_PHY_TIMEOUT);
  rtcnt_t time = start;
  while (chSysIsCounterWithinX(time, start, timeout)) {
 8006ca2:	f7fa f9ad 	bl	8001000 <chSysIsCounterWithinX>
 8006ca6:	b1f0      	cbz	r0, 8006ce6 <mac_lld_init+0x106>
 8006ca8:	2200      	movs	r2, #0
#endif
    for (i = 0; i < 31; i++) {
      macp->phyaddr = i << 11;
      ETH->MACMIIDR = (i << 6) | MACMIIDR_CR;
      if ((mii_read(macp, MII_PHYSID1) == (BOARD_PHY_ID >> 16)) &&
 8006caa:	f645 4090 	movw	r0, #23696	; 0x5c90
  rtcnt_t time = start;
  while (chSysIsCounterWithinX(time, start, timeout)) {
#endif
    for (i = 0; i < 31; i++) {
      macp->phyaddr = i << 11;
      ETH->MACMIIDR = (i << 6) | MACMIIDR_CR;
 8006cae:	0193      	lsls	r3, r2, #6
  rtcnt_t timeout  = start + MS2RTC(STM32_HCLK,STM32_MAC_PHY_TIMEOUT);
  rtcnt_t time = start;
  while (chSysIsCounterWithinX(time, start, timeout)) {
#endif
    for (i = 0; i < 31; i++) {
      macp->phyaddr = i << 11;
 8006cb0:	02d1      	lsls	r1, r2, #11
      ETH->MACMIIDR = (i << 6) | MACMIIDR_CR;
 8006cb2:	f043 0310 	orr.w	r3, r3, #16
 *
 * @notapi
 */
uint32_t mii_read(MACDriver *macp, uint32_t reg) {

  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR | ETH_MACMIIAR_MB;
 8006cb6:	f041 0691 	orr.w	r6, r1, #145	; 0x91
  rtcnt_t time = start;
  while (chSysIsCounterWithinX(time, start, timeout)) {
#endif
    for (i = 0; i < 31; i++) {
      macp->phyaddr = i << 11;
      ETH->MACMIIDR = (i << 6) | MACMIIDR_CR;
 8006cba:	6163      	str	r3, [r4, #20]
 *
 * @notapi
 */
uint32_t mii_read(MACDriver *macp, uint32_t reg) {

  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR | ETH_MACMIIAR_MB;
 8006cbc:	6126      	str	r6, [r4, #16]
  while ((ETH->MACMIIAR & ETH_MACMIIAR_MB) != 0)
 8006cbe:	6923      	ldr	r3, [r4, #16]
 8006cc0:	07db      	lsls	r3, r3, #31
 8006cc2:	d4fc      	bmi.n	8006cbe <mac_lld_init+0xde>
    ;
  return ETH->MACMIIDR;
 8006cc4:	f8d8 3014 	ldr.w	r3, [r8, #20]
  while (chSysIsCounterWithinX(time, start, timeout)) {
#endif
    for (i = 0; i < 31; i++) {
      macp->phyaddr = i << 11;
      ETH->MACMIIDR = (i << 6) | MACMIIDR_CR;
      if ((mii_read(macp, MII_PHYSID1) == (BOARD_PHY_ID >> 16)) &&
 8006cc8:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8006ccc:	d014      	beq.n	8006cf8 <mac_lld_init+0x118>
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t timeout  = start + MS2RTC(STM32_HCLK,STM32_MAC_PHY_TIMEOUT);
  rtcnt_t time = start;
  while (chSysIsCounterWithinX(time, start, timeout)) {
#endif
    for (i = 0; i < 31; i++) {
 8006cce:	3201      	adds	r2, #1
 8006cd0:	2a1f      	cmp	r2, #31
 8006cd2:	d1ec      	bne.n	8006cae <mac_lld_init+0xce>
 8006cd4:	4b3a      	ldr	r3, [pc, #232]	; (8006dc0 <mac_lld_init+0x1e0>)
 8006cd6:	6229      	str	r1, [r5, #32]
 8006cd8:	6858      	ldr	r0, [r3, #4]

#if STM32_MAC_PHY_TIMEOUT > 0
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t timeout  = start + MS2RTC(STM32_HCLK,STM32_MAC_PHY_TIMEOUT);
  rtcnt_t time = start;
  while (chSysIsCounterWithinX(time, start, timeout)) {
 8006cda:	4649      	mov	r1, r9
 8006cdc:	463a      	mov	r2, r7
 8006cde:	f7fa f98f 	bl	8001000 <chSysIsCounterWithinX>
 8006ce2:	2800      	cmp	r0, #0
 8006ce4:	d1e0      	bne.n	8006ca8 <mac_lld_init+0xc8>
    }
#if STM32_MAC_PHY_TIMEOUT > 0
    time = chSysGetRealtimeCounterX();
  }
#endif
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "MAC failure");
 8006ce6:	4930      	ldr	r1, [pc, #192]	; (8006da8 <mac_lld_init+0x1c8>)
 8006ce8:	4a36      	ldr	r2, [pc, #216]	; (8006dc4 <mac_lld_init+0x1e4>)
 8006cea:	4831      	ldr	r0, [pc, #196]	; (8006db0 <mac_lld_init+0x1d0>)
 8006cec:	f7ff ff28 	bl	8006b40 <chprintf.constprop.2>
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 8006cf0:	4834      	ldr	r0, [pc, #208]	; (8006dc4 <mac_lld_init+0x1e4>)
 8006cf2:	f7fa f93d 	bl	8000f70 <chSysHalt>
 8006cf6:	e00f      	b.n	8006d18 <mac_lld_init+0x138>
 *
 * @notapi
 */
uint32_t mii_read(MACDriver *macp, uint32_t reg) {

  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR | ETH_MACMIIAR_MB;
 8006cf8:	f041 03d1 	orr.w	r3, r1, #209	; 0xd1
 8006cfc:	f8c8 3010 	str.w	r3, [r8, #16]
  while ((ETH->MACMIIAR & ETH_MACMIIAR_MB) != 0)
 8006d00:	6923      	ldr	r3, [r4, #16]
 8006d02:	07de      	lsls	r6, r3, #31
 8006d04:	d4fc      	bmi.n	8006d00 <mac_lld_init+0x120>
    ;
  return ETH->MACMIIDR;
 8006d06:	f8d8 e014 	ldr.w	lr, [r8, #20]
#endif
    for (i = 0; i < 31; i++) {
      macp->phyaddr = i << 11;
      ETH->MACMIIDR = (i << 6) | MACMIIDR_CR;
      if ((mii_read(macp, MII_PHYSID1) == (BOARD_PHY_ID >> 16)) &&
          ((mii_read(macp, MII_PHYSID2) & 0xFFF0) == (BOARD_PHY_ID & 0xFFF0))) {
 8006d0a:	f64f 73f0 	movw	r3, #65520	; 0xfff0
 8006d0e:	ea0e 0303 	and.w	r3, lr, r3
  while (chSysIsCounterWithinX(time, start, timeout)) {
#endif
    for (i = 0; i < 31; i++) {
      macp->phyaddr = i << 11;
      ETH->MACMIIDR = (i << 6) | MACMIIDR_CR;
      if ((mii_read(macp, MII_PHYSID1) == (BOARD_PHY_ID >> 16)) &&
 8006d12:	4283      	cmp	r3, r0
 8006d14:	d1db      	bne.n	8006cce <mac_lld_init+0xee>
 8006d16:	6229      	str	r1, [r5, #32]
  /* PHY address setup.*/
#if defined(BOARD_PHY_ADDRESS)
  ETHD1.phyaddr = BOARD_PHY_ADDRESS << 11;
#else
  mii_find_phy(&ETHD1);
  chprintf((BaseSequentialStream *)&itm_port, "ETHD1 %s\n", "mii_find_phy");
 8006d18:	492b      	ldr	r1, [pc, #172]	; (8006dc8 <mac_lld_init+0x1e8>)
 8006d1a:	4a2c      	ldr	r2, [pc, #176]	; (8006dcc <mac_lld_init+0x1ec>)
 8006d1c:	4824      	ldr	r0, [pc, #144]	; (8006db0 <mac_lld_init+0x1d0>)
 8006d1e:	f7ff ff0f 	bl	8006b40 <chprintf.constprop.2>
 */
void mii_write(MACDriver *macp, uint32_t reg, uint32_t value) {

  ETH->MACMIIDR = value;
  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR |
                  ETH_MACMIIAR_MW | ETH_MACMIIAR_MB;
 8006d22:	6a2a      	ldr	r2, [r5, #32]
 *
 * @notapi
 */
void mii_write(MACDriver *macp, uint32_t reg, uint32_t value) {

  ETH->MACMIIDR = value;
 8006d24:	4b1f      	ldr	r3, [pc, #124]	; (8006da4 <mac_lld_init+0x1c4>)
  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR |
                  ETH_MACMIIAR_MW | ETH_MACMIIAR_MB;
 8006d26:	f042 0113 	orr.w	r1, r2, #19
 *
 * @notapi
 */
void mii_write(MACDriver *macp, uint32_t reg, uint32_t value) {

  ETH->MACMIIDR = value;
 8006d2a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8006d2e:	615a      	str	r2, [r3, #20]
  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR |
                  ETH_MACMIIAR_MW | ETH_MACMIIAR_MB;
  while ((ETH->MACMIIAR & ETH_MACMIIAR_MB) != 0)
 8006d30:	461a      	mov	r2, r3
 * @notapi
 */
void mii_write(MACDriver *macp, uint32_t reg, uint32_t value) {

  ETH->MACMIIDR = value;
  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR |
 8006d32:	6119      	str	r1, [r3, #16]
                  ETH_MACMIIAR_MW | ETH_MACMIIAR_MB;
  while ((ETH->MACMIIAR & ETH_MACMIIAR_MB) != 0)
 8006d34:	6913      	ldr	r3, [r2, #16]
 8006d36:	07db      	lsls	r3, r3, #31
 8006d38:	d4fc      	bmi.n	8006d34 <mac_lld_init+0x154>
  BOARD_PHY_RESET();
#else
  /* PHY soft reset procedure.*/
  mii_write(&ETHD1, MII_BMCR, BMCR_RESET);
#if defined(BOARD_PHY_RESET_DELAY)
  chprintf((BaseSequentialStream *)&itm_port, "BOARD_PHY_RESET_DELAY %d\n", BOARD_PHY_RESET_DELAY);
 8006d3a:	4925      	ldr	r1, [pc, #148]	; (8006dd0 <mac_lld_init+0x1f0>)
 8006d3c:	481c      	ldr	r0, [pc, #112]	; (8006db0 <mac_lld_init+0x1d0>)
 8006d3e:	2264      	movs	r2, #100	; 0x64
 8006d40:	f7ff fefe 	bl	8006b40 <chprintf.constprop.2>
  chSysPolledDelayX(BOARD_PHY_RESET_DELAY);
 8006d44:	2064      	movs	r0, #100	; 0x64
 8006d46:	f7fa f96b 	bl	8001020 <chSysPolledDelayX>
  chprintf((BaseSequentialStream *)&itm_port, "BOARD_PHY_RESET_DELAY %d\n", BOARD_PHY_RESET_DELAY);
 8006d4a:	4921      	ldr	r1, [pc, #132]	; (8006dd0 <mac_lld_init+0x1f0>)
 8006d4c:	4818      	ldr	r0, [pc, #96]	; (8006db0 <mac_lld_init+0x1d0>)
 8006d4e:	2264      	movs	r2, #100	; 0x64
 8006d50:	f7ff fef6 	bl	8006b40 <chprintf.constprop.2>
 8006d54:	6a2d      	ldr	r5, [r5, #32]
 *
 * @notapi
 */
uint32_t mii_read(MACDriver *macp, uint32_t reg) {

  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR | ETH_MACMIIAR_MB;
 8006d56:	4913      	ldr	r1, [pc, #76]	; (8006da4 <mac_lld_init+0x1c4>)
 8006d58:	f045 0011 	orr.w	r0, r5, #17
  while ((ETH->MACMIIAR & ETH_MACMIIAR_MB) != 0)
 8006d5c:	460c      	mov	r4, r1
 *
 * @notapi
 */
uint32_t mii_read(MACDriver *macp, uint32_t reg) {

  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR | ETH_MACMIIAR_MB;
 8006d5e:	6108      	str	r0, [r1, #16]
  while ((ETH->MACMIIAR & ETH_MACMIIAR_MB) != 0)
 8006d60:	690b      	ldr	r3, [r1, #16]
 8006d62:	4a10      	ldr	r2, [pc, #64]	; (8006da4 <mac_lld_init+0x1c4>)
 8006d64:	07df      	lsls	r7, r3, #31
 8006d66:	d4fb      	bmi.n	8006d60 <mac_lld_init+0x180>
    ;
  return ETH->MACMIIDR;
 8006d68:	6963      	ldr	r3, [r4, #20]
#if defined(BOARD_PHY_RESET_DELAY)
  chprintf((BaseSequentialStream *)&itm_port, "BOARD_PHY_RESET_DELAY %d\n", BOARD_PHY_RESET_DELAY);
  chSysPolledDelayX(BOARD_PHY_RESET_DELAY);
  chprintf((BaseSequentialStream *)&itm_port, "BOARD_PHY_RESET_DELAY %d\n", BOARD_PHY_RESET_DELAY);
#endif
  while (mii_read(&ETHD1, MII_BMCR) & BMCR_RESET)
 8006d6a:	041e      	lsls	r6, r3, #16
 8006d6c:	d4f7      	bmi.n	8006d5e <mac_lld_init+0x17e>
 *
 * @notapi
 */
uint32_t mii_read(MACDriver *macp, uint32_t reg) {

  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR | ETH_MACMIIAR_MB;
 8006d6e:	6110      	str	r0, [r2, #16]
  while ((ETH->MACMIIAR & ETH_MACMIIAR_MB) != 0)
 8006d70:	6913      	ldr	r3, [r2, #16]
 8006d72:	490c      	ldr	r1, [pc, #48]	; (8006da4 <mac_lld_init+0x1c4>)
 8006d74:	07d8      	lsls	r0, r3, #31
 8006d76:	d4fb      	bmi.n	8006d70 <mac_lld_init+0x190>
    ;
  return ETH->MACMIIDR;
 8006d78:	694b      	ldr	r3, [r1, #20]
 */
void mii_write(MACDriver *macp, uint32_t reg, uint32_t value) {

  ETH->MACMIIDR = value;
  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR |
                  ETH_MACMIIAR_MW | ETH_MACMIIAR_MB;
 8006d7a:	f045 0513 	orr.w	r5, r5, #19
    ;
#endif

#if STM32_MAC_ETH1_CHANGE_PHY_STATE
  /* PHY in power down mode until the driver will be started.*/
  mii_write(&ETHD1, MII_BMCR, mii_read(&ETHD1, MII_BMCR) | BMCR_PDOWN);
 8006d7e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 *
 * @notapi
 */
void mii_write(MACDriver *macp, uint32_t reg, uint32_t value) {

  ETH->MACMIIDR = value;
 8006d82:	614b      	str	r3, [r1, #20]
  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR |
                  ETH_MACMIIAR_MW | ETH_MACMIIAR_MB;
  while ((ETH->MACMIIAR & ETH_MACMIIAR_MB) != 0)
 8006d84:	460a      	mov	r2, r1
 * @notapi
 */
void mii_write(MACDriver *macp, uint32_t reg, uint32_t value) {

  ETH->MACMIIDR = value;
  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR |
 8006d86:	610d      	str	r5, [r1, #16]
                  ETH_MACMIIAR_MW | ETH_MACMIIAR_MB;
  while ((ETH->MACMIIAR & ETH_MACMIIAR_MB) != 0)
 8006d88:	6913      	ldr	r3, [r2, #16]
 8006d8a:	07db      	lsls	r3, r3, #31
 8006d8c:	d4fc      	bmi.n	8006d88 <mac_lld_init+0x1a8>
  /* PHY in power down mode until the driver will be started.*/
  mii_write(&ETHD1, MII_BMCR, mii_read(&ETHD1, MII_BMCR) | BMCR_PDOWN);
#endif

  /* MAC clocks stopped again.*/
  rccDisableETH(false);
 8006d8e:	4a0b      	ldr	r2, [pc, #44]	; (8006dbc <mac_lld_init+0x1dc>)
 8006d90:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8006d92:	f023 6360 	bic.w	r3, r3, #234881024	; 0xe000000
 8006d96:	6313      	str	r3, [r2, #48]	; 0x30
 8006d98:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006d9c:	20001dfc 	.word	0x20001dfc
 8006da0:	00e4e1c0 	.word	0x00e4e1c0
 8006da4:	40028000 	.word	0x40028000
 8006da8:	08017004 	.word	0x08017004
 8006dac:	08016df0 	.word	0x08016df0
 8006db0:	200180c8 	.word	0x200180c8
 8006db4:	200035f8 	.word	0x200035f8
 8006db8:	20004220 	.word	0x20004220
 8006dbc:	40023800 	.word	0x40023800
 8006dc0:	e0001000 	.word	0xe0001000
 8006dc4:	08016e00 	.word	0x08016e00
 8006dc8:	08016e0c 	.word	0x08016e0c
 8006dcc:	08016e18 	.word	0x08016e18
 8006dd0:	08016e28 	.word	0x08016e28
 8006dd4:	20003638 	.word	0x20003638
 8006dd8:	40013800 	.word	0x40013800
 8006ddc:	20003004 	.word	0x20003004
 8006de0:	20001e28 	.word	0x20001e28
 8006de4:	f3af 8000 	nop.w
 8006de8:	f3af 8000 	nop.w
 8006dec:	f3af 8000 	nop.w

08006df0 <mac_lld_start>:
 *
 * @param[in] macp      pointer to the @p MACDriver object
 *
 * @notapi
 */
void mac_lld_start(MACDriver *macp) {
 8006df0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  unsigned i;

  /* Resets the state of all descriptors.*/
  for (i = 0; i < STM32_MAC_RECEIVE_BUFFERS; i++)
    rd[i].rdes0 = STM32_RDES0_OWN;
 8006df4:	4c38      	ldr	r4, [pc, #224]	; (8006ed8 <mac_lld_start+0xe8>)
  macp->rxptr = (stm32_eth_rx_descriptor_t *)rd;
  for (i = 0; i < STM32_MAC_TRANSMIT_BUFFERS; i++)
    td[i].tdes0 = STM32_TDES0_TCH;
 8006df6:	4d39      	ldr	r5, [pc, #228]	; (8006edc <mac_lld_start+0xec>)
  macp->txptr = (stm32_eth_tx_descriptor_t *)td;

  /* MAC clocks activation and commanded reset procedure.*/
  rccEnableETH(false);
 8006df8:	4f39      	ldr	r7, [pc, #228]	; (8006ee0 <mac_lld_start+0xf0>)
  ETH->DMABMR |= ETH_DMABMR_SR;
  while(ETH->DMABMR & ETH_DMABMR_SR)
    ;
#endif

  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "NIC clock");
 8006dfa:	493a      	ldr	r1, [pc, #232]	; (8006ee4 <mac_lld_start+0xf4>)
 8006dfc:	4a3a      	ldr	r2, [pc, #232]	; (8006ee8 <mac_lld_start+0xf8>)
void mac_lld_start(MACDriver *macp) {
  unsigned i;

  /* Resets the state of all descriptors.*/
  for (i = 0; i < STM32_MAC_RECEIVE_BUFFERS; i++)
    rd[i].rdes0 = STM32_RDES0_OWN;
 8006dfe:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
  macp->rxptr = (stm32_eth_rx_descriptor_t *)rd;
  for (i = 0; i < STM32_MAC_TRANSMIT_BUFFERS; i++)
    td[i].tdes0 = STM32_TDES0_TCH;
 8006e02:	f44f 1680 	mov.w	r6, #1048576	; 0x100000
void mac_lld_start(MACDriver *macp) {
  unsigned i;

  /* Resets the state of all descriptors.*/
  for (i = 0; i < STM32_MAC_RECEIVE_BUFFERS; i++)
    rd[i].rdes0 = STM32_RDES0_OWN;
 8006e06:	6023      	str	r3, [r4, #0]
 8006e08:	6123      	str	r3, [r4, #16]
 8006e0a:	6223      	str	r3, [r4, #32]
 8006e0c:	6323      	str	r3, [r4, #48]	; 0x30
  macp->rxptr = (stm32_eth_rx_descriptor_t *)rd;
  for (i = 0; i < STM32_MAC_TRANSMIT_BUFFERS; i++)
    td[i].tdes0 = STM32_TDES0_TCH;
 8006e0e:	602e      	str	r6, [r5, #0]
 8006e10:	612e      	str	r6, [r5, #16]
  macp->txptr = (stm32_eth_tx_descriptor_t *)td;

  /* MAC clocks activation and commanded reset procedure.*/
  rccEnableETH(false);
 8006e12:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  unsigned i;

  /* Resets the state of all descriptors.*/
  for (i = 0; i < STM32_MAC_RECEIVE_BUFFERS; i++)
    rd[i].rdes0 = STM32_RDES0_OWN;
  macp->rxptr = (stm32_eth_rx_descriptor_t *)rd;
 8006e14:	6244      	str	r4, [r0, #36]	; 0x24
  for (i = 0; i < STM32_MAC_TRANSMIT_BUFFERS; i++)
    td[i].tdes0 = STM32_TDES0_TCH;
  macp->txptr = (stm32_eth_tx_descriptor_t *)td;

  /* MAC clocks activation and commanded reset procedure.*/
  rccEnableETH(false);
 8006e16:	f043 6360 	orr.w	r3, r3, #234881024	; 0xe000000
  for (i = 0; i < STM32_MAC_RECEIVE_BUFFERS; i++)
    rd[i].rdes0 = STM32_RDES0_OWN;
  macp->rxptr = (stm32_eth_rx_descriptor_t *)rd;
  for (i = 0; i < STM32_MAC_TRANSMIT_BUFFERS; i++)
    td[i].tdes0 = STM32_TDES0_TCH;
  macp->txptr = (stm32_eth_tx_descriptor_t *)td;
 8006e1a:	6285      	str	r5, [r0, #40]	; 0x28
 *
 * @param[in] macp      pointer to the @p MACDriver object
 *
 * @notapi
 */
void mac_lld_start(MACDriver *macp) {
 8006e1c:	4606      	mov	r6, r0
  for (i = 0; i < STM32_MAC_TRANSMIT_BUFFERS; i++)
    td[i].tdes0 = STM32_TDES0_TCH;
  macp->txptr = (stm32_eth_tx_descriptor_t *)td;

  /* MAC clocks activation and commanded reset procedure.*/
  rccEnableETH(false);
 8006e1e:	633b      	str	r3, [r7, #48]	; 0x30
  ETH->DMABMR |= ETH_DMABMR_SR;
  while(ETH->DMABMR & ETH_DMABMR_SR)
    ;
#endif

  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "NIC clock");
 8006e20:	4832      	ldr	r0, [pc, #200]	; (8006eec <mac_lld_start+0xfc>)
 8006e22:	f7ff fe8d 	bl	8006b40 <chprintf.constprop.2>

  /* ISR vector enabled.*/
  nvicEnableVector(ETH_IRQn, STM32_MAC_ETH1_IRQ_PRIORITY);
 8006e26:	203d      	movs	r0, #61	; 0x3d
 8006e28:	210d      	movs	r1, #13
 8006e2a:	f7ff fbf1 	bl	8006610 <nvicEnableVector>
 *
 * @notapi
 */
uint32_t mii_read(MACDriver *macp, uint32_t reg) {

  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR | ETH_MACMIIAR_MB;
 8006e2e:	6a30      	ldr	r0, [r6, #32]
 8006e30:	492f      	ldr	r1, [pc, #188]	; (8006ef0 <mac_lld_start+0x100>)
 8006e32:	f040 0311 	orr.w	r3, r0, #17
 8006e36:	610b      	str	r3, [r1, #16]
  while ((ETH->MACMIIAR & ETH_MACMIIAR_MB) != 0)
 8006e38:	690b      	ldr	r3, [r1, #16]
 8006e3a:	4a2d      	ldr	r2, [pc, #180]	; (8006ef0 <mac_lld_start+0x100>)
 8006e3c:	07df      	lsls	r7, r3, #31
 8006e3e:	d4fb      	bmi.n	8006e38 <mac_lld_start+0x48>
    ;
  return ETH->MACMIIDR;
 8006e40:	6953      	ldr	r3, [r2, #20]
 */
void mii_write(MACDriver *macp, uint32_t reg, uint32_t value) {

  ETH->MACMIIDR = value;
  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR |
                  ETH_MACMIIAR_MW | ETH_MACMIIAR_MB;
 8006e42:	f040 0013 	orr.w	r0, r0, #19
  /* ISR vector enabled.*/
  nvicEnableVector(ETH_IRQn, STM32_MAC_ETH1_IRQ_PRIORITY);

#if STM32_MAC_ETH1_CHANGE_PHY_STATE
  /* PHY in power up mode.*/
  mii_write(macp, MII_BMCR, mii_read(macp, MII_BMCR) & ~BMCR_PDOWN);
 8006e46:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 *
 * @notapi
 */
void mii_write(MACDriver *macp, uint32_t reg, uint32_t value) {

  ETH->MACMIIDR = value;
 8006e4a:	6153      	str	r3, [r2, #20]
  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR |
                  ETH_MACMIIAR_MW | ETH_MACMIIAR_MB;
  while ((ETH->MACMIIAR & ETH_MACMIIAR_MB) != 0)
 8006e4c:	4611      	mov	r1, r2
 * @notapi
 */
void mii_write(MACDriver *macp, uint32_t reg, uint32_t value) {

  ETH->MACMIIDR = value;
  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR |
 8006e4e:	6110      	str	r0, [r2, #16]
                  ETH_MACMIIAR_MW | ETH_MACMIIAR_MB;
  while ((ETH->MACMIIAR & ETH_MACMIIAR_MB) != 0)
 8006e50:	690b      	ldr	r3, [r1, #16]
 8006e52:	4a27      	ldr	r2, [pc, #156]	; (8006ef0 <mac_lld_start+0x100>)
 8006e54:	f013 0301 	ands.w	r3, r3, #1
 8006e58:	d1fa      	bne.n	8006e50 <mac_lld_start+0x60>
  ETH->MACFFR    = 0;
  ETH->MACFCR    = 0;
  ETH->MACVLANTR = 0;

  /* MAC address setup.*/
  if (macp->config->mac_address == NULL)
 8006e5a:	6871      	ldr	r1, [r6, #4]
  /* PHY in power up mode.*/
  mii_write(macp, MII_BMCR, mii_read(macp, MII_BMCR) & ~BMCR_PDOWN);
#endif

  /* MAC configuration.*/
  ETH->MACFFR    = 0;
 8006e5c:	6053      	str	r3, [r2, #4]
  ETH->MACFCR    = 0;
  ETH->MACVLANTR = 0;

  /* MAC address setup.*/
  if (macp->config->mac_address == NULL)
 8006e5e:	6808      	ldr	r0, [r1, #0]
  mii_write(macp, MII_BMCR, mii_read(macp, MII_BMCR) & ~BMCR_PDOWN);
#endif

  /* MAC configuration.*/
  ETH->MACFFR    = 0;
  ETH->MACFCR    = 0;
 8006e60:	6193      	str	r3, [r2, #24]
  ETH->MACVLANTR = 0;
 8006e62:	61d3      	str	r3, [r2, #28]

  /* MAC address setup.*/
  if (macp->config->mac_address == NULL)
 8006e64:	2800      	cmp	r0, #0
 8006e66:	d033      	beq.n	8006ed0 <mac_lld_start+0xe0>
    mac_lld_set_address(default_mac_address);
  else
    mac_lld_set_address(macp->config->mac_address);
 8006e68:	f7ff fe42 	bl	8006af0 <mac_lld_set_address>
     Note that the complete setup of the MAC is performed when the link
     status is detected.*/
#if STM32_MAC_IP_CHECKSUM_OFFLOAD
  ETH->MACCR = ETH_MACCR_IPCO | ETH_MACCR_RE | ETH_MACCR_TE;
#else
  ETH->MACCR =                  ETH_MACCR_RE | ETH_MACCR_TE;
 8006e6c:	4e20      	ldr	r6, [pc, #128]	; (8006ef0 <mac_lld_start+0x100>)
  /* Enabling required interrupt sources.*/
  ETH->DMASR    = ETH->DMASR;
  ETH->DMAIER   = ETH_DMAIER_NISE | ETH_DMAIER_RIE | ETH_DMAIER_TIE;

  /* DMA general settings.*/
  ETH->DMABMR   = ETH_DMABMR_AAB | ETH_DMABMR_RDP_1Beat | ETH_DMABMR_PBL_1Beat;
 8006e6e:	4f21      	ldr	r7, [pc, #132]	; (8006ef4 <mac_lld_start+0x104>)
  ETH->DMARDLAR = (uint32_t)rd;
  ETH->DMATDLAR = (uint32_t)td;

  /* Enabling required interrupt sources.*/
  ETH->DMASR    = ETH->DMASR;
  ETH->DMAIER   = ETH_DMAIER_NISE | ETH_DMAIER_RIE | ETH_DMAIER_TIE;
 8006e70:	f8df c098 	ldr.w	ip, [pc, #152]	; 8006f0c <mac_lld_start+0x11c>

  /* DMA general settings.*/
  ETH->DMABMR   = ETH_DMABMR_AAB | ETH_DMABMR_RDP_1Beat | ETH_DMABMR_PBL_1Beat;
 8006e74:	f8df e098 	ldr.w	lr, [pc, #152]	; 8006f10 <mac_lld_start+0x120>
  
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "DMA Settings");
 8006e78:	4a1f      	ldr	r2, [pc, #124]	; (8006ef8 <mac_lld_start+0x108>)
 8006e7a:	481c      	ldr	r0, [pc, #112]	; (8006eec <mac_lld_start+0xfc>)
 8006e7c:	4919      	ldr	r1, [pc, #100]	; (8006ee4 <mac_lld_start+0xf4>)
  ETH->MACCR =                  ETH_MACCR_RE | ETH_MACCR_TE;
#endif

  /* DMA configuration:
     Descriptor chains pointers.*/
  ETH->DMARDLAR = (uint32_t)rd;
 8006e7e:	f241 090c 	movw	r9, #4108	; 0x100c
  ETH->DMATDLAR = (uint32_t)td;
 8006e82:	f241 0810 	movw	r8, #4112	; 0x1010
     Note that the complete setup of the MAC is performed when the link
     status is detected.*/
#if STM32_MAC_IP_CHECKSUM_OFFLOAD
  ETH->MACCR = ETH_MACCR_IPCO | ETH_MACCR_RE | ETH_MACCR_TE;
#else
  ETH->MACCR =                  ETH_MACCR_RE | ETH_MACCR_TE;
 8006e86:	230c      	movs	r3, #12
 8006e88:	6033      	str	r3, [r6, #0]
#endif

  /* DMA configuration:
     Descriptor chains pointers.*/
  ETH->DMARDLAR = (uint32_t)rd;
 8006e8a:	f846 4009 	str.w	r4, [r6, r9]
  ETH->DMATDLAR = (uint32_t)td;

  /* Enabling required interrupt sources.*/
  ETH->DMASR    = ETH->DMASR;
 8006e8e:	f241 0314 	movw	r3, #4116	; 0x1014
#endif

  /* DMA configuration:
     Descriptor chains pointers.*/
  ETH->DMARDLAR = (uint32_t)rd;
  ETH->DMATDLAR = (uint32_t)td;
 8006e92:	f846 5008 	str.w	r5, [r6, r8]

  /* Enabling required interrupt sources.*/
  ETH->DMASR    = ETH->DMASR;
  ETH->DMAIER   = ETH_DMAIER_NISE | ETH_DMAIER_RIE | ETH_DMAIER_TIE;
 8006e96:	f241 041c 	movw	r4, #4124	; 0x101c
     Descriptor chains pointers.*/
  ETH->DMARDLAR = (uint32_t)rd;
  ETH->DMATDLAR = (uint32_t)td;

  /* Enabling required interrupt sources.*/
  ETH->DMASR    = ETH->DMASR;
 8006e9a:	58f5      	ldr	r5, [r6, r3]
 8006e9c:	50f5      	str	r5, [r6, r3]
  ETH->DMAIER   = ETH_DMAIER_NISE | ETH_DMAIER_RIE | ETH_DMAIER_TIE;
 8006e9e:	f846 c004 	str.w	ip, [r6, r4]

  /* DMA general settings.*/
  ETH->DMABMR   = ETH_DMABMR_AAB | ETH_DMABMR_RDP_1Beat | ETH_DMABMR_PBL_1Beat;
 8006ea2:	f8c7 e000 	str.w	lr, [r7]
  
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "DMA Settings");
 8006ea6:	f7ff fe4b 	bl	8006b40 <chprintf.constprop.2>

  /* Transmit FIFO flush.*/
  ETH->DMAOMR   = ETH_DMAOMR_FTF;
 8006eaa:	f241 0318 	movw	r3, #4120	; 0x1018
 8006eae:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8006eb2:	50f2      	str	r2, [r6, r3]
  while (ETH->DMAOMR & ETH_DMAOMR_FTF)
 8006eb4:	4a11      	ldr	r2, [pc, #68]	; (8006efc <mac_lld_start+0x10c>)
 8006eb6:	6813      	ldr	r3, [r2, #0]
 8006eb8:	4c10      	ldr	r4, [pc, #64]	; (8006efc <mac_lld_start+0x10c>)
 8006eba:	02db      	lsls	r3, r3, #11
 8006ebc:	d4fb      	bmi.n	8006eb6 <mac_lld_start+0xc6>
    ;

  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "FIFO FLush");
 8006ebe:	480b      	ldr	r0, [pc, #44]	; (8006eec <mac_lld_start+0xfc>)
 8006ec0:	4908      	ldr	r1, [pc, #32]	; (8006ee4 <mac_lld_start+0xf4>)
 8006ec2:	4a0f      	ldr	r2, [pc, #60]	; (8006f00 <mac_lld_start+0x110>)
 8006ec4:	f7ff fe3c 	bl	8006b40 <chprintf.constprop.2>

  /* DMA final configuration and start.*/
  ETH->DMAOMR   = ETH_DMAOMR_DTCEFD | ETH_DMAOMR_RSF | ETH_DMAOMR_TSF |
 8006ec8:	4b0e      	ldr	r3, [pc, #56]	; (8006f04 <mac_lld_start+0x114>)
 8006eca:	6023      	str	r3, [r4, #0]
 8006ecc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  ETH->MACFCR    = 0;
  ETH->MACVLANTR = 0;

  /* MAC address setup.*/
  if (macp->config->mac_address == NULL)
    mac_lld_set_address(default_mac_address);
 8006ed0:	480d      	ldr	r0, [pc, #52]	; (8006f08 <mac_lld_start+0x118>)
 8006ed2:	f7ff fe0d 	bl	8006af0 <mac_lld_set_address>
 8006ed6:	e7c9      	b.n	8006e6c <mac_lld_start+0x7c>
 8006ed8:	200035f8 	.word	0x200035f8
 8006edc:	20004220 	.word	0x20004220
 8006ee0:	40023800 	.word	0x40023800
 8006ee4:	08017004 	.word	0x08017004
 8006ee8:	08016e44 	.word	0x08016e44
 8006eec:	200180c8 	.word	0x200180c8
 8006ef0:	40028000 	.word	0x40028000
 8006ef4:	40029000 	.word	0x40029000
 8006ef8:	08016e50 	.word	0x08016e50
 8006efc:	40029018 	.word	0x40029018
 8006f00:	08016e60 	.word	0x08016e60
 8006f04:	06202002 	.word	0x06202002
 8006f08:	08016de0 	.word	0x08016de0
 8006f0c:	00010041 	.word	0x00010041
 8006f10:	02020100 	.word	0x02020100
 8006f14:	f3af 8000 	nop.w
 8006f18:	f3af 8000 	nop.w
 8006f1c:	f3af 8000 	nop.w

08006f20 <mac_lld_get_transmit_descriptor>:
 */
msg_t mac_lld_get_transmit_descriptor(MACDriver *macp,
                                      MACTransmitDescriptor *tdp) {
  stm32_eth_tx_descriptor_t *tdes;

  if (!macp->link_up)
 8006f20:	7f03      	ldrb	r3, [r0, #28]
 8006f22:	b1cb      	cbz	r3, 8006f58 <mac_lld_get_transmit_descriptor+0x38>
 8006f24:	2320      	movs	r3, #32
 8006f26:	f383 8811 	msr	BASEPRI, r3
    return MSG_TIMEOUT;

  osalSysLock();

  /* Get Current TX descriptor.*/
  tdes = macp->txptr;
 8006f2a:	6a82      	ldr	r2, [r0, #40]	; 0x28

  /* Ensure that descriptor isn't owned by the Ethernet DMA or locked by
     another thread.*/
  if (tdes->tdes0 & (STM32_TDES0_OWN | STM32_TDES0_LOCKED)) {
 8006f2c:	6813      	ldr	r3, [r2, #0]
 8006f2e:	f013 4301 	ands.w	r3, r3, #2164260864	; 0x81000000
 8006f32:	d114      	bne.n	8006f5e <mac_lld_get_transmit_descriptor+0x3e>
 * @retval MSG_TIMEOUT  descriptor not available.
 *
 * @notapi
 */
msg_t mac_lld_get_transmit_descriptor(MACDriver *macp,
                                      MACTransmitDescriptor *tdp) {
 8006f34:	b410      	push	{r4}
    osalSysUnlock();
    return MSG_TIMEOUT;
  }

  /* Marks the current descriptor as locked using a reserved bit.*/
  tdes->tdes0 |= STM32_TDES0_LOCKED;
 8006f36:	6814      	ldr	r4, [r2, #0]
 8006f38:	f044 7480 	orr.w	r4, r4, #16777216	; 0x1000000
 8006f3c:	6014      	str	r4, [r2, #0]

  /* Next TX descriptor to use.*/
  macp->txptr = (stm32_eth_tx_descriptor_t *)tdes->tdes3;
 8006f3e:	68d4      	ldr	r4, [r2, #12]
 8006f40:	6284      	str	r4, [r0, #40]	; 0x28
 8006f42:	f383 8811 	msr	BASEPRI, r3

  osalSysUnlock();

  /* Set the buffer size and configuration.*/
  tdp->offset   = 0;
  tdp->size     = STM32_MAC_BUFFERS_SIZE;
 8006f46:	f240 54f2 	movw	r4, #1522	; 0x5f2
  tdp->physdesc = tdes;

  return MSG_OK;
 8006f4a:	4618      	mov	r0, r3

  osalSysUnlock();

  /* Set the buffer size and configuration.*/
  tdp->offset   = 0;
  tdp->size     = STM32_MAC_BUFFERS_SIZE;
 8006f4c:	604c      	str	r4, [r1, #4]
  macp->txptr = (stm32_eth_tx_descriptor_t *)tdes->tdes3;

  osalSysUnlock();

  /* Set the buffer size and configuration.*/
  tdp->offset   = 0;
 8006f4e:	600b      	str	r3, [r1, #0]
  tdp->size     = STM32_MAC_BUFFERS_SIZE;
  tdp->physdesc = tdes;
 8006f50:	608a      	str	r2, [r1, #8]

  return MSG_OK;
}
 8006f52:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006f56:	4770      	bx	lr
msg_t mac_lld_get_transmit_descriptor(MACDriver *macp,
                                      MACTransmitDescriptor *tdp) {
  stm32_eth_tx_descriptor_t *tdes;

  if (!macp->link_up)
    return MSG_TIMEOUT;
 8006f58:	f04f 30ff 	mov.w	r0, #4294967295
 8006f5c:	4770      	bx	lr
 8006f5e:	2300      	movs	r3, #0
 8006f60:	f383 8811 	msr	BASEPRI, r3

  /* Ensure that descriptor isn't owned by the Ethernet DMA or locked by
     another thread.*/
  if (tdes->tdes0 & (STM32_TDES0_OWN | STM32_TDES0_LOCKED)) {
    osalSysUnlock();
    return MSG_TIMEOUT;
 8006f64:	f04f 30ff 	mov.w	r0, #4294967295
 8006f68:	4770      	bx	lr
 8006f6a:	bf00      	nop
 8006f6c:	f3af 8000 	nop.w

08006f70 <mac_lld_release_transmit_descriptor>:
 8006f70:	2320      	movs	r3, #32
 8006f72:	f383 8811 	msr	BASEPRI, r3
              "attempt to release descriptor already owned by DMA");

  osalSysLock();

  /* Unlocks the descriptor and returns it to the DMA engine.*/
  tdp->physdesc->tdes1 = tdp->offset;
 8006f76:	6883      	ldr	r3, [r0, #8]
 8006f78:	6801      	ldr	r1, [r0, #0]
 8006f7a:	6059      	str	r1, [r3, #4]
  tdp->physdesc->tdes0 = STM32_TDES0_CIC(STM32_MAC_IP_CHECKSUM_OFFLOAD) |
 8006f7c:	4809      	ldr	r0, [pc, #36]	; (8006fa4 <mac_lld_release_transmit_descriptor+0x34>)
                         STM32_TDES0_IC | STM32_TDES0_LS | STM32_TDES0_FS |
                         STM32_TDES0_TCH | STM32_TDES0_OWN;

  /* If the DMA engine is stalled then a restart request is issued.*/
  if ((ETH->DMASR & ETH_DMASR_TPS) == ETH_DMASR_TPS_Suspended) {
 8006f7e:	4a0a      	ldr	r2, [pc, #40]	; (8006fa8 <mac_lld_release_transmit_descriptor+0x38>)

  osalSysLock();

  /* Unlocks the descriptor and returns it to the DMA engine.*/
  tdp->physdesc->tdes1 = tdp->offset;
  tdp->physdesc->tdes0 = STM32_TDES0_CIC(STM32_MAC_IP_CHECKSUM_OFFLOAD) |
 8006f80:	6018      	str	r0, [r3, #0]
                         STM32_TDES0_IC | STM32_TDES0_LS | STM32_TDES0_FS |
                         STM32_TDES0_TCH | STM32_TDES0_OWN;

  /* If the DMA engine is stalled then a restart request is issued.*/
  if ((ETH->DMASR & ETH_DMASR_TPS) == ETH_DMASR_TPS_Suspended) {
 8006f82:	f241 0114 	movw	r1, #4116	; 0x1014
 8006f86:	5853      	ldr	r3, [r2, r1]
 8006f88:	f403 03e0 	and.w	r3, r3, #7340032	; 0x700000
 8006f8c:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
 8006f90:	d104      	bne.n	8006f9c <mac_lld_release_transmit_descriptor+0x2c>
    ETH->DMASR   = ETH_DMASR_TBUS;
    ETH->DMATPDR = ETH_DMASR_TBUS; /* Any value is OK.*/
 8006f92:	f241 0004 	movw	r0, #4100	; 0x1004
                         STM32_TDES0_IC | STM32_TDES0_LS | STM32_TDES0_FS |
                         STM32_TDES0_TCH | STM32_TDES0_OWN;

  /* If the DMA engine is stalled then a restart request is issued.*/
  if ((ETH->DMASR & ETH_DMASR_TPS) == ETH_DMASR_TPS_Suspended) {
    ETH->DMASR   = ETH_DMASR_TBUS;
 8006f96:	2304      	movs	r3, #4
 8006f98:	5053      	str	r3, [r2, r1]
    ETH->DMATPDR = ETH_DMASR_TBUS; /* Any value is OK.*/
 8006f9a:	5013      	str	r3, [r2, r0]
 8006f9c:	2300      	movs	r3, #0
 8006f9e:	f383 8811 	msr	BASEPRI, r3
 8006fa2:	4770      	bx	lr
 8006fa4:	f0100000 	.word	0xf0100000
 8006fa8:	40028000 	.word	0x40028000
 8006fac:	f3af 8000 	nop.w

08006fb0 <mac_lld_get_receive_descriptor>:
 8006fb0:	2320      	movs	r3, #32
 8006fb2:	f383 8811 	msr	BASEPRI, r3
  stm32_eth_rx_descriptor_t *rdes;

  osalSysLock();

  /* Get Current RX descriptor.*/
  rdes = macp->rxptr;
 8006fb6:	6a43      	ldr	r3, [r0, #36]	; 0x24

  /* Iterates through received frames until a valid one is found, invalid
     frames are discarded.*/
  while (!(rdes->rdes0 & STM32_RDES0_OWN)) {
 8006fb8:	681a      	ldr	r2, [r3, #0]
 8006fba:	2a00      	cmp	r2, #0
 8006fbc:	db27      	blt.n	800700e <mac_lld_get_receive_descriptor+0x5e>
 * @retval MSG_TIMEOUT  descriptor not available.
 *
 * @notapi
 */
msg_t mac_lld_get_receive_descriptor(MACDriver *macp,
                                     MACReceiveDescriptor *rdp) {
 8006fbe:	b430      	push	{r4, r5}

      osalSysUnlock();
      return MSG_OK;
    }
    /* Invalid frame found, purging.*/
    rdes->rdes0 = STM32_RDES0_OWN;
 8006fc0:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
  rdes = macp->rxptr;

  /* Iterates through received frames until a valid one is found, invalid
     frames are discarded.*/
  while (!(rdes->rdes0 & STM32_RDES0_OWN)) {
    if (!(rdes->rdes0 & (STM32_RDES0_AFM | STM32_RDES0_ES))
 8006fc4:	681c      	ldr	r4, [r3, #0]
 8006fc6:	4a15      	ldr	r2, [pc, #84]	; (800701c <mac_lld_get_receive_descriptor+0x6c>)
 8006fc8:	4022      	ands	r2, r4
 8006fca:	b92a      	cbnz	r2, 8006fd8 <mac_lld_get_receive_descriptor+0x28>
#if STM32_MAC_IP_CHECKSUM_OFFLOAD
        && (rdes->rdes0 & STM32_RDES0_FT)
        && !(rdes->rdes0 & (STM32_RDES0_IPHCE | STM32_RDES0_PCE))
#endif
        && (rdes->rdes0 & STM32_RDES0_FS) && (rdes->rdes0 & STM32_RDES0_LS)) {
 8006fcc:	681c      	ldr	r4, [r3, #0]
 8006fce:	05a4      	lsls	r4, r4, #22
 8006fd0:	d502      	bpl.n	8006fd8 <mac_lld_get_receive_descriptor+0x28>
 8006fd2:	681c      	ldr	r4, [r3, #0]
 8006fd4:	05e4      	lsls	r4, r4, #23
 8006fd6:	d40c      	bmi.n	8006ff2 <mac_lld_get_receive_descriptor+0x42>

      osalSysUnlock();
      return MSG_OK;
    }
    /* Invalid frame found, purging.*/
    rdes->rdes0 = STM32_RDES0_OWN;
 8006fd8:	601d      	str	r5, [r3, #0]
    rdes = (stm32_eth_rx_descriptor_t *)rdes->rdes3;
 8006fda:	68db      	ldr	r3, [r3, #12]
  /* Get Current RX descriptor.*/
  rdes = macp->rxptr;

  /* Iterates through received frames until a valid one is found, invalid
     frames are discarded.*/
  while (!(rdes->rdes0 & STM32_RDES0_OWN)) {
 8006fdc:	681a      	ldr	r2, [r3, #0]
 8006fde:	2a00      	cmp	r2, #0
 8006fe0:	daf0      	bge.n	8006fc4 <mac_lld_get_receive_descriptor+0x14>
    rdes->rdes0 = STM32_RDES0_OWN;
    rdes = (stm32_eth_rx_descriptor_t *)rdes->rdes3;
  }

  /* Next descriptor to check.*/
  macp->rxptr = rdes;
 8006fe2:	6243      	str	r3, [r0, #36]	; 0x24
 8006fe4:	2300      	movs	r3, #0
 8006fe6:	f383 8811 	msr	BASEPRI, r3

  osalSysUnlock();
  return MSG_TIMEOUT;
 8006fea:	f04f 30ff 	mov.w	r0, #4294967295
}
 8006fee:	bc30      	pop	{r4, r5}
 8006ff0:	4770      	bx	lr
        && !(rdes->rdes0 & (STM32_RDES0_IPHCE | STM32_RDES0_PCE))
#endif
        && (rdes->rdes0 & STM32_RDES0_FS) && (rdes->rdes0 & STM32_RDES0_LS)) {
      /* Found a valid one.*/
      rdp->offset   = 0;
      rdp->size     = ((rdes->rdes0 & STM32_RDES0_FL_MASK) >> 16) - 4;
 8006ff2:	681c      	ldr	r4, [r3, #0]
      rdp->physdesc = rdes;
      macp->rxptr   = (stm32_eth_rx_descriptor_t *)rdes->rdes3;
 8006ff4:	68dd      	ldr	r5, [r3, #12]
        && (rdes->rdes0 & STM32_RDES0_FT)
        && !(rdes->rdes0 & (STM32_RDES0_IPHCE | STM32_RDES0_PCE))
#endif
        && (rdes->rdes0 & STM32_RDES0_FS) && (rdes->rdes0 & STM32_RDES0_LS)) {
      /* Found a valid one.*/
      rdp->offset   = 0;
 8006ff6:	600a      	str	r2, [r1, #0]
      rdp->size     = ((rdes->rdes0 & STM32_RDES0_FL_MASK) >> 16) - 4;
 8006ff8:	f3c4 440d 	ubfx	r4, r4, #16, #14
 8006ffc:	3c04      	subs	r4, #4
 8006ffe:	604c      	str	r4, [r1, #4]
      rdp->physdesc = rdes;
 8007000:	608b      	str	r3, [r1, #8]
      macp->rxptr   = (stm32_eth_rx_descriptor_t *)rdes->rdes3;
 8007002:	6245      	str	r5, [r0, #36]	; 0x24
 8007004:	f382 8811 	msr	BASEPRI, r2

      osalSysUnlock();
      return MSG_OK;
 8007008:	4610      	mov	r0, r2
  /* Next descriptor to check.*/
  macp->rxptr = rdes;

  osalSysUnlock();
  return MSG_TIMEOUT;
}
 800700a:	bc30      	pop	{r4, r5}
 800700c:	4770      	bx	lr
    rdes->rdes0 = STM32_RDES0_OWN;
    rdes = (stm32_eth_rx_descriptor_t *)rdes->rdes3;
  }

  /* Next descriptor to check.*/
  macp->rxptr = rdes;
 800700e:	6243      	str	r3, [r0, #36]	; 0x24
 8007010:	2300      	movs	r3, #0
 8007012:	f383 8811 	msr	BASEPRI, r3

  osalSysUnlock();
  return MSG_TIMEOUT;
 8007016:	f04f 30ff 	mov.w	r0, #4294967295
}
 800701a:	4770      	bx	lr
 800701c:	40008000 	.word	0x40008000

08007020 <mac_lld_release_receive_descriptor>:
 8007020:	2320      	movs	r3, #32
 8007022:	f383 8811 	msr	BASEPRI, r3
              "attempt to release descriptor already owned by DMA");

  osalSysLock();

  /* Give buffer back to the Ethernet DMA.*/
  rdp->physdesc->rdes0 = STM32_RDES0_OWN;
 8007026:	6883      	ldr	r3, [r0, #8]

  /* If the DMA engine is stalled then a restart request is issued.*/
  if ((ETH->DMASR & ETH_DMASR_RPS) == ETH_DMASR_RPS_Suspended) {
 8007028:	4a0a      	ldr	r2, [pc, #40]	; (8007054 <mac_lld_release_receive_descriptor+0x34>)
              "attempt to release descriptor already owned by DMA");

  osalSysLock();

  /* Give buffer back to the Ethernet DMA.*/
  rdp->physdesc->rdes0 = STM32_RDES0_OWN;
 800702a:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000

  /* If the DMA engine is stalled then a restart request is issued.*/
  if ((ETH->DMASR & ETH_DMASR_RPS) == ETH_DMASR_RPS_Suspended) {
 800702e:	f241 0114 	movw	r1, #4116	; 0x1014
              "attempt to release descriptor already owned by DMA");

  osalSysLock();

  /* Give buffer back to the Ethernet DMA.*/
  rdp->physdesc->rdes0 = STM32_RDES0_OWN;
 8007032:	6018      	str	r0, [r3, #0]

  /* If the DMA engine is stalled then a restart request is issued.*/
  if ((ETH->DMASR & ETH_DMASR_RPS) == ETH_DMASR_RPS_Suspended) {
 8007034:	5853      	ldr	r3, [r2, r1]
 8007036:	f403 2360 	and.w	r3, r3, #917504	; 0xe0000
 800703a:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 800703e:	d104      	bne.n	800704a <mac_lld_release_receive_descriptor+0x2a>
    ETH->DMASR   = ETH_DMASR_RBUS;
    ETH->DMARPDR = ETH_DMASR_RBUS; /* Any value is OK.*/
 8007040:	f241 0008 	movw	r0, #4104	; 0x1008
  /* Give buffer back to the Ethernet DMA.*/
  rdp->physdesc->rdes0 = STM32_RDES0_OWN;

  /* If the DMA engine is stalled then a restart request is issued.*/
  if ((ETH->DMASR & ETH_DMASR_RPS) == ETH_DMASR_RPS_Suspended) {
    ETH->DMASR   = ETH_DMASR_RBUS;
 8007044:	2380      	movs	r3, #128	; 0x80
 8007046:	5053      	str	r3, [r2, r1]
    ETH->DMARPDR = ETH_DMASR_RBUS; /* Any value is OK.*/
 8007048:	5013      	str	r3, [r2, r0]
 800704a:	2300      	movs	r3, #0
 800704c:	f383 8811 	msr	BASEPRI, r3
 8007050:	4770      	bx	lr
 8007052:	bf00      	nop
 8007054:	40028000 	.word	0x40028000
 8007058:	f3af 8000 	nop.w
 800705c:	f3af 8000 	nop.w

08007060 <mac_lld_poll_link_status>:
 * @retval true         if the link is active.
 * @retval false        if the link is down.
 *
 * @notapi
 */
bool mac_lld_poll_link_status(MACDriver *macp) {
 8007060:	b470      	push	{r4, r5, r6}
 8007062:	4605      	mov	r5, r0
 *
 * @notapi
 */
uint32_t mii_read(MACDriver *macp, uint32_t reg) {

  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR | ETH_MACMIIAR_MB;
 8007064:	6a00      	ldr	r0, [r0, #32]
 * @notapi
 */
bool mac_lld_poll_link_status(MACDriver *macp) {
  uint32_t maccr, bmsr, bmcr;

  maccr = ETH->MACCR;
 8007066:	4926      	ldr	r1, [pc, #152]	; (8007100 <mac_lld_poll_link_status+0xa0>)
 *
 * @notapi
 */
uint32_t mii_read(MACDriver *macp, uint32_t reg) {

  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR | ETH_MACMIIAR_MB;
 8007068:	f040 0651 	orr.w	r6, r0, #81	; 0x51
 * @notapi
 */
bool mac_lld_poll_link_status(MACDriver *macp) {
  uint32_t maccr, bmsr, bmcr;

  maccr = ETH->MACCR;
 800706c:	680c      	ldr	r4, [r1, #0]
 *
 * @notapi
 */
uint32_t mii_read(MACDriver *macp, uint32_t reg) {

  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR | ETH_MACMIIAR_MB;
 800706e:	610e      	str	r6, [r1, #16]
  while ((ETH->MACMIIAR & ETH_MACMIIAR_MB) != 0)
 8007070:	690a      	ldr	r2, [r1, #16]
 8007072:	4b23      	ldr	r3, [pc, #140]	; (8007100 <mac_lld_poll_link_status+0xa0>)
 8007074:	07d2      	lsls	r2, r2, #31
 8007076:	d4fb      	bmi.n	8007070 <mac_lld_poll_link_status+0x10>
    ;
  return ETH->MACMIIDR;
 8007078:	695a      	ldr	r2, [r3, #20]
 *
 * @notapi
 */
uint32_t mii_read(MACDriver *macp, uint32_t reg) {

  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR | ETH_MACMIIAR_MB;
 800707a:	611e      	str	r6, [r3, #16]
  while ((ETH->MACMIIAR & ETH_MACMIIAR_MB) != 0)
 800707c:	461a      	mov	r2, r3
 800707e:	6911      	ldr	r1, [r2, #16]
 8007080:	4b1f      	ldr	r3, [pc, #124]	; (8007100 <mac_lld_poll_link_status+0xa0>)
 8007082:	07c9      	lsls	r1, r1, #31
 8007084:	d4fb      	bmi.n	800707e <mac_lld_poll_link_status+0x1e>
 *
 * @notapi
 */
uint32_t mii_read(MACDriver *macp, uint32_t reg) {

  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR | ETH_MACMIIAR_MB;
 8007086:	f040 0211 	orr.w	r2, r0, #17
  while ((ETH->MACMIIAR & ETH_MACMIIAR_MB) != 0)
    ;
  return ETH->MACMIIDR;
 800708a:	695e      	ldr	r6, [r3, #20]
 *
 * @notapi
 */
uint32_t mii_read(MACDriver *macp, uint32_t reg) {

  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR | ETH_MACMIIAR_MB;
 800708c:	611a      	str	r2, [r3, #16]
  while ((ETH->MACMIIAR & ETH_MACMIIAR_MB) != 0)
 800708e:	691a      	ldr	r2, [r3, #16]
 8007090:	491b      	ldr	r1, [pc, #108]	; (8007100 <mac_lld_poll_link_status+0xa0>)
 8007092:	07d2      	lsls	r2, r2, #31
 8007094:	d4fb      	bmi.n	800708e <mac_lld_poll_link_status+0x2e>
    ;
  return ETH->MACMIIDR;
 8007096:	694b      	ldr	r3, [r1, #20]
  (void)mii_read(macp, MII_BMSR);
  bmsr = mii_read(macp, MII_BMSR);
  bmcr = mii_read(macp, MII_BMCR);

  /* Check on auto-negotiation mode.*/
  if (bmcr & BMCR_ANENABLE) {
 8007098:	04da      	lsls	r2, r3, #19
 800709a:	d507      	bpl.n	80070ac <mac_lld_poll_link_status+0x4c>
    uint32_t lpa;

    /* Auto-negotiation must be finished without faults and link established.*/
    if ((bmsr & (BMSR_LSTATUS | BMSR_RFAULT | BMSR_ANEGCOMPLETE)) !=
 800709c:	f006 0634 	and.w	r6, r6, #52	; 0x34
 80070a0:	2e24      	cmp	r6, #36	; 0x24
 80070a2:	d016      	beq.n	80070d2 <mac_lld_poll_link_status+0x72>
        (BMSR_LSTATUS | BMSR_ANEGCOMPLETE))
      return macp->link_up = false;
 80070a4:	2000      	movs	r0, #0
 80070a6:	7728      	strb	r0, [r5, #28]
  /* Changes the mode in the MAC.*/
  ETH->MACCR = maccr;

  /* Returns the link status.*/
  return macp->link_up = true;
}
 80070a8:	bc70      	pop	{r4, r5, r6}
 80070aa:	4770      	bx	lr
    else
      maccr &= ~ETH_MACCR_DM;
  }
  else {
    /* Link must be established.*/
    if (!(bmsr & BMSR_LSTATUS))
 80070ac:	0771      	lsls	r1, r6, #29
 80070ae:	d5f9      	bpl.n	80070a4 <mac_lld_poll_link_status+0x44>
      return macp->link_up = false;

    /* Check on link speed.*/
    if (bmcr & BMCR_SPEED100)
 80070b0:	049a      	lsls	r2, r3, #18
      maccr |= ETH_MACCR_FES;
 80070b2:	bf4c      	ite	mi
 80070b4:	f444 4480 	orrmi.w	r4, r4, #16384	; 0x4000
    else
      maccr &= ~ETH_MACCR_FES;
 80070b8:	f424 4480 	bicpl.w	r4, r4, #16384	; 0x4000

    /* Check on link mode.*/
    if (bmcr & BMCR_FULLDPLX)
 80070bc:	05db      	lsls	r3, r3, #23
 80070be:	d41c      	bmi.n	80070fa <mac_lld_poll_link_status+0x9a>
      maccr |= ETH_MACCR_DM;
    else
      maccr &= ~ETH_MACCR_DM;
 80070c0:	f424 6400 	bic.w	r4, r4, #2048	; 0x800
  }

  /* Changes the mode in the MAC.*/
  ETH->MACCR = maccr;
 80070c4:	4a0e      	ldr	r2, [pc, #56]	; (8007100 <mac_lld_poll_link_status+0xa0>)

  /* Returns the link status.*/
  return macp->link_up = true;
 80070c6:	2301      	movs	r3, #1
    else
      maccr &= ~ETH_MACCR_DM;
  }

  /* Changes the mode in the MAC.*/
  ETH->MACCR = maccr;
 80070c8:	6014      	str	r4, [r2, #0]

  /* Returns the link status.*/
  return macp->link_up = true;
 80070ca:	4618      	mov	r0, r3
 80070cc:	772b      	strb	r3, [r5, #28]
}
 80070ce:	bc70      	pop	{r4, r5, r6}
 80070d0:	4770      	bx	lr
 *
 * @notapi
 */
uint32_t mii_read(MACDriver *macp, uint32_t reg) {

  ETH->MACMIIAR = macp->phyaddr | (reg << 6) | MACMIIDR_CR | ETH_MACMIIAR_MB;
 80070d2:	f440 70a8 	orr.w	r0, r0, #336	; 0x150
 80070d6:	f040 0001 	orr.w	r0, r0, #1
 80070da:	6108      	str	r0, [r1, #16]
  while ((ETH->MACMIIAR & ETH_MACMIIAR_MB) != 0)
 80070dc:	690b      	ldr	r3, [r1, #16]
 80070de:	4a08      	ldr	r2, [pc, #32]	; (8007100 <mac_lld_poll_link_status+0xa0>)
 80070e0:	07d8      	lsls	r0, r3, #31
 80070e2:	d4fb      	bmi.n	80070dc <mac_lld_poll_link_status+0x7c>
    ;
  return ETH->MACMIIDR;
 80070e4:	6953      	ldr	r3, [r2, #20]

    /* Auto-negotiation enabled, checks the LPA register.*/
    lpa = mii_read(macp, MII_LPA);

    /* Check on link speed.*/
    if (lpa & (LPA_100HALF | LPA_100FULL | LPA_100BASE4))
 80070e6:	f413 7f60 	tst.w	r3, #896	; 0x380
      maccr |= ETH_MACCR_FES;
 80070ea:	bf14      	ite	ne
 80070ec:	f444 4480 	orrne.w	r4, r4, #16384	; 0x4000
    else
      maccr &= ~ETH_MACCR_FES;
 80070f0:	f424 4480 	biceq.w	r4, r4, #16384	; 0x4000

    /* Check on link mode.*/
    if (lpa & (LPA_10FULL | LPA_100FULL))
 80070f4:	f413 7fa0 	tst.w	r3, #320	; 0x140
 80070f8:	d0e2      	beq.n	80070c0 <mac_lld_poll_link_status+0x60>
    else
      maccr &= ~ETH_MACCR_FES;

    /* Check on link mode.*/
    if (bmcr & BMCR_FULLDPLX)
      maccr |= ETH_MACCR_DM;
 80070fa:	f444 6400 	orr.w	r4, r4, #2048	; 0x800
 80070fe:	e7e1      	b.n	80070c4 <mac_lld_poll_link_status+0x64>
 8007100:	40028000 	.word	0x40028000
 8007104:	f3af 8000 	nop.w
 8007108:	f3af 8000 	nop.w
 800710c:	f3af 8000 	nop.w

08007110 <mac_lld_write_transmit_descriptor>:
 *
 * @notapi
 */
size_t mac_lld_write_transmit_descriptor(MACTransmitDescriptor *tdp,
                                         uint8_t *buf,
                                         size_t size) {
 8007110:	b538      	push	{r3, r4, r5, lr}

  osalDbgAssert(!(tdp->physdesc->tdes0 & STM32_TDES0_OWN),
              "attempt to write descriptor already owned by DMA");

  if (size > tdp->size - tdp->offset)
 8007112:	e890 0018 	ldmia.w	r0, {r3, r4}
 8007116:	1ae4      	subs	r4, r4, r3
 8007118:	4294      	cmp	r4, r2
 800711a:	bf28      	it	cs
 800711c:	4614      	movcs	r4, r2
    size = tdp->size - tdp->offset;

  if (size > 0) {
 800711e:	b14c      	cbz	r4, 8007134 <mac_lld_write_transmit_descriptor+0x24>
    memcpy((uint8_t *)(tdp->physdesc->tdes2) + tdp->offset, buf, size);
 8007120:	6882      	ldr	r2, [r0, #8]
 8007122:	4605      	mov	r5, r0
 8007124:	6890      	ldr	r0, [r2, #8]
 8007126:	4622      	mov	r2, r4
 8007128:	4418      	add	r0, r3
 800712a:	f7f9 fbc9 	bl	80008c0 <memcpy>
    tdp->offset += size;
 800712e:	682b      	ldr	r3, [r5, #0]
 8007130:	4423      	add	r3, r4
 8007132:	602b      	str	r3, [r5, #0]
  }
  return size;
}
 8007134:	4620      	mov	r0, r4
 8007136:	bd38      	pop	{r3, r4, r5, pc}
 8007138:	f3af 8000 	nop.w
 800713c:	f3af 8000 	nop.w

08007140 <mac_lld_read_receive_descriptor>:
 *
 * @notapi
 */
size_t mac_lld_read_receive_descriptor(MACReceiveDescriptor *rdp,
                                       uint8_t *buf,
                                       size_t size) {
 8007140:	b538      	push	{r3, r4, r5, lr}

  osalDbgAssert(!(rdp->physdesc->rdes0 & STM32_RDES0_OWN),
              "attempt to read descriptor already owned by DMA");

  if (size > rdp->size - rdp->offset)
 8007142:	e890 0018 	ldmia.w	r0, {r3, r4}
 8007146:	1ae4      	subs	r4, r4, r3
 8007148:	4294      	cmp	r4, r2
 800714a:	bf28      	it	cs
 800714c:	4614      	movcs	r4, r2
    size = rdp->size - rdp->offset;

  if (size > 0) {
 800714e:	b154      	cbz	r4, 8007166 <mac_lld_read_receive_descriptor+0x26>
    memcpy(buf, (uint8_t *)(rdp->physdesc->rdes2) + rdp->offset, size);
 8007150:	6882      	ldr	r2, [r0, #8]
 8007152:	6892      	ldr	r2, [r2, #8]
 8007154:	4605      	mov	r5, r0
 8007156:	4608      	mov	r0, r1
 8007158:	18d1      	adds	r1, r2, r3
 800715a:	4622      	mov	r2, r4
 800715c:	f7f9 fbb0 	bl	80008c0 <memcpy>
    rdp->offset += size;
 8007160:	682b      	ldr	r3, [r5, #0]
 8007162:	4423      	add	r3, r4
 8007164:	602b      	str	r3, [r5, #0]
  }
  return size;
}
 8007166:	4620      	mov	r0, r4
 8007168:	bd38      	pop	{r3, r4, r5, pc}
 800716a:	bf00      	nop
 800716c:	f3af 8000 	nop.w

08007170 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8007170:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8007174:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 800732c <_pal_lld_init+0x1bc>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007178:	f8df c1b4 	ldr.w	ip, [pc, #436]	; 8007330 <_pal_lld_init+0x1c0>
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 800717c:	f8d8 a030 	ldr.w	sl, [r8, #48]	; 0x30
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007180:	f8df e1b0 	ldr.w	lr, [pc, #432]	; 8007334 <_pal_lld_init+0x1c4>
 8007184:	4f63      	ldr	r7, [pc, #396]	; (8007314 <_pal_lld_init+0x1a4>)
 8007186:	4e64      	ldr	r6, [pc, #400]	; (8007318 <_pal_lld_init+0x1a8>)
 8007188:	4d64      	ldr	r5, [pc, #400]	; (800731c <_pal_lld_init+0x1ac>)
 800718a:	4c65      	ldr	r4, [pc, #404]	; (8007320 <_pal_lld_init+0x1b0>)
 800718c:	4965      	ldr	r1, [pc, #404]	; (8007324 <_pal_lld_init+0x1b4>)
 800718e:	4a66      	ldr	r2, [pc, #408]	; (8007328 <_pal_lld_init+0x1b8>)
 8007190:	f8df b1a4 	ldr.w	fp, [pc, #420]	; 8007338 <_pal_lld_init+0x1c8>
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8007194:	f240 19ff 	movw	r9, #511	; 0x1ff
 8007198:	ea4a 0a09 	orr.w	sl, sl, r9
 800719c:	f8c8 a030 	str.w	sl, [r8, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 80071a0:	f8d8 a050 	ldr.w	sl, [r8, #80]	; 0x50
 80071a4:	ea4a 0909 	orr.w	r9, sl, r9
 80071a8:	f8c8 9050 	str.w	r9, [r8, #80]	; 0x50
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80071ac:	6843      	ldr	r3, [r0, #4]
 80071ae:	f8cc 3004 	str.w	r3, [ip, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80071b2:	6883      	ldr	r3, [r0, #8]
 80071b4:	f8cc 3008 	str.w	r3, [ip, #8]
  gpiop->PUPDR   = config->pupdr;
 80071b8:	68c3      	ldr	r3, [r0, #12]
 80071ba:	f8cc 300c 	str.w	r3, [ip, #12]
  gpiop->ODR     = config->odr;
 80071be:	6903      	ldr	r3, [r0, #16]
 80071c0:	f8cc 3014 	str.w	r3, [ip, #20]
  gpiop->AFRL    = config->afrl;
 80071c4:	6943      	ldr	r3, [r0, #20]
 80071c6:	f8cc 3020 	str.w	r3, [ip, #32]
  gpiop->AFRH    = config->afrh;
 80071ca:	6983      	ldr	r3, [r0, #24]
 80071cc:	f8cc 3024 	str.w	r3, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80071d0:	6803      	ldr	r3, [r0, #0]
 80071d2:	f8cc 3000 	str.w	r3, [ip]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80071d6:	6a03      	ldr	r3, [r0, #32]
 80071d8:	f8ce 3004 	str.w	r3, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80071dc:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80071de:	f8ce 3008 	str.w	r3, [lr, #8]
  gpiop->PUPDR   = config->pupdr;
 80071e2:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80071e4:	f8ce 300c 	str.w	r3, [lr, #12]
  gpiop->ODR     = config->odr;
 80071e8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80071ea:	f8ce 3014 	str.w	r3, [lr, #20]
  gpiop->AFRL    = config->afrl;
 80071ee:	6b03      	ldr	r3, [r0, #48]	; 0x30
 80071f0:	f8ce 3020 	str.w	r3, [lr, #32]
  gpiop->AFRH    = config->afrh;
 80071f4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80071f6:	f8ce 3024 	str.w	r3, [lr, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80071fa:	69c3      	ldr	r3, [r0, #28]
 80071fc:	f8ce 3000 	str.w	r3, [lr]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007200:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8007202:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8007204:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8007206:	60bb      	str	r3, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 8007208:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800720a:	60fb      	str	r3, [r7, #12]
  gpiop->ODR     = config->odr;
 800720c:	6c83      	ldr	r3, [r0, #72]	; 0x48
 800720e:	617b      	str	r3, [r7, #20]
  gpiop->AFRL    = config->afrl;
 8007210:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8007212:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 8007214:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8007216:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8007218:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800721a:	603b      	str	r3, [r7, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800721c:	6d87      	ldr	r7, [r0, #88]	; 0x58
 800721e:	6077      	str	r7, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8007220:	6dc7      	ldr	r7, [r0, #92]	; 0x5c
 8007222:	60b7      	str	r7, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 8007224:	6e07      	ldr	r7, [r0, #96]	; 0x60
 8007226:	60f7      	str	r7, [r6, #12]
  gpiop->ODR     = config->odr;
 8007228:	6e47      	ldr	r7, [r0, #100]	; 0x64
 800722a:	6177      	str	r7, [r6, #20]
  gpiop->AFRL    = config->afrl;
 800722c:	6e87      	ldr	r7, [r0, #104]	; 0x68
 800722e:	6237      	str	r7, [r6, #32]
  gpiop->AFRH    = config->afrh;
 8007230:	6ec7      	ldr	r7, [r0, #108]	; 0x6c
 8007232:	6277      	str	r7, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8007234:	6d47      	ldr	r7, [r0, #84]	; 0x54
 8007236:	6037      	str	r7, [r6, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007238:	6f46      	ldr	r6, [r0, #116]	; 0x74
 800723a:	606e      	str	r6, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800723c:	6f86      	ldr	r6, [r0, #120]	; 0x78
 800723e:	60ae      	str	r6, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 8007240:	6fc6      	ldr	r6, [r0, #124]	; 0x7c
 8007242:	60ee      	str	r6, [r5, #12]
  gpiop->ODR     = config->odr;
 8007244:	f8d0 6080 	ldr.w	r6, [r0, #128]	; 0x80
 8007248:	616e      	str	r6, [r5, #20]
  gpiop->AFRL    = config->afrl;
 800724a:	f8d0 6084 	ldr.w	r6, [r0, #132]	; 0x84
 800724e:	622e      	str	r6, [r5, #32]
  gpiop->AFRH    = config->afrh;
 8007250:	f8d0 6088 	ldr.w	r6, [r0, #136]	; 0x88
 8007254:	626e      	str	r6, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8007256:	6f06      	ldr	r6, [r0, #112]	; 0x70
 8007258:	602e      	str	r6, [r5, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800725a:	f8d0 5090 	ldr.w	r5, [r0, #144]	; 0x90
 800725e:	6065      	str	r5, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8007260:	f8d0 5094 	ldr.w	r5, [r0, #148]	; 0x94
 8007264:	60a5      	str	r5, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8007266:	f8d0 5098 	ldr.w	r5, [r0, #152]	; 0x98
 800726a:	60e5      	str	r5, [r4, #12]
  gpiop->ODR     = config->odr;
 800726c:	f8d0 509c 	ldr.w	r5, [r0, #156]	; 0x9c
 8007270:	6165      	str	r5, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8007272:	f8d0 50a0 	ldr.w	r5, [r0, #160]	; 0xa0
 8007276:	6225      	str	r5, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8007278:	f8d0 50a4 	ldr.w	r5, [r0, #164]	; 0xa4
 800727c:	6265      	str	r5, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800727e:	f8d0 508c 	ldr.w	r5, [r0, #140]	; 0x8c
 8007282:	6025      	str	r5, [r4, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007284:	f8d0 40ac 	ldr.w	r4, [r0, #172]	; 0xac
 8007288:	604c      	str	r4, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800728a:	f8d0 40b0 	ldr.w	r4, [r0, #176]	; 0xb0
 800728e:	608c      	str	r4, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8007290:	f8d0 40b4 	ldr.w	r4, [r0, #180]	; 0xb4
 8007294:	60cc      	str	r4, [r1, #12]
  gpiop->ODR     = config->odr;
 8007296:	f8d0 40b8 	ldr.w	r4, [r0, #184]	; 0xb8
 800729a:	614c      	str	r4, [r1, #20]
  gpiop->AFRL    = config->afrl;
 800729c:	f8d0 40bc 	ldr.w	r4, [r0, #188]	; 0xbc
 80072a0:	620c      	str	r4, [r1, #32]
  gpiop->AFRH    = config->afrh;
 80072a2:	f8d0 40c0 	ldr.w	r4, [r0, #192]	; 0xc0
 80072a6:	624c      	str	r4, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80072a8:	f8d0 40a8 	ldr.w	r4, [r0, #168]	; 0xa8
 80072ac:	600c      	str	r4, [r1, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80072ae:	f8d0 10c8 	ldr.w	r1, [r0, #200]	; 0xc8
 80072b2:	6051      	str	r1, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80072b4:	f8d0 10cc 	ldr.w	r1, [r0, #204]	; 0xcc
 80072b8:	6091      	str	r1, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 80072ba:	f8d0 10d0 	ldr.w	r1, [r0, #208]	; 0xd0
 80072be:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 80072c0:	f8d0 10d4 	ldr.w	r1, [r0, #212]	; 0xd4
 80072c4:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 80072c6:	f8d0 10d8 	ldr.w	r1, [r0, #216]	; 0xd8
 80072ca:	6211      	str	r1, [r2, #32]
  gpiop->AFRH    = config->afrh;
 80072cc:	f8d0 10dc 	ldr.w	r1, [r0, #220]	; 0xdc
 80072d0:	6251      	str	r1, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80072d2:	f8d0 10c4 	ldr.w	r1, [r0, #196]	; 0xc4
 80072d6:	6011      	str	r1, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80072d8:	f8d0 20e4 	ldr.w	r2, [r0, #228]	; 0xe4
 80072dc:	f8cb 2004 	str.w	r2, [fp, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80072e0:	f8d0 20e8 	ldr.w	r2, [r0, #232]	; 0xe8
 80072e4:	f8cb 2008 	str.w	r2, [fp, #8]
  gpiop->PUPDR   = config->pupdr;
 80072e8:	f8d0 20ec 	ldr.w	r2, [r0, #236]	; 0xec
 80072ec:	f8cb 200c 	str.w	r2, [fp, #12]
  gpiop->ODR     = config->odr;
 80072f0:	f8d0 20f0 	ldr.w	r2, [r0, #240]	; 0xf0
 80072f4:	f8cb 2014 	str.w	r2, [fp, #20]
  gpiop->AFRL    = config->afrl;
 80072f8:	f8d0 20f4 	ldr.w	r2, [r0, #244]	; 0xf4
 80072fc:	f8cb 2020 	str.w	r2, [fp, #32]
  gpiop->AFRH    = config->afrh;
 8007300:	f8d0 20f8 	ldr.w	r2, [r0, #248]	; 0xf8
 8007304:	f8cb 2024 	str.w	r2, [fp, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8007308:	f8d0 20e0 	ldr.w	r2, [r0, #224]	; 0xe0
 800730c:	f8cb 2000 	str.w	r2, [fp]
 8007310:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007314:	40020800 	.word	0x40020800
 8007318:	40020c00 	.word	0x40020c00
 800731c:	40021000 	.word	0x40021000
 8007320:	40021400 	.word	0x40021400
 8007324:	40021800 	.word	0x40021800
 8007328:	40021c00 	.word	0x40021c00
 800732c:	40023800 	.word	0x40023800
 8007330:	40020000 	.word	0x40020000
 8007334:	40020400 	.word	0x40020400
 8007338:	40022000 	.word	0x40022000
 800733c:	f3af 8000 	nop.w

08007340 <rtc_lld_init>:
/**
 * @brief   Enable access to registers.
 *
 * @notapi
 */
void rtc_lld_init(void) {
 8007340:	b510      	push	{r4, lr}

  /* RTC object initialization.*/
  rtcObjectInit(&RTCD1);
 8007342:	4c12      	ldr	r4, [pc, #72]	; (800738c <rtc_lld_init+0x4c>)
 8007344:	4620      	mov	r0, r4
 8007346:	f7ff f883 	bl	8006450 <rtcObjectInit>

  /* RTC pointer initialization.*/
  RTCD1.rtc = RTC;
 800734a:	4b11      	ldr	r3, [pc, #68]	; (8007390 <rtc_lld_init+0x50>)
 800734c:	6023      	str	r3, [r4, #0]

  /* Disable write protection. */
  RTCD1.rtc->WPR = 0xCA;
  RTCD1.rtc->WPR = 0x53;
 800734e:	2253      	movs	r2, #83	; 0x53

  /* RTC pointer initialization.*/
  RTCD1.rtc = RTC;

  /* Disable write protection. */
  RTCD1.rtc->WPR = 0xCA;
 8007350:	21ca      	movs	r1, #202	; 0xca
 8007352:	6259      	str	r1, [r3, #36]	; 0x24
  RTCD1.rtc->WPR = 0x53;
 8007354:	625a      	str	r2, [r3, #36]	; 0x24

  /* If calendar has not been initialized yet then proceed with the
     initial setup.*/
  if (!(RTCD1.rtc->ISR & RTC_ISR_INITS)) {
 8007356:	68da      	ldr	r2, [r3, #12]
 8007358:	f012 0f10 	tst.w	r2, #16
 *
 * @notapi
 */
static void rtc_enter_init(void) {

  RTCD1.rtc->ISR |= RTC_ISR_INIT;
 800735c:	68da      	ldr	r2, [r3, #12]
  RTCD1.rtc->WPR = 0xCA;
  RTCD1.rtc->WPR = 0x53;

  /* If calendar has not been initialized yet then proceed with the
     initial setup.*/
  if (!(RTCD1.rtc->ISR & RTC_ISR_INITS)) {
 800735e:	d111      	bne.n	8007384 <rtc_lld_init+0x44>
 *
 * @notapi
 */
static void rtc_enter_init(void) {

  RTCD1.rtc->ISR |= RTC_ISR_INIT;
 8007360:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8007364:	60da      	str	r2, [r3, #12]
  while ((RTCD1.rtc->ISR & RTC_ISR_INITF) == 0)
 8007366:	68da      	ldr	r2, [r3, #12]
 8007368:	4909      	ldr	r1, [pc, #36]	; (8007390 <rtc_lld_init+0x50>)
 800736a:	0652      	lsls	r2, r2, #25
 800736c:	d5fb      	bpl.n	8007366 <rtc_lld_init+0x26>

    rtc_enter_init();

    RTCD1.rtc->CR   = 0;
    RTCD1.rtc->ISR  = 0;
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 800736e:	4b09      	ldr	r3, [pc, #36]	; (8007394 <rtc_lld_init+0x54>)
     initial setup.*/
  if (!(RTCD1.rtc->ISR & RTC_ISR_INITS)) {

    rtc_enter_init();

    RTCD1.rtc->CR   = 0;
 8007370:	2200      	movs	r2, #0
 8007372:	608a      	str	r2, [r1, #8]
    RTCD1.rtc->ISR  = 0;
 8007374:	60ca      	str	r2, [r1, #12]
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 8007376:	610b      	str	r3, [r1, #16]
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 8007378:	610b      	str	r3, [r1, #16]
 *
 * @notapi
 */
static inline void rtc_exit_init(void) {

  RTCD1.rtc->ISR &= ~RTC_ISR_INIT;
 800737a:	68cb      	ldr	r3, [r1, #12]
 800737c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8007380:	60cb      	str	r3, [r1, #12]
 8007382:	bd10      	pop	{r4, pc}
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;

    rtc_exit_init();
  }
  else
    RTCD1.rtc->ISR &= ~RTC_ISR_RSF;
 8007384:	f022 0220 	bic.w	r2, r2, #32
 8007388:	60da      	str	r2, [r3, #12]
 800738a:	bd10      	pop	{r4, pc}
 800738c:	20004240 	.word	0x20004240
 8007390:	40002800 	.word	0x40002800
 8007394:	007f00ff 	.word	0x007f00ff
 8007398:	f3af 8000 	nop.w
 800739c:	f3af 8000 	nop.w

080073a0 <VectorB0>:
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  STM32_ST_TIM->SR = 0;
 80073a0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80073a4:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  STM32_ST_TIM->SR = 0;
 80073a6:	2400      	movs	r4, #0
 80073a8:	611c      	str	r4, [r3, #16]
 80073aa:	2320      	movs	r3, #32
 80073ac:	f383 8811 	msr	BASEPRI, r3
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
 80073b0:	f7f9 fde6 	bl	8000f80 <chSysTimerHandlerI>
 80073b4:	f384 8811 	msr	BASEPRI, r4
  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
}
 80073b8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
 80073bc:	f7f9 bd48 	b.w	8000e50 <_port_irq_epilogue>

080073c0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 80073c0:	b470      	push	{r4, r5, r6}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80073c2:	480d      	ldr	r0, [pc, #52]	; (80073f8 <st_lld_init+0x38>)
 80073c4:	6c01      	ldr	r1, [r0, #64]	; 0x40

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80073c6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 80073ca:	2200      	movs	r2, #0
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80073cc:	2401      	movs	r4, #1

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80073ce:	f041 0101 	orr.w	r1, r1, #1

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80073d2:	f641 564b 	movw	r6, #7499	; 0x1d4b
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80073d6:	f04f 35ff 	mov.w	r5, #4294967295

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80073da:	6401      	str	r1, [r0, #64]	; 0x40

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80073dc:	629e      	str	r6, [r3, #40]	; 0x28
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 80073de:	201c      	movs	r0, #28
  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80073e0:	62dd      	str	r5, [r3, #44]	; 0x2c
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 80073e2:	2108      	movs	r1, #8
  ST_ENABLE_CLOCK();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 80073e4:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 80073e6:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 80073e8:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 80073ea:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80073ec:	615c      	str	r4, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80073ee:	601c      	str	r4, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 80073f0:	bc70      	pop	{r4, r5, r6}
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 80073f2:	f7ff b90d 	b.w	8006610 <nvicEnableVector>
 80073f6:	bf00      	nop
 80073f8:	40023800 	.word	0x40023800
 80073fc:	f3af 8000 	nop.w

08007400 <notify2>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 8007400:	4a02      	ldr	r2, [pc, #8]	; (800740c <notify2+0xc>)
 8007402:	68d3      	ldr	r3, [r2, #12]
 8007404:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8007408:	60d3      	str	r3, [r2, #12]
 800740a:	4770      	bx	lr
 800740c:	40004400 	.word	0x40004400

08007410 <notify6>:

#if STM32_SERIAL_USE_USART6 || defined(__DOXYGEN__)
static void notify6(io_queue_t *qp) {

  (void)qp;
  USART6->CR1 |= USART_CR1_TXEIE;
 8007410:	4a02      	ldr	r2, [pc, #8]	; (800741c <notify6+0xc>)
 8007412:	68d3      	ldr	r3, [r2, #12]
 8007414:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8007418:	60d3      	str	r3, [r2, #12]
 800741a:	4770      	bx	lr
 800741c:	40011400 	.word	0x40011400

08007420 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8007420:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  USART_TypeDef *u = sdp->usart;
 8007424:	6f45      	ldr	r5, [r0, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 8007426:	f8d5 800c 	ldr.w	r8, [r5, #12]
  uint16_t sr = u->SR;
 800742a:	682b      	ldr	r3, [r5, #0]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 800742c:	05da      	lsls	r2, r3, #23
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 800742e:	4606      	mov	r6, r0
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
  uint16_t sr = u->SR;
 8007430:	b29c      	uxth	r4, r3

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8007432:	d451      	bmi.n	80074d8 <serve_interrupt+0xb8>
 8007434:	2320      	movs	r3, #32
 8007436:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800743a:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 800743e:	d02b      	beq.n	8007498 <serve_interrupt+0x78>
    sts |= SD_PARITY_ERROR;
  if (sr & USART_SR_FE)
    sts |= SD_FRAMING_ERROR;
  if (sr & USART_SR_NE)
    sts |= SD_NOISE_ERROR;
  chnAddFlagsI(sdp, sts);
 8007440:	1d37      	adds	r7, r6, #4
 8007442:	e007      	b.n	8007454 <serve_interrupt+0x34>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 8007444:	06a0      	lsls	r0, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 8007446:	6869      	ldr	r1, [r5, #4]
    if (sr & USART_SR_RXNE)
 8007448:	d41d      	bmi.n	8007486 <serve_interrupt+0x66>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 800744a:	682c      	ldr	r4, [r5, #0]
 800744c:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800744e:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8007452:	d021      	beq.n	8007498 <serve_interrupt+0x78>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8007454:	0723      	lsls	r3, r4, #28
 8007456:	d0f5      	beq.n	8007444 <serve_interrupt+0x24>
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
  eventflags_t sts = 0;

  if (sr & USART_SR_ORE)
    sts |= SD_OVERRUN_ERROR;
 8007458:	f014 0f08 	tst.w	r4, #8
 800745c:	bf0c      	ite	eq
 800745e:	2100      	moveq	r1, #0
 8007460:	2180      	movne	r1, #128	; 0x80
  if (sr & USART_SR_PE)
 8007462:	07e0      	lsls	r0, r4, #31
    sts |= SD_PARITY_ERROR;
 8007464:	bf48      	it	mi
 8007466:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 800746a:	07a2      	lsls	r2, r4, #30
    sts |= SD_FRAMING_ERROR;
 800746c:	bf48      	it	mi
 800746e:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 8007472:	0763      	lsls	r3, r4, #29
    sts |= SD_NOISE_ERROR;
 8007474:	bf48      	it	mi
 8007476:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800747a:	4638      	mov	r0, r7
 800747c:	f7fa fd70 	bl	8001f60 <chEvtBroadcastFlagsI>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 8007480:	06a0      	lsls	r0, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 8007482:	6869      	ldr	r1, [r5, #4]
    if (sr & USART_SR_RXNE)
 8007484:	d5e1      	bpl.n	800744a <serve_interrupt+0x2a>
      sdIncomingDataI(sdp, b);
 8007486:	b2c9      	uxtb	r1, r1
 8007488:	4630      	mov	r0, r6
 800748a:	f7ff f861 	bl	8006550 <sdIncomingDataI>
    sr = u->SR;
 800748e:	682c      	ldr	r4, [r5, #0]
 8007490:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8007492:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8007496:	d1dd      	bne.n	8007454 <serve_interrupt+0x34>
 8007498:	2300      	movs	r3, #0
 800749a:	f383 8811 	msr	BASEPRI, r3
    sr = u->SR;
  }
  osalSysUnlockFromISR();

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 800749e:	f018 0f80 	tst.w	r8, #128	; 0x80
 80074a2:	d001      	beq.n	80074a8 <serve_interrupt+0x88>
 80074a4:	0622      	lsls	r2, r4, #24
 80074a6:	d426      	bmi.n	80074f6 <serve_interrupt+0xd6>
      u->DR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 80074a8:	0663      	lsls	r3, r4, #25
 80074aa:	d513      	bpl.n	80074d4 <serve_interrupt+0xb4>
 80074ac:	2320      	movs	r3, #32
 80074ae:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0));
 80074b2:	6cb2      	ldr	r2, [r6, #72]	; 0x48
 80074b4:	6c73      	ldr	r3, [r6, #68]	; 0x44
 80074b6:	429a      	cmp	r2, r3
 80074b8:	d02b      	beq.n	8007512 <serve_interrupt+0xf2>
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 80074ba:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 80074be:	ea08 0303 	and.w	r3, r8, r3
    u->SR = ~USART_SR_TC;
 80074c2:	f06f 0240 	mvn.w	r2, #64	; 0x40
  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 80074c6:	60eb      	str	r3, [r5, #12]
 80074c8:	2300      	movs	r3, #0
    u->SR = ~USART_SR_TC;
 80074ca:	602a      	str	r2, [r5, #0]
 80074cc:	f383 8811 	msr	BASEPRI, r3
 80074d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80074d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80074d8:	2320      	movs	r3, #32
 80074da:	f383 8811 	msr	BASEPRI, r3
 80074de:	f44f 7100 	mov.w	r1, #512	; 0x200
 80074e2:	3004      	adds	r0, #4
 80074e4:	f7fa fd3c 	bl	8001f60 <chEvtBroadcastFlagsI>

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    u->SR = ~USART_SR_LBD;
 80074e8:	f46f 7380 	mvn.w	r3, #256	; 0x100
 80074ec:	602b      	str	r3, [r5, #0]
 80074ee:	2300      	movs	r3, #0
 80074f0:	f383 8811 	msr	BASEPRI, r3
 80074f4:	e79e      	b.n	8007434 <serve_interrupt+0x14>
 80074f6:	2320      	movs	r3, #32
 80074f8:	f383 8811 	msr	BASEPRI, r3

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
 80074fc:	f106 0030 	add.w	r0, r6, #48	; 0x30
 8007500:	f7fb f8c6 	bl	8002690 <chOQGetI>
    if (b < Q_OK) {
 8007504:	2800      	cmp	r0, #0
 8007506:	db0c      	blt.n	8007522 <serve_interrupt+0x102>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->DR = b;
 8007508:	6068      	str	r0, [r5, #4]
 800750a:	2300      	movs	r3, #0
 800750c:	f383 8811 	msr	BASEPRI, r3
 8007510:	e7ca      	b.n	80074a8 <serve_interrupt+0x88>
 8007512:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 8007514:	2b00      	cmp	r3, #0
 8007516:	d0d0      	beq.n	80074ba <serve_interrupt+0x9a>
 8007518:	1d30      	adds	r0, r6, #4
 800751a:	2110      	movs	r1, #16
 800751c:	f7fa fd20 	bl	8001f60 <chEvtBroadcastFlagsI>
 8007520:	e7cb      	b.n	80074ba <serve_interrupt+0x9a>
 8007522:	1d30      	adds	r0, r6, #4
 8007524:	2108      	movs	r1, #8
 8007526:	f7fa fd1b 	bl	8001f60 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 800752a:	f64f 733f 	movw	r3, #65343	; 0xff3f
 800752e:	ea08 0303 	and.w	r3, r8, r3
 8007532:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8007536:	60eb      	str	r3, [r5, #12]
 8007538:	e7e7      	b.n	800750a <serve_interrupt+0xea>
 800753a:	bf00      	nop
 800753c:	f3af 8000 	nop.w

08007540 <VectorD8>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8007540:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);
 8007542:	4803      	ldr	r0, [pc, #12]	; (8007550 <VectorD8+0x10>)
 8007544:	f7ff ff6c 	bl	8007420 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8007548:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
 800754c:	f7f9 bc80 	b.w	8000e50 <_port_irq_epilogue>
 8007550:	20004244 	.word	0x20004244
 8007554:	f3af 8000 	nop.w
 8007558:	f3af 8000 	nop.w
 800755c:	f3af 8000 	nop.w

08007560 <Vector15C>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART6_HANDLER) {
 8007560:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD6);
 8007562:	4803      	ldr	r0, [pc, #12]	; (8007570 <Vector15C+0x10>)
 8007564:	f7ff ff5c 	bl	8007420 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8007568:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD6);

  OSAL_IRQ_EPILOGUE();
 800756c:	f7f9 bc70 	b.w	8000e50 <_port_irq_epilogue>
 8007570:	200042bc 	.word	0x200042bc
 8007574:	f3af 8000 	nop.w
 8007578:	f3af 8000 	nop.w
 800757c:	f3af 8000 	nop.w

08007580 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8007580:	b538      	push	{r3, r4, r5, lr}
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 8007582:	4d08      	ldr	r5, [pc, #32]	; (80075a4 <sd_lld_init+0x24>)
  sdObjectInit(&SD5, NULL, notify5);
  SD5.usart = UART5;
#endif

#if STM32_SERIAL_USE_USART6
  sdObjectInit(&SD6, NULL, notify6);
 8007584:	4c08      	ldr	r4, [pc, #32]	; (80075a8 <sd_lld_init+0x28>)
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 8007586:	4a09      	ldr	r2, [pc, #36]	; (80075ac <sd_lld_init+0x2c>)
 8007588:	4628      	mov	r0, r5
 800758a:	2100      	movs	r1, #0
 800758c:	f7fe ffb0 	bl	80064f0 <sdObjectInit>
  SD2.usart = USART2;
 8007590:	4b07      	ldr	r3, [pc, #28]	; (80075b0 <sd_lld_init+0x30>)
  sdObjectInit(&SD5, NULL, notify5);
  SD5.usart = UART5;
#endif

#if STM32_SERIAL_USE_USART6
  sdObjectInit(&SD6, NULL, notify6);
 8007592:	4a08      	ldr	r2, [pc, #32]	; (80075b4 <sd_lld_init+0x34>)
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
 8007594:	676b      	str	r3, [r5, #116]	; 0x74
  sdObjectInit(&SD5, NULL, notify5);
  SD5.usart = UART5;
#endif

#if STM32_SERIAL_USE_USART6
  sdObjectInit(&SD6, NULL, notify6);
 8007596:	4620      	mov	r0, r4
 8007598:	2100      	movs	r1, #0
 800759a:	f7fe ffa9 	bl	80064f0 <sdObjectInit>
  SD6.usart = USART6;
 800759e:	4b06      	ldr	r3, [pc, #24]	; (80075b8 <sd_lld_init+0x38>)
 80075a0:	6763      	str	r3, [r4, #116]	; 0x74
 80075a2:	bd38      	pop	{r3, r4, r5, pc}
 80075a4:	20004244 	.word	0x20004244
 80075a8:	200042bc 	.word	0x200042bc
 80075ac:	08007401 	.word	0x08007401
 80075b0:	40004400 	.word	0x40004400
 80075b4:	08007411 	.word	0x08007411
 80075b8:	40011400 	.word	0x40011400
 80075bc:	f3af 8000 	nop.w

080075c0 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 80075c0:	b538      	push	{r3, r4, r5, lr}

  if (config == NULL)
    config = &default_config;
 80075c2:	4c25      	ldr	r4, [pc, #148]	; (8007658 <sd_lld_start+0x98>)

  if (sdp->state == SD_STOP) {
 80075c4:	7a03      	ldrb	r3, [r0, #8]
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
 80075c6:	2900      	cmp	r1, #0
 80075c8:	bf18      	it	ne
 80075ca:	460c      	movne	r4, r1

  if (sdp->state == SD_STOP) {
 80075cc:	2b01      	cmp	r3, #1
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 80075ce:	4605      	mov	r5, r0

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 80075d0:	d022      	beq.n	8007618 <sd_lld_start+0x58>
 80075d2:	6f6b      	ldr	r3, [r5, #116]	; 0x74
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 80075d4:	4a21      	ldr	r2, [pc, #132]	; (800765c <sd_lld_start+0x9c>)
 80075d6:	4293      	cmp	r3, r2
 80075d8:	d02e      	beq.n	8007638 <sd_lld_start+0x78>
 80075da:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80075de:	4293      	cmp	r3, r2
 80075e0:	d02a      	beq.n	8007638 <sd_lld_start+0x78>
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;
 80075e2:	6821      	ldr	r1, [r4, #0]
 80075e4:	4a1e      	ldr	r2, [pc, #120]	; (8007660 <sd_lld_start+0xa0>)
 80075e6:	fbb2 f2f1 	udiv	r2, r2, r1
 80075ea:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 80075ec:	88a2      	ldrh	r2, [r4, #4]
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80075ee:	88e0      	ldrh	r0, [r4, #6]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80075f0:	8921      	ldrh	r1, [r4, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 80075f2:	f442 5204 	orr.w	r2, r2, #8448	; 0x2100
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80075f6:	f040 0040 	orr.w	r0, r0, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 80075fa:	f042 022c 	orr.w	r2, r2, #44	; 0x2c
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80075fe:	f041 0101 	orr.w	r1, r1, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8007602:	b292      	uxth	r2, r2
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8007604:	b280      	uxth	r0, r0
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8007606:	b289      	uxth	r1, r1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8007608:	2400      	movs	r4, #0
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800760a:	6118      	str	r0, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800760c:	6159      	str	r1, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800760e:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8007610:	601c      	str	r4, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8007612:	681a      	ldr	r2, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8007614:	685b      	ldr	r3, [r3, #4]
 8007616:	bd38      	pop	{r3, r4, r5, pc}
      rccEnableUSART1(FALSE);
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
 8007618:	4b12      	ldr	r3, [pc, #72]	; (8007664 <sd_lld_start+0xa4>)
 800761a:	4298      	cmp	r0, r3
 800761c:	d012      	beq.n	8007644 <sd_lld_start+0x84>
      rccEnableUART5(FALSE);
      nvicEnableVector(STM32_UART5_NUMBER, STM32_SERIAL_UART5_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART6
    if (&SD6 == sdp) {
 800761e:	4b12      	ldr	r3, [pc, #72]	; (8007668 <sd_lld_start+0xa8>)
 8007620:	4298      	cmp	r0, r3
 8007622:	d1d6      	bne.n	80075d2 <sd_lld_start+0x12>
      rccEnableUSART6(FALSE);
 8007624:	4a11      	ldr	r2, [pc, #68]	; (800766c <sd_lld_start+0xac>)
 8007626:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8007628:	f043 0320 	orr.w	r3, r3, #32
 800762c:	6453      	str	r3, [r2, #68]	; 0x44
      nvicEnableVector(STM32_USART6_NUMBER, STM32_SERIAL_USART6_PRIORITY);
 800762e:	2047      	movs	r0, #71	; 0x47
 8007630:	210c      	movs	r1, #12
 8007632:	f7fe ffed 	bl	8006610 <nvicEnableVector>
 8007636:	e7cc      	b.n	80075d2 <sd_lld_start+0x12>
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8007638:	6821      	ldr	r1, [r4, #0]
 800763a:	4a0d      	ldr	r2, [pc, #52]	; (8007670 <sd_lld_start+0xb0>)
 800763c:	fbb2 f2f1 	udiv	r2, r2, r1
 8007640:	609a      	str	r2, [r3, #8]
 8007642:	e7d3      	b.n	80075ec <sd_lld_start+0x2c>
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
      rccEnableUSART2(FALSE);
 8007644:	4a09      	ldr	r2, [pc, #36]	; (800766c <sd_lld_start+0xac>)
 8007646:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8007648:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800764c:	6413      	str	r3, [r2, #64]	; 0x40
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
 800764e:	2026      	movs	r0, #38	; 0x26
 8007650:	210c      	movs	r1, #12
 8007652:	f7fe ffdd 	bl	8006610 <nvicEnableVector>
 8007656:	e7bc      	b.n	80075d2 <sd_lld_start+0x12>
 8007658:	08016e70 	.word	0x08016e70
 800765c:	40011000 	.word	0x40011000
 8007660:	023c3460 	.word	0x023c3460
 8007664:	20004244 	.word	0x20004244
 8007668:	200042bc 	.word	0x200042bc
 800766c:	40023800 	.word	0x40023800
 8007670:	047868c0 	.word	0x047868c0
 8007674:	f3af 8000 	nop.w
 8007678:	f3af 8000 	nop.w
 800767c:	f3af 8000 	nop.w

08007680 <VectorDC>:
/**
 * @brief   USART3 IRQ handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
 8007680:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void serve_usart_irq(UARTDriver *uartp) {

  uint32_t isr;
  USART_TypeDef *u = uartp->usart;
 8007682:	4e28      	ldr	r6, [pc, #160]	; (8007724 <VectorDC+0xa4>)
 8007684:	68b7      	ldr	r7, [r6, #8]

  /* Reading and clearing status.*/
  isr = u->SR;
 8007686:	683c      	ldr	r4, [r7, #0]
  //u->ICR = isr;

  /* Error condition detection.*/
  if (isr & (/*USART_SR_LBD |*/ USART_SR_ORE | USART_SR_NE |
 8007688:	0725      	lsls	r5, r4, #28
 800768a:	d019      	beq.n	80076c0 <VectorDC+0x40>
             USART_SR_FE  | USART_SR_PE)) {
    if (uartp->config->rxerr_cb != NULL)
 800768c:	6873      	ldr	r3, [r6, #4]
 800768e:	691b      	ldr	r3, [r3, #16]
 8007690:	b1b3      	cbz	r3, 80076c0 <VectorDC+0x40>
static uartflags_t translate_errors(uint32_t isr) 
{
  uartflags_t sts = 0;

  if (isr & USART_SR_ORE)
    sts |= UART_OVERRUN_ERROR;
 8007692:	f014 0f08 	tst.w	r4, #8
 8007696:	bf0c      	ite	eq
 8007698:	2100      	moveq	r1, #0
 800769a:	2110      	movne	r1, #16
  if (isr & USART_SR_PE)
 800769c:	07e0      	lsls	r0, r4, #31
    sts |= UART_PARITY_ERROR;
 800769e:	bf48      	it	mi
 80076a0:	f041 0104 	orrmi.w	r1, r1, #4
  if (isr & USART_SR_FE)
 80076a4:	07a2      	lsls	r2, r4, #30
    sts |= UART_FRAMING_ERROR;
 80076a6:	bf48      	it	mi
 80076a8:	f041 0108 	orrmi.w	r1, r1, #8
  if (isr & USART_SR_NE)
 80076ac:	0765      	lsls	r5, r4, #29
    sts |= UART_NOISE_ERROR;
 80076ae:	bf48      	it	mi
 80076b0:	f041 0120 	orrmi.w	r1, r1, #32
  if (isr & USART_SR_LBD)
 80076b4:	05e0      	lsls	r0, r4, #23
    sts |= UART_BREAK_DETECTED;
 80076b6:	bf48      	it	mi
 80076b8:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40

  /* Error condition detection.*/
  if (isr & (/*USART_SR_LBD |*/ USART_SR_ORE | USART_SR_NE |
             USART_SR_FE  | USART_SR_PE)) {
    if (uartp->config->rxerr_cb != NULL)
      uartp->config->rxerr_cb(uartp, translate_errors(isr));        // Receive error callback
 80076bc:	4819      	ldr	r0, [pc, #100]	; (8007724 <VectorDC+0xa4>)
 80076be:	4798      	blx	r3
  }

#if STM32_UART_USE_INTERRUPTS
  uint32_t cr1 = u->CR1;
 80076c0:	68fd      	ldr	r5, [r7, #12]

  /* Data available (receive). */
  if ((cr1 & USART_CR1_RXNEIE) && (isr & USART_SR_RXNE))
 80076c2:	06aa      	lsls	r2, r5, #26
 80076c4:	d501      	bpl.n	80076ca <VectorDC+0x4a>
 80076c6:	06a3      	lsls	r3, r4, #26
 80076c8:	d423      	bmi.n	8007712 <VectorDC+0x92>
        uartp->config->rxchar_cb(uartp, uartp->rxbuf);				// Receive character callback
	//}
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_SR_TXE)) 
 80076ca:	0628      	lsls	r0, r5, #24
 80076cc:	d501      	bpl.n	80076d2 <VectorDC+0x52>
 80076ce:	0621      	lsls	r1, r4, #24
 80076d0:	d413      	bmi.n	80076fa <VectorDC+0x7a>
	    uartp->txstate = UART_TX_IDLE;
      //u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;       // Disable transmit data interrupt, enable TxBuffer empty
    //}
  }
  /* Physical transmission end.*/
  if ((cr1 & USART_CR1_TCIE) && (isr & USART_SR_TC))
 80076d2:	066a      	lsls	r2, r5, #25
 80076d4:	d50d      	bpl.n	80076f2 <VectorDC+0x72>
 80076d6:	0663      	lsls	r3, r4, #25
 80076d8:	d50b      	bpl.n	80076f2 <VectorDC+0x72>
  {
	palClearPad(GPIOG, GPIOG_PIN8);
 80076da:	4a13      	ldr	r2, [pc, #76]	; (8007728 <VectorDC+0xa8>)
    if (uartp->config->txend2_cb != NULL)
 80076dc:	6873      	ldr	r3, [r6, #4]
    //}
  }
  /* Physical transmission end.*/
  if ((cr1 & USART_CR1_TCIE) && (isr & USART_SR_TC))
  {
	palClearPad(GPIOG, GPIOG_PIN8);
 80076de:	f44f 7180 	mov.w	r1, #256	; 0x100
 80076e2:	8351      	strh	r1, [r2, #26]
    if (uartp->config->txend2_cb != NULL)
 80076e4:	685b      	ldr	r3, [r3, #4]
 80076e6:	b10b      	cbz	r3, 80076ec <VectorDC+0x6c>
      uartp->config->txend2_cb(uartp);      // Signal that whole transmit message gone
 80076e8:	480e      	ldr	r0, [pc, #56]	; (8007724 <VectorDC+0xa4>)
 80076ea:	4798      	blx	r3
    u->CR1 = cr1 & ~USART_CR1_TCIE;         // Disable transmit buffer empty interrupt
 80076ec:	f025 0540 	bic.w	r5, r5, #64	; 0x40
 80076f0:	60fd      	str	r5, [r7, #12]
  OSAL_IRQ_PROLOGUE();

  serve_usart_irq(&UARTD3);

  OSAL_IRQ_EPILOGUE();
}
 80076f2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  OSAL_IRQ_PROLOGUE();

  serve_usart_irq(&UARTD3);

  OSAL_IRQ_EPILOGUE();
 80076f6:	f7f9 bbab 	b.w	8000e50 <_port_irq_epilogue>
    //if (--(uartp->txCount) == 0)
    //{
      //uartp->txBuf = NULL;
      /* A callback is generated, if enabled, after a completed transfer.*/
      //uartp->txstate = UART_TX_COMPLETE;
	  if (uartp->config->txend1_cb != NULL)
 80076fa:	6873      	ldr	r3, [r6, #4]
 80076fc:	681b      	ldr	r3, [r3, #0]
 80076fe:	b10b      	cbz	r3, 8007704 <VectorDC+0x84>
		uartp->config->txend1_cb(uartp);            // Signal that Tx buffer finished with
 8007700:	4808      	ldr	r0, [pc, #32]	; (8007724 <VectorDC+0xa4>)
 8007702:	4798      	blx	r3

	  /* If the callback didn't explicitly change state then the transmitter
	     automatically returns to the idle state.*/
	  if (uartp->txstate == UART_TX_COMPLETE)
 8007704:	7873      	ldrb	r3, [r6, #1]
 8007706:	4a07      	ldr	r2, [pc, #28]	; (8007724 <VectorDC+0xa4>)
 8007708:	2b02      	cmp	r3, #2
	    uartp->txstate = UART_TX_IDLE;
 800770a:	bf04      	itt	eq
 800770c:	2300      	moveq	r3, #0
 800770e:	7053      	strbeq	r3, [r2, #1]
 8007710:	e7df      	b.n	80076d2 <VectorDC+0x52>
	    }
	  }
	}*/
	//else
	//{   // Receive character while in UART_RX_IDLE mode
      if (uartp->config->rxchar_cb != NULL)
 8007712:	6873      	ldr	r3, [r6, #4]
 8007714:	4803      	ldr	r0, [pc, #12]	; (8007724 <VectorDC+0xa4>)
 8007716:	68db      	ldr	r3, [r3, #12]
 8007718:	2b00      	cmp	r3, #0
 800771a:	d0d6      	beq.n	80076ca <VectorDC+0x4a>
        uartp->config->rxchar_cb(uartp, uartp->rxbuf);				// Receive character callback
 800771c:	8981      	ldrh	r1, [r0, #12]
 800771e:	b289      	uxth	r1, r1
 8007720:	4798      	blx	r3
 8007722:	e7d2      	b.n	80076ca <VectorDC+0x4a>
 8007724:	20004334 	.word	0x20004334
 8007728:	40021800 	.word	0x40021800
 800772c:	f3af 8000 	nop.w

08007730 <uart_lld_init>:
/**
 * @brief   Low level UART driver initialization.
 *
 * @notapi
 */
void uart_lld_init(void) {
 8007730:	b510      	push	{r4, lr}
  UARTD2.dmatx   = STM32_DMA_STREAM(STM32_UART_USART2_TX_DMA_STREAM);
  #endif
#endif

#if STM32_UART_USE_USART3
  uartObjectInit(&UARTD3);
 8007732:	4c03      	ldr	r4, [pc, #12]	; (8007740 <uart_lld_init+0x10>)
 8007734:	4620      	mov	r0, r4
 8007736:	f7fe ff53 	bl	80065e0 <uartObjectInit>
  UARTD3.usart   = USART3;
 800773a:	4b02      	ldr	r3, [pc, #8]	; (8007744 <uart_lld_init+0x14>)
 800773c:	60a3      	str	r3, [r4, #8]
 800773e:	bd10      	pop	{r4, pc}
 8007740:	20004334 	.word	0x20004334
 8007744:	40004800 	.word	0x40004800
 8007748:	f3af 8000 	nop.w
 800774c:	f3af 8000 	nop.w

08007750 <uart_lld_start>:
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 *
 * @notapi
 */
void uart_lld_start(UARTDriver *uartp) {
 8007750:	b538      	push	{r3, r4, r5, lr}

  if (uartp->state == UART_STOP) {
 8007752:	7803      	ldrb	r3, [r0, #0]
 8007754:	2b01      	cmp	r3, #1
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 *
 * @notapi
 */
void uart_lld_start(UARTDriver *uartp) {
 8007756:	4604      	mov	r4, r0

  if (uartp->state == UART_STOP) {
 8007758:	d021      	beq.n	800779e <uart_lld_start+0x4e>
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void usart_start(UARTDriver *uartp) 
{
  USART_TypeDef *u = uartp->usart;
 800775a:	68a3      	ldr	r3, [r4, #8]
  if (uartp->usart == USART1)
    u->BRR = STM32_USART1CLK / uartp->config->speed;
  else
    u->BRR = STM32_PCLK / uartp->config->speed;
#else /* !defined(STM32F0XX) */
  if (uartp->usart == USART1)
 800775c:	4919      	ldr	r1, [pc, #100]	; (80077c4 <uart_lld_start+0x74>)
    uartp->rxCount = 0;
    uartp->rxBuffer = NULL;
#endif
  }

  uartp->rxstate = UART_RX_IDLE;
 800775e:	2200      	movs	r2, #0
  if (uartp->usart == USART1)
    u->BRR = STM32_USART1CLK / uartp->config->speed;
  else
    u->BRR = STM32_PCLK / uartp->config->speed;
#else /* !defined(STM32F0XX) */
  if (uartp->usart == USART1)
 8007760:	428b      	cmp	r3, r1
    u->BRR = STM32_PCLK2 / uartp->config->speed;
 8007762:	6861      	ldr	r1, [r4, #4]
    uartp->rxCount = 0;
    uartp->rxBuffer = NULL;
#endif
  }

  uartp->rxstate = UART_RX_IDLE;
 8007764:	70a2      	strb	r2, [r4, #2]
  uartp->txstate = UART_TX_IDLE;
 8007766:	7062      	strb	r2, [r4, #1]
  dmaStreamDisable(uartp->dmarx);
  dmaStreamDisable(uartp->dmatx);
#endif
  
  /* Stops USART operations.*/
  uartp->usart->CR1 = 0;
 8007768:	60da      	str	r2, [r3, #12]
  uartp->usart->CR2 = 0;
 800776a:	611a      	str	r2, [r3, #16]
  uartp->usart->CR3 = 0;
 800776c:	615a      	str	r2, [r3, #20]
    u->BRR = STM32_PCLK / uartp->config->speed;
#else /* !defined(STM32F0XX) */
  if (uartp->usart == USART1)
    u->BRR = STM32_PCLK2 / uartp->config->speed;
  else
    u->BRR = STM32_PCLK1 / uartp->config->speed;
 800776e:	6948      	ldr	r0, [r1, #20]
    u->BRR = STM32_USART1CLK / uartp->config->speed;
  else
    u->BRR = STM32_PCLK / uartp->config->speed;
#else /* !defined(STM32F0XX) */
  if (uartp->usart == USART1)
    u->BRR = STM32_PCLK2 / uartp->config->speed;
 8007770:	bf0c      	ite	eq
 8007772:	4a15      	ldreq	r2, [pc, #84]	; (80077c8 <uart_lld_start+0x78>)
  else
    u->BRR = STM32_PCLK1 / uartp->config->speed;
 8007774:	4a15      	ldrne	r2, [pc, #84]	; (80077cc <uart_lld_start+0x7c>)
 8007776:	fbb2 f2f0 	udiv	r2, r2, r0
 800777a:	609a      	str	r2, [r3, #8]
          USART_CR1_TCIE;
  u->CR1 = uartp->config->cr1 | cr1;
  #else
  u->CR3 = uartp->config->cr3 | USART_CR3_EIE;
  u->CR1 = uartp->config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
  USART_CR1_RXNEIE | USART_CR1_TE |
 800777c:	698a      	ldr	r2, [r1, #24]
  else
    cr1 = USART_CR1_UE | USART_CR1_PEIE | USART_CR1_TE | USART_CR1_RE |
          USART_CR1_TCIE;
  u->CR1 = uartp->config->cr1 | cr1;
  #else
  u->CR3 = uartp->config->cr3 | USART_CR3_EIE;
 800777e:	6a08      	ldr	r0, [r1, #32]
  (void)u->DR;
  u->SR = 0;

  /* Note that some bits are enforced because required for correct driver
     operations.*/
  u->CR2 = uartp->config->cr2 /*| USART_CR2_LBDIE*/;
 8007780:	69cc      	ldr	r4, [r1, #28]
  else
    u->BRR = STM32_PCLK1 / uartp->config->speed;
#endif /* !defined(STM32F0XX) */

  /* Resetting eventual pending status flags.*/
  (void)u->SR;
 8007782:	6819      	ldr	r1, [r3, #0]
  (void)u->DR;
 8007784:	6859      	ldr	r1, [r3, #4]
          USART_CR1_TCIE;
  u->CR1 = uartp->config->cr1 | cr1;
  #else
  u->CR3 = uartp->config->cr3 | USART_CR3_EIE;
  u->CR1 = uartp->config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
  USART_CR1_RXNEIE | USART_CR1_TE |
 8007786:	f442 5204 	orr.w	r2, r2, #8448	; 0x2100
#endif /* !defined(STM32F0XX) */

  /* Resetting eventual pending status flags.*/
  (void)u->SR;
  (void)u->DR;
  u->SR = 0;
 800778a:	2500      	movs	r5, #0
          USART_CR1_TCIE;
  u->CR1 = uartp->config->cr1 | cr1;
  #else
  u->CR3 = uartp->config->cr3 | USART_CR3_EIE;
  u->CR1 = uartp->config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
  USART_CR1_RXNEIE | USART_CR1_TE |
 800778c:	f042 022c 	orr.w	r2, r2, #44	; 0x2c
  else
    cr1 = USART_CR1_UE | USART_CR1_PEIE | USART_CR1_TE | USART_CR1_RE |
          USART_CR1_TCIE;
  u->CR1 = uartp->config->cr1 | cr1;
  #else
  u->CR3 = uartp->config->cr3 | USART_CR3_EIE;
 8007790:	f040 0101 	orr.w	r1, r0, #1
#endif /* !defined(STM32F0XX) */

  /* Resetting eventual pending status flags.*/
  (void)u->SR;
  (void)u->DR;
  u->SR = 0;
 8007794:	601d      	str	r5, [r3, #0]

  /* Note that some bits are enforced because required for correct driver
     operations.*/
  u->CR2 = uartp->config->cr2 /*| USART_CR2_LBDIE*/;
 8007796:	611c      	str	r4, [r3, #16]
  else
    cr1 = USART_CR1_UE | USART_CR1_PEIE | USART_CR1_TE | USART_CR1_RE |
          USART_CR1_TCIE;
  u->CR1 = uartp->config->cr1 | cr1;
  #else
  u->CR3 = uartp->config->cr3 | USART_CR3_EIE;
 8007798:	6159      	str	r1, [r3, #20]
  u->CR1 = uartp->config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800779a:	60da      	str	r2, [r3, #12]
 800779c:	bd38      	pop	{r3, r4, r5, pc}
	  #endif
    }
#endif

#if STM32_UART_USE_USART3
    if (&UARTD3 == uartp) {
 800779e:	4b0c      	ldr	r3, [pc, #48]	; (80077d0 <uart_lld_start+0x80>)
 80077a0:	4298      	cmp	r0, r3
 80077a2:	d004      	beq.n	80077ae <uart_lld_start+0x5e>
    if ((uartp->config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_M)
      uartp->dmamode |= STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    dmaStreamSetPeripheral(uartp->dmarx, &uartp->usart->RDR);
    dmaStreamSetPeripheral(uartp->dmatx, &uartp->usart->TDR);
	#endif
    uartp->rxbuf = 0;
 80077a4:	2300      	movs	r3, #0
 80077a6:	81a3      	strh	r3, [r4, #12]
#if STM32_UART_USE_INTERRUPTS
    uartp->rxCount = 0;
    uartp->rxBuffer = NULL;
 80077a8:	61a3      	str	r3, [r4, #24]
    dmaStreamSetPeripheral(uartp->dmarx, &uartp->usart->RDR);
    dmaStreamSetPeripheral(uartp->dmatx, &uartp->usart->TDR);
	#endif
    uartp->rxbuf = 0;
#if STM32_UART_USE_INTERRUPTS
    uartp->rxCount = 0;
 80077aa:	82a3      	strh	r3, [r4, #20]
 80077ac:	e7d5      	b.n	800775a <uart_lld_start+0xa>
                            STM32_UART_USART3_IRQ_PRIORITY,
                            (stm32_dmaisr_t)uart_lld_serve_tx_end_irq,
                            (void *)uartp);
      osalDbgAssert(!b, "stream already allocated");
	  #endif
      rccEnableUSART3(FALSE);
 80077ae:	4a09      	ldr	r2, [pc, #36]	; (80077d4 <uart_lld_start+0x84>)
 80077b0:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80077b2:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80077b6:	6413      	str	r3, [r2, #64]	; 0x40
      nvicEnableVector(STM32_USART3_NUMBER, STM32_UART_USART3_IRQ_PRIORITY);
 80077b8:	2027      	movs	r0, #39	; 0x27
 80077ba:	210c      	movs	r1, #12
 80077bc:	f7fe ff28 	bl	8006610 <nvicEnableVector>
 80077c0:	e7f0      	b.n	80077a4 <uart_lld_start+0x54>
 80077c2:	bf00      	nop
 80077c4:	40011000 	.word	0x40011000
 80077c8:	047868c0 	.word	0x047868c0
 80077cc:	023c3460 	.word	0x023c3460
 80077d0:	20004334 	.word	0x20004334
 80077d4:	40023800 	.word	0x40023800
 80077d8:	f3af 8000 	nop.w
 80077dc:	f3af 8000 	nop.w

080077e0 <__early_init>:
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
 80077e0:	f7ff b91e 	b.w	8006a20 <stm32_clock_init>
 80077e4:	f3af 8000 	nop.w
 80077e8:	f3af 8000 	nop.w
 80077ec:	f3af 8000 	nop.w

080077f0 <boardInit>:

/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
 80077f0:	4770      	bx	lr
 80077f2:	bf00      	nop
 80077f4:	f3af 8000 	nop.w
 80077f8:	f3af 8000 	nop.w
 80077fc:	f3af 8000 	nop.w

08007800 <ethernetif_init>:
}

/*
 * Initialization.
 */
static err_t ethernetif_init(struct netif *netif) {
 8007800:	b4f0      	push	{r4, r5, r6, r7}
 8007802:	4603      	mov	r3, r0
   * of bits per second.
   */
  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LWIP_LINK_SPEED);

  netif->state = NULL;
  netif->name[0] = LWIP_IFNAME0;
 8007804:	226d      	movs	r2, #109	; 0x6d
 8007806:	f880 202a 	strb.w	r2, [r0, #42]	; 0x2a
  netif->name[1] = LWIP_IFNAME1;
 800780a:	2773      	movs	r7, #115	; 0x73
/*
 * Initialization.
 */
static void low_level_init(struct netif *netif) {
  /* set MAC hardware address length */
  netif->hwaddr_len = ETHARP_HWADDR_LEN;
 800780c:	2406      	movs	r4, #6
  /* maximum transfer unit */
  netif->mtu = 1500;

  /* device capabilities */
  /* don't set NETIF_FLAG_ETHARP if this device is not an Ethernet one */
  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
 800780e:	2232      	movs	r2, #50	; 0x32
  netif->name[1] = LWIP_IFNAME1;
  /* We directly use etharp_output() here to save a function call.
   * You can instead declare your own function an call etharp_output()
   * from it if you have to do some checks before sending (e.g. if link
   * is available...) */
  netif->output = etharp_output;
 8007810:	4e08      	ldr	r6, [pc, #32]	; (8007834 <ethernetif_init+0x34>)
  netif->linkoutput = low_level_output;
 8007812:	4d09      	ldr	r5, [pc, #36]	; (8007838 <ethernetif_init+0x38>)
   */
  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LWIP_LINK_SPEED);

  netif->state = NULL;
  netif->name[0] = LWIP_IFNAME0;
  netif->name[1] = LWIP_IFNAME1;
 8007814:	f883 702b 	strb.w	r7, [r3, #43]	; 0x2b
   * The last argument should be replaced with your link speed, in units
   * of bits per second.
   */
  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LWIP_LINK_SPEED);

  netif->state = NULL;
 8007818:	2000      	movs	r0, #0
static void low_level_init(struct netif *netif) {
  /* set MAC hardware address length */
  netif->hwaddr_len = ETHARP_HWADDR_LEN;

  /* maximum transfer unit */
  netif->mtu = 1500;
 800781a:	f240 51dc 	movw	r1, #1500	; 0x5dc
/*
 * Initialization.
 */
static void low_level_init(struct netif *netif) {
  /* set MAC hardware address length */
  netif->hwaddr_len = ETHARP_HWADDR_LEN;
 800781e:	f883 4022 	strb.w	r4, [r3, #34]	; 0x22
  /* maximum transfer unit */
  netif->mtu = 1500;

  /* device capabilities */
  /* don't set NETIF_FLAG_ETHARP if this device is not an Ethernet one */
  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
 8007822:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  netif->name[1] = LWIP_IFNAME1;
  /* We directly use etharp_output() here to save a function call.
   * You can instead declare your own function an call etharp_output()
   * from it if you have to do some checks before sending (e.g. if link
   * is available...) */
  netif->output = etharp_output;
 8007826:	615e      	str	r6, [r3, #20]
  netif->linkoutput = low_level_output;
 8007828:	619d      	str	r5, [r3, #24]
static void low_level_init(struct netif *netif) {
  /* set MAC hardware address length */
  netif->hwaddr_len = ETHARP_HWADDR_LEN;

  /* maximum transfer unit */
  netif->mtu = 1500;
 800782a:	8419      	strh	r1, [r3, #32]
   * The last argument should be replaced with your link speed, in units
   * of bits per second.
   */
  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LWIP_LINK_SPEED);

  netif->state = NULL;
 800782c:	61d8      	str	r0, [r3, #28]

  /* initialize the hardware */
  low_level_init(netif);

  return ERR_OK;
}
 800782e:	bcf0      	pop	{r4, r5, r6, r7}
 8007830:	4770      	bx	lr
 8007832:	bf00      	nop
 8007834:	080083b1 	.word	0x080083b1
 8007838:	08007841 	.word	0x08007841
 800783c:	f3af 8000 	nop.w

08007840 <low_level_output>:
}

/*
 * Transmits a frame.
 */
static err_t low_level_output(struct netif *netif, struct pbuf *p) {
 8007840:	b510      	push	{r4, lr}
 8007842:	b084      	sub	sp, #16
 8007844:	460c      	mov	r4, r1
  struct pbuf *q;
  MACTransmitDescriptor td;

  (void)netif;
  if (macWaitTransmitDescriptor(&ETHD1, &td, MS2ST(LWIP_SEND_TIMEOUT)) != MSG_OK)
 8007846:	480e      	ldr	r0, [pc, #56]	; (8007880 <low_level_output+0x40>)
 8007848:	a901      	add	r1, sp, #4
 800784a:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 800784e:	f7fe fd7f 	bl	8006350 <macWaitTransmitDescriptor>
 8007852:	b998      	cbnz	r0, 800787c <low_level_output+0x3c>
#if ETH_PAD_SIZE
  pbuf_header(p, -ETH_PAD_SIZE);        /* drop the padding word */
#endif

  /* Iterates through the pbuf chain. */
  for(q = p; q != NULL; q = q->next)
 8007854:	b13c      	cbz	r4, 8007866 <low_level_output+0x26>
    macWriteTransmitDescriptor(&td, (uint8_t *)q->payload, (size_t)q->len);
 8007856:	6861      	ldr	r1, [r4, #4]
 8007858:	8962      	ldrh	r2, [r4, #10]
 800785a:	a801      	add	r0, sp, #4
 800785c:	f7ff fc58 	bl	8007110 <mac_lld_write_transmit_descriptor>
#if ETH_PAD_SIZE
  pbuf_header(p, -ETH_PAD_SIZE);        /* drop the padding word */
#endif

  /* Iterates through the pbuf chain. */
  for(q = p; q != NULL; q = q->next)
 8007860:	6824      	ldr	r4, [r4, #0]
 8007862:	2c00      	cmp	r4, #0
 8007864:	d1f7      	bne.n	8007856 <low_level_output+0x16>
    macWriteTransmitDescriptor(&td, (uint8_t *)q->payload, (size_t)q->len);
  macReleaseTransmitDescriptor(&td);
 8007866:	a801      	add	r0, sp, #4
 8007868:	f7fe fda2 	bl	80063b0 <macReleaseTransmitDescriptor>

#if ETH_PAD_SIZE
  pbuf_header(p, ETH_PAD_SIZE);         /* reclaim the padding word */
#endif

  LINK_STATS_INC(link.xmit);
 800786c:	4a05      	ldr	r2, [pc, #20]	; (8007884 <low_level_output+0x44>)
 800786e:	8813      	ldrh	r3, [r2, #0]
 8007870:	3301      	adds	r3, #1
 8007872:	8013      	strh	r3, [r2, #0]

  return ERR_OK;
 8007874:	2000      	movs	r0, #0
}
 8007876:	b240      	sxtb	r0, r0
 8007878:	b004      	add	sp, #16
 800787a:	bd10      	pop	{r4, pc}
  struct pbuf *q;
  MACTransmitDescriptor td;

  (void)netif;
  if (macWaitTransmitDescriptor(&ETHD1, &td, MS2ST(LWIP_SEND_TIMEOUT)) != MSG_OK)
    return ERR_TIMEOUT;
 800787c:	20fd      	movs	r0, #253	; 0xfd
 800787e:	e7fa      	b.n	8007876 <low_level_output+0x36>
 8007880:	20001dfc 	.word	0x20001dfc
 8007884:	2000c9fc 	.word	0x2000c9fc
 8007888:	f3af 8000 	nop.w
 800788c:	f3af 8000 	nop.w

08007890 <chprintf.constprop.1>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8007890:	b40e      	push	{r1, r2, r3}
 8007892:	b500      	push	{lr}
 8007894:	b082      	sub	sp, #8
 8007896:	aa03      	add	r2, sp, #12
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
 8007898:	4805      	ldr	r0, [pc, #20]	; (80078b0 <chprintf.constprop.1+0x20>)
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 800789a:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800789e:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80078a0:	f009 fa2e 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 80078a4:	b002      	add	sp, #8
 80078a6:	f85d eb04 	ldr.w	lr, [sp], #4
 80078aa:	b003      	add	sp, #12
 80078ac:	4770      	bx	lr
 80078ae:	bf00      	nop
 80078b0:	200180c8 	.word	0x200180c8
 80078b4:	f3af 8000 	nop.w
 80078b8:	f3af 8000 	nop.w
 80078bc:	f3af 8000 	nop.w

080078c0 <lwip_thread>:
 * @brief LWIP handling thread.
 *
 * @param[in] p pointer to a @p lwipthread_opts structure or @p NULL
 * @return The function does not return.
 */
msg_t lwip_thread(void *p) {
 80078c0:	b5f0      	push	{r4, r5, r6, r7, lr}
  event_listener_t el0, el1;
  struct ip_addr ip, gateway, netmask;
  static struct netif thisif;
  static const MACConfig mac_config = {thisif.hwaddr};

  chRegSetThreadName("lwipthread");
 80078c2:	4b72      	ldr	r3, [pc, #456]	; (8007a8c <lwip_thread+0x1cc>)
 80078c4:	4a72      	ldr	r2, [pc, #456]	; (8007a90 <lwip_thread+0x1d0>)
 80078c6:	699b      	ldr	r3, [r3, #24]
 * @brief LWIP handling thread.
 *
 * @param[in] p pointer to a @p lwipthread_opts structure or @p NULL
 * @return The function does not return.
 */
msg_t lwip_thread(void *p) {
 80078c8:	4604      	mov	r4, r0
  static const MACConfig mac_config = {thisif.hwaddr};

  chRegSetThreadName("lwipthread");

  /* Initializes the thing.*/
  tcpip_init(NULL, NULL);
 80078ca:	2000      	movs	r0, #0
 * @brief LWIP handling thread.
 *
 * @param[in] p pointer to a @p lwipthread_opts structure or @p NULL
 * @return The function does not return.
 */
msg_t lwip_thread(void *p) {
 80078cc:	b09d      	sub	sp, #116	; 0x74
  event_listener_t el0, el1;
  struct ip_addr ip, gateway, netmask;
  static struct netif thisif;
  static const MACConfig mac_config = {thisif.hwaddr};

  chRegSetThreadName("lwipthread");
 80078ce:	619a      	str	r2, [r3, #24]

  /* Initializes the thing.*/
  tcpip_init(NULL, NULL);
 80078d0:	4601      	mov	r1, r0
 80078d2:	f009 f8e5 	bl	8010aa0 <tcpip_init>

  /* TCP/IP parameters, runtime or compile time.*/
  if (p) {
 80078d6:	b184      	cbz	r4, 80078fa <lwip_thread+0x3a>
 80078d8:	4a6e      	ldr	r2, [pc, #440]	; (8007a94 <lwip_thread+0x1d4>)
 80078da:	2300      	movs	r3, #0
    struct lwipthread_opts *opts = p;
    unsigned i;

    for (i = 0; i < 6; i++)
      thisif.hwaddr[i] = opts->macaddress[i];
 80078dc:	6821      	ldr	r1, [r4, #0]
 80078de:	5cc9      	ldrb	r1, [r1, r3]
 80078e0:	f802 1f01 	strb.w	r1, [r2, #1]!
  /* TCP/IP parameters, runtime or compile time.*/
  if (p) {
    struct lwipthread_opts *opts = p;
    unsigned i;

    for (i = 0; i < 6; i++)
 80078e4:	3301      	adds	r3, #1
 80078e6:	2b06      	cmp	r3, #6
 80078e8:	d1f8      	bne.n	80078dc <lwip_thread+0x1c>
      thisif.hwaddr[i] = opts->macaddress[i];
    ip.addr = opts->address;
 80078ea:	6861      	ldr	r1, [r4, #4]
    gateway.addr = opts->gateway;
 80078ec:	68e2      	ldr	r2, [r4, #12]
    netmask.addr = opts->netmask;
 80078ee:	68a3      	ldr	r3, [r4, #8]
    struct lwipthread_opts *opts = p;
    unsigned i;

    for (i = 0; i < 6; i++)
      thisif.hwaddr[i] = opts->macaddress[i];
    ip.addr = opts->address;
 80078f0:	9105      	str	r1, [sp, #20]
    gateway.addr = opts->gateway;
 80078f2:	9206      	str	r2, [sp, #24]
    netmask.addr = opts->netmask;
 80078f4:	9307      	str	r3, [sp, #28]
 80078f6:	4f68      	ldr	r7, [pc, #416]	; (8007a98 <lwip_thread+0x1d8>)
 80078f8:	e01a      	b.n	8007930 <lwip_thread+0x70>
  }
  else {
    thisif.hwaddr[0] = LWIP_ETHADDR_0;
 80078fa:	4f67      	ldr	r7, [pc, #412]	; (8007a98 <lwip_thread+0x1d8>)
    thisif.hwaddr[1] = LWIP_ETHADDR_1;
    thisif.hwaddr[2] = LWIP_ETHADDR_2;
    thisif.hwaddr[3] = LWIP_ETHADDR_3;
    thisif.hwaddr[4] = LWIP_ETHADDR_4;
    thisif.hwaddr[5] = LWIP_ETHADDR_5;
    LWIP_IPADDR(&ip);
 80078fc:	4b67      	ldr	r3, [pc, #412]	; (8007a9c <lwip_thread+0x1dc>)
    LWIP_GATEWAY(&gateway);
 80078fe:	4a68      	ldr	r2, [pc, #416]	; (8007aa0 <lwip_thread+0x1e0>)
    thisif.hwaddr[1] = LWIP_ETHADDR_1;
    thisif.hwaddr[2] = LWIP_ETHADDR_2;
    thisif.hwaddr[3] = LWIP_ETHADDR_3;
    thisif.hwaddr[4] = LWIP_ETHADDR_4;
    thisif.hwaddr[5] = LWIP_ETHADDR_5;
    LWIP_IPADDR(&ip);
 8007900:	9305      	str	r3, [sp, #20]
    ip.addr = opts->address;
    gateway.addr = opts->gateway;
    netmask.addr = opts->netmask;
  }
  else {
    thisif.hwaddr[0] = LWIP_ETHADDR_0;
 8007902:	f04f 0ec2 	mov.w	lr, #194	; 0xc2
    thisif.hwaddr[1] = LWIP_ETHADDR_1;
 8007906:	26af      	movs	r6, #175	; 0xaf
    thisif.hwaddr[2] = LWIP_ETHADDR_2;
 8007908:	2551      	movs	r5, #81	; 0x51
    thisif.hwaddr[3] = LWIP_ETHADDR_3;
 800790a:	2403      	movs	r4, #3
    thisif.hwaddr[4] = LWIP_ETHADDR_4;
 800790c:	20cf      	movs	r0, #207	; 0xcf
    thisif.hwaddr[5] = LWIP_ETHADDR_5;
 800790e:	2146      	movs	r1, #70	; 0x46
    LWIP_IPADDR(&ip);
    LWIP_GATEWAY(&gateway);
    LWIP_NETMASK(&netmask);
 8007910:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    ip.addr = opts->address;
    gateway.addr = opts->gateway;
    netmask.addr = opts->netmask;
  }
  else {
    thisif.hwaddr[0] = LWIP_ETHADDR_0;
 8007914:	f887 e023 	strb.w	lr, [r7, #35]	; 0x23
    thisif.hwaddr[1] = LWIP_ETHADDR_1;
 8007918:	f887 6024 	strb.w	r6, [r7, #36]	; 0x24
    thisif.hwaddr[2] = LWIP_ETHADDR_2;
 800791c:	f887 5025 	strb.w	r5, [r7, #37]	; 0x25
    thisif.hwaddr[3] = LWIP_ETHADDR_3;
 8007920:	f887 4026 	strb.w	r4, [r7, #38]	; 0x26
    thisif.hwaddr[4] = LWIP_ETHADDR_4;
 8007924:	f887 0027 	strb.w	r0, [r7, #39]	; 0x27
    thisif.hwaddr[5] = LWIP_ETHADDR_5;
 8007928:	f887 1028 	strb.w	r1, [r7, #40]	; 0x28
    LWIP_IPADDR(&ip);
    LWIP_GATEWAY(&gateway);
 800792c:	9206      	str	r2, [sp, #24]
    LWIP_NETMASK(&netmask);
 800792e:	9307      	str	r3, [sp, #28]
  }
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "tcpip_init");
 8007930:	4a5c      	ldr	r2, [pc, #368]	; (8007aa4 <lwip_thread+0x1e4>)
 8007932:	495d      	ldr	r1, [pc, #372]	; (8007aa8 <lwip_thread+0x1e8>)
 8007934:	485d      	ldr	r0, [pc, #372]	; (8007aac <lwip_thread+0x1ec>)
 8007936:	4e5e      	ldr	r6, [pc, #376]	; (8007ab0 <lwip_thread+0x1f0>)
 8007938:	f7ff ffaa 	bl	8007890 <chprintf.constprop.1>
  macStart(&ETHD1, &mac_config);
 800793c:	485d      	ldr	r0, [pc, #372]	; (8007ab4 <lwip_thread+0x1f4>)
 800793e:	495e      	ldr	r1, [pc, #376]	; (8007ab8 <lwip_thread+0x1f8>)
 8007940:	f7fe fcf6 	bl	8006330 <macStart>
  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "NIC started");
 8007944:	4958      	ldr	r1, [pc, #352]	; (8007aa8 <lwip_thread+0x1e8>)
 8007946:	4a5d      	ldr	r2, [pc, #372]	; (8007abc <lwip_thread+0x1fc>)
 8007948:	4858      	ldr	r0, [pc, #352]	; (8007aac <lwip_thread+0x1ec>)
 800794a:	f7ff ffa1 	bl	8007890 <chprintf.constprop.1>
  netif_add(&thisif, &ip, &netmask, &gateway, NULL, ethernetif_init, tcpip_input);
 800794e:	4a5c      	ldr	r2, [pc, #368]	; (8007ac0 <lwip_thread+0x200>)
 8007950:	4b5c      	ldr	r3, [pc, #368]	; (8007ac4 <lwip_thread+0x204>)
 8007952:	4851      	ldr	r0, [pc, #324]	; (8007a98 <lwip_thread+0x1d8>)
 8007954:	2100      	movs	r1, #0
 8007956:	e88d 000e 	stmia.w	sp, {r1, r2, r3}
 800795a:	aa07      	add	r2, sp, #28
 800795c:	ab06      	add	r3, sp, #24
 800795e:	a905      	add	r1, sp, #20
 8007960:	f001 fbbe 	bl	80090e0 <netif_add>

  netif_set_default(&thisif);
 8007964:	484c      	ldr	r0, [pc, #304]	; (8007a98 <lwip_thread+0x1d8>)
 8007966:	f001 fc0b 	bl	8009180 <netif_set_default>
  netif_set_up(&thisif);
 800796a:	484b      	ldr	r0, [pc, #300]	; (8007a98 <lwip_thread+0x1d8>)
 800796c:	f001 fc10 	bl	8009190 <netif_set_up>

  /* Setup event sources.*/
  evtObjectInit(&evt, LWIP_LINK_POLL_INTERVAL);
 8007970:	a815      	add	r0, sp, #84	; 0x54
 8007972:	f24c 3150 	movw	r1, #50000	; 0xc350
 8007976:	f009 f8e3 	bl	8010b40 <evtObjectInit>
  evtStart(&evt);
 800797a:	a815      	add	r0, sp, #84	; 0x54
 800797c:	f009 f8e8 	bl	8010b50 <evtStart>
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventflags_t events) {

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 8007980:	a81a      	add	r0, sp, #104	; 0x68
 8007982:	a90b      	add	r1, sp, #44	; 0x2c
 8007984:	2201      	movs	r2, #1
 8007986:	f04f 33ff 	mov.w	r3, #4294967295
 800798a:	f7fa fa81 	bl	8001e90 <chEvtRegisterMaskWithFlags>
 800798e:	a910      	add	r1, sp, #64	; 0x40
 8007990:	2202      	movs	r2, #2
 8007992:	f04f 33ff 	mov.w	r3, #4294967295
 8007996:	484c      	ldr	r0, [pc, #304]	; (8007ac8 <lwip_thread+0x208>)
 8007998:	f7fa fa7a 	bl	8001e90 <chEvtRegisterMaskWithFlags>
  chEvtRegisterMask(&evt.et_es, &el0, PERIODIC_TIMER_ID);
  chEvtRegisterMask(macGetReceiveEventSource(&ETHD1), &el1, FRAME_RECEIVED_ID);
  chEvtAddEvents(PERIODIC_TIMER_ID | FRAME_RECEIVED_ID);
 800799c:	2003      	movs	r0, #3
 800799e:	f7fa fab7 	bl	8001f10 <chEvtAddEvents>

  /* Goes to the final priority after initialization.*/
  chThdSetPriority(LWIP_THREAD_PRIORITY);
 80079a2:	2002      	movs	r0, #2
 80079a4:	f7f9 fdf4 	bl	8001590 <chThdSetPriority>
 80079a8:	e001      	b.n	80079ae <lwip_thread+0xee>
        else
          tcpip_callback_with_block((tcpip_callback_fn) netif_set_link_down,
                                     &thisif, 0);
      }
    }
    if (mask & FRAME_RECEIVED_ID) {
 80079aa:	07a2      	lsls	r2, r4, #30
 80079ac:	d41f      	bmi.n	80079ee <lwip_thread+0x12e>

  /* Goes to the final priority after initialization.*/
  chThdSetPriority(LWIP_THREAD_PRIORITY);

  while (TRUE) {
    eventmask_t mask = chEvtWaitAny(ALL_EVENTS);
 80079ae:	f04f 30ff 	mov.w	r0, #4294967295
 80079b2:	f7fa fb4d 	bl	8002050 <chEvtWaitAny>
    if (mask & PERIODIC_TIMER_ID) {
 80079b6:	07c1      	lsls	r1, r0, #31

  /* Goes to the final priority after initialization.*/
  chThdSetPriority(LWIP_THREAD_PRIORITY);

  while (TRUE) {
    eventmask_t mask = chEvtWaitAny(ALL_EVENTS);
 80079b8:	4604      	mov	r4, r0
    if (mask & PERIODIC_TIMER_ID) {
 80079ba:	d5f6      	bpl.n	80079aa <lwip_thread+0xea>
      bool current_link_status = macPollLinkStatus(&ETHD1);
 80079bc:	483d      	ldr	r0, [pc, #244]	; (8007ab4 <lwip_thread+0x1f4>)
 80079be:	f7fe fd37 	bl	8006430 <macPollLinkStatus>
	  chprintf((BaseSequentialStream *)&itm_port, "cable is %s\n", current_link_status ? "linked" : "not linked");
 80079c2:	4605      	mov	r5, r0
 80079c4:	2800      	cmp	r0, #0
 80079c6:	d047      	beq.n	8007a58 <lwip_thread+0x198>
 80079c8:	4a40      	ldr	r2, [pc, #256]	; (8007acc <lwip_thread+0x20c>)
 80079ca:	4838      	ldr	r0, [pc, #224]	; (8007aac <lwip_thread+0x1ec>)
 80079cc:	4940      	ldr	r1, [pc, #256]	; (8007ad0 <lwip_thread+0x210>)
 80079ce:	f7ff ff5f 	bl	8007890 <chprintf.constprop.1>
      if (current_link_status != netif_is_link_up(&thisif)) {
 80079d2:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80079d6:	f003 0310 	and.w	r3, r3, #16
 80079da:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80079de:	2b00      	cmp	r3, #0
 80079e0:	d1e3      	bne.n	80079aa <lwip_thread+0xea>
        if (current_link_status)
          tcpip_callback_with_block((tcpip_callback_fn) netif_set_link_up,
 80079e2:	483c      	ldr	r0, [pc, #240]	; (8007ad4 <lwip_thread+0x214>)
 80079e4:	492c      	ldr	r1, [pc, #176]	; (8007a98 <lwip_thread+0x1d8>)
 80079e6:	f009 f80b 	bl	8010a00 <tcpip_callback_with_block>
        else
          tcpip_callback_with_block((tcpip_callback_fn) netif_set_link_down,
                                     &thisif, 0);
      }
    }
    if (mask & FRAME_RECEIVED_ID) {
 80079ea:	07a2      	lsls	r2, r4, #30
 80079ec:	d5df      	bpl.n	80079ae <lwip_thread+0xee>
  MACReceiveDescriptor rd;
  struct pbuf *p, *q;
  u16_t len;

  (void)netif;
  if (macWaitReceiveDescriptor(&ETHD1, &rd, TIME_IMMEDIATE) == MSG_OK) {
 80079ee:	4831      	ldr	r0, [pc, #196]	; (8007ab4 <lwip_thread+0x1f4>)
 80079f0:	a908      	add	r1, sp, #32
 80079f2:	2200      	movs	r2, #0
 80079f4:	f7fe fce4 	bl	80063c0 <macWaitReceiveDescriptor>
 80079f8:	2800      	cmp	r0, #0
 80079fa:	d1d8      	bne.n	80079ae <lwip_thread+0xee>
#if ETH_PAD_SIZE
    len += ETH_PAD_SIZE;        /* allow room for Ethernet padding */
#endif

    /* We allocate a pbuf chain of pbufs from the pool. */
    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
 80079fc:	2003      	movs	r0, #3
 80079fe:	4602      	mov	r2, r0
 8007a00:	f8bd 1024 	ldrh.w	r1, [sp, #36]	; 0x24
 8007a04:	f001 fd7c 	bl	8009500 <pbuf_alloc>

    if (p != NULL) {
 8007a08:	4605      	mov	r5, r0
 8007a0a:	2800      	cmp	r0, #0
 8007a0c:	d033      	beq.n	8007a76 <lwip_thread+0x1b6>
 8007a0e:	4604      	mov	r4, r0
      pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
#endif

      /* Iterates through the pbuf chain. */
      for(q = p; q != NULL; q = q->next)
        macReadReceiveDescriptor(&rd, (uint8_t *)q->payload, (size_t)q->len);
 8007a10:	6861      	ldr	r1, [r4, #4]
 8007a12:	8962      	ldrh	r2, [r4, #10]
 8007a14:	a808      	add	r0, sp, #32
 8007a16:	f7ff fb93 	bl	8007140 <mac_lld_read_receive_descriptor>
#if ETH_PAD_SIZE
      pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
#endif

      /* Iterates through the pbuf chain. */
      for(q = p; q != NULL; q = q->next)
 8007a1a:	6824      	ldr	r4, [r4, #0]
 8007a1c:	2c00      	cmp	r4, #0
 8007a1e:	d1f7      	bne.n	8007a10 <lwip_thread+0x150>
        macReadReceiveDescriptor(&rd, (uint8_t *)q->payload, (size_t)q->len);
      macReleaseReceiveDescriptor(&rd);
 8007a20:	a808      	add	r0, sp, #32
 8007a22:	f7fe fcfd 	bl	8006420 <macReleaseReceiveDescriptor>

#if ETH_PAD_SIZE
      pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
#endif

      LINK_STATS_INC(link.recv);
 8007a26:	8873      	ldrh	r3, [r6, #2]
    }
    if (mask & FRAME_RECEIVED_ID) {
      struct pbuf *p;
      while ((p = low_level_input(&thisif)) != NULL) {
        struct eth_hdr *ethhdr = p->payload;
        switch (htons(ethhdr->type)) {
 8007a28:	686a      	ldr	r2, [r5, #4]

#if ETH_PAD_SIZE
      pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
#endif

      LINK_STATS_INC(link.recv);
 8007a2a:	3301      	adds	r3, #1
 8007a2c:	8073      	strh	r3, [r6, #2]
    }
    if (mask & FRAME_RECEIVED_ID) {
      struct pbuf *p;
      while ((p = low_level_input(&thisif)) != NULL) {
        struct eth_hdr *ethhdr = p->payload;
        switch (htons(ethhdr->type)) {
 8007a2e:	8990      	ldrh	r0, [r2, #12]
 8007a30:	f007 f9b6 	bl	800eda0 <lwip_htons>
 8007a34:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
 8007a38:	d007      	beq.n	8007a4a <lwip_thread+0x18a>
 8007a3a:	f640 0306 	movw	r3, #2054	; 0x806
 8007a3e:	4298      	cmp	r0, r3
 8007a40:	d003      	beq.n	8007a4a <lwip_thread+0x18a>
          /* full packet send to tcpip_thread to process */
          if (thisif.input(p, &thisif) == ERR_OK)
            break;
          LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
        default:
          pbuf_free(p);
 8007a42:	4628      	mov	r0, r5
 8007a44:	f001 fcdc 	bl	8009400 <pbuf_free>
 8007a48:	e7d1      	b.n	80079ee <lwip_thread+0x12e>
        /* PPPoE packet? */
        case ETHTYPE_PPPOEDISC:
        case ETHTYPE_PPPOE:
#endif /* PPPOE_SUPPORT */
          /* full packet send to tcpip_thread to process */
          if (thisif.input(p, &thisif) == ERR_OK)
 8007a4a:	693b      	ldr	r3, [r7, #16]
 8007a4c:	4912      	ldr	r1, [pc, #72]	; (8007a98 <lwip_thread+0x1d8>)
 8007a4e:	4628      	mov	r0, r5
 8007a50:	4798      	blx	r3
 8007a52:	2800      	cmp	r0, #0
 8007a54:	d0cb      	beq.n	80079ee <lwip_thread+0x12e>
 8007a56:	e7f4      	b.n	8007a42 <lwip_thread+0x182>

  while (TRUE) {
    eventmask_t mask = chEvtWaitAny(ALL_EVENTS);
    if (mask & PERIODIC_TIMER_ID) {
      bool current_link_status = macPollLinkStatus(&ETHD1);
	  chprintf((BaseSequentialStream *)&itm_port, "cable is %s\n", current_link_status ? "linked" : "not linked");
 8007a58:	4814      	ldr	r0, [pc, #80]	; (8007aac <lwip_thread+0x1ec>)
 8007a5a:	491d      	ldr	r1, [pc, #116]	; (8007ad0 <lwip_thread+0x210>)
 8007a5c:	4a1e      	ldr	r2, [pc, #120]	; (8007ad8 <lwip_thread+0x218>)
 8007a5e:	f7ff ff17 	bl	8007890 <chprintf.constprop.1>
      if (current_link_status != netif_is_link_up(&thisif)) {
 8007a62:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8007a66:	06db      	lsls	r3, r3, #27
 8007a68:	d59f      	bpl.n	80079aa <lwip_thread+0xea>
        if (current_link_status)
          tcpip_callback_with_block((tcpip_callback_fn) netif_set_link_up,
                                     &thisif, 0);
        else
          tcpip_callback_with_block((tcpip_callback_fn) netif_set_link_down,
 8007a6a:	462a      	mov	r2, r5
 8007a6c:	490a      	ldr	r1, [pc, #40]	; (8007a98 <lwip_thread+0x1d8>)
 8007a6e:	481b      	ldr	r0, [pc, #108]	; (8007adc <lwip_thread+0x21c>)
 8007a70:	f008 ffc6 	bl	8010a00 <tcpip_callback_with_block>
 8007a74:	e799      	b.n	80079aa <lwip_thread+0xea>
#endif

      LINK_STATS_INC(link.recv);
    }
    else {
      macReleaseReceiveDescriptor(&rd);
 8007a76:	a808      	add	r0, sp, #32
 8007a78:	f7fe fcd2 	bl	8006420 <macReleaseReceiveDescriptor>
      LINK_STATS_INC(link.memerr);
 8007a7c:	89b2      	ldrh	r2, [r6, #12]
      LINK_STATS_INC(link.drop);
 8007a7e:	88f3      	ldrh	r3, [r6, #6]

      LINK_STATS_INC(link.recv);
    }
    else {
      macReleaseReceiveDescriptor(&rd);
      LINK_STATS_INC(link.memerr);
 8007a80:	3201      	adds	r2, #1
      LINK_STATS_INC(link.drop);
 8007a82:	3301      	adds	r3, #1

      LINK_STATS_INC(link.recv);
    }
    else {
      macReleaseReceiveDescriptor(&rd);
      LINK_STATS_INC(link.memerr);
 8007a84:	81b2      	strh	r2, [r6, #12]
      LINK_STATS_INC(link.drop);
 8007a86:	80f3      	strh	r3, [r6, #6]
 8007a88:	e791      	b.n	80079ae <lwip_thread+0xee>
 8007a8a:	bf00      	nop
 8007a8c:	20001150 	.word	0x20001150
 8007a90:	08016f80 	.word	0x08016f80
 8007a94:	20004372 	.word	0x20004372
 8007a98:	20004350 	.word	0x20004350
 8007a9c:	0a02a8c0 	.word	0x0a02a8c0
 8007aa0:	0102a8c0 	.word	0x0102a8c0
 8007aa4:	08016f8c 	.word	0x08016f8c
 8007aa8:	08017004 	.word	0x08017004
 8007aac:	200180c8 	.word	0x200180c8
 8007ab0:	2000c9fc 	.word	0x2000c9fc
 8007ab4:	20001dfc 	.word	0x20001dfc
 8007ab8:	08016fc0 	.word	0x08016fc0
 8007abc:	08016f98 	.word	0x08016f98
 8007ac0:	08007801 	.word	0x08007801
 8007ac4:	080109b1 	.word	0x080109b1
 8007ac8:	20001e14 	.word	0x20001e14
 8007acc:	08016fb8 	.word	0x08016fb8
 8007ad0:	08016fa4 	.word	0x08016fa4
 8007ad4:	080091c1 	.word	0x080091c1
 8007ad8:	08016fb4 	.word	0x08016fb4
 8007adc:	080091f1 	.word	0x080091f1

08007ae0 <sys_init>:
#include "lwip/stats.h"

#include "arch/cc.h"
#include "arch/sys_arch.h"

void sys_init(void) {
 8007ae0:	4770      	bx	lr
 8007ae2:	bf00      	nop
 8007ae4:	f3af 8000 	nop.w
 8007ae8:	f3af 8000 	nop.w
 8007aec:	f3af 8000 	nop.w

08007af0 <sys_sem_new>:

}

err_t sys_sem_new(sys_sem_t *sem, u8_t count) {
 8007af0:	b538      	push	{r3, r4, r5, lr}
 8007af2:	4604      	mov	r4, r0
 8007af4:	460d      	mov	r5, r1

  *sem = chHeapAlloc(NULL, sizeof(semaphore_t));
 8007af6:	2000      	movs	r0, #0
 8007af8:	210c      	movs	r1, #12
 8007afa:	f7fa fe99 	bl	8002830 <chHeapAlloc>
 8007afe:	6020      	str	r0, [r4, #0]
  if (*sem == 0) {
 8007b00:	b190      	cbz	r0, 8007b28 <sys_sem_new+0x38>
    SYS_STATS_INC(sem.err);
    return ERR_MEM;
  }
  else {
    chSemObjectInit(*sem, (cnt_t)count);
 8007b02:	4629      	mov	r1, r5
 8007b04:	f7f9 fed4 	bl	80018b0 <chSemObjectInit>
    SYS_STATS_INC_USED(sem);
 8007b08:	4a0b      	ldr	r2, [pc, #44]	; (8007b38 <sys_sem_new+0x48>)
 8007b0a:	f8b2 313e 	ldrh.w	r3, [r2, #318]	; 0x13e
 8007b0e:	f8b2 1140 	ldrh.w	r1, [r2, #320]	; 0x140
 8007b12:	3301      	adds	r3, #1
 8007b14:	b29b      	uxth	r3, r3
 8007b16:	4299      	cmp	r1, r3
 8007b18:	f8a2 313e 	strh.w	r3, [r2, #318]	; 0x13e
 8007b1c:	bf38      	it	cc
 8007b1e:	f8a2 3140 	strhcc.w	r3, [r2, #320]	; 0x140
    return ERR_OK;
 8007b22:	2000      	movs	r0, #0
  }
}
 8007b24:	b240      	sxtb	r0, r0
 8007b26:	bd38      	pop	{r3, r4, r5, pc}

err_t sys_sem_new(sys_sem_t *sem, u8_t count) {

  *sem = chHeapAlloc(NULL, sizeof(semaphore_t));
  if (*sem == 0) {
    SYS_STATS_INC(sem.err);
 8007b28:	4a03      	ldr	r2, [pc, #12]	; (8007b38 <sys_sem_new+0x48>)
 8007b2a:	f8b2 3142 	ldrh.w	r3, [r2, #322]	; 0x142
 8007b2e:	3301      	adds	r3, #1
 8007b30:	f8a2 3142 	strh.w	r3, [r2, #322]	; 0x142
    return ERR_MEM;
 8007b34:	20ff      	movs	r0, #255	; 0xff
 8007b36:	e7f5      	b.n	8007b24 <sys_sem_new+0x34>
 8007b38:	2000c9fc 	.word	0x2000c9fc
 8007b3c:	f3af 8000 	nop.w

08007b40 <sys_sem_free>:
    SYS_STATS_INC_USED(sem);
    return ERR_OK;
  }
}

void sys_sem_free(sys_sem_t *sem) {
 8007b40:	b510      	push	{r4, lr}
 8007b42:	4604      	mov	r4, r0

  chHeapFree(*sem);
 8007b44:	6800      	ldr	r0, [r0, #0]
 8007b46:	f7fa febb 	bl	80028c0 <chHeapFree>
  *sem = SYS_SEM_NULL;
  SYS_STATS_DEC(sem.used);
 8007b4a:	4a04      	ldr	r2, [pc, #16]	; (8007b5c <sys_sem_free+0x1c>)
 8007b4c:	f8b2 313e 	ldrh.w	r3, [r2, #318]	; 0x13e
}

void sys_sem_free(sys_sem_t *sem) {

  chHeapFree(*sem);
  *sem = SYS_SEM_NULL;
 8007b50:	2100      	movs	r1, #0
  SYS_STATS_DEC(sem.used);
 8007b52:	3b01      	subs	r3, #1
}

void sys_sem_free(sys_sem_t *sem) {

  chHeapFree(*sem);
  *sem = SYS_SEM_NULL;
 8007b54:	6021      	str	r1, [r4, #0]
  SYS_STATS_DEC(sem.used);
 8007b56:	f8a2 313e 	strh.w	r3, [r2, #318]	; 0x13e
 8007b5a:	bd10      	pop	{r4, pc}
 8007b5c:	2000c9fc 	.word	0x2000c9fc

08007b60 <sys_sem_signal>:
}

void sys_sem_signal(sys_sem_t *sem) {

  chSemSignal(*sem);
 8007b60:	6800      	ldr	r0, [r0, #0]
 8007b62:	f7f9 bf2d 	b.w	80019c0 <chSemSignal>
 8007b66:	bf00      	nop
 8007b68:	f3af 8000 	nop.w
 8007b6c:	f3af 8000 	nop.w

08007b70 <sys_arch_sem_wait>:

  chSemSignalI(*sem);
  chSchRescheduleS();
}

u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout) {
 8007b70:	b538      	push	{r3, r4, r5, lr}
 8007b72:	2320      	movs	r3, #32
 8007b74:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8007b78:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
  systime_t time, tmo;

  osalSysLock();
  tmo = timeout > 0 ? (systime_t)timeout : TIME_INFINITE;
 8007b7c:	2900      	cmp	r1, #0
  time = osalOsGetSystemTimeX();
  if (chSemWaitTimeoutS(*sem, tmo) != MSG_OK)
 8007b7e:	bf08      	it	eq
 8007b80:	f04f 31ff 	moveq.w	r1, #4294967295
 8007b84:	6800      	ldr	r0, [r0, #0]
 8007b86:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8007b88:	f7f9 feea 	bl	8001960 <chSemWaitTimeoutS>
 8007b8c:	b128      	cbz	r0, 8007b9a <sys_arch_sem_wait+0x2a>
    time = SYS_ARCH_TIMEOUT;
 8007b8e:	f04f 30ff 	mov.w	r0, #4294967295
 8007b92:	2300      	movs	r3, #0
 8007b94:	f383 8811 	msr	BASEPRI, r3
  else
    time = osalOsGetSystemTimeX() - time;
  osalSysUnlock();
  return time;
}
 8007b98:	bd38      	pop	{r3, r4, r5, pc}
 8007b9a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8007b9c:	2300      	movs	r3, #0
  tmo = timeout > 0 ? (systime_t)timeout : TIME_INFINITE;
  time = osalOsGetSystemTimeX();
  if (chSemWaitTimeoutS(*sem, tmo) != MSG_OK)
    time = SYS_ARCH_TIMEOUT;
  else
    time = osalOsGetSystemTimeX() - time;
 8007b9e:	1b40      	subs	r0, r0, r5
 8007ba0:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
  return time;
}
 8007ba4:	bd38      	pop	{r3, r4, r5, pc}
 8007ba6:	bf00      	nop
 8007ba8:	f3af 8000 	nop.w
 8007bac:	f3af 8000 	nop.w

08007bb0 <sys_sem_valid>:

int sys_sem_valid(sys_sem_t *sem) {
  return *sem != SYS_SEM_NULL;
 8007bb0:	6800      	ldr	r0, [r0, #0]
}
 8007bb2:	3000      	adds	r0, #0
 8007bb4:	bf18      	it	ne
 8007bb6:	2001      	movne	r0, #1
 8007bb8:	4770      	bx	lr
 8007bba:	bf00      	nop
 8007bbc:	f3af 8000 	nop.w

08007bc0 <sys_sem_set_invalid>:

// typically called within lwIP after freeing a semaphore
// to make sure the pointer is not left pointing to invalid data
void sys_sem_set_invalid(sys_sem_t *sem) {
  *sem = SYS_SEM_NULL;
 8007bc0:	2300      	movs	r3, #0
 8007bc2:	6003      	str	r3, [r0, #0]
 8007bc4:	4770      	bx	lr
 8007bc6:	bf00      	nop
 8007bc8:	f3af 8000 	nop.w
 8007bcc:	f3af 8000 	nop.w

08007bd0 <sys_mbox_new>:
}

err_t sys_mbox_new(sys_mbox_t *mbox, int size) {
 8007bd0:	b538      	push	{r3, r4, r5, lr}
 8007bd2:	460c      	mov	r4, r1
  
  *mbox = chHeapAlloc(NULL, sizeof(mailbox_t) + sizeof(msg_t) * size);
 8007bd4:	310a      	adds	r1, #10
// to make sure the pointer is not left pointing to invalid data
void sys_sem_set_invalid(sys_sem_t *sem) {
  *sem = SYS_SEM_NULL;
}

err_t sys_mbox_new(sys_mbox_t *mbox, int size) {
 8007bd6:	4605      	mov	r5, r0
  
  *mbox = chHeapAlloc(NULL, sizeof(mailbox_t) + sizeof(msg_t) * size);
 8007bd8:	0089      	lsls	r1, r1, #2
 8007bda:	2000      	movs	r0, #0
 8007bdc:	f7fa fe28 	bl	8002830 <chHeapAlloc>
 8007be0:	4601      	mov	r1, r0
 8007be2:	6028      	str	r0, [r5, #0]
  if (*mbox == 0) {
 8007be4:	b160      	cbz	r0, 8007c00 <sys_mbox_new+0x30>
    SYS_STATS_INC(mbox.err);
    return ERR_MEM;
  }
  else {
    chMBObjectInit(*mbox, (void *)(((uint8_t *)*mbox) + sizeof(mailbox_t)), size);
 8007be6:	4622      	mov	r2, r4
 8007be8:	3128      	adds	r1, #40	; 0x28
 8007bea:	f7fa fb39 	bl	8002260 <chMBObjectInit>
    SYS_STATS_INC(mbox.used);
 8007bee:	4a08      	ldr	r2, [pc, #32]	; (8007c10 <sys_mbox_new+0x40>)
 8007bf0:	f8b2 314a 	ldrh.w	r3, [r2, #330]	; 0x14a
 8007bf4:	3301      	adds	r3, #1
 8007bf6:	f8a2 314a 	strh.w	r3, [r2, #330]	; 0x14a
    return ERR_OK;
 8007bfa:	2000      	movs	r0, #0
  }
}
 8007bfc:	b240      	sxtb	r0, r0
 8007bfe:	bd38      	pop	{r3, r4, r5, pc}

err_t sys_mbox_new(sys_mbox_t *mbox, int size) {
  
  *mbox = chHeapAlloc(NULL, sizeof(mailbox_t) + sizeof(msg_t) * size);
  if (*mbox == 0) {
    SYS_STATS_INC(mbox.err);
 8007c00:	4a03      	ldr	r2, [pc, #12]	; (8007c10 <sys_mbox_new+0x40>)
 8007c02:	f8b2 314e 	ldrh.w	r3, [r2, #334]	; 0x14e
 8007c06:	3301      	adds	r3, #1
 8007c08:	f8a2 314e 	strh.w	r3, [r2, #334]	; 0x14e
    return ERR_MEM;
 8007c0c:	20ff      	movs	r0, #255	; 0xff
 8007c0e:	e7f5      	b.n	8007bfc <sys_mbox_new+0x2c>
 8007c10:	2000c9fc 	.word	0x2000c9fc
 8007c14:	f3af 8000 	nop.w
 8007c18:	f3af 8000 	nop.w
 8007c1c:	f3af 8000 	nop.w

08007c20 <sys_mbox_free>:
    SYS_STATS_INC(mbox.used);
    return ERR_OK;
  }
}

void sys_mbox_free(sys_mbox_t *mbox) {
 8007c20:	b538      	push	{r3, r4, r5, lr}
 8007c22:	4604      	mov	r4, r0
 8007c24:	2320      	movs	r3, #32
 8007c26:	f383 8811 	msr	BASEPRI, r3
 8007c2a:	6803      	ldr	r3, [r0, #0]
 8007c2c:	2200      	movs	r2, #0
 8007c2e:	699b      	ldr	r3, [r3, #24]
 8007c30:	f382 8811 	msr	BASEPRI, r2

  if (tmpcnt != 0) {
    // If there are messages still present in the mailbox when the mailbox
    // is deallocated, it is an indication of a programming error in lwIP
    // and the developer should be notified.
    SYS_STATS_INC(mbox.err);
 8007c34:	4d0a      	ldr	r5, [pc, #40]	; (8007c60 <sys_mbox_free+0x40>)

  osalSysLock();
  tmpcnt = chMBGetUsedCountI(*mbox);
  osalSysUnlock();

  if (tmpcnt != 0) {
 8007c36:	b13b      	cbz	r3, 8007c48 <sys_mbox_free+0x28>
    // If there are messages still present in the mailbox when the mailbox
    // is deallocated, it is an indication of a programming error in lwIP
    // and the developer should be notified.
    SYS_STATS_INC(mbox.err);
 8007c38:	f8b5 314e 	ldrh.w	r3, [r5, #334]	; 0x14e
    chMBReset(*mbox);
 8007c3c:	6800      	ldr	r0, [r0, #0]

  if (tmpcnt != 0) {
    // If there are messages still present in the mailbox when the mailbox
    // is deallocated, it is an indication of a programming error in lwIP
    // and the developer should be notified.
    SYS_STATS_INC(mbox.err);
 8007c3e:	3301      	adds	r3, #1
 8007c40:	f8a5 314e 	strh.w	r3, [r5, #334]	; 0x14e
    chMBReset(*mbox);
 8007c44:	f7fa fb3c 	bl	80022c0 <chMBReset>
  }
  chHeapFree(*mbox);
 8007c48:	6820      	ldr	r0, [r4, #0]
 8007c4a:	f7fa fe39 	bl	80028c0 <chHeapFree>
  *mbox = SYS_MBOX_NULL;
  SYS_STATS_DEC(mbox.used);
 8007c4e:	f8b5 314a 	ldrh.w	r3, [r5, #330]	; 0x14a
    // and the developer should be notified.
    SYS_STATS_INC(mbox.err);
    chMBReset(*mbox);
  }
  chHeapFree(*mbox);
  *mbox = SYS_MBOX_NULL;
 8007c52:	2200      	movs	r2, #0
  SYS_STATS_DEC(mbox.used);
 8007c54:	3b01      	subs	r3, #1
    // and the developer should be notified.
    SYS_STATS_INC(mbox.err);
    chMBReset(*mbox);
  }
  chHeapFree(*mbox);
  *mbox = SYS_MBOX_NULL;
 8007c56:	6022      	str	r2, [r4, #0]
  SYS_STATS_DEC(mbox.used);
 8007c58:	f8a5 314a 	strh.w	r3, [r5, #330]	; 0x14a
 8007c5c:	bd38      	pop	{r3, r4, r5, pc}
 8007c5e:	bf00      	nop
 8007c60:	2000c9fc 	.word	0x2000c9fc
 8007c64:	f3af 8000 	nop.w
 8007c68:	f3af 8000 	nop.w
 8007c6c:	f3af 8000 	nop.w

08007c70 <sys_mbox_post>:
}

void sys_mbox_post(sys_mbox_t *mbox, void *msg) {

  chMBPost(*mbox, (msg_t)msg, TIME_INFINITE);
 8007c70:	6800      	ldr	r0, [r0, #0]
 8007c72:	f04f 32ff 	mov.w	r2, #4294967295
 8007c76:	f7fa bb53 	b.w	8002320 <chMBPost>
 8007c7a:	bf00      	nop
 8007c7c:	f3af 8000 	nop.w

08007c80 <sys_mbox_trypost>:
}

err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg) {
 8007c80:	b508      	push	{r3, lr}

  if (chMBPost(*mbox, (msg_t)msg, TIME_IMMEDIATE) == MSG_TIMEOUT) {
 8007c82:	6800      	ldr	r0, [r0, #0]
 8007c84:	2200      	movs	r2, #0
 8007c86:	f7fa fb4b 	bl	8002320 <chMBPost>
 8007c8a:	3001      	adds	r0, #1
    SYS_STATS_INC(mbox.err);
    return ERR_MEM;
  }
  return ERR_OK;
 8007c8c:	bf18      	it	ne
 8007c8e:	2000      	movne	r0, #0
  chMBPost(*mbox, (msg_t)msg, TIME_INFINITE);
}

err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg) {

  if (chMBPost(*mbox, (msg_t)msg, TIME_IMMEDIATE) == MSG_TIMEOUT) {
 8007c90:	d001      	beq.n	8007c96 <sys_mbox_trypost+0x16>
    SYS_STATS_INC(mbox.err);
    return ERR_MEM;
  }
  return ERR_OK;
}
 8007c92:	b240      	sxtb	r0, r0
 8007c94:	bd08      	pop	{r3, pc}
}

err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg) {

  if (chMBPost(*mbox, (msg_t)msg, TIME_IMMEDIATE) == MSG_TIMEOUT) {
    SYS_STATS_INC(mbox.err);
 8007c96:	4a04      	ldr	r2, [pc, #16]	; (8007ca8 <sys_mbox_trypost+0x28>)
 8007c98:	f8b2 314e 	ldrh.w	r3, [r2, #334]	; 0x14e
 8007c9c:	3301      	adds	r3, #1
 8007c9e:	f8a2 314e 	strh.w	r3, [r2, #334]	; 0x14e
    return ERR_MEM;
 8007ca2:	20ff      	movs	r0, #255	; 0xff
 8007ca4:	e7f5      	b.n	8007c92 <sys_mbox_trypost+0x12>
 8007ca6:	bf00      	nop
 8007ca8:	2000c9fc 	.word	0x2000c9fc
 8007cac:	f3af 8000 	nop.w

08007cb0 <sys_arch_mbox_fetch>:
  }
  return ERR_OK;
}

u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout) {
 8007cb0:	b538      	push	{r3, r4, r5, lr}
 8007cb2:	2320      	movs	r3, #32
 8007cb4:	f383 8811 	msr	BASEPRI, r3
 8007cb8:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
  systime_t time, tmo;

  osalSysLock();
  tmo = timeout > 0 ? (systime_t)timeout : TIME_INFINITE;
 8007cbc:	2a00      	cmp	r2, #0
  time = osalOsGetSystemTimeX();
  if (chMBFetchS(*mbox, (msg_t *)msg, tmo) != MSG_OK)
 8007cbe:	bf08      	it	eq
 8007cc0:	f04f 32ff 	moveq.w	r2, #4294967295
 8007cc4:	6800      	ldr	r0, [r0, #0]
 8007cc6:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8007cc8:	f7fa fba2 	bl	8002410 <chMBFetchS>
 8007ccc:	b128      	cbz	r0, 8007cda <sys_arch_mbox_fetch+0x2a>
    time = SYS_ARCH_TIMEOUT;
 8007cce:	f04f 30ff 	mov.w	r0, #4294967295
 8007cd2:	2300      	movs	r3, #0
 8007cd4:	f383 8811 	msr	BASEPRI, r3
  else
    time = osalOsGetSystemTimeX() - time;
  osalSysUnlock();
  return time;
}
 8007cd8:	bd38      	pop	{r3, r4, r5, pc}
 8007cda:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8007cdc:	2300      	movs	r3, #0
  tmo = timeout > 0 ? (systime_t)timeout : TIME_INFINITE;
  time = osalOsGetSystemTimeX();
  if (chMBFetchS(*mbox, (msg_t *)msg, tmo) != MSG_OK)
    time = SYS_ARCH_TIMEOUT;
  else
    time = osalOsGetSystemTimeX() - time;
 8007cde:	1b40      	subs	r0, r0, r5
 8007ce0:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
  return time;
}
 8007ce4:	bd38      	pop	{r3, r4, r5, pc}
 8007ce6:	bf00      	nop
 8007ce8:	f3af 8000 	nop.w
 8007cec:	f3af 8000 	nop.w

08007cf0 <sys_arch_mbox_tryfetch>:

u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg) {
 8007cf0:	b508      	push	{r3, lr}

  if (chMBFetch(*mbox, (msg_t *)msg, TIME_IMMEDIATE) == MSG_TIMEOUT)
 8007cf2:	2200      	movs	r2, #0
 8007cf4:	6800      	ldr	r0, [r0, #0]
 8007cf6:	f7fa fbab 	bl	8002450 <chMBFetch>
    return SYS_MBOX_EMPTY;
  return 0;
}
 8007cfa:	3001      	adds	r0, #1
 8007cfc:	f04f 30ff 	mov.w	r0, #4294967295
 8007d00:	bf18      	it	ne
 8007d02:	2000      	movne	r0, #0
 8007d04:	bd08      	pop	{r3, pc}
 8007d06:	bf00      	nop
 8007d08:	f3af 8000 	nop.w
 8007d0c:	f3af 8000 	nop.w

08007d10 <sys_mbox_valid>:

int sys_mbox_valid(sys_mbox_t *mbox) {
  return *mbox != SYS_MBOX_NULL;
 8007d10:	6800      	ldr	r0, [r0, #0]
}
 8007d12:	3000      	adds	r0, #0
 8007d14:	bf18      	it	ne
 8007d16:	2001      	movne	r0, #1
 8007d18:	4770      	bx	lr
 8007d1a:	bf00      	nop
 8007d1c:	f3af 8000 	nop.w

08007d20 <sys_mbox_set_invalid>:

// typically called within lwIP after freeing an mbox
// to make sure the pointer is not left pointing to invalid data
void sys_mbox_set_invalid(sys_mbox_t *mbox) {
  *mbox = SYS_MBOX_NULL;
 8007d20:	2300      	movs	r3, #0
 8007d22:	6003      	str	r3, [r0, #0]
 8007d24:	4770      	bx	lr
 8007d26:	bf00      	nop
 8007d28:	f3af 8000 	nop.w
 8007d2c:	f3af 8000 	nop.w

08007d30 <sys_thread_new>:

  size_t wsz;
  void *wsp;

  (void)name;
  wsz = THD_WORKING_AREA_SIZE(stacksize);
 8007d30:	f203 134f 	addw	r3, r3, #335	; 0x14f
void sys_mbox_set_invalid(sys_mbox_t *mbox) {
  *mbox = SYS_MBOX_NULL;
}

sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread,
                            void *arg, int stacksize, int prio) {
 8007d34:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  size_t wsz;
  void *wsp;

  (void)name;
  wsz = THD_WORKING_AREA_SIZE(stacksize);
 8007d38:	f043 0407 	orr.w	r4, r3, #7
 8007d3c:	3401      	adds	r4, #1
  wsp = chCoreAlloc(wsz);
 8007d3e:	4620      	mov	r0, r4
void sys_mbox_set_invalid(sys_mbox_t *mbox) {
  *mbox = SYS_MBOX_NULL;
}

sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread,
                            void *arg, int stacksize, int prio) {
 8007d40:	460d      	mov	r5, r1
 8007d42:	4617      	mov	r7, r2
 8007d44:	9e06      	ldr	r6, [sp, #24]
  size_t wsz;
  void *wsp;

  (void)name;
  wsz = THD_WORKING_AREA_SIZE(stacksize);
  wsp = chCoreAlloc(wsz);
 8007d46:	f7fa fd23 	bl	8002790 <chCoreAlloc>
  if (wsp == NULL)
 8007d4a:	b138      	cbz	r0, 8007d5c <sys_thread_new+0x2c>
    return NULL;
  return (sys_thread_t)chThdCreateStatic(wsp, wsz, prio, (tfunc_t)thread, arg);
 8007d4c:	9706      	str	r7, [sp, #24]
 8007d4e:	4621      	mov	r1, r4
 8007d50:	4632      	mov	r2, r6
 8007d52:	462b      	mov	r3, r5
}
 8007d54:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  (void)name;
  wsz = THD_WORKING_AREA_SIZE(stacksize);
  wsp = chCoreAlloc(wsz);
  if (wsp == NULL)
    return NULL;
  return (sys_thread_t)chThdCreateStatic(wsp, wsz, prio, (tfunc_t)thread, arg);
 8007d58:	f7f9 bbca 	b.w	80014f0 <chThdCreateStatic>
}
 8007d5c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08007d60 <chprintf.constprop.1>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8007d60:	b40e      	push	{r1, r2, r3}
 8007d62:	b500      	push	{lr}
 8007d64:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8007d66:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 8007d68:	461a      	mov	r2, r3
 8007d6a:	4905      	ldr	r1, [pc, #20]	; (8007d80 <chprintf.constprop.1+0x20>)
 8007d6c:	4805      	ldr	r0, [pc, #20]	; (8007d84 <chprintf.constprop.1+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8007d6e:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8007d70:	f008 ffc6 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8007d74:	b002      	add	sp, #8
 8007d76:	f85d eb04 	ldr.w	lr, [sp], #4
 8007d7a:	b003      	add	sp, #12
 8007d7c:	4770      	bx	lr
 8007d7e:	bf00      	nop
 8007d80:	08016fe0 	.word	0x08016fe0
 8007d84:	200180c8 	.word	0x200180c8
 8007d88:	f3af 8000 	nop.w
 8007d8c:	f3af 8000 	nop.w

08007d90 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
 8007d90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007d94:	460e      	mov	r6, r1
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
 8007d96:	f890 1022 	ldrb.w	r1, [r0, #34]	; 0x22
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
 8007d9a:	6874      	ldr	r4, [r6, #4]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
 8007d9c:	2906      	cmp	r1, #6
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
 8007d9e:	b082      	sub	sp, #8
 8007da0:	4605      	mov	r5, r0
 8007da2:	4617      	mov	r7, r2
 8007da4:	4698      	mov	r8, r3
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
 8007da6:	d00b      	beq.n	8007dc0 <etharp_send_ip+0x30>
 8007da8:	4b10      	ldr	r3, [pc, #64]	; (8007dec <etharp_send_ip+0x5c>)
 8007daa:	9300      	str	r3, [sp, #0]
 8007dac:	4810      	ldr	r0, [pc, #64]	; (8007df0 <etharp_send_ip+0x60>)
 8007dae:	4911      	ldr	r1, [pc, #68]	; (8007df4 <etharp_send_ip+0x64>)
 8007db0:	4a11      	ldr	r2, [pc, #68]	; (8007df8 <etharp_send_ip+0x68>)
 8007db2:	f44f 73d2 	mov.w	r3, #420	; 0x1a4
 8007db6:	f7ff ffd3 	bl	8007d60 <chprintf.constprop.1>
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 8007dba:	480f      	ldr	r0, [pc, #60]	; (8007df8 <etharp_send_ip+0x68>)
 8007dbc:	f7f9 f8d8 	bl	8000f70 <chSysHalt>
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
 8007dc0:	f8d8 3000 	ldr.w	r3, [r8]
 8007dc4:	6023      	str	r3, [r4, #0]
 8007dc6:	f8b8 3004 	ldrh.w	r3, [r8, #4]
 8007dca:	80a3      	strh	r3, [r4, #4]
  ETHADDR16_COPY(&ethhdr->src, src);
 8007dcc:	683b      	ldr	r3, [r7, #0]
 8007dce:	f8c4 3006 	str.w	r3, [r4, #6]
 8007dd2:	88bb      	ldrh	r3, [r7, #4]
 8007dd4:	8163      	strh	r3, [r4, #10]
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 8007dd6:	69ab      	ldr	r3, [r5, #24]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
  ETHADDR16_COPY(&ethhdr->src, src);
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
 8007dd8:	2000      	movs	r0, #0
 8007dda:	2208      	movs	r2, #8
 8007ddc:	7360      	strb	r0, [r4, #13]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 8007dde:	4631      	mov	r1, r6
 8007de0:	4628      	mov	r0, r5

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
  ETHADDR16_COPY(&ethhdr->src, src);
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
 8007de2:	7322      	strb	r2, [r4, #12]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
}
 8007de4:	b002      	add	sp, #8
 8007de6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  ETHADDR32_COPY(&ethhdr->dest, dst);
  ETHADDR16_COPY(&ethhdr->src, src);
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 8007dea:	4718      	bx	r3
 8007dec:	0801704c 	.word	0x0801704c
 8007df0:	200180c8 	.word	0x200180c8
 8007df4:	08016fe0 	.word	0x08016fe0
 8007df8:	08017008 	.word	0x08017008
 8007dfc:	f3af 8000 	nop.w

08007e00 <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
 8007e00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007e04:	f8df 81e8 	ldr.w	r8, [pc, #488]	; 8007ff0 <etharp_find_entry+0x1f0>
 8007e08:	b085      	sub	sp, #20
 8007e0a:	2300      	movs	r3, #0
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
 8007e0c:	f04f 0e0a 	mov.w	lr, #10
 8007e10:	4642      	mov	r2, r8
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
 8007e12:	469c      	mov	ip, r3
 8007e14:	9303      	str	r3, [sp, #12]
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
 8007e16:	4676      	mov	r6, lr
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 8007e18:	4675      	mov	r5, lr
 8007e1a:	46f3      	mov	fp, lr
 8007e1c:	469a      	mov	sl, r3
 8007e1e:	9102      	str	r1, [sp, #8]
 8007e20:	e004      	b.n	8007e2c <etharp_find_entry+0x2c>
 8007e22:	3301      	adds	r3, #1
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8007e24:	2b0a      	cmp	r3, #10
 8007e26:	f102 0214 	add.w	r2, r2, #20
 8007e2a:	d018      	beq.n	8007e5e <etharp_find_entry+0x5e>
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8007e2c:	2e0a      	cmp	r6, #10
 8007e2e:	b2dc      	uxtb	r4, r3
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 8007e30:	7c97      	ldrb	r7, [r2, #18]
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8007e32:	d038      	beq.n	8007ea6 <etharp_find_entry+0xa6>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 8007e34:	2f00      	cmp	r7, #0
 8007e36:	d0f4      	beq.n	8007e22 <etharp_find_entry+0x22>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 8007e38:	b128      	cbz	r0, 8007e46 <etharp_find_entry+0x46>
 8007e3a:	6801      	ldr	r1, [r0, #0]
 8007e3c:	4689      	mov	r9, r1
 8007e3e:	6851      	ldr	r1, [r2, #4]
 8007e40:	4589      	cmp	r9, r1
 8007e42:	f000 80bc 	beq.w	8007fbe <etharp_find_entry+0x1be>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8007e46:	2f01      	cmp	r7, #1
 8007e48:	d031      	beq.n	8007eae <etharp_find_entry+0xae>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 8007e4a:	7cd7      	ldrb	r7, [r2, #19]
 8007e4c:	3301      	adds	r3, #1
 8007e4e:	4567      	cmp	r7, ip
            old_stable = i;
 8007e50:	bf24      	itt	cs
 8007e52:	4625      	movcs	r5, r4
 8007e54:	46bc      	movcs	ip, r7
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8007e56:	2b0a      	cmp	r3, #10
 8007e58:	f102 0214 	add.w	r2, r2, #20
 8007e5c:	d1e6      	bne.n	8007e2c <etharp_find_entry+0x2c>
 8007e5e:	9902      	ldr	r1, [sp, #8]
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
 8007e60:	078a      	lsls	r2, r1, #30
 8007e62:	f100 80b1 	bmi.w	8007fc8 <etharp_find_entry+0x1c8>
 8007e66:	b274      	sxtb	r4, r6
 8007e68:	2c0a      	cmp	r4, #10
 8007e6a:	4681      	mov	r9, r0
 8007e6c:	d035      	beq.n	8007eda <etharp_find_entry+0xda>
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
 8007e6e:	b2f6      	uxtb	r6, r6
 8007e70:	4627      	mov	r7, r4
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 8007e72:	00bc      	lsls	r4, r7, #2
 8007e74:	19e3      	adds	r3, r4, r7
 8007e76:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 8007e7a:	7c9b      	ldrb	r3, [r3, #18]
 8007e7c:	bb03      	cbnz	r3, 8007ec0 <etharp_find_entry+0xc0>
    arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
 8007e7e:	f1b9 0f00 	cmp.w	r9, #0
 8007e82:	d005      	beq.n	8007e90 <etharp_find_entry+0x90>
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
 8007e84:	19e3      	adds	r3, r4, r7
 8007e86:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 8007e8a:	f8d9 2000 	ldr.w	r2, [r9]
 8007e8e:	605a      	str	r2, [r3, #4]
  }
  arp_table[i].ctime = 0;
 8007e90:	443c      	add	r4, r7
 8007e92:	eb08 0884 	add.w	r8, r8, r4, lsl #2
 8007e96:	2300      	movs	r3, #0
  return (err_t)i;
 8007e98:	b2f6      	uxtb	r6, r6
  /* IP address given? */
  if (ipaddr != NULL) {
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
  }
  arp_table[i].ctime = 0;
 8007e9a:	f888 3013 	strb.w	r3, [r8, #19]
 8007e9e:	b270      	sxtb	r0, r6
  return (err_t)i;
}
 8007ea0:	b005      	add	sp, #20
 8007ea2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8007ea6:	2f00      	cmp	r7, #0
 8007ea8:	d1c6      	bne.n	8007e38 <etharp_find_entry+0x38>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 8007eaa:	4626      	mov	r6, r4
 8007eac:	e7b9      	b.n	8007e22 <etharp_find_entry+0x22>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8007eae:	6817      	ldr	r7, [r2, #0]
 8007eb0:	2f00      	cmp	r7, #0
 8007eb2:	d07c      	beq.n	8007fae <etharp_find_entry+0x1ae>
          if (arp_table[i].ctime >= age_queue) {
 8007eb4:	7cd7      	ldrb	r7, [r2, #19]
 8007eb6:	4557      	cmp	r7, sl
 8007eb8:	d3b3      	bcc.n	8007e22 <etharp_find_entry+0x22>
            old_queue = i;
 8007eba:	46a6      	mov	lr, r4
 8007ebc:	46ba      	mov	sl, r7
 8007ebe:	e7b0      	b.n	8007e22 <etharp_find_entry+0x22>
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 8007ec0:	4b45      	ldr	r3, [pc, #276]	; (8007fd8 <etharp_find_entry+0x1d8>)
 8007ec2:	9300      	str	r3, [sp, #0]
 8007ec4:	4945      	ldr	r1, [pc, #276]	; (8007fdc <etharp_find_entry+0x1dc>)
 8007ec6:	4a46      	ldr	r2, [pc, #280]	; (8007fe0 <etharp_find_entry+0x1e0>)
 8007ec8:	4846      	ldr	r0, [pc, #280]	; (8007fe4 <etharp_find_entry+0x1e4>)
 8007eca:	f240 1389 	movw	r3, #393	; 0x189
 8007ece:	f7ff ff47 	bl	8007d60 <chprintf.constprop.1>
 8007ed2:	4843      	ldr	r0, [pc, #268]	; (8007fe0 <etharp_find_entry+0x1e0>)
 8007ed4:	f7f9 f84c 	bl	8000f70 <chSysHalt>
 8007ed8:	e7d1      	b.n	8007e7e <etharp_find_entry+0x7e>
  /* { we have no match } => try to create a new entry */
   
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
 8007eda:	07cb      	lsls	r3, r1, #31
 8007edc:	d574      	bpl.n	8007fc8 <etharp_find_entry+0x1c8>
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
 8007ede:	b26c      	sxtb	r4, r5
 8007ee0:	2c0a      	cmp	r4, #10
 8007ee2:	d026      	beq.n	8007f32 <etharp_find_entry+0x132>
      /* recycle oldest stable*/
      i = old_stable;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
 8007ee4:	4627      	mov	r7, r4
 8007ee6:	00a4      	lsls	r4, r4, #2
 8007ee8:	19e3      	adds	r3, r4, r7
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
      /* recycle oldest stable*/
      i = old_stable;
 8007eea:	b2ee      	uxtb	r6, r5
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
 8007eec:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
 8007ef0:	2b00      	cmp	r3, #0
 8007ef2:	d056      	beq.n	8007fa2 <etharp_find_entry+0x1a2>
 8007ef4:	4b38      	ldr	r3, [pc, #224]	; (8007fd8 <etharp_find_entry+0x1d8>)
 8007ef6:	9300      	str	r3, [sp, #0]
 8007ef8:	483a      	ldr	r0, [pc, #232]	; (8007fe4 <etharp_find_entry+0x1e4>)
 8007efa:	4938      	ldr	r1, [pc, #224]	; (8007fdc <etharp_find_entry+0x1dc>)
 8007efc:	4a3a      	ldr	r2, [pc, #232]	; (8007fe8 <etharp_find_entry+0x1e8>)
 8007efe:	f240 1371 	movw	r3, #369	; 0x171
 8007f02:	f7ff ff2d 	bl	8007d60 <chprintf.constprop.1>
 8007f06:	4838      	ldr	r0, [pc, #224]	; (8007fe8 <etharp_find_entry+0x1e8>)
 8007f08:	f7f9 f832 	bl	8000f70 <chSysHalt>
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8007f0c:	00bc      	lsls	r4, r7, #2
 8007f0e:	19e5      	adds	r5, r4, r7
 8007f10:	00ad      	lsls	r5, r5, #2
 8007f12:	eb08 0a05 	add.w	sl, r8, r5
 8007f16:	f858 0005 	ldr.w	r0, [r8, r5]
 8007f1a:	f8df b0d4 	ldr.w	fp, [pc, #212]	; 8007ff0 <etharp_find_entry+0x1f0>
 8007f1e:	2800      	cmp	r0, #0
 8007f20:	d03f      	beq.n	8007fa2 <etharp_find_entry+0x1a2>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 8007f22:	f001 fa6d 	bl	8009400 <pbuf_free>
    arp_table[i].q = NULL;
 8007f26:	2300      	movs	r3, #0
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8007f28:	f88a 3012 	strb.w	r3, [sl, #18]
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
 8007f2c:	f84b 3005 	str.w	r3, [fp, r5]
 8007f30:	e7a5      	b.n	8007e7e <etharp_find_entry+0x7e>
      i = old_stable;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
    /* 3) found recyclable pending entry without queued packets? */
    } else if (old_pending < ARP_TABLE_SIZE) {
 8007f32:	f1bb 0f0a 	cmp.w	fp, #10
 8007f36:	d130      	bne.n	8007f9a <etharp_find_entry+0x19a>
      /* recycle oldest pending */
      i = old_pending;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
    /* 4) found recyclable pending entry with queued packets? */
    } else if (old_queue < ARP_TABLE_SIZE) {
 8007f38:	f1be 0f0a 	cmp.w	lr, #10
 8007f3c:	d044      	beq.n	8007fc8 <etharp_find_entry+0x1c8>
      /* recycle oldest pending (queued packets are free in etharp_free_entry) */
      i = old_queue;
 8007f3e:	fa5f f68e 	uxtb.w	r6, lr
 8007f42:	4637      	mov	r7, r6
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
      return (s8_t)ERR_MEM;
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 8007f44:	2e09      	cmp	r6, #9
 8007f46:	d9e1      	bls.n	8007f0c <etharp_find_entry+0x10c>
 8007f48:	4d23      	ldr	r5, [pc, #140]	; (8007fd8 <etharp_find_entry+0x1d8>)
 8007f4a:	4924      	ldr	r1, [pc, #144]	; (8007fdc <etharp_find_entry+0x1dc>)
 8007f4c:	4a27      	ldr	r2, [pc, #156]	; (8007fec <etharp_find_entry+0x1ec>)
 8007f4e:	9500      	str	r5, [sp, #0]
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8007f50:	eb06 0486 	add.w	r4, r6, r6, lsl #2
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
      return (s8_t)ERR_MEM;
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 8007f54:	f240 1383 	movw	r3, #387	; 0x183
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8007f58:	00a4      	lsls	r4, r4, #2
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
      return (s8_t)ERR_MEM;
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 8007f5a:	4822      	ldr	r0, [pc, #136]	; (8007fe4 <etharp_find_entry+0x1e4>)
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8007f5c:	f8df a090 	ldr.w	sl, [pc, #144]	; 8007ff0 <etharp_find_entry+0x1f0>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
      return (s8_t)ERR_MEM;
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 8007f60:	f7ff fefe 	bl	8007d60 <chprintf.constprop.1>
 8007f64:	4821      	ldr	r0, [pc, #132]	; (8007fec <etharp_find_entry+0x1ec>)
 8007f66:	f7f9 f803 	bl	8000f70 <chSysHalt>
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8007f6a:	f858 0004 	ldr.w	r0, [r8, r4]
 8007f6e:	eb08 0b04 	add.w	fp, r8, r4
 8007f72:	b358      	cbz	r0, 8007fcc <etharp_find_entry+0x1cc>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 8007f74:	f001 fa44 	bl	8009400 <pbuf_free>
    arp_table[i].q = NULL;
 8007f78:	2300      	movs	r3, #0
 8007f7a:	f84a 3004 	str.w	r3, [sl, r4]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8007f7e:	f88b 3012 	strb.w	r3, [fp, #18]
    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 8007f82:	9500      	str	r5, [sp, #0]
 8007f84:	4915      	ldr	r1, [pc, #84]	; (8007fdc <etharp_find_entry+0x1dc>)
 8007f86:	4a19      	ldr	r2, [pc, #100]	; (8007fec <etharp_find_entry+0x1ec>)
 8007f88:	4816      	ldr	r0, [pc, #88]	; (8007fe4 <etharp_find_entry+0x1e4>)
 8007f8a:	f240 1387 	movw	r3, #391	; 0x187
 8007f8e:	f7ff fee7 	bl	8007d60 <chprintf.constprop.1>
 8007f92:	4816      	ldr	r0, [pc, #88]	; (8007fec <etharp_find_entry+0x1ec>)
 8007f94:	f7f8 ffec 	bl	8000f70 <chSysHalt>
 8007f98:	e76b      	b.n	8007e72 <etharp_find_entry+0x72>
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
    /* 3) found recyclable pending entry without queued packets? */
    } else if (old_pending < ARP_TABLE_SIZE) {
      /* recycle oldest pending */
      i = old_pending;
 8007f9a:	fa5f f68b 	uxtb.w	r6, fp
 8007f9e:	4637      	mov	r7, r6
 8007fa0:	e7d0      	b.n	8007f44 <etharp_find_entry+0x144>
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8007fa2:	19e3      	adds	r3, r4, r7
 8007fa4:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 8007fa8:	2200      	movs	r2, #0
 8007faa:	749a      	strb	r2, [r3, #18]
 8007fac:	e767      	b.n	8007e7e <etharp_find_entry+0x7e>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8007fae:	7cd7      	ldrb	r7, [r2, #19]
 8007fb0:	9903      	ldr	r1, [sp, #12]
 8007fb2:	428f      	cmp	r7, r1
 8007fb4:	f4ff af35 	bcc.w	8007e22 <etharp_find_entry+0x22>
            old_pending = i;
 8007fb8:	46a3      	mov	fp, r4
 8007fba:	9703      	str	r7, [sp, #12]
 8007fbc:	e731      	b.n	8007e22 <etharp_find_entry+0x22>
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
 8007fbe:	b2e6      	uxtb	r6, r4
 8007fc0:	b270      	sxtb	r0, r6
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
  }
  arp_table[i].ctime = 0;
  return (err_t)i;
}
 8007fc2:	b005      	add	sp, #20
 8007fc4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
 8007fc8:	26ff      	movs	r6, #255	; 0xff
 8007fca:	e768      	b.n	8007e9e <etharp_find_entry+0x9e>
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8007fcc:	2314      	movs	r3, #20
 8007fce:	fb03 aa06 	mla	sl, r3, r6, sl
 8007fd2:	f88a 0012 	strb.w	r0, [sl, #18]
 8007fd6:	e7d4      	b.n	8007f82 <etharp_find_entry+0x182>
 8007fd8:	0801704c 	.word	0x0801704c
 8007fdc:	08016fe0 	.word	0x08016fe0
 8007fe0:	080170a8 	.word	0x080170a8
 8007fe4:	200180c8 	.word	0x200180c8
 8007fe8:	0801707c 	.word	0x0801707c
 8007fec:	08017094 	.word	0x08017094
 8007ff0:	20004714 	.word	0x20004714
 8007ff4:	f3af 8000 	nop.w
 8007ff8:	f3af 8000 	nop.w
 8007ffc:	f3af 8000 	nop.w

08008000 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL milliseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
 8008000:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008004:	4d17      	ldr	r5, [pc, #92]	; (8008064 <etharp_tmr+0x64>)
 8008006:	f1a5 0412 	sub.w	r4, r5, #18
 800800a:	f104 06c8 	add.w	r6, r4, #200	; 0xc8
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 800800e:	f04f 0800 	mov.w	r8, #0
        etharp_free_entry(i);
      }
      else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
        /* Reset state to stable, so that the next transmitted packet will
           re-send an ARP request. */
        arp_table[i].state = ETHARP_STATE_STABLE;
 8008012:	2702      	movs	r7, #2
 8008014:	e009      	b.n	800802a <etharp_tmr+0x2a>
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 8008016:	2a01      	cmp	r2, #1
 8008018:	d020      	beq.n	800805c <etharp_tmr+0x5c>
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
             arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
        /* clean up entries that have just been expired */
        etharp_free_entry(i);
      }
      else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
 800801a:	2a03      	cmp	r2, #3
        /* Reset state to stable, so that the next transmitted packet will
           re-send an ARP request. */
        arp_table[i].state = ETHARP_STATE_STABLE;
 800801c:	bf08      	it	eq
 800801e:	74a7      	strbeq	r7, [r4, #18]
 8008020:	3414      	adds	r4, #20
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8008022:	42b4      	cmp	r4, r6
 8008024:	f105 0514 	add.w	r5, r5, #20
 8008028:	d016      	beq.n	8008058 <etharp_tmr+0x58>
    u8_t state = arp_table[i].state;
 800802a:	7ca2      	ldrb	r2, [r4, #18]
    if (state != ETHARP_STATE_EMPTY
 800802c:	2a00      	cmp	r2, #0
 800802e:	d0f7      	beq.n	8008020 <etharp_tmr+0x20>
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
 8008030:	7ce3      	ldrb	r3, [r4, #19]
 8008032:	3301      	adds	r3, #1
 8008034:	b2db      	uxtb	r3, r3
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 8008036:	2bef      	cmp	r3, #239	; 0xef
    if (state != ETHARP_STATE_EMPTY
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
 8008038:	74e3      	strb	r3, [r4, #19]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 800803a:	d9ec      	bls.n	8008016 <etharp_tmr+0x16>
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 800803c:	f855 0c12 	ldr.w	r0, [r5, #-18]
 8008040:	b118      	cbz	r0, 800804a <etharp_tmr+0x4a>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 8008042:	f001 f9dd 	bl	8009400 <pbuf_free>
    arp_table[i].q = NULL;
 8008046:	f845 8c12 	str.w	r8, [r5, #-18]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 800804a:	f884 8012 	strb.w	r8, [r4, #18]
 800804e:	3414      	adds	r4, #20
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8008050:	42b4      	cmp	r4, r6
 8008052:	f105 0514 	add.w	r5, r5, #20
 8008056:	d1e8      	bne.n	800802a <etharp_tmr+0x2a>
        /* resend an ARP query here? */
      }
#endif /* ARP_QUEUEING */
    }
  }
}
 8008058:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 800805c:	2b01      	cmp	r3, #1
 800805e:	d8ed      	bhi.n	800803c <etharp_tmr+0x3c>
 8008060:	e7de      	b.n	8008020 <etharp_tmr+0x20>
 8008062:	bf00      	nop
 8008064:	20004726 	.word	0x20004726
 8008068:	f3af 8000 	nop.w
 800806c:	f3af 8000 	nop.w

08008070 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
 8008070:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8008074:	4605      	mov	r5, r0
 8008076:	b083      	sub	sp, #12
 8008078:	4688      	mov	r8, r1
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
 800807a:	f100 0723 	add.w	r7, r0, #35	; 0x23
 800807e:	f100 0904 	add.w	r9, r0, #4
  struct etharp_hdr *hdr;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ASSERT("netif != NULL", netif != NULL);
 8008082:	2800      	cmp	r0, #0
 8008084:	d069      	beq.n	800815a <etharp_request+0xea>

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
 8008086:	2003      	movs	r0, #3
 8008088:	212a      	movs	r1, #42	; 0x2a
 800808a:	2200      	movs	r2, #0
 800808c:	f001 fa38 	bl	8009500 <pbuf_alloc>
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
 8008090:	4606      	mov	r6, r0
 8008092:	2800      	cmp	r0, #0
 8008094:	d06e      	beq.n	8008174 <etharp_request+0x104>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
 8008096:	8943      	ldrh	r3, [r0, #10]
 8008098:	2b29      	cmp	r3, #41	; 0x29
 800809a:	d951      	bls.n	8008140 <etharp_request+0xd0>
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = (struct eth_hdr *)p->payload;
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
 800809c:	2001      	movs	r0, #1
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = (struct eth_hdr *)p->payload;
 800809e:	6874      	ldr	r4, [r6, #4]
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
 80080a0:	f006 fe7e 	bl	800eda0 <lwip_htons>
 80080a4:	82a0      	strh	r0, [r4, #20]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
 80080a6:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
 80080aa:	2b06      	cmp	r3, #6
 80080ac:	d00b      	beq.n	80080c6 <etharp_request+0x56>
 80080ae:	4b34      	ldr	r3, [pc, #208]	; (8008180 <etharp_request+0x110>)
 80080b0:	9300      	str	r3, [sp, #0]
 80080b2:	4834      	ldr	r0, [pc, #208]	; (8008184 <etharp_request+0x114>)
 80080b4:	4934      	ldr	r1, [pc, #208]	; (8008188 <etharp_request+0x118>)
 80080b6:	4a35      	ldr	r2, [pc, #212]	; (800818c <etharp_request+0x11c>)
 80080b8:	f240 43b9 	movw	r3, #1209	; 0x4b9
 80080bc:	f7ff fe50 	bl	8007d60 <chprintf.constprop.1>
 80080c0:	4832      	ldr	r0, [pc, #200]	; (800818c <etharp_request+0x11c>)
 80080c2:	f7f8 ff55 	bl	8000f70 <chSysHalt>
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 80080c6:	4a32      	ldr	r2, [pc, #200]	; (8008190 <etharp_request+0x120>)
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 80080c8:	6839      	ldr	r1, [r7, #0]
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
 80080ca:	4b32      	ldr	r3, [pc, #200]	; (8008194 <etharp_request+0x124>)
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 80080cc:	f8c4 1016 	str.w	r1, [r4, #22]
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 80080d0:	6810      	ldr	r0, [r2, #0]
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 80080d2:	f8b7 e004 	ldrh.w	lr, [r7, #4]
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 80080d6:	8891      	ldrh	r1, [r2, #4]
 80080d8:	6220      	str	r0, [r4, #32]
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
 80080da:	889a      	ldrh	r2, [r3, #4]
 80080dc:	6818      	ldr	r0, [r3, #0]
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 80080de:	f8a4 e01a 	strh.w	lr, [r4, #26]
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 80080e2:	84a1      	strh	r1, [r4, #36]	; 0x24
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
 80080e4:	6020      	str	r0, [r4, #0]
 80080e6:	80a2      	strh	r2, [r4, #4]
#endif /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
 80080e8:	683b      	ldr	r3, [r7, #0]
 80080ea:	f8c4 3006 	str.w	r3, [r4, #6]
 80080ee:	88bb      	ldrh	r3, [r7, #4]
 80080f0:	8163      	strh	r3, [r4, #10]
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
 80080f2:	f8d9 3000 	ldr.w	r3, [r9]
 80080f6:	61e3      	str	r3, [r4, #28]
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
 80080f8:	f8d8 3000 	ldr.w	r3, [r8]
 80080fc:	f8c4 3026 	str.w	r3, [r4, #38]	; 0x26

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
  hdr->proto = PP_HTONS(ETHTYPE_IP);
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
 8008100:	2106      	movs	r1, #6
  hdr->protolen = sizeof(ip_addr_t);
 8008102:	2304      	movs	r3, #4
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
  hdr->proto = PP_HTONS(ETHTYPE_IP);
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
 8008104:	74a1      	strb	r1, [r4, #18]
  hdr->protolen = sizeof(ip_addr_t);
 8008106:	74e3      	strb	r3, [r4, #19]
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 8008108:	2200      	movs	r2, #0
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 800810a:	2308      	movs	r3, #8
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 800810c:	f04f 0e01 	mov.w	lr, #1
  hdr->hwlen = ETHARP_HWADDR_LEN;
  hdr->protolen = sizeof(ip_addr_t);

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
  /* send ARP query */
  result = netif->linkoutput(netif, p);
 8008110:	69af      	ldr	r7, [r5, #24]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
  hdr->protolen = sizeof(ip_addr_t);

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
 8008112:	7361      	strb	r1, [r4, #13]
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 8008114:	73a2      	strb	r2, [r4, #14]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 8008116:	7462      	strb	r2, [r4, #17]
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 8008118:	f884 e00f 	strb.w	lr, [r4, #15]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 800811c:	7423      	strb	r3, [r4, #16]
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
  hdr->protolen = sizeof(ip_addr_t);

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
 800811e:	7323      	strb	r3, [r4, #12]
  /* send ARP query */
  result = netif->linkoutput(netif, p);
 8008120:	4631      	mov	r1, r6
 8008122:	4628      	mov	r0, r5
 8008124:	47b8      	blx	r7
  ETHARP_STATS_INC(etharp.xmit);
 8008126:	4a1c      	ldr	r2, [pc, #112]	; (8008198 <etharp_request+0x128>)
 8008128:	8b13      	ldrh	r3, [r2, #24]
  hdr->hwlen = ETHARP_HWADDR_LEN;
  hdr->protolen = sizeof(ip_addr_t);

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
  /* send ARP query */
  result = netif->linkoutput(netif, p);
 800812a:	4604      	mov	r4, r0
  ETHARP_STATS_INC(etharp.xmit);
 800812c:	3301      	adds	r3, #1
  /* free ARP query packet */
  pbuf_free(p);
 800812e:	4630      	mov	r0, r6
  hdr->protolen = sizeof(ip_addr_t);

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  ETHARP_STATS_INC(etharp.xmit);
 8008130:	8313      	strh	r3, [r2, #24]
  /* free ARP query packet */
  pbuf_free(p);
 8008132:	f001 f965 	bl	8009400 <pbuf_free>
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
 8008136:	4620      	mov	r0, r4
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
 8008138:	b240      	sxtb	r0, r0
 800813a:	b003      	add	sp, #12
 800813c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
 8008140:	4b0f      	ldr	r3, [pc, #60]	; (8008180 <etharp_request+0x110>)
 8008142:	9300      	str	r3, [sp, #0]
 8008144:	4910      	ldr	r1, [pc, #64]	; (8008188 <etharp_request+0x118>)
 8008146:	4a15      	ldr	r2, [pc, #84]	; (800819c <etharp_request+0x12c>)
 8008148:	480e      	ldr	r0, [pc, #56]	; (8008184 <etharp_request+0x114>)
 800814a:	f240 43b1 	movw	r3, #1201	; 0x4b1
 800814e:	f7ff fe07 	bl	8007d60 <chprintf.constprop.1>
 8008152:	4812      	ldr	r0, [pc, #72]	; (800819c <etharp_request+0x12c>)
 8008154:	f7f8 ff0c 	bl	8000f70 <chSysHalt>
 8008158:	e7a0      	b.n	800809c <etharp_request+0x2c>
  struct etharp_hdr *hdr;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ASSERT("netif != NULL", netif != NULL);
 800815a:	4b09      	ldr	r3, [pc, #36]	; (8008180 <etharp_request+0x110>)
 800815c:	9300      	str	r3, [sp, #0]
 800815e:	490a      	ldr	r1, [pc, #40]	; (8008188 <etharp_request+0x118>)
 8008160:	4a0f      	ldr	r2, [pc, #60]	; (80081a0 <etharp_request+0x130>)
 8008162:	4808      	ldr	r0, [pc, #32]	; (8008184 <etharp_request+0x114>)
 8008164:	f240 43a5 	movw	r3, #1189	; 0x4a5
 8008168:	f7ff fdfa 	bl	8007d60 <chprintf.constprop.1>
 800816c:	480c      	ldr	r0, [pc, #48]	; (80081a0 <etharp_request+0x130>)
 800816e:	f7f8 feff 	bl	8000f70 <chSysHalt>
 8008172:	e788      	b.n	8008086 <etharp_request+0x16>
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
 8008174:	4a08      	ldr	r2, [pc, #32]	; (8008198 <etharp_request+0x128>)
 8008176:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 8008178:	3301      	adds	r3, #1
 800817a:	8493      	strh	r3, [r2, #36]	; 0x24
    return ERR_MEM;
 800817c:	20ff      	movs	r0, #255	; 0xff
 800817e:	e7db      	b.n	8008138 <etharp_request+0xc8>
 8008180:	0801704c 	.word	0x0801704c
 8008184:	200180c8 	.word	0x200180c8
 8008188:	08016fe0 	.word	0x08016fe0
 800818c:	08017008 	.word	0x08017008
 8008190:	080171f0 	.word	0x080171f0
 8008194:	08016fd0 	.word	0x08016fd0
 8008198:	2000c9fc 	.word	0x2000c9fc
 800819c:	08017108 	.word	0x08017108
 80081a0:	080170f8 	.word	0x080170f8
 80081a4:	f3af 8000 	nop.w
 80081a8:	f3af 8000 	nop.w
 80081ac:	f3af 8000 	nop.w

080081b0 <etharp_output_to_arp_index>:
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
 80081b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 80081b4:	0097      	lsls	r7, r2, #2
 80081b6:	4e1d      	ldr	r6, [pc, #116]	; (800822c <etharp_output_to_arp_index+0x7c>)
 80081b8:	18bd      	adds	r5, r7, r2
 80081ba:	eb06 0585 	add.w	r5, r6, r5, lsl #2
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
 80081be:	b083      	sub	sp, #12
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 80081c0:	7cab      	ldrb	r3, [r5, #18]
 80081c2:	2b01      	cmp	r3, #1
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
 80081c4:	4614      	mov	r4, r2
 80081c6:	4680      	mov	r8, r0
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 80081c8:	f105 0510 	add.w	r5, r5, #16
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
 80081cc:	4689      	mov	r9, r1
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 80081ce:	d91f      	bls.n	8008210 <etharp_output_to_arp_index+0x60>
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 80081d0:	2b02      	cmp	r3, #2
 80081d2:	d00c      	beq.n	80081ee <etharp_output_to_arp_index+0x3e>
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    }
  }
  
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
 80081d4:	443c      	add	r4, r7
 80081d6:	eb06 0384 	add.w	r3, r6, r4, lsl #2
 80081da:	330c      	adds	r3, #12
 80081dc:	4649      	mov	r1, r9
 80081de:	4640      	mov	r0, r8
 80081e0:	f108 0223 	add.w	r2, r8, #35	; 0x23
    &arp_table[arp_idx].ethaddr);
}
 80081e4:	b003      	add	sp, #12
 80081e6:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    }
  }
  
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
 80081ea:	f7ff bdd1 	b.w	8007d90 <etharp_send_ip>
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
 80081ee:	1939      	adds	r1, r7, r4
 80081f0:	eb06 0181 	add.w	r1, r6, r1, lsl #2
 80081f4:	f101 0510 	add.w	r5, r1, #16
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 80081f8:	7ccb      	ldrb	r3, [r1, #19]
 80081fa:	2be3      	cmp	r3, #227	; 0xe3
 80081fc:	d9ea      	bls.n	80081d4 <etharp_output_to_arp_index+0x24>
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 80081fe:	3104      	adds	r1, #4
 8008200:	4640      	mov	r0, r8
 8008202:	f7ff ff35 	bl	8008070 <etharp_request>
 8008206:	2800      	cmp	r0, #0
 8008208:	d1e4      	bne.n	80081d4 <etharp_output_to_arp_index+0x24>
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
 800820a:	2303      	movs	r3, #3
 800820c:	70ab      	strb	r3, [r5, #2]
 800820e:	e7e1      	b.n	80081d4 <etharp_output_to_arp_index+0x24>
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 8008210:	4b07      	ldr	r3, [pc, #28]	; (8008230 <etharp_output_to_arp_index+0x80>)
 8008212:	9300      	str	r3, [sp, #0]
 8008214:	4907      	ldr	r1, [pc, #28]	; (8008234 <etharp_output_to_arp_index+0x84>)
 8008216:	4a08      	ldr	r2, [pc, #32]	; (8008238 <etharp_output_to_arp_index+0x88>)
 8008218:	4808      	ldr	r0, [pc, #32]	; (800823c <etharp_output_to_arp_index+0x8c>)
 800821a:	f240 334d 	movw	r3, #845	; 0x34d
 800821e:	f7ff fd9f 	bl	8007d60 <chprintf.constprop.1>
 8008222:	4805      	ldr	r0, [pc, #20]	; (8008238 <etharp_output_to_arp_index+0x88>)
 8008224:	f7f8 fea4 	bl	8000f70 <chSysHalt>
 8008228:	78ab      	ldrb	r3, [r5, #2]
 800822a:	e7d1      	b.n	80081d0 <etharp_output_to_arp_index+0x20>
 800822c:	20004714 	.word	0x20004714
 8008230:	0801704c 	.word	0x0801704c
 8008234:	08016fe0 	.word	0x08016fe0
 8008238:	0801713c 	.word	0x0801713c
 800823c:	200180c8 	.word	0x200180c8

08008240 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
 8008240:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008244:	460f      	mov	r7, r1
 8008246:	b082      	sub	sp, #8
 8008248:	4604      	mov	r4, r0
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 800824a:	4601      	mov	r1, r0
 800824c:	6838      	ldr	r0, [r7, #0]
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
 800824e:	4690      	mov	r8, r2
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 8008250:	f006 f906 	bl	800e460 <ip4_addr_isbroadcast>
 8008254:	2800      	cmp	r0, #0
 8008256:	d165      	bne.n	8008324 <etharp_query+0xe4>
      ip_addr_ismulticast(ipaddr) ||
 8008258:	683b      	ldr	r3, [r7, #0]
 800825a:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 800825e:	2ae0      	cmp	r2, #224	; 0xe0
 8008260:	d060      	beq.n	8008324 <etharp_query+0xe4>
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
 8008262:	2b00      	cmp	r3, #0
 8008264:	d05e      	beq.n	8008324 <etharp_query+0xe4>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  }

  /* find entry in ARP cache, ask to create entry if queueing packet */
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
 8008266:	4638      	mov	r0, r7
 8008268:	2101      	movs	r1, #1
 800826a:	f7ff fdc9 	bl	8007e00 <etharp_find_entry>

  /* could not find or create entry? */
  if (i < 0) {
 800826e:	1e06      	subs	r6, r0, #0
 8008270:	db31      	blt.n	80082d6 <etharp_query+0x96>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 8008272:	00b5      	lsls	r5, r6, #2
 8008274:	f8df 9128 	ldr.w	r9, [pc, #296]	; 80083a0 <etharp_query+0x160>
 8008278:	19aa      	adds	r2, r5, r6
 800827a:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 800827e:	3210      	adds	r2, #16
 8008280:	7893      	ldrb	r3, [r2, #2]
 8008282:	b19b      	cbz	r3, 80082ac <etharp_query+0x6c>
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
 8008284:	2b01      	cmp	r3, #1
 8008286:	d013      	beq.n	80082b0 <etharp_query+0x70>
 8008288:	f1b8 0f00 	cmp.w	r8, #0
 800828c:	d04f      	beq.n	800832e <etharp_query+0xee>
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
    /* send the packet */
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
 800828e:	19ab      	adds	r3, r5, r6
 8008290:	eb09 0383 	add.w	r3, r9, r3, lsl #2
  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
 8008294:	4d3d      	ldr	r5, [pc, #244]	; (800838c <etharp_query+0x14c>)
    /* send the packet */
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
 8008296:	330c      	adds	r3, #12
 8008298:	4641      	mov	r1, r8
 800829a:	4620      	mov	r0, r4
 800829c:	f104 0223 	add.w	r2, r4, #35	; 0x23
  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
 80082a0:	702e      	strb	r6, [r5, #0]
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
    }
  }
  return result;
}
 80082a2:	b002      	add	sp, #8
 80082a4:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
    /* send the packet */
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
 80082a8:	f7ff bd72 	b.w	8007d90 <etharp_send_ip>
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
    arp_table[i].state = ETHARP_STATE_PENDING;
 80082ac:	2301      	movs	r3, #1
 80082ae:	7093      	strb	r3, [r2, #2]
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
 80082b0:	4639      	mov	r1, r7
 80082b2:	4620      	mov	r0, r4
 80082b4:	f7ff fedc 	bl	8008070 <etharp_request>
      /* ARP request couldn't be sent */
      /* We don't re-send arp request in etharp_tmr, but we still queue packets,
         since this failure could be temporary, and the next packet calling
         etharp_query again could lead to sending the queued packets. */
    }
    if (q == NULL) {
 80082b8:	f1b8 0f00 	cmp.w	r8, #0
 80082bc:	d006      	beq.n	80082cc <etharp_query+0x8c>
  }

  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 80082be:	19ab      	adds	r3, r5, r6
 80082c0:	eb09 0383 	add.w	r3, r9, r3, lsl #2
 80082c4:	7c9b      	ldrb	r3, [r3, #18]
 80082c6:	2b01      	cmp	r3, #1
 80082c8:	d8e1      	bhi.n	800828e <etharp_query+0x4e>
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
    /* send the packet */
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  /* pending entry? (either just created or already pending */
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 80082ca:	d00f      	beq.n	80082ec <etharp_query+0xac>
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
 80082cc:	4606      	mov	r6, r0
 80082ce:	b270      	sxtb	r0, r6
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
    }
  }
  return result;
}
 80082d0:	b002      	add	sp, #8
 80082d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);

  /* could not find or create entry? */
  if (i < 0) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
 80082d6:	f1b8 0f00 	cmp.w	r8, #0
 80082da:	d0f8      	beq.n	80082ce <etharp_query+0x8e>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
 80082dc:	4a2c      	ldr	r2, [pc, #176]	; (8008390 <etharp_query+0x150>)
 80082de:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 80082e0:	b270      	sxtb	r0, r6
 80082e2:	3301      	adds	r3, #1
 80082e4:	8493      	strh	r3, [r2, #36]	; 0x24
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
    }
  }
  return result;
}
 80082e6:	b002      	add	sp, #8
 80082e8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
    while (p) {
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
 80082ec:	f8df a0b4 	ldr.w	sl, [pc, #180]	; 80083a4 <etharp_query+0x164>
 80082f0:	4644      	mov	r4, r8
 80082f2:	e004      	b.n	80082fe <etharp_query+0xbe>
      if(p->type != PBUF_ROM) {
 80082f4:	7b23      	ldrb	r3, [r4, #12]
 80082f6:	2b01      	cmp	r3, #1
 80082f8:	d132      	bne.n	8008360 <etharp_query+0x120>
        copy_needed = 1;
        break;
      }
      p = p->next;
 80082fa:	6824      	ldr	r4, [r4, #0]
    int copy_needed = 0;
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
    while (p) {
 80082fc:	b30c      	cbz	r4, 8008342 <etharp_query+0x102>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
 80082fe:	8962      	ldrh	r2, [r4, #10]
 8008300:	8923      	ldrh	r3, [r4, #8]
 8008302:	429a      	cmp	r2, r3
 8008304:	d1f6      	bne.n	80082f4 <etharp_query+0xb4>
 8008306:	6827      	ldr	r7, [r4, #0]
 8008308:	4822      	ldr	r0, [pc, #136]	; (8008394 <etharp_query+0x154>)
 800830a:	4923      	ldr	r1, [pc, #140]	; (8008398 <etharp_query+0x158>)
 800830c:	4a23      	ldr	r2, [pc, #140]	; (800839c <etharp_query+0x15c>)
 800830e:	f240 433e 	movw	r3, #1086	; 0x43e
 8008312:	b19f      	cbz	r7, 800833c <etharp_query+0xfc>
 8008314:	f8cd a000 	str.w	sl, [sp]
 8008318:	f7ff fd22 	bl	8007d60 <chprintf.constprop.1>
 800831c:	481f      	ldr	r0, [pc, #124]	; (800839c <etharp_query+0x15c>)
 800831e:	f7f8 fe27 	bl	8000f70 <chSysHalt>
 8008322:	e7e7      	b.n	80082f4 <etharp_query+0xb4>
  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
 8008324:	26f2      	movs	r6, #242	; 0xf2
 8008326:	b270      	sxtb	r0, r6
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
    }
  }
  return result;
}
 8008328:	b002      	add	sp, #8
 800832a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
 800832e:	4620      	mov	r0, r4
 8008330:	4639      	mov	r1, r7
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
    }
  }
  return result;
}
 8008332:	b002      	add	sp, #8
 8008334:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
 8008338:	f7ff be9a 	b.w	8008070 <etharp_request>
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
    while (p) {
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
      if(p->type != PBUF_ROM) {
 800833c:	7b23      	ldrb	r3, [r4, #12]
 800833e:	2b01      	cmp	r3, #1
 8008340:	d10e      	bne.n	8008360 <etharp_query+0x120>
        }
      }
    } else {
      /* referencing the old pbuf is enough */
      p = q;
      pbuf_ref(p);
 8008342:	4640      	mov	r0, r8
 8008344:	f001 fa9c 	bl	8009880 <pbuf_ref>
 8008348:	4644      	mov	r4, r8
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
        result = ERR_MEM;
      }
#else /* ARP_QUEUEING */
      /* always queue one packet per ARP request only, freeing a previously queued packet */
      if (arp_table[i].q != NULL) {
 800834a:	19ab      	adds	r3, r5, r6
 800834c:	f859 0023 	ldr.w	r0, [r9, r3, lsl #2]
 8008350:	b108      	cbz	r0, 8008356 <etharp_query+0x116>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet %p for ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
        pbuf_free(arp_table[i].q);
 8008352:	f001 f855 	bl	8009400 <pbuf_free>
      }
      arp_table[i].q = p;
 8008356:	4435      	add	r5, r6
      result = ERR_OK;
 8008358:	2600      	movs	r6, #0
      /* always queue one packet per ARP request only, freeing a previously queued packet */
      if (arp_table[i].q != NULL) {
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet %p for ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
        pbuf_free(arp_table[i].q);
      }
      arp_table[i].q = p;
 800835a:	f849 4025 	str.w	r4, [r9, r5, lsl #2]
 800835e:	e7b6      	b.n	80082ce <etharp_query+0x8e>
      }
      p = p->next;
    }
    if(copy_needed) {
      /* copy the whole packet into new pbufs */
      p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 8008360:	8921      	ldrh	r1, [r4, #8]
 8008362:	2003      	movs	r0, #3
 8008364:	2200      	movs	r2, #0
 8008366:	f001 f8cb 	bl	8009500 <pbuf_alloc>
      if(p != NULL) {
 800836a:	4604      	mov	r4, r0
 800836c:	b138      	cbz	r0, 800837e <etharp_query+0x13e>
        if (pbuf_copy(p, q) != ERR_OK) {
 800836e:	4641      	mov	r1, r8
 8008370:	f001 fae6 	bl	8009940 <pbuf_copy>
 8008374:	2800      	cmp	r0, #0
 8008376:	d0e8      	beq.n	800834a <etharp_query+0x10a>
          pbuf_free(p);
 8008378:	4620      	mov	r0, r4
 800837a:	f001 f841 	bl	8009400 <pbuf_free>
      arp_table[i].q = p;
      result = ERR_OK;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
#endif /* ARP_QUEUEING */
    } else {
      ETHARP_STATS_INC(etharp.memerr);
 800837e:	4a04      	ldr	r2, [pc, #16]	; (8008390 <etharp_query+0x150>)
 8008380:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 8008382:	3301      	adds	r3, #1
 8008384:	8493      	strh	r3, [r2, #36]	; 0x24
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
 8008386:	26ff      	movs	r6, #255	; 0xff
 8008388:	e7a1      	b.n	80082ce <etharp_query+0x8e>
 800838a:	bf00      	nop
 800838c:	20004710 	.word	0x20004710
 8008390:	2000c9fc 	.word	0x2000c9fc
 8008394:	200180c8 	.word	0x200180c8
 8008398:	08016fe0 	.word	0x08016fe0
 800839c:	0801716c 	.word	0x0801716c
 80083a0:	20004714 	.word	0x20004714
 80083a4:	0801704c 	.word	0x0801704c
 80083a8:	f3af 8000 	nop.w
 80083ac:	f3af 8000 	nop.w

080083b0 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
{
 80083b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80083b2:	460e      	mov	r6, r1
 80083b4:	b085      	sub	sp, #20
 80083b6:	4614      	mov	r4, r2
  struct eth_addr *dest;
  struct eth_addr mcastaddr;
  ip_addr_t *dst_addr = ipaddr;

  LWIP_ASSERT("netif != NULL", netif != NULL);
 80083b8:	4605      	mov	r5, r0
 80083ba:	2800      	cmp	r0, #0
 80083bc:	d06c      	beq.n	8008498 <etharp_output+0xe8>
  LWIP_ASSERT("q != NULL", q != NULL);
 80083be:	2e00      	cmp	r6, #0
 80083c0:	d078      	beq.n	80084b4 <etharp_output+0x104>
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 80083c2:	2c00      	cmp	r4, #0
 80083c4:	f000 8094 	beq.w	80084f0 <etharp_output+0x140>

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
 80083c8:	4630      	mov	r0, r6
 80083ca:	210e      	movs	r1, #14
 80083cc:	f000 ffa8 	bl	8009320 <pbuf_header>
 80083d0:	2800      	cmp	r0, #0
 80083d2:	f040 8087 	bne.w	80084e4 <etharp_output+0x134>

  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
 80083d6:	6820      	ldr	r0, [r4, #0]
 80083d8:	4629      	mov	r1, r5
 80083da:	f006 f841 	bl	800e460 <ip4_addr_isbroadcast>
 80083de:	2800      	cmp	r0, #0
 80083e0:	d13b      	bne.n	800845a <etharp_output+0xaa>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
 80083e2:	6823      	ldr	r3, [r4, #0]
 80083e4:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 80083e8:	2ae0      	cmp	r2, #224	; 0xe0
 80083ea:	d040      	beq.n	800846e <etharp_output+0xbe>
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
 80083ec:	686a      	ldr	r2, [r5, #4]
 80083ee:	68a9      	ldr	r1, [r5, #8]
 80083f0:	405a      	eors	r2, r3
 80083f2:	420a      	tst	r2, r1
 80083f4:	d009      	beq.n	800840a <etharp_output+0x5a>
        !ip_addr_islinklocal(ipaddr)) {
 80083f6:	b29b      	uxth	r3, r3
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
 80083f8:	f64f 62a9 	movw	r2, #65193	; 0xfea9
 80083fc:	4293      	cmp	r3, r2
 80083fe:	d004      	beq.n	800840a <etharp_output+0x5a>
         router for forwarding". */
      if (!ip_addr_islinklocal(&iphdr->src))
#endif /* LWIP_AUTOIP */
      {
        /* interface has default gateway? */
        if (!ip_addr_isany(&netif->gw)) {
 8008400:	68eb      	ldr	r3, [r5, #12]
 8008402:	f105 040c 	add.w	r4, r5, #12
 8008406:	2b00      	cmp	r3, #0
 8008408:	d07f      	beq.n	800850a <etharp_output+0x15a>
    if (netif->addr_hint != NULL) {
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 800840a:	f8df e138 	ldr.w	lr, [pc, #312]	; 8008544 <etharp_output+0x194>
 800840e:	4b44      	ldr	r3, [pc, #272]	; (8008520 <etharp_output+0x170>)
 8008410:	f89e 2000 	ldrb.w	r2, [lr]
 8008414:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 8008418:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 800841c:	7c99      	ldrb	r1, [r3, #18]
 800841e:	2901      	cmp	r1, #1
 8008420:	d903      	bls.n	800842a <etharp_output+0x7a>
 8008422:	685b      	ldr	r3, [r3, #4]
 8008424:	6821      	ldr	r1, [r4, #0]
 8008426:	4299      	cmp	r1, r3
 8008428:	d071      	beq.n	800850e <etharp_output+0x15e>
 800842a:	4a3d      	ldr	r2, [pc, #244]	; (8008520 <etharp_output+0x170>)
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
{
 800842c:	2300      	movs	r3, #0
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 800842e:	7c91      	ldrb	r1, [r2, #18]
 8008430:	2901      	cmp	r1, #1
 8008432:	b2df      	uxtb	r7, r3
 8008434:	f103 0301 	add.w	r3, r3, #1
 8008438:	d903      	bls.n	8008442 <etharp_output+0x92>
 800843a:	6820      	ldr	r0, [r4, #0]
 800843c:	6851      	ldr	r1, [r2, #4]
 800843e:	4288      	cmp	r0, r1
 8008440:	d045      	beq.n	80084ce <etharp_output+0x11e>
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 8008442:	2b0a      	cmp	r3, #10
 8008444:	f102 0214 	add.w	r2, r2, #20
 8008448:	d1f1      	bne.n	800842e <etharp_output+0x7e>
        return etharp_output_to_arp_index(netif, q, i);
      }
    }
    /* no stable entry found, use the (slower) query function:
       queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, dst_addr, q);
 800844a:	4628      	mov	r0, r5
 800844c:	4621      	mov	r1, r4
 800844e:	4632      	mov	r2, r6
 8008450:	f7ff fef6 	bl	8008240 <etharp_query>

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
 8008454:	b240      	sxtb	r0, r0
 8008456:	b005      	add	sp, #20
 8008458:	bdf0      	pop	{r4, r5, r6, r7, pc}
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
 800845a:	4b32      	ldr	r3, [pc, #200]	; (8008524 <etharp_output+0x174>)
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
 800845c:	4631      	mov	r1, r6
 800845e:	4628      	mov	r0, r5
 8008460:	f105 0223 	add.w	r2, r5, #35	; 0x23
 8008464:	f7ff fc94 	bl	8007d90 <etharp_send_ip>
}
 8008468:	b240      	sxtb	r0, r0
 800846a:	b005      	add	sp, #20
 800846c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  } else if (ip_addr_ismulticast(ipaddr)) {
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 800846e:	7863      	ldrb	r3, [r4, #1]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 8008470:	78a1      	ldrb	r1, [r4, #2]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 8008472:	78e2      	ldrb	r2, [r4, #3]
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
 8008474:	f88d 0009 	strb.w	r0, [sp, #9]
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 8008478:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
 800847c:	2401      	movs	r4, #1
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
 800847e:	205e      	movs	r0, #94	; 0x5e
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 8008480:	f88d 300b 	strb.w	r3, [sp, #11]
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
 8008484:	f88d 4008 	strb.w	r4, [sp, #8]
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
 8008488:	f88d 000a 	strb.w	r0, [sp, #10]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 800848c:	f88d 100c 	strb.w	r1, [sp, #12]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 8008490:	f88d 200d 	strb.w	r2, [sp, #13]
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
 8008494:	ab02      	add	r3, sp, #8
 8008496:	e7e1      	b.n	800845c <etharp_output+0xac>
{
  struct eth_addr *dest;
  struct eth_addr mcastaddr;
  ip_addr_t *dst_addr = ipaddr;

  LWIP_ASSERT("netif != NULL", netif != NULL);
 8008498:	4b23      	ldr	r3, [pc, #140]	; (8008528 <etharp_output+0x178>)
 800849a:	9300      	str	r3, [sp, #0]
 800849c:	4823      	ldr	r0, [pc, #140]	; (800852c <etharp_output+0x17c>)
 800849e:	4924      	ldr	r1, [pc, #144]	; (8008530 <etharp_output+0x180>)
 80084a0:	4a24      	ldr	r2, [pc, #144]	; (8008534 <etharp_output+0x184>)
 80084a2:	f240 3375 	movw	r3, #885	; 0x375
 80084a6:	f7ff fc5b 	bl	8007d60 <chprintf.constprop.1>
 80084aa:	4822      	ldr	r0, [pc, #136]	; (8008534 <etharp_output+0x184>)
 80084ac:	f7f8 fd60 	bl	8000f70 <chSysHalt>
  LWIP_ASSERT("q != NULL", q != NULL);
 80084b0:	2e00      	cmp	r6, #0
 80084b2:	d186      	bne.n	80083c2 <etharp_output+0x12>
 80084b4:	4b1c      	ldr	r3, [pc, #112]	; (8008528 <etharp_output+0x178>)
 80084b6:	9300      	str	r3, [sp, #0]
 80084b8:	491d      	ldr	r1, [pc, #116]	; (8008530 <etharp_output+0x180>)
 80084ba:	4a1f      	ldr	r2, [pc, #124]	; (8008538 <etharp_output+0x188>)
 80084bc:	481b      	ldr	r0, [pc, #108]	; (800852c <etharp_output+0x17c>)
 80084be:	f240 3376 	movw	r3, #886	; 0x376
 80084c2:	f7ff fc4d 	bl	8007d60 <chprintf.constprop.1>
 80084c6:	481c      	ldr	r0, [pc, #112]	; (8008538 <etharp_output+0x188>)
 80084c8:	f7f8 fd52 	bl	8000f70 <chSysHalt>
 80084cc:	e779      	b.n	80083c2 <etharp_output+0x12>
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
          (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
        /* found an existing, stable entry */
        ETHARP_SET_HINT(netif, i);
 80084ce:	b2ff      	uxtb	r7, r7
        return etharp_output_to_arp_index(netif, q, i);
 80084d0:	463a      	mov	r2, r7
 80084d2:	4628      	mov	r0, r5
 80084d4:	4631      	mov	r1, r6
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
          (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
        /* found an existing, stable entry */
        ETHARP_SET_HINT(netif, i);
 80084d6:	f88e 7000 	strb.w	r7, [lr]
        return etharp_output_to_arp_index(netif, q, i);
 80084da:	f7ff fe69 	bl	80081b0 <etharp_output_to_arp_index>

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
 80084de:	b240      	sxtb	r0, r0
 80084e0:	b005      	add	sp, #20
 80084e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
 80084e4:	4a15      	ldr	r2, [pc, #84]	; (800853c <etharp_output+0x18c>)
 80084e6:	8953      	ldrh	r3, [r2, #10]
 80084e8:	3301      	adds	r3, #1
 80084ea:	8153      	strh	r3, [r2, #10]
    return ERR_BUF;
 80084ec:	20fe      	movs	r0, #254	; 0xfe
 80084ee:	e7b1      	b.n	8008454 <etharp_output+0xa4>
  struct eth_addr mcastaddr;
  ip_addr_t *dst_addr = ipaddr;

  LWIP_ASSERT("netif != NULL", netif != NULL);
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 80084f0:	4b0d      	ldr	r3, [pc, #52]	; (8008528 <etharp_output+0x178>)
 80084f2:	9300      	str	r3, [sp, #0]
 80084f4:	490e      	ldr	r1, [pc, #56]	; (8008530 <etharp_output+0x180>)
 80084f6:	4a12      	ldr	r2, [pc, #72]	; (8008540 <etharp_output+0x190>)
 80084f8:	480c      	ldr	r0, [pc, #48]	; (800852c <etharp_output+0x17c>)
 80084fa:	f240 3377 	movw	r3, #887	; 0x377
 80084fe:	f7ff fc2f 	bl	8007d60 <chprintf.constprop.1>
 8008502:	480f      	ldr	r0, [pc, #60]	; (8008540 <etharp_output+0x190>)
 8008504:	f7f8 fd34 	bl	8000f70 <chSysHalt>
 8008508:	e75e      	b.n	80083c8 <etharp_output+0x18>
          /* send to hardware address of default gateway IP address */
          dst_addr = &(netif->gw);
        /* no default gateway available */
        } else {
          /* no route to destination error (default gateway missing) */
          return ERR_RTE;
 800850a:	20fc      	movs	r0, #252	; 0xfc
 800850c:	e7a2      	b.n	8008454 <etharp_output+0xa4>
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
          /* the per-pcb-cached entry is stable and the right one! */
          ETHARP_STATS_INC(etharp.cachehit);
 800850e:	4c0b      	ldr	r4, [pc, #44]	; (800853c <etharp_output+0x18c>)
 8008510:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
 8008512:	4628      	mov	r0, r5
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
          /* the per-pcb-cached entry is stable and the right one! */
          ETHARP_STATS_INC(etharp.cachehit);
 8008514:	3301      	adds	r3, #1
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
 8008516:	4631      	mov	r1, r6
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
          /* the per-pcb-cached entry is stable and the right one! */
          ETHARP_STATS_INC(etharp.cachehit);
 8008518:	85e3      	strh	r3, [r4, #46]	; 0x2e
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
 800851a:	f7ff fe49 	bl	80081b0 <etharp_output_to_arp_index>
 800851e:	e799      	b.n	8008454 <etharp_output+0xa4>
 8008520:	20004714 	.word	0x20004714
 8008524:	08016fd0 	.word	0x08016fd0
 8008528:	0801704c 	.word	0x0801704c
 800852c:	200180c8 	.word	0x200180c8
 8008530:	08016fe0 	.word	0x08016fe0
 8008534:	080170f8 	.word	0x080170f8
 8008538:	08017188 	.word	0x08017188
 800853c:	2000c9fc 	.word	0x2000c9fc
 8008540:	08017194 	.word	0x08017194
 8008544:	20004710 	.word	0x20004710
 8008548:	f3af 8000 	nop.w
 800854c:	f3af 8000 	nop.w

08008550 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 8008550:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
 8008554:	8947      	ldrh	r7, [r0, #10]
 8008556:	2f0e      	cmp	r7, #14
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 8008558:	b087      	sub	sp, #28
 800855a:	4604      	mov	r4, r0
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
 800855c:	d918      	bls.n	8008590 <ethernet_input+0x40>
    ETHARP_STATS_INC(etharp.drop);
    goto free_and_return;
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
 800855e:	6845      	ldr	r5, [r0, #4]

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
 8008560:	782b      	ldrb	r3, [r5, #0]
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  type = ethhdr->type;
 8008562:	f8b5 800c 	ldrh.w	r8, [r5, #12]
 8008566:	460e      	mov	r6, r1

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
 8008568:	07d9      	lsls	r1, r3, #31
 800856a:	d50b      	bpl.n	8008584 <ethernet_input+0x34>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
 800856c:	2b01      	cmp	r3, #1
 800856e:	d04c      	beq.n	800860a <ethernet_input+0xba>
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
      }
    } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
 8008570:	4628      	mov	r0, r5
 8008572:	4991      	ldr	r1, [pc, #580]	; (80087b8 <ethernet_input+0x268>)
 8008574:	2206      	movs	r2, #6
 8008576:	f00b fbf3 	bl	8013d60 <memcmp>
 800857a:	b918      	cbnz	r0, 8008584 <ethernet_input+0x34>
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
 800857c:	7b63      	ldrb	r3, [r4, #13]
 800857e:	f043 0308 	orr.w	r3, r3, #8
 8008582:	7363      	strb	r3, [r4, #13]
    }
  }

  switch (type) {
 8008584:	f1b8 0f08 	cmp.w	r8, #8
 8008588:	d028      	beq.n	80085dc <ethernet_input+0x8c>
 800858a:	f5b8 6fc1 	cmp.w	r8, #1544	; 0x608
 800858e:	d00d      	beq.n	80085ac <ethernet_input+0x5c>
      pppoe_data_input(netif, p);
      break;
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
 8008590:	4b8a      	ldr	r3, [pc, #552]	; (80087bc <ethernet_input+0x26c>)
 8008592:	8d19      	ldrh	r1, [r3, #40]	; 0x28
      ETHARP_STATS_INC(etharp.drop);
 8008594:	8bda      	ldrh	r2, [r3, #30]
      pppoe_data_input(netif, p);
      break;
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
 8008596:	3101      	adds	r1, #1
      ETHARP_STATS_INC(etharp.drop);
 8008598:	3201      	adds	r2, #1
      pppoe_data_input(netif, p);
      break;
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
 800859a:	8519      	strh	r1, [r3, #40]	; 0x28
      ETHARP_STATS_INC(etharp.drop);
 800859c:	83da      	strh	r2, [r3, #30]
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
 800859e:	4620      	mov	r0, r4
 80085a0:	f000 ff2e 	bl	8009400 <pbuf_free>
  return ERR_OK;
}
 80085a4:	2000      	movs	r0, #0
 80085a6:	b007      	add	sp, #28
 80085a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ip_input(p, netif);
      }
      break;
      
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 80085ac:	f896 3029 	ldrb.w	r3, [r6, #41]	; 0x29
 80085b0:	069b      	lsls	r3, r3, #26
 80085b2:	d5f4      	bpl.n	800859e <ethernet_input+0x4e>

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);

  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
 80085b4:	2f29      	cmp	r7, #41	; 0x29
 80085b6:	d938      	bls.n	800862a <ethernet_input+0xda>
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 80085b8:	89eb      	ldrh	r3, [r5, #14]
 80085ba:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80085be:	d102      	bne.n	80085c6 <ethernet_input+0x76>
 80085c0:	7cab      	ldrb	r3, [r5, #18]
 80085c2:	2b06      	cmp	r3, #6
 80085c4:	d03c      	beq.n	8008640 <ethernet_input+0xf0>
      (hdr->protolen != sizeof(ip_addr_t)) ||
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
    ETHARP_STATS_INC(etharp.proterr);
 80085c6:	4b7d      	ldr	r3, [pc, #500]	; (80087bc <ethernet_input+0x26c>)
 80085c8:	8d19      	ldrh	r1, [r3, #40]	; 0x28
    ETHARP_STATS_INC(etharp.drop);
 80085ca:	8bda      	ldrh	r2, [r3, #30]
      (hdr->protolen != sizeof(ip_addr_t)) ||
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
    ETHARP_STATS_INC(etharp.proterr);
 80085cc:	3101      	adds	r1, #1
    ETHARP_STATS_INC(etharp.drop);
 80085ce:	3201      	adds	r2, #1
    pbuf_free(p);
 80085d0:	4620      	mov	r0, r4
      (hdr->protolen != sizeof(ip_addr_t)) ||
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
    ETHARP_STATS_INC(etharp.proterr);
 80085d2:	8519      	strh	r1, [r3, #40]	; 0x28
    ETHARP_STATS_INC(etharp.drop);
 80085d4:	83da      	strh	r2, [r3, #30]
    pbuf_free(p);
 80085d6:	f000 ff13 	bl	8009400 <pbuf_free>
 80085da:	e7e3      	b.n	80085a4 <ethernet_input+0x54>

  switch (type) {
#if LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 80085dc:	f896 3029 	ldrb.w	r3, [r6, #41]	; 0x29
 80085e0:	069a      	lsls	r2, r3, #26
 80085e2:	d5dc      	bpl.n	800859e <ethernet_input+0x4e>
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -ip_hdr_offset)) {
 80085e4:	4620      	mov	r0, r4
 80085e6:	f06f 010d 	mvn.w	r1, #13
 80085ea:	f000 fe99 	bl	8009320 <pbuf_header>
 80085ee:	b1b8      	cbz	r0, 8008620 <ethernet_input+0xd0>
        LWIP_ASSERT("Can't move over header in packet", 0);
 80085f0:	4b73      	ldr	r3, [pc, #460]	; (80087c0 <ethernet_input+0x270>)
 80085f2:	9300      	str	r3, [sp, #0]
 80085f4:	4973      	ldr	r1, [pc, #460]	; (80087c4 <ethernet_input+0x274>)
 80085f6:	4a74      	ldr	r2, [pc, #464]	; (80087c8 <ethernet_input+0x278>)
 80085f8:	4874      	ldr	r0, [pc, #464]	; (80087cc <ethernet_input+0x27c>)
 80085fa:	f240 534f 	movw	r3, #1359	; 0x54f
 80085fe:	f7ff fbaf 	bl	8007d60 <chprintf.constprop.1>
 8008602:	4871      	ldr	r0, [pc, #452]	; (80087c8 <ethernet_input+0x278>)
 8008604:	f7f8 fcb4 	bl	8000f70 <chSysHalt>
 8008608:	e7c9      	b.n	800859e <ethernet_input+0x4e>
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
 800860a:	786b      	ldrb	r3, [r5, #1]
 800860c:	2b00      	cmp	r3, #0
 800860e:	d1b9      	bne.n	8008584 <ethernet_input+0x34>
 8008610:	78ab      	ldrb	r3, [r5, #2]
 8008612:	2b5e      	cmp	r3, #94	; 0x5e
 8008614:	d1b6      	bne.n	8008584 <ethernet_input+0x34>
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
 8008616:	7b43      	ldrb	r3, [r0, #13]
 8008618:	f043 0310 	orr.w	r3, r3, #16
 800861c:	7343      	strb	r3, [r0, #13]
 800861e:	e7b1      	b.n	8008584 <ethernet_input+0x34>
      if(pbuf_header(p, -ip_hdr_offset)) {
        LWIP_ASSERT("Can't move over header in packet", 0);
        goto free_and_return;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
 8008620:	4620      	mov	r0, r4
 8008622:	4631      	mov	r1, r6
 8008624:	f005 fd1c 	bl	800e060 <ip_input>
      }
      break;
 8008628:	e7bc      	b.n	80085a4 <ethernet_input+0x54>
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
      (s16_t)SIZEOF_ETHARP_PACKET));
    ETHARP_STATS_INC(etharp.lenerr);
 800862a:	4b64      	ldr	r3, [pc, #400]	; (80087bc <ethernet_input+0x26c>)
 800862c:	8c59      	ldrh	r1, [r3, #34]	; 0x22
    ETHARP_STATS_INC(etharp.drop);
 800862e:	8bda      	ldrh	r2, [r3, #30]
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
      (s16_t)SIZEOF_ETHARP_PACKET));
    ETHARP_STATS_INC(etharp.lenerr);
 8008630:	3101      	adds	r1, #1
    ETHARP_STATS_INC(etharp.drop);
 8008632:	3201      	adds	r2, #1
    pbuf_free(p);
 8008634:	4620      	mov	r0, r4
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
      (s16_t)SIZEOF_ETHARP_PACKET));
    ETHARP_STATS_INC(etharp.lenerr);
 8008636:	8459      	strh	r1, [r3, #34]	; 0x22
    ETHARP_STATS_INC(etharp.drop);
 8008638:	83da      	strh	r2, [r3, #30]
    pbuf_free(p);
 800863a:	f000 fee1 	bl	8009400 <pbuf_free>
 800863e:	e7b1      	b.n	80085a4 <ethernet_input+0x54>
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
 8008640:	7ceb      	ldrb	r3, [r5, #19]
 8008642:	2b04      	cmp	r3, #4
 8008644:	d1bf      	bne.n	80085c6 <ethernet_input+0x76>
      (hdr->protolen != sizeof(ip_addr_t)) ||
 8008646:	8a2b      	ldrh	r3, [r5, #16]
 8008648:	2b08      	cmp	r3, #8
 800864a:	d1bc      	bne.n	80085c6 <ethernet_input+0x76>
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
    return;
  }
  ETHARP_STATS_INC(etharp.recv);
 800864c:	f8df a16c 	ldr.w	sl, [pc, #364]	; 80087bc <ethernet_input+0x26c>
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);

  /* this interface is not configured? */
  if (ip_addr_isany(&netif->ip_addr)) {
 8008650:	6873      	ldr	r3, [r6, #4]
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
    return;
  }
  ETHARP_STATS_INC(etharp.recv);
 8008652:	f8ba 201a 	ldrh.w	r2, [sl, #26]
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
 8008656:	46ab      	mov	fp, r5
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
    return;
  }
  ETHARP_STATS_INC(etharp.recv);
 8008658:	3201      	adds	r2, #1
 800865a:	f8aa 201a 	strh.w	r2, [sl, #26]
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
 800865e:	f85b 0f1c 	ldr.w	r0, [fp, #28]!
 8008662:	9004      	str	r0, [sp, #16]
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
 8008664:	f8d5 0026 	ldr.w	r0, [r5, #38]	; 0x26
 8008668:	9005      	str	r0, [sp, #20]

  /* this interface is not configured? */
  if (ip_addr_isany(&netif->ip_addr)) {
 800866a:	2b00      	cmp	r3, #0
 800866c:	d065      	beq.n	800873a <ethernet_input+0x1ea>
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 800866e:	9a05      	ldr	r2, [sp, #20]
 8008670:	4293      	cmp	r3, r2
 8008672:	bf08      	it	eq
 8008674:	f04f 0801 	moveq.w	r8, #1
 8008678:	f105 0716 	add.w	r7, r5, #22
  /* this interface is not configured? */
  if (ip_addr_isany(&netif->ip_addr)) {
    for_us = 0;
  } else {
    /* ARP packet directed to us? */
    for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
 800867c:	bf1a      	itte	ne
 800867e:	f04f 0800 	movne.w	r8, #0
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8008682:	f04f 0c02 	movne.w	ip, #2
 8008686:	46c4      	moveq	ip, r8
 */
static err_t
etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  s8_t i;
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
 8008688:	f896 3022 	ldrb.w	r3, [r6, #34]	; 0x22
 800868c:	2b06      	cmp	r3, #6
 800868e:	d00f      	beq.n	80086b0 <ethernet_input+0x160>
 8008690:	4b4b      	ldr	r3, [pc, #300]	; (80087c0 <ethernet_input+0x270>)
 8008692:	9300      	str	r3, [sp, #0]
 8008694:	494b      	ldr	r1, [pc, #300]	; (80087c4 <ethernet_input+0x274>)
 8008696:	4a4e      	ldr	r2, [pc, #312]	; (80087d0 <ethernet_input+0x280>)
 8008698:	484c      	ldr	r0, [pc, #304]	; (80087cc <ethernet_input+0x27c>)
 800869a:	f8cd c008 	str.w	ip, [sp, #8]
 800869e:	f240 13c3 	movw	r3, #451	; 0x1c3
 80086a2:	f7ff fb5d 	bl	8007d60 <chprintf.constprop.1>
 80086a6:	484a      	ldr	r0, [pc, #296]	; (80087d0 <ethernet_input+0x280>)
 80086a8:	f7f8 fc62 	bl	8000f70 <chSysHalt>
 80086ac:	f8dd c008 	ldr.w	ip, [sp, #8]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
 80086b0:	9804      	ldr	r0, [sp, #16]
 80086b2:	f8cd c008 	str.w	ip, [sp, #8]
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
      }
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
 80086b6:	f106 0923 	add.w	r9, r6, #35	; 0x23
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
 80086ba:	b380      	cbz	r0, 800871e <ethernet_input+0x1ce>
      ip_addr_isbroadcast(ipaddr, netif) ||
 80086bc:	4631      	mov	r1, r6
 80086be:	f005 fecf 	bl	800e460 <ip4_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
 80086c2:	9003      	str	r0, [sp, #12]
 80086c4:	bb58      	cbnz	r0, 800871e <ethernet_input+0x1ce>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
 80086c6:	9b04      	ldr	r3, [sp, #16]
 80086c8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
 80086cc:	2be0      	cmp	r3, #224	; 0xe0
 80086ce:	d026      	beq.n	800871e <ethernet_input+0x1ce>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags);
 80086d0:	f8dd c008 	ldr.w	ip, [sp, #8]
 80086d4:	a804      	add	r0, sp, #16
 80086d6:	4661      	mov	r1, ip
 80086d8:	f7ff fb92 	bl	8007e00 <etharp_find_entry>
  /* bail out if no entry could be found */
  if (i < 0) {
 80086dc:	2800      	cmp	r0, #0
 80086de:	db1e      	blt.n	800871e <ethernet_input+0x1ce>
    arp_table[i].state = ETHARP_STATE_STATIC;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
 80086e0:	f8df e0f4 	ldr.w	lr, [pc, #244]	; 80087d8 <ethernet_input+0x288>
 80086e4:	2314      	movs	r3, #20
 80086e6:	fb03 f300 	mul.w	r3, r3, r0
 80086ea:	eb0e 0103 	add.w	r1, lr, r3
 80086ee:	2002      	movs	r0, #2
  }

  /* record network interface */
  arp_table[i].netif = netif;
 80086f0:	608e      	str	r6, [r1, #8]
    arp_table[i].state = ETHARP_STATE_STATIC;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
 80086f2:	7488      	strb	r0, [r1, #18]
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 80086f4:	6838      	ldr	r0, [r7, #0]
 80086f6:	60c8      	str	r0, [r1, #12]
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
#else /* ARP_QUEUEING */
  if (arp_table[i].q != NULL) {
 80086f8:	f85e 2003 	ldr.w	r2, [lr, r3]
 80086fc:	9202      	str	r2, [sp, #8]
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 80086fe:	88b8      	ldrh	r0, [r7, #4]
  /* reset time stamp */
  arp_table[i].ctime = 0;
 8008700:	9a03      	ldr	r2, [sp, #12]
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 8008702:	8208      	strh	r0, [r1, #16]
  /* reset time stamp */
  arp_table[i].ctime = 0;
 8008704:	74ca      	strb	r2, [r1, #19]
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
#else /* ARP_QUEUEING */
  if (arp_table[i].q != NULL) {
 8008706:	9902      	ldr	r1, [sp, #8]
 8008708:	b149      	cbz	r1, 800871e <ethernet_input+0x1ce>
    struct pbuf *p = arp_table[i].q;
    arp_table[i].q = NULL;
 800870a:	f84e 2003 	str.w	r2, [lr, r3]
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
 800870e:	4630      	mov	r0, r6
 8008710:	464a      	mov	r2, r9
 8008712:	463b      	mov	r3, r7
 8008714:	f7ff fb3c 	bl	8007d90 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
 8008718:	9802      	ldr	r0, [sp, #8]
 800871a:	f000 fe71 	bl	8009400 <pbuf_free>
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
                   for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);

  /* now act on the message itself */
  switch (hdr->opcode) {
 800871e:	8aab      	ldrh	r3, [r5, #20]
 8008720:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008724:	d00f      	beq.n	8008746 <ethernet_input+0x1f6>
 8008726:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800872a:	f43f af38 	beq.w	800859e <ethernet_input+0x4e>
    dhcp_arp_reply(netif, &sipaddr);
#endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
    break;
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
 800872e:	f8ba 302c 	ldrh.w	r3, [sl, #44]	; 0x2c
 8008732:	3301      	adds	r3, #1
 8008734:	f8aa 302c 	strh.w	r3, [sl, #44]	; 0x2c
 8008738:	e731      	b.n	800859e <ethernet_input+0x4e>
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);

  /* this interface is not configured? */
  if (ip_addr_isany(&netif->ip_addr)) {
    for_us = 0;
 800873a:	4698      	mov	r8, r3
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 800873c:	f105 0716 	add.w	r7, r5, #22
 8008740:	f04f 0c02 	mov.w	ip, #2
 8008744:	e7a0      	b.n	8008688 <ethernet_input+0x138>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
 8008746:	f1b8 0f00 	cmp.w	r8, #0
 800874a:	f43f af28 	beq.w	800859e <ethernet_input+0x4e>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
 800874e:	2002      	movs	r0, #2
 8008750:	f006 fb26 	bl	800eda0 <lwip_htons>
 8008754:	82a8      	strh	r0, [r5, #20]

      IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
 8008756:	f8db 3000 	ldr.w	r3, [fp]
 800875a:	f8c5 3026 	str.w	r3, [r5, #38]	; 0x26
      IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
 800875e:	6873      	ldr	r3, [r6, #4]
 8008760:	61eb      	str	r3, [r5, #28]

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
 8008762:	f896 3022 	ldrb.w	r3, [r6, #34]	; 0x22
 8008766:	2b06      	cmp	r3, #6
 8008768:	d00b      	beq.n	8008782 <ethernet_input+0x232>
 800876a:	4b15      	ldr	r3, [pc, #84]	; (80087c0 <ethernet_input+0x270>)
 800876c:	9300      	str	r3, [sp, #0]
 800876e:	4817      	ldr	r0, [pc, #92]	; (80087cc <ethernet_input+0x27c>)
 8008770:	4914      	ldr	r1, [pc, #80]	; (80087c4 <ethernet_input+0x274>)
 8008772:	4a18      	ldr	r2, [pc, #96]	; (80087d4 <ethernet_input+0x284>)
 8008774:	f240 3312 	movw	r3, #786	; 0x312
 8008778:	f7ff faf2 	bl	8007d60 <chprintf.constprop.1>
 800877c:	4815      	ldr	r0, [pc, #84]	; (80087d4 <ethernet_input+0x284>)
 800877e:	f7f8 fbf7 	bl	8000f70 <chSysHalt>
       * 'sender IP address' MUST be sent using link-layer broadcast instead of
       * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
      ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
 8008782:	683b      	ldr	r3, [r7, #0]
 8008784:	622b      	str	r3, [r5, #32]
 8008786:	88bb      	ldrh	r3, [r7, #4]
 8008788:	84ab      	strh	r3, [r5, #36]	; 0x24
#if LWIP_AUTOIP
      ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
      ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
 800878a:	683b      	ldr	r3, [r7, #0]
 800878c:	602b      	str	r3, [r5, #0]
 800878e:	88bb      	ldrh	r3, [r7, #4]
 8008790:	80ab      	strh	r3, [r5, #4]
#endif /* LWIP_AUTOIP */
      ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
 8008792:	f8d9 3000 	ldr.w	r3, [r9]
 8008796:	603b      	str	r3, [r7, #0]
 8008798:	f8b9 3004 	ldrh.w	r3, [r9, #4]
 800879c:	80bb      	strh	r3, [r7, #4]
      ETHADDR16_COPY(&ethhdr->src, ethaddr);
 800879e:	f8d9 3000 	ldr.w	r3, [r9]
 80087a2:	f8c5 3006 	str.w	r3, [r5, #6]
 80087a6:	f8b9 3004 	ldrh.w	r3, [r9, #4]
 80087aa:	816b      	strh	r3, [r5, #10]

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
 80087ac:	69b3      	ldr	r3, [r6, #24]
 80087ae:	4630      	mov	r0, r6
 80087b0:	4621      	mov	r1, r4
 80087b2:	4798      	blx	r3
 80087b4:	e6f3      	b.n	800859e <ethernet_input+0x4e>
 80087b6:	bf00      	nop
 80087b8:	08016fd0 	.word	0x08016fd0
 80087bc:	2000c9fc 	.word	0x2000c9fc
 80087c0:	0801704c 	.word	0x0801704c
 80087c4:	08016fe0 	.word	0x08016fe0
 80087c8:	080171a4 	.word	0x080171a4
 80087cc:	200180c8 	.word	0x200180c8
 80087d0:	080171c8 	.word	0x080171c8
 80087d4:	08017008 	.word	0x08017008
 80087d8:	20004714 	.word	0x20004714
 80087dc:	f3af 8000 	nop.w

080087e0 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
 80087e0:	b508      	push	{r3, lr}
  /* Modules initialization */
  stats_init();
 80087e2:	f001 fa65 	bl	8009cb0 <stats_init>
#if !NO_SYS
  sys_init();
 80087e6:	f7ff f97b 	bl	8007ae0 <sys_init>
#endif /* !NO_SYS */
  mem_init();
 80087ea:	f000 f829 	bl	8008840 <mem_init>
  memp_init();
 80087ee:	f000 fb3f 	bl	8008e70 <memp_init>
  pbuf_init();
  netif_init();
 80087f2:	f000 fc35 	bl	8009060 <netif_init>
#if LWIP_SOCKET
  lwip_socket_init();
 80087f6:	f008 f853 	bl	80108a0 <lwip_socket_init>
#endif /* LWIP_ARP */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
 80087fa:	f004 ff89 	bl	800d710 <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
 80087fe:	f001 faaf 	bl	8009d60 <tcp_init>
#endif /* LWIP_DNS */

#if LWIP_TIMERS
  sys_timeouts_init();
#endif /* LWIP_TIMERS */
}
 8008802:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */

#if LWIP_TIMERS
  sys_timeouts_init();
 8008806:	f006 bb93 	b.w	800ef30 <sys_timeouts_init>
 800880a:	bf00      	nop
 800880c:	f3af 8000 	nop.w

08008810 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8008810:	b40e      	push	{r1, r2, r3}
 8008812:	b500      	push	{lr}
 8008814:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8008816:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 8008818:	461a      	mov	r2, r3
 800881a:	4905      	ldr	r1, [pc, #20]	; (8008830 <chprintf.constprop.0+0x20>)
 800881c:	4805      	ldr	r0, [pc, #20]	; (8008834 <chprintf.constprop.0+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800881e:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8008820:	f008 fa6e 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8008824:	b002      	add	sp, #8
 8008826:	f85d eb04 	ldr.w	lr, [sp], #4
 800882a:	b003      	add	sp, #12
 800882c:	4770      	bx	lr
 800882e:	bf00      	nop
 8008830:	08016fe0 	.word	0x08016fe0
 8008834:	200180c8 	.word	0x200180c8
 8008838:	f3af 8000 	nop.w
 800883c:	f3af 8000 	nop.w

08008840 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
 8008840:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 8008844:	4b1a      	ldr	r3, [pc, #104]	; (80088b0 <mem_init+0x70>)
  ram_end->prev = MEM_SIZE_ALIGNED;

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
 8008846:	4f1b      	ldr	r7, [pc, #108]	; (80088b4 <mem_init+0x74>)

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 8008848:	f8df 8080 	ldr.w	r8, [pc, #128]	; 80088cc <mem_init+0x8c>
  ram_end->used = 1;
  ram_end->next = MEM_SIZE_ALIGNED;
  ram_end->prev = MEM_SIZE_ALIGNED;

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
 800884c:	f8df c080 	ldr.w	ip, [pc, #128]	; 80088d0 <mem_init+0x90>
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 8008850:	f8df e080 	ldr.w	lr, [pc, #128]	; 80088d4 <mem_init+0x94>
  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if(sys_mutex_new(&mem_mutex) != ERR_OK) {
 8008854:	4818      	ldr	r0, [pc, #96]	; (80088b8 <mem_init+0x78>)

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 8008856:	f023 0303 	bic.w	r3, r3, #3
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 800885a:	f503 54af 	add.w	r4, r3, #5600	; 0x15e0

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
 800885e:	f44f 52af 	mov.w	r2, #5600	; 0x15e0
  mem->prev = 0;
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
  ram_end->used = 1;
 8008862:	2601      	movs	r6, #1
  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
 8008864:	2500      	movs	r5, #0
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
  ram_end->used = 1;
 8008866:	7126      	strb	r6, [r4, #4]
  ram_end->next = MEM_SIZE_ALIGNED;
 8008868:	8022      	strh	r2, [r4, #0]
  ram_end->prev = MEM_SIZE_ALIGNED;
 800886a:	8062      	strh	r2, [r4, #2]
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
 800886c:	b082      	sub	sp, #8

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
 800886e:	801a      	strh	r2, [r3, #0]
  mem->prev = 0;
 8008870:	805d      	strh	r5, [r3, #2]
  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if(sys_mutex_new(&mem_mutex) != ERR_OK) {
 8008872:	4631      	mov	r1, r6
  ram_end->prev = MEM_SIZE_ALIGNED;

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
 8008874:	f8a7 20a8 	strh.w	r2, [r7, #168]	; 0xa8
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
  mem->used = 0;
 8008878:	711d      	strb	r5, [r3, #4]

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 800887a:	f8c8 3000 	str.w	r3, [r8]
  ram_end->used = 1;
  ram_end->next = MEM_SIZE_ALIGNED;
  ram_end->prev = MEM_SIZE_ALIGNED;

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
 800887e:	f8cc 3000 	str.w	r3, [ip]
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 8008882:	f8ce 4000 	str.w	r4, [lr]
  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if(sys_mutex_new(&mem_mutex) != ERR_OK) {
 8008886:	f7ff f933 	bl	8007af0 <sys_sem_new>
 800888a:	b910      	cbnz	r0, 8008892 <mem_init+0x52>
    LWIP_ASSERT("failed to create mem_mutex", 0);
  }
}
 800888c:	b002      	add	sp, #8
 800888e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  lfree = (struct mem *)(void *)ram;

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if(sys_mutex_new(&mem_mutex) != ERR_OK) {
    LWIP_ASSERT("failed to create mem_mutex", 0);
 8008892:	4b0a      	ldr	r3, [pc, #40]	; (80088bc <mem_init+0x7c>)
 8008894:	9300      	str	r3, [sp, #0]
 8008896:	490a      	ldr	r1, [pc, #40]	; (80088c0 <mem_init+0x80>)
 8008898:	4a0a      	ldr	r2, [pc, #40]	; (80088c4 <mem_init+0x84>)
 800889a:	480b      	ldr	r0, [pc, #44]	; (80088c8 <mem_init+0x88>)
 800889c:	f44f 7396 	mov.w	r3, #300	; 0x12c
 80088a0:	f7ff ffb6 	bl	8008810 <chprintf.constprop.0>
 80088a4:	4807      	ldr	r0, [pc, #28]	; (80088c4 <mem_init+0x84>)
  }
}
 80088a6:	b002      	add	sp, #8
 80088a8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80088ac:	f7f8 bb60 	b.w	8000f70 <chSysHalt>
 80088b0:	200047df 	.word	0x200047df
 80088b4:	2000c9fc 	.word	0x2000c9fc
 80088b8:	20005dd8 	.word	0x20005dd8
 80088bc:	0801721c 	.word	0x0801721c
 80088c0:	08016fe0 	.word	0x08016fe0
 80088c4:	08017200 	.word	0x08017200
 80088c8:	200180c8 	.word	0x200180c8
 80088cc:	20005ddc 	.word	0x20005ddc
 80088d0:	20005dd0 	.word	0x20005dd0
 80088d4:	20005dd4 	.word	0x20005dd4
 80088d8:	f3af 8000 	nop.w
 80088dc:	f3af 8000 	nop.w

080088e0 <mem_free>:
mem_free(void *rmem)
{
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 80088e0:	2800      	cmp	r0, #0
 80088e2:	f000 80d6 	beq.w	8008a92 <mem_free+0x1b2>
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
 80088e6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
 80088ea:	0783      	lsls	r3, r0, #30
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
 80088ec:	b082      	sub	sp, #8
 80088ee:	4604      	mov	r4, r0

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
 80088f0:	f040 8083 	bne.w	80089fa <mem_free+0x11a>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 80088f4:	4d67      	ldr	r5, [pc, #412]	; (8008a94 <mem_free+0x1b4>)
 80088f6:	682b      	ldr	r3, [r5, #0]
 80088f8:	429c      	cmp	r4, r3
 80088fa:	d303      	bcc.n	8008904 <mem_free+0x24>
 80088fc:	4e66      	ldr	r6, [pc, #408]	; (8008a98 <mem_free+0x1b8>)
 80088fe:	6833      	ldr	r3, [r6, #0]
 8008900:	429c      	cmp	r4, r3
 8008902:	d31b      	bcc.n	800893c <mem_free+0x5c>
 8008904:	4b65      	ldr	r3, [pc, #404]	; (8008a9c <mem_free+0x1bc>)
 8008906:	9300      	str	r3, [sp, #0]
 8008908:	4965      	ldr	r1, [pc, #404]	; (8008aa0 <mem_free+0x1c0>)
 800890a:	4a66      	ldr	r2, [pc, #408]	; (8008aa4 <mem_free+0x1c4>)
 800890c:	4866      	ldr	r0, [pc, #408]	; (8008aa8 <mem_free+0x1c8>)
 800890e:	f240 1343 	movw	r3, #323	; 0x143
 8008912:	f7ff ff7d 	bl	8008810 <chprintf.constprop.0>
 8008916:	4863      	ldr	r0, [pc, #396]	; (8008aa4 <mem_free+0x1c4>)
 8008918:	f7f8 fb2a 	bl	8000f70 <chSysHalt>
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 800891c:	682b      	ldr	r3, [r5, #0]
 800891e:	429c      	cmp	r4, r3
 8008920:	d208      	bcs.n	8008934 <mem_free+0x54>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
 8008922:	4a62      	ldr	r2, [pc, #392]	; (8008aac <mem_free+0x1cc>)
 8008924:	f8b2 30b0 	ldrh.w	r3, [r2, #176]	; 0xb0
 8008928:	3301      	adds	r3, #1
 800892a:	f8a2 30b0 	strh.w	r3, [r2, #176]	; 0xb0
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 800892e:	b002      	add	sp, #8
 8008930:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008934:	4e58      	ldr	r6, [pc, #352]	; (8008a98 <mem_free+0x1b8>)
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 8008936:	6833      	ldr	r3, [r6, #0]
 8008938:	429c      	cmp	r4, r3
 800893a:	d2f2      	bcs.n	8008922 <mem_free+0x42>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
 800893c:	485c      	ldr	r0, [pc, #368]	; (8008ab0 <mem_free+0x1d0>)
 800893e:	2100      	movs	r1, #0
 8008940:	f7ff f916 	bl	8007b70 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
 8008944:	f814 3c04 	ldrb.w	r3, [r4, #-4]
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 8008948:	f1a4 0708 	sub.w	r7, r4, #8
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
 800894c:	2b00      	cmp	r3, #0
 800894e:	f000 8093 	beq.w	8008a78 <mem_free+0x198>
  /* ... and is now unused. */
  mem->used = 0;

  if (mem < lfree) {
 8008952:	f8df 8160 	ldr.w	r8, [pc, #352]	; 8008ab4 <mem_free+0x1d4>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
 8008956:	4855      	ldr	r0, [pc, #340]	; (8008aac <mem_free+0x1cc>)
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;

  if (mem < lfree) {
 8008958:	f8d8 3000 	ldr.w	r3, [r8]
    /* the newly freed struct is now the lowest */
    lfree = mem;
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
 800895c:	6829      	ldr	r1, [r5, #0]
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
 800895e:	2200      	movs	r2, #0
 8008960:	f804 2c04 	strb.w	r2, [r4, #-4]

  if (mem < lfree) {
 8008964:	429f      	cmp	r7, r3
 8008966:	f834 2c08 	ldrh.w	r2, [r4, #-8]
 800896a:	f8b0 30aa 	ldrh.w	r3, [r0, #170]	; 0xaa
    /* the newly freed struct is now the lowest */
    lfree = mem;
 800896e:	bf38      	it	cc
 8008970:	f8c8 7000 	strcc.w	r7, [r8]
 8008974:	1a9a      	subs	r2, r3, r2
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
 8008976:	1a7b      	subs	r3, r7, r1
 8008978:	4413      	add	r3, r2
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 800897a:	428f      	cmp	r7, r1
  if (mem < lfree) {
    /* the newly freed struct is now the lowest */
    lfree = mem;
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
 800897c:	f8a0 30aa 	strh.w	r3, [r0, #170]	; 0xaa
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 8008980:	d36e      	bcc.n	8008a60 <mem_free+0x180>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 8008982:	6833      	ldr	r3, [r6, #0]
 8008984:	429f      	cmp	r7, r3
 8008986:	d25f      	bcs.n	8008a48 <mem_free+0x168>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
 8008988:	f814 3c04 	ldrb.w	r3, [r4, #-4]
 800898c:	2b00      	cmp	r3, #0
 800898e:	d14f      	bne.n	8008a30 <mem_free+0x150>

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 8008990:	f834 3c08 	ldrh.w	r3, [r4, #-8]
 8008994:	f5b3 5faf 	cmp.w	r3, #5600	; 0x15e0
 8008998:	d83c      	bhi.n	8008a14 <mem_free+0x134>

  nmem = (struct mem *)(void *)&ram[mem->next];
 800899a:	682a      	ldr	r2, [r5, #0]
 800899c:	4413      	add	r3, r2
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 800899e:	429f      	cmp	r7, r3
 80089a0:	d011      	beq.n	80089c6 <mem_free+0xe6>
 80089a2:	7919      	ldrb	r1, [r3, #4]
 80089a4:	b979      	cbnz	r1, 80089c6 <mem_free+0xe6>
 80089a6:	6831      	ldr	r1, [r6, #0]
 80089a8:	428b      	cmp	r3, r1
 80089aa:	d00c      	beq.n	80089c6 <mem_free+0xe6>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
 80089ac:	f8d8 1000 	ldr.w	r1, [r8]
 80089b0:	4840      	ldr	r0, [pc, #256]	; (8008ab4 <mem_free+0x1d4>)
 80089b2:	428b      	cmp	r3, r1
      lfree = mem;
    }
    mem->next = nmem->next;
 80089b4:	8819      	ldrh	r1, [r3, #0]
 80089b6:	f824 1c08 	strh.w	r1, [r4, #-8]
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
 80089ba:	881b      	ldrh	r3, [r3, #0]

  nmem = (struct mem *)(void *)&ram[mem->next];
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
      lfree = mem;
 80089bc:	bf08      	it	eq
 80089be:	6007      	streq	r7, [r0, #0]
    }
    mem->next = nmem->next;
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
 80089c0:	4413      	add	r3, r2
 80089c2:	1ab9      	subs	r1, r7, r2
 80089c4:	8059      	strh	r1, [r3, #2]
  }

  /* plug hole backward */
  pmem = (struct mem *)(void *)&ram[mem->prev];
 80089c6:	f834 3c06 	ldrh.w	r3, [r4, #-6]
 80089ca:	18d1      	adds	r1, r2, r3
  if (pmem != mem && pmem->used == 0) {
 80089cc:	428f      	cmp	r7, r1
 80089ce:	d00e      	beq.n	80089ee <mem_free+0x10e>
 80089d0:	7908      	ldrb	r0, [r1, #4]
 80089d2:	b960      	cbnz	r0, 80089ee <mem_free+0x10e>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
 80089d4:	f8d8 0000 	ldr.w	r0, [r8]
 80089d8:	4d36      	ldr	r5, [pc, #216]	; (8008ab4 <mem_free+0x1d4>)
 80089da:	4287      	cmp	r7, r0
      lfree = pmem;
 80089dc:	bf08      	it	eq
 80089de:	6029      	streq	r1, [r5, #0]
    }
    pmem->next = mem->next;
 80089e0:	f834 1c08 	ldrh.w	r1, [r4, #-8]
 80089e4:	52d1      	strh	r1, [r2, r3]
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
 80089e6:	f834 1c08 	ldrh.w	r1, [r4, #-8]
 80089ea:	440a      	add	r2, r1
 80089ec:	8053      	strh	r3, [r2, #2]
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
 80089ee:	4830      	ldr	r0, [pc, #192]	; (8008ab0 <mem_free+0x1d0>)
}
 80089f0:	b002      	add	sp, #8
 80089f2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
 80089f6:	f7ff b8b3 	b.w	8007b60 <sys_sem_signal>

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
 80089fa:	4b28      	ldr	r3, [pc, #160]	; (8008a9c <mem_free+0x1bc>)
 80089fc:	9300      	str	r3, [sp, #0]
 80089fe:	4928      	ldr	r1, [pc, #160]	; (8008aa0 <mem_free+0x1c0>)
 8008a00:	4a2d      	ldr	r2, [pc, #180]	; (8008ab8 <mem_free+0x1d8>)
 8008a02:	4829      	ldr	r0, [pc, #164]	; (8008aa8 <mem_free+0x1c8>)
 8008a04:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8008a08:	f7ff ff02 	bl	8008810 <chprintf.constprop.0>
 8008a0c:	482a      	ldr	r0, [pc, #168]	; (8008ab8 <mem_free+0x1d8>)
 8008a0e:	f7f8 faaf 	bl	8000f70 <chSysHalt>
 8008a12:	e76f      	b.n	80088f4 <mem_free+0x14>
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 8008a14:	4b21      	ldr	r3, [pc, #132]	; (8008a9c <mem_free+0x1bc>)
 8008a16:	9300      	str	r3, [sp, #0]
 8008a18:	4921      	ldr	r1, [pc, #132]	; (8008aa0 <mem_free+0x1c0>)
 8008a1a:	4a28      	ldr	r2, [pc, #160]	; (8008abc <mem_free+0x1dc>)
 8008a1c:	4822      	ldr	r0, [pc, #136]	; (8008aa8 <mem_free+0x1c8>)
 8008a1e:	23f6      	movs	r3, #246	; 0xf6
 8008a20:	f7ff fef6 	bl	8008810 <chprintf.constprop.0>
 8008a24:	4825      	ldr	r0, [pc, #148]	; (8008abc <mem_free+0x1dc>)
 8008a26:	f7f8 faa3 	bl	8000f70 <chSysHalt>
 8008a2a:	f834 3c08 	ldrh.w	r3, [r4, #-8]
 8008a2e:	e7b4      	b.n	800899a <mem_free+0xba>
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
 8008a30:	4b1a      	ldr	r3, [pc, #104]	; (8008a9c <mem_free+0x1bc>)
 8008a32:	9300      	str	r3, [sp, #0]
 8008a34:	491a      	ldr	r1, [pc, #104]	; (8008aa0 <mem_free+0x1c0>)
 8008a36:	4a22      	ldr	r2, [pc, #136]	; (8008ac0 <mem_free+0x1e0>)
 8008a38:	481b      	ldr	r0, [pc, #108]	; (8008aa8 <mem_free+0x1c8>)
 8008a3a:	23f3      	movs	r3, #243	; 0xf3
 8008a3c:	f7ff fee8 	bl	8008810 <chprintf.constprop.0>
 8008a40:	481f      	ldr	r0, [pc, #124]	; (8008ac0 <mem_free+0x1e0>)
 8008a42:	f7f8 fa95 	bl	8000f70 <chSysHalt>
 8008a46:	e7a3      	b.n	8008990 <mem_free+0xb0>
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 8008a48:	4b14      	ldr	r3, [pc, #80]	; (8008a9c <mem_free+0x1bc>)
 8008a4a:	9300      	str	r3, [sp, #0]
 8008a4c:	4914      	ldr	r1, [pc, #80]	; (8008aa0 <mem_free+0x1c0>)
 8008a4e:	4a1d      	ldr	r2, [pc, #116]	; (8008ac4 <mem_free+0x1e4>)
 8008a50:	4815      	ldr	r0, [pc, #84]	; (8008aa8 <mem_free+0x1c8>)
 8008a52:	23f2      	movs	r3, #242	; 0xf2
 8008a54:	f7ff fedc 	bl	8008810 <chprintf.constprop.0>
 8008a58:	481a      	ldr	r0, [pc, #104]	; (8008ac4 <mem_free+0x1e4>)
 8008a5a:	f7f8 fa89 	bl	8000f70 <chSysHalt>
 8008a5e:	e793      	b.n	8008988 <mem_free+0xa8>
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 8008a60:	4b0e      	ldr	r3, [pc, #56]	; (8008a9c <mem_free+0x1bc>)
 8008a62:	9300      	str	r3, [sp, #0]
 8008a64:	490e      	ldr	r1, [pc, #56]	; (8008aa0 <mem_free+0x1c0>)
 8008a66:	4a18      	ldr	r2, [pc, #96]	; (8008ac8 <mem_free+0x1e8>)
 8008a68:	480f      	ldr	r0, [pc, #60]	; (8008aa8 <mem_free+0x1c8>)
 8008a6a:	23f1      	movs	r3, #241	; 0xf1
 8008a6c:	f7ff fed0 	bl	8008810 <chprintf.constprop.0>
 8008a70:	4815      	ldr	r0, [pc, #84]	; (8008ac8 <mem_free+0x1e8>)
 8008a72:	f7f8 fa7d 	bl	8000f70 <chSysHalt>
 8008a76:	e784      	b.n	8008982 <mem_free+0xa2>
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
 8008a78:	4b08      	ldr	r3, [pc, #32]	; (8008a9c <mem_free+0x1bc>)
 8008a7a:	9300      	str	r3, [sp, #0]
 8008a7c:	4908      	ldr	r1, [pc, #32]	; (8008aa0 <mem_free+0x1c0>)
 8008a7e:	4a13      	ldr	r2, [pc, #76]	; (8008acc <mem_free+0x1ec>)
 8008a80:	4809      	ldr	r0, [pc, #36]	; (8008aa8 <mem_free+0x1c8>)
 8008a82:	f240 1353 	movw	r3, #339	; 0x153
 8008a86:	f7ff fec3 	bl	8008810 <chprintf.constprop.0>
 8008a8a:	4810      	ldr	r0, [pc, #64]	; (8008acc <mem_free+0x1ec>)
 8008a8c:	f7f8 fa70 	bl	8000f70 <chSysHalt>
 8008a90:	e75f      	b.n	8008952 <mem_free+0x72>
 8008a92:	4770      	bx	lr
 8008a94:	20005ddc 	.word	0x20005ddc
 8008a98:	20005dd4 	.word	0x20005dd4
 8008a9c:	0801721c 	.word	0x0801721c
 8008aa0:	08016fe0 	.word	0x08016fe0
 8008aa4:	0801726c 	.word	0x0801726c
 8008aa8:	200180c8 	.word	0x200180c8
 8008aac:	2000c9fc 	.word	0x2000c9fc
 8008ab0:	20005dd8 	.word	0x20005dd8
 8008ab4:	20005dd0 	.word	0x20005dd0
 8008ab8:	08017248 	.word	0x08017248
 8008abc:	080172e8 	.word	0x080172e8
 8008ac0:	080172cc 	.word	0x080172cc
 8008ac4:	080172b0 	.word	0x080172b0
 8008ac8:	08017298 	.word	0x08017298
 8008acc:	08017284 	.word	0x08017284

08008ad0 <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t newsize)
{
 8008ad0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
 8008ad4:	3103      	adds	r1, #3
 8008ad6:	f64f 75fc 	movw	r5, #65532	; 0xfffc
 8008ada:	400d      	ands	r5, r1

  if(newsize < MIN_SIZE_ALIGNED) {
 8008adc:	2d0b      	cmp	r5, #11
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t newsize)
{
 8008ade:	b082      	sub	sp, #8

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
 8008ae0:	d96c      	bls.n	8008bbc <mem_trim+0xec>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
 8008ae2:	f5b5 5faf 	cmp.w	r5, #5600	; 0x15e0
 8008ae6:	d870      	bhi.n	8008bca <mem_trim+0xfa>
    return NULL;
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 8008ae8:	f8df 8170 	ldr.w	r8, [pc, #368]	; 8008c5c <mem_trim+0x18c>
 8008aec:	f8d8 3000 	ldr.w	r3, [r8]
 8008af0:	4283      	cmp	r3, r0
 8008af2:	4604      	mov	r4, r0
 8008af4:	d848      	bhi.n	8008b88 <mem_trim+0xb8>
 8008af6:	4a50      	ldr	r2, [pc, #320]	; (8008c38 <mem_trim+0x168>)
 8008af8:	6812      	ldr	r2, [r2, #0]
 8008afa:	4290      	cmp	r0, r2
 8008afc:	d244      	bcs.n	8008b88 <mem_trim+0xb8>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 8008afe:	f1a4 0708 	sub.w	r7, r4, #8
 8008b02:	f834 6c08 	ldrh.w	r6, [r4, #-8]
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);
 8008b06:	1afb      	subs	r3, r7, r3
 8008b08:	b29f      	uxth	r7, r3
 8008b0a:	3e08      	subs	r6, #8

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 8008b0c:	1bf6      	subs	r6, r6, r7
 8008b0e:	b2b6      	uxth	r6, r6
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
 8008b10:	42ae      	cmp	r6, r5
 8008b12:	d360      	bcc.n	8008bd6 <mem_trim+0x106>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
 8008b14:	42b5      	cmp	r5, r6
 8008b16:	d05c      	beq.n	8008bd2 <mem_trim+0x102>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
 8008b18:	2100      	movs	r1, #0
 8008b1a:	4848      	ldr	r0, [pc, #288]	; (8008c3c <mem_trim+0x16c>)
 8008b1c:	f7ff f828 	bl	8007b70 <sys_arch_sem_wait>

  mem2 = (struct mem *)(void *)&ram[mem->next];
 8008b20:	f8d8 3000 	ldr.w	r3, [r8]
 8008b24:	f834 0c08 	ldrh.w	r0, [r4, #-8]
 8008b28:	1819      	adds	r1, r3, r0
  if(mem2->used == 0) {
 8008b2a:	790a      	ldrb	r2, [r1, #4]
 8008b2c:	2a00      	cmp	r2, #0
 8008b2e:	d160      	bne.n	8008bf2 <mem_trim+0x122>
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    if (lfree == mem2) {
 8008b30:	f8df e124 	ldr.w	lr, [pc, #292]	; 8008c58 <mem_trim+0x188>
  mem2 = (struct mem *)(void *)&ram[mem->next];
  if(mem2->used == 0) {
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
 8008b34:	f833 c000 	ldrh.w	ip, [r3, r0]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    if (lfree == mem2) {
 8008b38:	f8de 0000 	ldr.w	r0, [lr]
 8008b3c:	f105 0208 	add.w	r2, r5, #8
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8008b40:	443a      	add	r2, r7
 8008b42:	b292      	uxth	r2, r2
    if (lfree == mem2) {
 8008b44:	4288      	cmp	r0, r1
      lfree = (struct mem *)(void *)&ram[ptr2];
 8008b46:	eb03 0102 	add.w	r1, r3, r2
    }
    mem2 = (struct mem *)(void *)&ram[ptr2];
    mem2->used = 0;
 8008b4a:	f04f 0000 	mov.w	r0, #0
    /* restore the next pointer */
    mem2->next = next;
 8008b4e:	f8a1 c000 	strh.w	ip, [r1]
    /* link it back to mem */
    mem2->prev = ptr;
 8008b52:	804f      	strh	r7, [r1, #2]
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    if (lfree == mem2) {
      lfree = (struct mem *)(void *)&ram[ptr2];
    }
    mem2 = (struct mem *)(void *)&ram[ptr2];
    mem2->used = 0;
 8008b54:	7108      	strb	r0, [r1, #4]
    /* restore the next pointer */
    mem2->next = next;
    /* link it back to mem */
    mem2->prev = ptr;
    /* link mem to it */
    mem->next = ptr2;
 8008b56:	f824 2c08 	strh.w	r2, [r4, #-8]
    /* remember the old next pointer */
    next = mem2->next;
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    if (lfree == mem2) {
      lfree = (struct mem *)(void *)&ram[ptr2];
 8008b5a:	bf08      	it	eq
 8008b5c:	f8ce 1000 	streq.w	r1, [lr]
    /* link mem to it */
    mem->next = ptr2;
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8008b60:	8809      	ldrh	r1, [r1, #0]
 8008b62:	f5b1 5faf 	cmp.w	r1, #5600	; 0x15e0
 8008b66:	d001      	beq.n	8008b6c <mem_trim+0x9c>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 8008b68:	440b      	add	r3, r1
 8008b6a:	805a      	strh	r2, [r3, #2]
    mem2->prev = ptr;
    mem->next = ptr2;
    if (mem2->next != MEM_SIZE_ALIGNED) {
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
 8008b6c:	4a34      	ldr	r2, [pc, #208]	; (8008c40 <mem_trim+0x170>)
 8008b6e:	f8b2 30aa 	ldrh.w	r3, [r2, #170]	; 0xaa
 8008b72:	441d      	add	r5, r3
 8008b74:	1bae      	subs	r6, r5, r6
 8008b76:	f8a2 60aa 	strh.w	r6, [r2, #170]	; 0xaa
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
 8008b7a:	4830      	ldr	r0, [pc, #192]	; (8008c3c <mem_trim+0x16c>)
 8008b7c:	f7fe fff0 	bl	8007b60 <sys_sem_signal>
  return rmem;
 8008b80:	4620      	mov	r0, r4
}
 8008b82:	b002      	add	sp, #8
 8008b84:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 8008b88:	4b2e      	ldr	r3, [pc, #184]	; (8008c44 <mem_trim+0x174>)
 8008b8a:	9300      	str	r3, [sp, #0]
 8008b8c:	492e      	ldr	r1, [pc, #184]	; (8008c48 <mem_trim+0x178>)
 8008b8e:	4a2f      	ldr	r2, [pc, #188]	; (8008c4c <mem_trim+0x17c>)
 8008b90:	482f      	ldr	r0, [pc, #188]	; (8008c50 <mem_trim+0x180>)
 8008b92:	f240 1387 	movw	r3, #391	; 0x187
 8008b96:	f7ff fe3b 	bl	8008810 <chprintf.constprop.0>
 8008b9a:	482c      	ldr	r0, [pc, #176]	; (8008c4c <mem_trim+0x17c>)
 8008b9c:	f7f8 f9e8 	bl	8000f70 <chSysHalt>
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 8008ba0:	f8d8 3000 	ldr.w	r3, [r8]
 8008ba4:	429c      	cmp	r4, r3
 8008ba6:	d20b      	bcs.n	8008bc0 <mem_trim+0xf0>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
 8008ba8:	4a25      	ldr	r2, [pc, #148]	; (8008c40 <mem_trim+0x170>)
 8008baa:	f8b2 30b0 	ldrh.w	r3, [r2, #176]	; 0xb0
 8008bae:	3301      	adds	r3, #1
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
 8008bb0:	4620      	mov	r0, r4
  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
 8008bb2:	f8a2 30b0 	strh.w	r3, [r2, #176]	; 0xb0
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
 8008bb6:	b002      	add	sp, #8
 8008bb8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
 8008bbc:	250c      	movs	r5, #12
 8008bbe:	e793      	b.n	8008ae8 <mem_trim+0x18>
 8008bc0:	4a1d      	ldr	r2, [pc, #116]	; (8008c38 <mem_trim+0x168>)
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 8008bc2:	6812      	ldr	r2, [r2, #0]
 8008bc4:	4294      	cmp	r4, r2
 8008bc6:	d2ef      	bcs.n	8008ba8 <mem_trim+0xd8>
 8008bc8:	e799      	b.n	8008afe <mem_trim+0x2e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
 8008bca:	2000      	movs	r0, #0
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
 8008bcc:	b002      	add	sp, #8
 8008bce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008bd2:	4620      	mov	r0, r4
 8008bd4:	e7ef      	b.n	8008bb6 <mem_trim+0xe6>
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
 8008bd6:	4b1b      	ldr	r3, [pc, #108]	; (8008c44 <mem_trim+0x174>)
 8008bd8:	9300      	str	r3, [sp, #0]
 8008bda:	491b      	ldr	r1, [pc, #108]	; (8008c48 <mem_trim+0x178>)
 8008bdc:	4a1d      	ldr	r2, [pc, #116]	; (8008c54 <mem_trim+0x184>)
 8008bde:	481c      	ldr	r0, [pc, #112]	; (8008c50 <mem_trim+0x180>)
 8008be0:	f44f 73cc 	mov.w	r3, #408	; 0x198
 8008be4:	f7ff fe14 	bl	8008810 <chprintf.constprop.0>
 8008be8:	481a      	ldr	r0, [pc, #104]	; (8008c54 <mem_trim+0x184>)
 8008bea:	f7f8 f9c1 	bl	8000f70 <chSysHalt>
  if (newsize > size) {
    /* not supported */
    return NULL;
 8008bee:	2000      	movs	r0, #0
 8008bf0:	e7e1      	b.n	8008bb6 <mem_trim+0xe6>
    if (mem2->next != MEM_SIZE_ALIGNED) {
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 8008bf2:	f105 0214 	add.w	r2, r5, #20
 8008bf6:	42b2      	cmp	r2, r6
 8008bf8:	d8bf      	bhi.n	8008b7a <mem_trim+0xaa>
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    mem2 = (struct mem *)(void *)&ram[ptr2];
    if (mem2 < lfree) {
 8008bfa:	4917      	ldr	r1, [pc, #92]	; (8008c58 <mem_trim+0x188>)
 8008bfc:	f105 0208 	add.w	r2, r5, #8
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8008c00:	443a      	add	r2, r7
 8008c02:	fa1f fc82 	uxth.w	ip, r2
    mem2 = (struct mem *)(void *)&ram[ptr2];
    if (mem2 < lfree) {
 8008c06:	680a      	ldr	r2, [r1, #0]
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    mem2 = (struct mem *)(void *)&ram[ptr2];
 8008c08:	eb03 0e0c 	add.w	lr, r3, ip
    if (mem2 < lfree) {
 8008c0c:	4596      	cmp	lr, r2
      lfree = mem2;
 8008c0e:	bf38      	it	cc
 8008c10:	f8c1 e000 	strcc.w	lr, [r1]
    }
    mem2->used = 0;
 8008c14:	2100      	movs	r1, #0
 8008c16:	f88e 1004 	strb.w	r1, [lr, #4]
    mem2->next = mem->next;
 8008c1a:	f823 000c 	strh.w	r0, [r3, ip]
    mem2->prev = ptr;
 8008c1e:	f8ae 7002 	strh.w	r7, [lr, #2]
    mem->next = ptr2;
 8008c22:	f824 cc08 	strh.w	ip, [r4, #-8]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8008c26:	f833 100c 	ldrh.w	r1, [r3, ip]
 8008c2a:	f5b1 5faf 	cmp.w	r1, #5600	; 0x15e0
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 8008c2e:	bf1c      	itt	ne
 8008c30:	185b      	addne	r3, r3, r1
 8008c32:	f8a3 c002 	strhne.w	ip, [r3, #2]
 8008c36:	e799      	b.n	8008b6c <mem_trim+0x9c>
 8008c38:	20005dd4 	.word	0x20005dd4
 8008c3c:	20005dd8 	.word	0x20005dd8
 8008c40:	2000c9fc 	.word	0x2000c9fc
 8008c44:	0801721c 	.word	0x0801721c
 8008c48:	08016fe0 	.word	0x08016fe0
 8008c4c:	08017314 	.word	0x08017314
 8008c50:	200180c8 	.word	0x200180c8
 8008c54:	0801732c 	.word	0x0801732c
 8008c58:	20005dd0 	.word	0x20005dd0
 8008c5c:	20005ddc 	.word	0x20005ddc

08008c60 <mem_malloc>:
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
 8008c60:	2800      	cmp	r0, #0
 8008c62:	f000 8093 	beq.w	8008d8c <mem_malloc+0x12c>
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
 8008c66:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
 8008c6a:	3003      	adds	r0, #3
 8008c6c:	f64f 77fc 	movw	r7, #65532	; 0xfffc
 8008c70:	4007      	ands	r7, r0

  if(size < MIN_SIZE_ALIGNED) {
 8008c72:	2f0b      	cmp	r7, #11
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
 8008c74:	b082      	sub	sp, #8

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);

  if(size < MIN_SIZE_ALIGNED) {
 8008c76:	d934      	bls.n	8008ce2 <mem_malloc+0x82>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
 8008c78:	f5b7 5faf 	cmp.w	r7, #5600	; 0x15e0
 8008c7c:	f200 8082 	bhi.w	8008d84 <mem_malloc+0x124>
 8008c80:	f5c7 56af 	rsb	r6, r7, #5600	; 0x15e0
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_mutex_lock(&mem_mutex);
 8008c84:	4861      	ldr	r0, [pc, #388]	; (8008e0c <mem_malloc+0x1ac>)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 8008c86:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 8008e30 <mem_malloc+0x1d0>
  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_mutex_lock(&mem_mutex);
 8008c8a:	2100      	movs	r1, #0
 8008c8c:	f7fe ff70 	bl	8007b70 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 8008c90:	f8df c1a0 	ldr.w	ip, [pc, #416]	; 8008e34 <mem_malloc+0x1d4>
 8008c94:	f8d8 e000 	ldr.w	lr, [r8]
 8008c98:	f8dc 2000 	ldr.w	r2, [ip]
 8008c9c:	ebc2 030e 	rsb	r3, r2, lr
 8008ca0:	b29b      	uxth	r3, r3
 8008ca2:	429e      	cmp	r6, r3
 8008ca4:	dc09      	bgt.n	8008cba <mem_malloc+0x5a>
 8008ca6:	e00f      	b.n	8008cc8 <mem_malloc+0x68>
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 8008ca8:	5ad4      	ldrh	r4, [r2, r3]
 8008caa:	f1a4 0108 	sub.w	r1, r4, #8
 8008cae:	1ac9      	subs	r1, r1, r3
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 8008cb0:	42b9      	cmp	r1, r7
 8008cb2:	d21a      	bcs.n	8008cea <mem_malloc+0x8a>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 8008cb4:	4623      	mov	r3, r4
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 8008cb6:	42b3      	cmp	r3, r6
 8008cb8:	da06      	bge.n	8008cc8 <mem_malloc+0x68>
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
      mem = (struct mem *)(void *)&ram[ptr];
 8008cba:	18d5      	adds	r5, r2, r3
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 8008cbc:	7928      	ldrb	r0, [r5, #4]
 8008cbe:	2800      	cmp	r0, #0
 8008cc0:	d0f2      	beq.n	8008ca8 <mem_malloc+0x48>
 8008cc2:	5ad3      	ldrh	r3, [r2, r3]
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 8008cc4:	42b3      	cmp	r3, r6
 8008cc6:	dbf8      	blt.n	8008cba <mem_malloc+0x5a>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
    /* if we got interrupted by a mem_free, try again */
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
 8008cc8:	4a51      	ldr	r2, [pc, #324]	; (8008e10 <mem_malloc+0x1b0>)
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
 8008cca:	4850      	ldr	r0, [pc, #320]	; (8008e0c <mem_malloc+0x1ac>)
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
    /* if we got interrupted by a mem_free, try again */
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
 8008ccc:	f8b2 30ae 	ldrh.w	r3, [r2, #174]	; 0xae
 8008cd0:	3301      	adds	r3, #1
 8008cd2:	f8a2 30ae 	strh.w	r3, [r2, #174]	; 0xae
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
 8008cd6:	f7fe ff43 	bl	8007b60 <sys_sem_signal>
  return NULL;
 8008cda:	2000      	movs	r0, #0
}
 8008cdc:	b002      	add	sp, #8
 8008cde:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008ce2:	f241 56d4 	movw	r6, #5588	; 0x15d4
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);

  if(size < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
 8008ce6:	270c      	movs	r7, #12
 8008ce8:	e7cc      	b.n	8008c84 <mem_malloc+0x24>
      if ((!mem->used) &&
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 8008cea:	f107 0614 	add.w	r6, r7, #20
 8008cee:	428e      	cmp	r6, r1
 8008cf0:	d922      	bls.n	8008d38 <mem_malloc+0xd8>
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
 8008cf2:	4947      	ldr	r1, [pc, #284]	; (8008e10 <mem_malloc+0x1b0>)
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 8008cf4:	2201      	movs	r2, #1
 8008cf6:	712a      	strb	r2, [r5, #4]
 8008cf8:	f8b1 20aa 	ldrh.w	r2, [r1, #170]	; 0xaa
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
 8008cfc:	f8b1 00ac 	ldrh.w	r0, [r1, #172]	; 0xac
 8008d00:	4414      	add	r4, r2
 8008d02:	1ae3      	subs	r3, r4, r3
 8008d04:	b29b      	uxth	r3, r3
 8008d06:	4298      	cmp	r0, r3
 8008d08:	f8a1 30aa 	strh.w	r3, [r1, #170]	; 0xaa
 8008d0c:	bf38      	it	cc
 8008d0e:	f8a1 30ac 	strhcc.w	r3, [r1, #172]	; 0xac
 8008d12:	f107 0608 	add.w	r6, r7, #8
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
 8008d16:	45ae      	cmp	lr, r5
 8008d18:	d05e      	beq.n	8008dd8 <mem_malloc+0x178>
 8008d1a:	4c3e      	ldr	r4, [pc, #248]	; (8008e14 <mem_malloc+0x1b4>)
          }
          lfree = cur;
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
 8008d1c:	483b      	ldr	r0, [pc, #236]	; (8008e0c <mem_malloc+0x1ac>)
 8008d1e:	f7fe ff1f 	bl	8007b60 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 8008d22:	6823      	ldr	r3, [r4, #0]
 8008d24:	442e      	add	r6, r5
 8008d26:	42b3      	cmp	r3, r6
 8008d28:	d349      	bcc.n	8008dbe <mem_malloc+0x15e>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
 8008d2a:	07ab      	lsls	r3, r5, #30
 8008d2c:	d12f      	bne.n	8008d8e <mem_malloc+0x12e>
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
 8008d2e:	f105 0008 	add.w	r0, r5, #8
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  return NULL;
}
 8008d32:	b002      	add	sp, #8
 8008d34:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008d38:	f107 0608 	add.w	r6, r7, #8
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 8008d3c:	1999      	adds	r1, r3, r6
 8008d3e:	b289      	uxth	r1, r1
          /* create mem2 struct */
          mem2 = (struct mem *)(void *)&ram[ptr2];
 8008d40:	eb02 0901 	add.w	r9, r2, r1
          mem2->used = 0;
          mem2->next = mem->next;
          mem2->prev = ptr;
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
          mem->used = 1;
 8008d44:	f04f 0a01 	mov.w	sl, #1
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
          /* create mem2 struct */
          mem2 = (struct mem *)(void *)&ram[ptr2];
          mem2->used = 0;
 8008d48:	f889 0004 	strb.w	r0, [r9, #4]
          mem2->next = mem->next;
 8008d4c:	5254      	strh	r4, [r2, r1]
          mem2->prev = ptr;
 8008d4e:	f8a9 3002 	strh.w	r3, [r9, #2]
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
 8008d52:	8029      	strh	r1, [r5, #0]
          mem->used = 1;

          if (mem2->next != MEM_SIZE_ALIGNED) {
 8008d54:	5a53      	ldrh	r3, [r2, r1]
          mem2->used = 0;
          mem2->next = mem->next;
          mem2->prev = ptr;
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
          mem->used = 1;
 8008d56:	f885 a004 	strb.w	sl, [r5, #4]

          if (mem2->next != MEM_SIZE_ALIGNED) {
 8008d5a:	f5b3 5faf 	cmp.w	r3, #5600	; 0x15e0
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 8008d5e:	bf18      	it	ne
 8008d60:	189b      	addne	r3, r3, r2
          }
          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
 8008d62:	4a2b      	ldr	r2, [pc, #172]	; (8008e10 <mem_malloc+0x1b0>)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
          mem->used = 1;

          if (mem2->next != MEM_SIZE_ALIGNED) {
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 8008d64:	bf18      	it	ne
 8008d66:	8059      	strhne	r1, [r3, #2]
 8008d68:	f8b2 30aa 	ldrh.w	r3, [r2, #170]	; 0xaa
          }
          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
 8008d6c:	f8b2 10ac 	ldrh.w	r1, [r2, #172]	; 0xac
 8008d70:	3308      	adds	r3, #8
 8008d72:	443b      	add	r3, r7
 8008d74:	b29b      	uxth	r3, r3
 8008d76:	4299      	cmp	r1, r3
 8008d78:	f8a2 30aa 	strh.w	r3, [r2, #170]	; 0xaa
 8008d7c:	d2cb      	bcs.n	8008d16 <mem_malloc+0xb6>
 8008d7e:	f8a2 30ac 	strh.w	r3, [r2, #172]	; 0xac
 8008d82:	e7c8      	b.n	8008d16 <mem_malloc+0xb6>
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    return NULL;
 8008d84:	2000      	movs	r0, #0
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  return NULL;
}
 8008d86:	b002      	add	sp, #8
 8008d88:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008d8c:	4770      	bx	lr
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
 8008d8e:	4c22      	ldr	r4, [pc, #136]	; (8008e18 <mem_malloc+0x1b8>)
 8008d90:	4922      	ldr	r1, [pc, #136]	; (8008e1c <mem_malloc+0x1bc>)
 8008d92:	4a23      	ldr	r2, [pc, #140]	; (8008e20 <mem_malloc+0x1c0>)
 8008d94:	9400      	str	r4, [sp, #0]
 8008d96:	f240 2369 	movw	r3, #617	; 0x269
 8008d9a:	4822      	ldr	r0, [pc, #136]	; (8008e24 <mem_malloc+0x1c4>)
 8008d9c:	f7ff fd38 	bl	8008810 <chprintf.constprop.0>
 8008da0:	481f      	ldr	r0, [pc, #124]	; (8008e20 <mem_malloc+0x1c0>)
 8008da2:	f7f8 f8e5 	bl	8000f70 <chSysHalt>
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
 8008da6:	9400      	str	r4, [sp, #0]
 8008da8:	491c      	ldr	r1, [pc, #112]	; (8008e1c <mem_malloc+0x1bc>)
 8008daa:	4a1f      	ldr	r2, [pc, #124]	; (8008e28 <mem_malloc+0x1c8>)
 8008dac:	481d      	ldr	r0, [pc, #116]	; (8008e24 <mem_malloc+0x1c4>)
 8008dae:	f240 236b 	movw	r3, #619	; 0x26b
 8008db2:	f7ff fd2d 	bl	8008810 <chprintf.constprop.0>
 8008db6:	481c      	ldr	r0, [pc, #112]	; (8008e28 <mem_malloc+0x1c8>)
 8008db8:	f7f8 f8da 	bl	8000f70 <chSysHalt>
 8008dbc:	e7b7      	b.n	8008d2e <mem_malloc+0xce>
          lfree = cur;
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 8008dbe:	4b16      	ldr	r3, [pc, #88]	; (8008e18 <mem_malloc+0x1b8>)
 8008dc0:	9300      	str	r3, [sp, #0]
 8008dc2:	4916      	ldr	r1, [pc, #88]	; (8008e1c <mem_malloc+0x1bc>)
 8008dc4:	4a19      	ldr	r2, [pc, #100]	; (8008e2c <mem_malloc+0x1cc>)
 8008dc6:	4817      	ldr	r0, [pc, #92]	; (8008e24 <mem_malloc+0x1c4>)
 8008dc8:	f240 2367 	movw	r3, #615	; 0x267
 8008dcc:	f7ff fd20 	bl	8008810 <chprintf.constprop.0>
 8008dd0:	4816      	ldr	r0, [pc, #88]	; (8008e2c <mem_malloc+0x1cc>)
 8008dd2:	f7f8 f8cd 	bl	8000f70 <chSysHalt>
 8008dd6:	e7a8      	b.n	8008d2a <mem_malloc+0xca>
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
          struct mem *cur = lfree;
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 8008dd8:	f89e 3004 	ldrb.w	r3, [lr, #4]
 8008ddc:	4c0d      	ldr	r4, [pc, #52]	; (8008e14 <mem_malloc+0x1b4>)
 8008dde:	b173      	cbz	r3, 8008dfe <mem_malloc+0x19e>
 8008de0:	6822      	ldr	r2, [r4, #0]
 8008de2:	4596      	cmp	lr, r2
 8008de4:	d00e      	beq.n	8008e04 <mem_malloc+0x1a4>
 8008de6:	f8dc 1000 	ldr.w	r1, [ip]
 8008dea:	e001      	b.n	8008df0 <mem_malloc+0x190>
 8008dec:	4596      	cmp	lr, r2
 8008dee:	d009      	beq.n	8008e04 <mem_malloc+0x1a4>
              /* If mem_free or mem_trim have run, we have to restart since they
                 could have altered our current struct mem or lfree. */
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
 8008df0:	f8be e000 	ldrh.w	lr, [lr]
 8008df4:	448e      	add	lr, r1
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
          struct mem *cur = lfree;
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 8008df6:	f89e 3004 	ldrb.w	r3, [lr, #4]
 8008dfa:	2b00      	cmp	r3, #0
 8008dfc:	d1f6      	bne.n	8008dec <mem_malloc+0x18c>
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
          }
          lfree = cur;
 8008dfe:	f8c8 e000 	str.w	lr, [r8]
 8008e02:	e78b      	b.n	8008d1c <mem_malloc+0xbc>
 8008e04:	f8c8 2000 	str.w	r2, [r8]
 8008e08:	e788      	b.n	8008d1c <mem_malloc+0xbc>
 8008e0a:	bf00      	nop
 8008e0c:	20005dd8 	.word	0x20005dd8
 8008e10:	2000c9fc 	.word	0x2000c9fc
 8008e14:	20005dd4 	.word	0x20005dd4
 8008e18:	0801721c 	.word	0x0801721c
 8008e1c:	08016fe0 	.word	0x08016fe0
 8008e20:	0801737c 	.word	0x0801737c
 8008e24:	200180c8 	.word	0x200180c8
 8008e28:	080173ac 	.word	0x080173ac
 8008e2c:	0801734c 	.word	0x0801734c
 8008e30:	20005dd0 	.word	0x20005dd0
 8008e34:	20005ddc 	.word	0x20005ddc
 8008e38:	f3af 8000 	nop.w
 8008e3c:	f3af 8000 	nop.w

08008e40 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8008e40:	b40e      	push	{r1, r2, r3}
 8008e42:	b500      	push	{lr}
 8008e44:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8008e46:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 8008e48:	461a      	mov	r2, r3
 8008e4a:	4905      	ldr	r1, [pc, #20]	; (8008e60 <chprintf.constprop.0+0x20>)
 8008e4c:	4805      	ldr	r0, [pc, #20]	; (8008e64 <chprintf.constprop.0+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8008e4e:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8008e50:	f007 ff56 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8008e54:	b002      	add	sp, #8
 8008e56:	f85d eb04 	ldr.w	lr, [sp], #4
 8008e5a:	b003      	add	sp, #12
 8008e5c:	4770      	bx	lr
 8008e5e:	bf00      	nop
 8008e60:	08016fe0 	.word	0x08016fe0
 8008e64:	200180c8 	.word	0x200180c8
 8008e68:	f3af 8000 	nop.w
 8008e6c:	f3af 8000 	nop.w

08008e70 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
 8008e70:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008e74:	4b1f      	ldr	r3, [pc, #124]	; (8008ef4 <memp_init+0x84>)
 8008e76:	f8df 8088 	ldr.w	r8, [pc, #136]	; 8008f00 <memp_init+0x90>
 8008e7a:	f103 048c 	add.w	r4, r3, #140	; 0x8c
 8008e7e:	4641      	mov	r1, r8
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
    MEMP_STATS_AVAIL(used, i, 0);
 8008e80:	2200      	movs	r2, #0
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
 8008e82:	f831 0f02 	ldrh.w	r0, [r1, #2]!
{
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
    MEMP_STATS_AVAIL(used, i, 0);
 8008e86:	f8a3 20b4 	strh.w	r2, [r3, #180]	; 0xb4
    MEMP_STATS_AVAIL(max, i, 0);
 8008e8a:	f8a3 20b6 	strh.w	r2, [r3, #182]	; 0xb6
    MEMP_STATS_AVAIL(err, i, 0);
 8008e8e:	f8a3 20b8 	strh.w	r2, [r3, #184]	; 0xb8
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
 8008e92:	f8a3 00b2 	strh.w	r0, [r3, #178]	; 0xb2
 8008e96:	330a      	adds	r3, #10
memp_init(void)
{
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
 8008e98:	42a3      	cmp	r3, r4
 8008e9a:	d1f2      	bne.n	8008e82 <memp_init+0x12>
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
 8008e9c:	4b16      	ldr	r3, [pc, #88]	; (8008ef8 <memp_init+0x88>)
 8008e9e:	4f17      	ldr	r7, [pc, #92]	; (8008efc <memp_init+0x8c>)
 8008ea0:	f8df c060 	ldr.w	ip, [pc, #96]	; 8008f04 <memp_init+0x94>
 8008ea4:	f023 0e03 	bic.w	lr, r3, #3
 8008ea8:	f107 0a38 	add.w	sl, r7, #56	; 0x38
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
 8008eac:	f04f 0900 	mov.w	r9, #0
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
 8008eb0:	f838 5f02 	ldrh.w	r5, [r8, #2]!
#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
 8008eb4:	f847 9f04 	str.w	r9, [r7, #4]!
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
 8008eb8:	b1b5      	cbz	r5, 8008ee8 <memp_init+0x78>
 8008eba:	2200      	movs	r2, #0
 8008ebc:	4611      	mov	r1, r2
 8008ebe:	f8bc 6000 	ldrh.w	r6, [ip]
 8008ec2:	4673      	mov	r3, lr
 8008ec4:	e000      	b.n	8008ec8 <memp_init+0x58>
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 8008ec6:	4623      	mov	r3, r4
 8008ec8:	3201      	adds	r2, #1
    memp_tab[i] = NULL;
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
 8008eca:	b290      	uxth	r0, r2
 8008ecc:	4285      	cmp	r5, r0
      memp->next = memp_tab[i];
 8008ece:	6019      	str	r1, [r3, #0]
      memp_tab[i] = memp;
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 8008ed0:	eb03 0406 	add.w	r4, r3, r6
 8008ed4:	4619      	mov	r1, r3
    memp_tab[i] = NULL;
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
 8008ed6:	d8f6      	bhi.n	8008ec6 <memp_init+0x56>
 8008ed8:	3d01      	subs	r5, #1
 8008eda:	b2ad      	uxth	r5, r5
 8008edc:	fb06 e305 	mla	r3, r6, r5, lr
 8008ee0:	fb05 6606 	mla	r6, r5, r6, r6
 8008ee4:	603b      	str	r3, [r7, #0]
 8008ee6:	44b6      	add	lr, r6

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
 8008ee8:	4557      	cmp	r7, sl
 8008eea:	f10c 0c02 	add.w	ip, ip, #2
 8008eee:	d1df      	bne.n	8008eb0 <memp_init+0x40>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
 8008ef0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008ef4:	2000c9fc 	.word	0x2000c9fc
 8008ef8:	20005de3 	.word	0x20005de3
 8008efc:	2000c9b0 	.word	0x2000c9b0
 8008f00:	080173ce 	.word	0x080173ce
 8008f04:	08017480 	.word	0x08017480
 8008f08:	f3af 8000 	nop.w
 8008f0c:	f3af 8000 	nop.w

08008f10 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
 8008f10:	b510      	push	{r4, lr}
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 8008f12:	280d      	cmp	r0, #13
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
 8008f14:	b082      	sub	sp, #8
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 8008f16:	d835      	bhi.n	8008f84 <memp_malloc+0x74>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
 8008f18:	4a21      	ldr	r2, [pc, #132]	; (8008fa0 <memp_malloc+0x90>)
 8008f1a:	f852 4020 	ldr.w	r4, [r2, r0, lsl #2]
  
  if (memp != NULL) {
 8008f1e:	b324      	cbz	r4, 8008f6a <memp_malloc+0x5a>
    memp_tab[type] = memp->next;
 8008f20:	6821      	ldr	r1, [r4, #0]
#if MEMP_OVERFLOW_CHECK
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
 8008f22:	4b20      	ldr	r3, [pc, #128]	; (8008fa4 <memp_malloc+0x94>)
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  
  if (memp != NULL) {
    memp_tab[type] = memp->next;
 8008f24:	f842 1020 	str.w	r1, [r2, r0, lsl #2]
#if MEMP_OVERFLOW_CHECK
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
 8008f28:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8008f2c:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 8008f30:	33b0      	adds	r3, #176	; 0xb0
 8008f32:	889a      	ldrh	r2, [r3, #4]
 8008f34:	88d9      	ldrh	r1, [r3, #6]
 8008f36:	3201      	adds	r2, #1
 8008f38:	b292      	uxth	r2, r2
 8008f3a:	809a      	strh	r2, [r3, #4]
 8008f3c:	4291      	cmp	r1, r2
 8008f3e:	bf38      	it	cc
 8008f40:	80da      	strhcc	r2, [r3, #6]
    LWIP_ASSERT("memp_malloc: memp properly aligned",
 8008f42:	07a3      	lsls	r3, r4, #30
 8008f44:	d102      	bne.n	8008f4c <memp_malloc+0x3c>
 8008f46:	4620      	mov	r0, r4
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
 8008f48:	b002      	add	sp, #8
 8008f4a:	bd10      	pop	{r4, pc}
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
 8008f4c:	4b16      	ldr	r3, [pc, #88]	; (8008fa8 <memp_malloc+0x98>)
 8008f4e:	9300      	str	r3, [sp, #0]
 8008f50:	4916      	ldr	r1, [pc, #88]	; (8008fac <memp_malloc+0x9c>)
 8008f52:	4a17      	ldr	r2, [pc, #92]	; (8008fb0 <memp_malloc+0xa0>)
 8008f54:	4817      	ldr	r0, [pc, #92]	; (8008fb4 <memp_malloc+0xa4>)
 8008f56:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 8008f5a:	f7ff ff71 	bl	8008e40 <chprintf.constprop.0>
 8008f5e:	4814      	ldr	r0, [pc, #80]	; (8008fb0 <memp_malloc+0xa0>)
 8008f60:	f7f8 f806 	bl	8000f70 <chSysHalt>
 8008f64:	4620      	mov	r0, r4
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
 8008f66:	b002      	add	sp, #8
 8008f68:	bd10      	pop	{r4, pc}
    LWIP_ASSERT("memp_malloc: memp properly aligned",
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
    memp = (struct memp*)(void *)((u8_t*)memp + MEMP_SIZE);
  } else {
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
    MEMP_STATS_INC(err, type);
 8008f6a:	4a0e      	ldr	r2, [pc, #56]	; (8008fa4 <memp_malloc+0x94>)
 8008f6c:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 8008f70:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 8008f74:	4620      	mov	r0, r4
 8008f76:	f8b3 20b8 	ldrh.w	r2, [r3, #184]	; 0xb8
 8008f7a:	3201      	adds	r2, #1
 8008f7c:	f8a3 20b8 	strh.w	r2, [r3, #184]	; 0xb8
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
 8008f80:	b002      	add	sp, #8
 8008f82:	bd10      	pop	{r4, pc}
#endif
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 8008f84:	4b08      	ldr	r3, [pc, #32]	; (8008fa8 <memp_malloc+0x98>)
 8008f86:	9300      	str	r3, [sp, #0]
 8008f88:	4908      	ldr	r1, [pc, #32]	; (8008fac <memp_malloc+0x9c>)
 8008f8a:	4a0b      	ldr	r2, [pc, #44]	; (8008fb8 <memp_malloc+0xa8>)
 8008f8c:	4809      	ldr	r0, [pc, #36]	; (8008fb4 <memp_malloc+0xa4>)
 8008f8e:	f44f 73c7 	mov.w	r3, #398	; 0x18e
 8008f92:	f7ff ff55 	bl	8008e40 <chprintf.constprop.0>
 8008f96:	4808      	ldr	r0, [pc, #32]	; (8008fb8 <memp_malloc+0xa8>)
 8008f98:	f7f7 ffea 	bl	8000f70 <chSysHalt>
 8008f9c:	2000      	movs	r0, #0
 8008f9e:	e7d3      	b.n	8008f48 <memp_malloc+0x38>
 8008fa0:	2000c9b4 	.word	0x2000c9b4
 8008fa4:	2000c9fc 	.word	0x2000c9fc
 8008fa8:	08017410 	.word	0x08017410
 8008fac:	08016fe0 	.word	0x08016fe0
 8008fb0:	0801743c 	.word	0x0801743c
 8008fb4:	200180c8 	.word	0x200180c8
 8008fb8:	080173f0 	.word	0x080173f0
 8008fbc:	f3af 8000 	nop.w

08008fc0 <memp_free>:
memp_free(memp_t type, void *mem)
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
 8008fc0:	b321      	cbz	r1, 800900c <memp_free+0x4c>
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
 8008fc2:	b530      	push	{r4, r5, lr}
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
 8008fc4:	078b      	lsls	r3, r1, #30
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
 8008fc6:	b083      	sub	sp, #12
 8008fc8:	460c      	mov	r4, r1
 8008fca:	4605      	mov	r5, r0
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
 8008fcc:	d111      	bne.n	8008ff2 <memp_free+0x32>
  memp_overflow_check_element_overflow(memp, type);
  memp_overflow_check_element_underflow(memp, type);
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
 8008fce:	4b10      	ldr	r3, [pc, #64]	; (8009010 <memp_free+0x50>)
  
  memp->next = memp_tab[type]; 
 8008fd0:	4910      	ldr	r1, [pc, #64]	; (8009014 <memp_free+0x54>)
  memp_overflow_check_element_overflow(memp, type);
  memp_overflow_check_element_underflow(memp, type);
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
 8008fd2:	eb05 0285 	add.w	r2, r5, r5, lsl #2
 8008fd6:	eb03 0342 	add.w	r3, r3, r2, lsl #1
  
  memp->next = memp_tab[type]; 
 8008fda:	f851 0025 	ldr.w	r0, [r1, r5, lsl #2]
  memp_overflow_check_element_overflow(memp, type);
  memp_overflow_check_element_underflow(memp, type);
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
 8008fde:	f8b3 20b4 	ldrh.w	r2, [r3, #180]	; 0xb4
 8008fe2:	3a01      	subs	r2, #1
 8008fe4:	f8a3 20b4 	strh.w	r2, [r3, #180]	; 0xb4
  
  memp->next = memp_tab[type]; 
 8008fe8:	6020      	str	r0, [r4, #0]
  memp_tab[type] = memp;
 8008fea:	f841 4025 	str.w	r4, [r1, r5, lsl #2]
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
 8008fee:	b003      	add	sp, #12
 8008ff0:	bd30      	pop	{r4, r5, pc}
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
 8008ff2:	4b09      	ldr	r3, [pc, #36]	; (8009018 <memp_free+0x58>)
 8008ff4:	9300      	str	r3, [sp, #0]
 8008ff6:	4909      	ldr	r1, [pc, #36]	; (800901c <memp_free+0x5c>)
 8008ff8:	4a09      	ldr	r2, [pc, #36]	; (8009020 <memp_free+0x60>)
 8008ffa:	480a      	ldr	r0, [pc, #40]	; (8009024 <memp_free+0x64>)
 8008ffc:	f44f 73de 	mov.w	r3, #444	; 0x1bc
 8009000:	f7ff ff1e 	bl	8008e40 <chprintf.constprop.0>
 8009004:	4806      	ldr	r0, [pc, #24]	; (8009020 <memp_free+0x60>)
 8009006:	f7f7 ffb3 	bl	8000f70 <chSysHalt>
 800900a:	e7e0      	b.n	8008fce <memp_free+0xe>
 800900c:	4770      	bx	lr
 800900e:	bf00      	nop
 8009010:	2000c9fc 	.word	0x2000c9fc
 8009014:	2000c9b4 	.word	0x2000c9b4
 8009018:	08017410 	.word	0x08017410
 800901c:	08016fe0 	.word	0x08016fe0
 8009020:	08017460 	.word	0x08017460
 8009024:	200180c8 	.word	0x200180c8
 8009028:	f3af 8000 	nop.w
 800902c:	f3af 8000 	nop.w

08009030 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8009030:	b40e      	push	{r1, r2, r3}
 8009032:	b500      	push	{lr}
 8009034:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8009036:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 8009038:	461a      	mov	r2, r3
 800903a:	4905      	ldr	r1, [pc, #20]	; (8009050 <chprintf.constprop.0+0x20>)
 800903c:	4805      	ldr	r0, [pc, #20]	; (8009054 <chprintf.constprop.0+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800903e:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8009040:	f007 fe5e 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8009044:	b002      	add	sp, #8
 8009046:	f85d eb04 	ldr.w	lr, [sp], #4
 800904a:	b003      	add	sp, #12
 800904c:	4770      	bx	lr
 800904e:	bf00      	nop
 8009050:	08016fe0 	.word	0x08016fe0
 8009054:	200180c8 	.word	0x200180c8
 8009058:	f3af 8000 	nop.w
 800905c:	f3af 8000 	nop.w

08009060 <netif_init>:
}
#endif /* LWIP_HAVE_LOOPIF */

void
netif_init(void)
{
 8009060:	4770      	bx	lr
 8009062:	bf00      	nop
 8009064:	f3af 8000 	nop.w
 8009068:	f3af 8000 	nop.w
 800906c:	f3af 8000 	nop.w

08009070 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
 8009070:	b570      	push	{r4, r5, r6, lr}
 8009072:	4604      	mov	r4, r0
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
 8009074:	460e      	mov	r6, r1
 8009076:	b329      	cbz	r1, 80090c4 <netif_set_ipaddr+0x54>
 8009078:	680b      	ldr	r3, [r1, #0]
 800907a:	6842      	ldr	r2, [r0, #4]
 800907c:	4293      	cmp	r3, r2
 800907e:	d01f      	beq.n	80090c0 <netif_set_ipaddr+0x50>
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
 8009080:	4913      	ldr	r1, [pc, #76]	; (80090d0 <netif_set_ipaddr+0x60>)
 8009082:	6808      	ldr	r0, [r1, #0]
    while (pcb != NULL) {
 8009084:	b308      	cbz	r0, 80090ca <netif_set_ipaddr+0x5a>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
 8009086:	6803      	ldr	r3, [r0, #0]
 8009088:	4293      	cmp	r3, r2
 800908a:	d005      	beq.n	8009098 <netif_set_ipaddr+0x28>
        struct tcp_pcb *next = pcb->next;
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
        pcb = next;
      } else {
        pcb = pcb->next;
 800908c:	68c0      	ldr	r0, [r0, #12]
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
 800908e:	b148      	cbz	r0, 80090a4 <netif_set_ipaddr+0x34>
 8009090:	6862      	ldr	r2, [r4, #4]
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
 8009092:	6803      	ldr	r3, [r0, #0]
 8009094:	4293      	cmp	r3, r2
 8009096:	d1f9      	bne.n	800908c <netif_set_ipaddr+0x1c>
        /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
        && !ip_addr_islinklocal(&(pcb->local_ip))
#endif /* LWIP_AUTOIP */
        ) {
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
 8009098:	68c5      	ldr	r5, [r0, #12]
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
 800909a:	f001 fde9 	bl	800ac70 <tcp_abort>
        pcb = next;
 800909e:	4628      	mov	r0, r5
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
 80090a0:	2800      	cmp	r0, #0
 80090a2:	d1f5      	bne.n	8009090 <netif_set_ipaddr+0x20>
 80090a4:	6832      	ldr	r2, [r6, #0]
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 80090a6:	4b0b      	ldr	r3, [pc, #44]	; (80090d4 <netif_set_ipaddr+0x64>)
 80090a8:	681b      	ldr	r3, [r3, #0]
 80090aa:	b14b      	cbz	r3, 80090c0 <netif_set_ipaddr+0x50>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
 80090ac:	6818      	ldr	r0, [r3, #0]
 80090ae:	b120      	cbz	r0, 80090ba <netif_set_ipaddr+0x4a>
 80090b0:	6865      	ldr	r5, [r4, #4]
 80090b2:	42a8      	cmp	r0, r5
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
 80090b4:	bf04      	itt	eq
 80090b6:	601a      	streq	r2, [r3, #0]
 80090b8:	6832      	ldreq	r2, [r6, #0]
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 80090ba:	68db      	ldr	r3, [r3, #12]
 80090bc:	2b00      	cmp	r3, #0
 80090be:	d1f5      	bne.n	80090ac <netif_set_ipaddr+0x3c>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
 80090c0:	6062      	str	r2, [r4, #4]
 80090c2:	bd70      	pop	{r4, r5, r6, pc}
 80090c4:	460a      	mov	r2, r1
 80090c6:	6062      	str	r2, [r4, #4]
 80090c8:	bd70      	pop	{r4, r5, r6, pc}
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
 80090ca:	461a      	mov	r2, r3
 80090cc:	e7eb      	b.n	80090a6 <netif_set_ipaddr+0x36>
 80090ce:	bf00      	nop
 80090d0:	2000cb60 	.word	0x2000cb60
 80090d4:	2000cb5c 	.word	0x2000cb5c
 80090d8:	f3af 8000 	nop.w
 80090dc:	f3af 8000 	nop.w

080090e0 <netif_add>:
 * @return netif, or NULL if failed.
 */
struct netif *
netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
  ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
{
 80090e0:	e92d 44f0 	stmdb	sp!, {r4, r5, r6, r7, sl, lr}
 80090e4:	b082      	sub	sp, #8
 80090e6:	4604      	mov	r4, r0
 80090e8:	9e09      	ldr	r6, [sp, #36]	; 0x24
 80090ea:	468a      	mov	sl, r1
 80090ec:	4617      	mov	r7, r2
 80090ee:	461d      	mov	r5, r3

  LWIP_ASSERT("No init function given", init != NULL);
 80090f0:	b36e      	cbz	r6, 800914e <netif_add+0x6e>
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  netif->num = netif_num++;
 80090f2:	f8df e088 	ldr.w	lr, [pc, #136]	; 800917c <netif_add+0x9c>
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
 80090f6:	9b08      	ldr	r3, [sp, #32]
  netif->num = netif_num++;
  netif->input = input;
 80090f8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
 80090fa:	61e3      	str	r3, [r4, #28]
  netif->num = netif_num++;
 80090fc:	f89e 3000 	ldrb.w	r3, [lr]
  netif->input = input;
 8009100:	6122      	str	r2, [r4, #16]
{

  LWIP_ASSERT("No init function given", init != NULL);

  /* reset new interface configuration state */
  ip_addr_set_zero(&netif->ip_addr);
 8009102:	2200      	movs	r2, #0
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  netif->num = netif_num++;
 8009104:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
 */
void
netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
    ip_addr_t *gw)
{
  netif_set_ipaddr(netif, ipaddr);
 8009108:	4651      	mov	r1, sl
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  netif->num = netif_num++;
 800910a:	3301      	adds	r3, #1
{

  LWIP_ASSERT("No init function given", init != NULL);

  /* reset new interface configuration state */
  ip_addr_set_zero(&netif->ip_addr);
 800910c:	6062      	str	r2, [r4, #4]
  ip_addr_set_zero(&netif->netmask);
 800910e:	60a2      	str	r2, [r4, #8]
  ip_addr_set_zero(&netif->gw);
 8009110:	60e2      	str	r2, [r4, #12]
  netif->flags = 0;
 8009112:	f884 2029 	strb.w	r2, [r4, #41]	; 0x29
 */
void
netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
    ip_addr_t *gw)
{
  netif_set_ipaddr(netif, ipaddr);
 8009116:	4620      	mov	r0, r4
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  netif->num = netif_num++;
 8009118:	f88e 3000 	strb.w	r3, [lr]
 */
void
netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
    ip_addr_t *gw)
{
  netif_set_ipaddr(netif, ipaddr);
 800911c:	f7ff ffa8 	bl	8009070 <netif_set_ipaddr>
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
 8009120:	b17f      	cbz	r7, 8009142 <netif_add+0x62>
 8009122:	683b      	ldr	r3, [r7, #0]
 8009124:	60a3      	str	r3, [r4, #8]
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, ip_addr_t *gw)
{
  ip_addr_set(&(netif->gw), gw);
 8009126:	b105      	cbz	r5, 800912a <netif_add+0x4a>
 8009128:	682d      	ldr	r5, [r5, #0]
 800912a:	60e5      	str	r5, [r4, #12]
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
 800912c:	4620      	mov	r0, r4
 800912e:	47b0      	blx	r6
 8009130:	b948      	cbnz	r0, 8009146 <netif_add+0x66>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
 8009132:	4b0d      	ldr	r3, [pc, #52]	; (8009168 <netif_add+0x88>)
 8009134:	681a      	ldr	r2, [r3, #0]
 8009136:	6022      	str	r2, [r4, #0]
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
 8009138:	4620      	mov	r0, r4
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  netif_list = netif;
 800913a:	601c      	str	r4, [r3, #0]
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
 800913c:	b002      	add	sp, #8
 800913e:	e8bd 84f0 	ldmia.w	sp!, {r4, r5, r6, r7, sl, pc}
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
 8009142:	463b      	mov	r3, r7
 8009144:	e7ee      	b.n	8009124 <netif_add+0x44>

  netif_set_addr(netif, ipaddr, netmask, gw);

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    return NULL;
 8009146:	2000      	movs	r0, #0
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
 8009148:	b002      	add	sp, #8
 800914a:	e8bd 84f0 	ldmia.w	sp!, {r4, r5, r6, r7, sl, pc}
struct netif *
netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
  ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
{

  LWIP_ASSERT("No init function given", init != NULL);
 800914e:	4b07      	ldr	r3, [pc, #28]	; (800916c <netif_add+0x8c>)
 8009150:	9300      	str	r3, [sp, #0]
 8009152:	4907      	ldr	r1, [pc, #28]	; (8009170 <netif_add+0x90>)
 8009154:	4a07      	ldr	r2, [pc, #28]	; (8009174 <netif_add+0x94>)
 8009156:	4808      	ldr	r0, [pc, #32]	; (8009178 <netif_add+0x98>)
 8009158:	238f      	movs	r3, #143	; 0x8f
 800915a:	f7ff ff69 	bl	8009030 <chprintf.constprop.0>
 800915e:	4805      	ldr	r0, [pc, #20]	; (8009174 <netif_add+0x94>)
 8009160:	f7f7 ff06 	bl	8000f70 <chSysHalt>
 8009164:	e7c5      	b.n	80090f2 <netif_add+0x12>
 8009166:	bf00      	nop
 8009168:	2000c9ec 	.word	0x2000c9ec
 800916c:	080174b8 	.word	0x080174b8
 8009170:	08016fe0 	.word	0x08016fe0
 8009174:	080174a0 	.word	0x080174a0
 8009178:	200180c8 	.word	0x200180c8
 800917c:	2000c9f4 	.word	0x2000c9f4

08009180 <netif_set_default>:
    snmp_delete_iprteidx_tree(1, netif);
  } else {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
 8009180:	4b01      	ldr	r3, [pc, #4]	; (8009188 <netif_set_default+0x8>)
 8009182:	6018      	str	r0, [r3, #0]
 8009184:	4770      	bx	lr
 8009186:	bf00      	nop
 8009188:	2000c9f0 	.word	0x2000c9f0
 800918c:	f3af 8000 	nop.w

08009190 <netif_set_up>:
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  if (!(netif->flags & NETIF_FLAG_UP)) {
 8009190:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
 8009194:	07da      	lsls	r2, r3, #31
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
 8009196:	4601      	mov	r1, r0
  if (!(netif->flags & NETIF_FLAG_UP)) {
 8009198:	d407      	bmi.n	80091aa <netif_set_up+0x1a>
    netif->flags |= NETIF_FLAG_UP;
 800919a:	f043 0201 	orr.w	r2, r3, #1
    NETIF_STATUS_CALLBACK(netif);

    if (netif->flags & NETIF_FLAG_LINK_UP) {
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & (NETIF_FLAG_ETHARP)) {
 800919e:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80091a2:	2b30      	cmp	r3, #48	; 0x30
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  if (!(netif->flags & NETIF_FLAG_UP)) {
    netif->flags |= NETIF_FLAG_UP;
 80091a4:	f880 2029 	strb.w	r2, [r0, #41]	; 0x29
    NETIF_STATUS_CALLBACK(netif);

    if (netif->flags & NETIF_FLAG_LINK_UP) {
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & (NETIF_FLAG_ETHARP)) {
 80091a8:	d000      	beq.n	80091ac <netif_set_up+0x1c>
 80091aa:	4770      	bx	lr
        etharp_gratuitous(netif);
 80091ac:	3104      	adds	r1, #4
 80091ae:	f7fe bf5f 	b.w	8008070 <etharp_request>
 80091b2:	bf00      	nop
 80091b4:	f3af 8000 	nop.w
 80091b8:	f3af 8000 	nop.w
 80091bc:	f3af 8000 	nop.w

080091c0 <netif_set_link_up>:
/**
 * Called by a driver when its link goes up
 */
void netif_set_link_up(struct netif *netif )
{
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
 80091c0:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
 80091c4:	06da      	lsls	r2, r3, #27

/**
 * Called by a driver when its link goes up
 */
void netif_set_link_up(struct netif *netif )
{
 80091c6:	4601      	mov	r1, r0
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
 80091c8:	d407      	bmi.n	80091da <netif_set_link_up+0x1a>
    netif->flags |= NETIF_FLAG_LINK_UP;
 80091ca:	f043 0210 	orr.w	r2, r3, #16
#endif /* LWIP_AUTOIP */

    if (netif->flags & NETIF_FLAG_UP) {
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & NETIF_FLAG_ETHARP) {
 80091ce:	f003 0321 	and.w	r3, r3, #33	; 0x21
 80091d2:	2b21      	cmp	r3, #33	; 0x21
 * Called by a driver when its link goes up
 */
void netif_set_link_up(struct netif *netif )
{
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
    netif->flags |= NETIF_FLAG_LINK_UP;
 80091d4:	f880 2029 	strb.w	r2, [r0, #41]	; 0x29
#endif /* LWIP_AUTOIP */

    if (netif->flags & NETIF_FLAG_UP) {
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & NETIF_FLAG_ETHARP) {
 80091d8:	d000      	beq.n	80091dc <netif_set_link_up+0x1c>
 80091da:	4770      	bx	lr
        etharp_gratuitous(netif);
 80091dc:	3104      	adds	r1, #4
 80091de:	f7fe bf47 	b.w	8008070 <etharp_request>
 80091e2:	bf00      	nop
 80091e4:	f3af 8000 	nop.w
 80091e8:	f3af 8000 	nop.w
 80091ec:	f3af 8000 	nop.w

080091f0 <netif_set_link_down>:
/**
 * Called by a driver when its link goes down
 */
void netif_set_link_down(struct netif *netif )
{
  if (netif->flags & NETIF_FLAG_LINK_UP) {
 80091f0:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
 80091f4:	06da      	lsls	r2, r3, #27
    netif->flags &= ~NETIF_FLAG_LINK_UP;
 80091f6:	bf44      	itt	mi
 80091f8:	f023 0310 	bicmi.w	r3, r3, #16
 80091fc:	f880 3029 	strbmi.w	r3, [r0, #41]	; 0x29
 8009200:	4770      	bx	lr
 8009202:	bf00      	nop
 8009204:	f3af 8000 	nop.w
 8009208:	f3af 8000 	nop.w
 800920c:	f3af 8000 	nop.w

08009210 <pbuf_free_ooseq_callback>:

  SYS_ARCH_PROTECT(old_level);
  pbuf_free_ooseq_pending = 0;
  SYS_ARCH_UNPROTECT(old_level);

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 8009210:	4a09      	ldr	r2, [pc, #36]	; (8009238 <pbuf_free_ooseq_callback+0x28>)
{
  struct tcp_pcb* pcb;
  SYS_ARCH_DECL_PROTECT(old_level);

  SYS_ARCH_PROTECT(old_level);
  pbuf_free_ooseq_pending = 0;
 8009212:	4b0a      	ldr	r3, [pc, #40]	; (800923c <pbuf_free_ooseq_callback+0x2c>)
/**
 * Just a callback function for tcpip_timeout() that calls pbuf_free_ooseq().
 */
static void
pbuf_free_ooseq_callback(void *arg)
{
 8009214:	b510      	push	{r4, lr}

  SYS_ARCH_PROTECT(old_level);
  pbuf_free_ooseq_pending = 0;
  SYS_ARCH_UNPROTECT(old_level);

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 8009216:	6814      	ldr	r4, [r2, #0]
{
  struct tcp_pcb* pcb;
  SYS_ARCH_DECL_PROTECT(old_level);

  SYS_ARCH_PROTECT(old_level);
  pbuf_free_ooseq_pending = 0;
 8009218:	2200      	movs	r2, #0
 800921a:	701a      	strb	r2, [r3, #0]
  SYS_ARCH_UNPROTECT(old_level);

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 800921c:	b914      	cbnz	r4, 8009224 <pbuf_free_ooseq_callback+0x14>
 800921e:	e009      	b.n	8009234 <pbuf_free_ooseq_callback+0x24>
 8009220:	68e4      	ldr	r4, [r4, #12]
 8009222:	b13c      	cbz	r4, 8009234 <pbuf_free_ooseq_callback+0x24>
    if (NULL != pcb->ooseq) {
 8009224:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8009226:	2800      	cmp	r0, #0
 8009228:	d0fa      	beq.n	8009220 <pbuf_free_ooseq_callback+0x10>
      /** Free the ooseq pbufs of one PCB only */
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
      tcp_segs_free(pcb->ooseq);
 800922a:	f000 ff09 	bl	800a040 <tcp_segs_free>
      pcb->ooseq = NULL;
 800922e:	2300      	movs	r3, #0
 8009230:	6763      	str	r3, [r4, #116]	; 0x74
 8009232:	bd10      	pop	{r4, pc}
 8009234:	bd10      	pop	{r4, pc}
 8009236:	bf00      	nop
 8009238:	2000cb60 	.word	0x2000cb60
 800923c:	2000c9f5 	.word	0x2000c9f5

08009240 <pbuf_pool_is_empty.part.0>:
  pbuf_free_ooseq_pending = 1;
  SYS_ARCH_UNPROTECT(old_level);

  if(!queued) {
    /* queue a call to pbuf_free_ooseq if not already queued */
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
 8009240:	2100      	movs	r1, #0
}
#endif /* !NO_SYS */

/** Queue a call to pbuf_free_ooseq if not already queued. */
static void
pbuf_pool_is_empty(void)
 8009242:	b508      	push	{r3, lr}
  pbuf_free_ooseq_pending = 1;
  SYS_ARCH_UNPROTECT(old_level);

  if(!queued) {
    /* queue a call to pbuf_free_ooseq if not already queued */
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
 8009244:	460a      	mov	r2, r1
 8009246:	4804      	ldr	r0, [pc, #16]	; (8009258 <pbuf_pool_is_empty.part.0+0x18>)
 8009248:	f007 fbda 	bl	8010a00 <tcpip_callback_with_block>
 800924c:	b110      	cbz	r0, 8009254 <pbuf_pool_is_empty.part.0+0x14>
 800924e:	4b03      	ldr	r3, [pc, #12]	; (800925c <pbuf_pool_is_empty.part.0+0x1c>)
 8009250:	2200      	movs	r2, #0
 8009252:	701a      	strb	r2, [r3, #0]
 8009254:	bd08      	pop	{r3, pc}
 8009256:	bf00      	nop
 8009258:	08009211 	.word	0x08009211
 800925c:	2000c9f5 	.word	0x2000c9f5

08009260 <chprintf.constprop.1>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8009260:	b40e      	push	{r1, r2, r3}
 8009262:	b500      	push	{lr}
 8009264:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8009266:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 8009268:	461a      	mov	r2, r3
 800926a:	4905      	ldr	r1, [pc, #20]	; (8009280 <chprintf.constprop.1+0x20>)
 800926c:	4805      	ldr	r0, [pc, #20]	; (8009284 <chprintf.constprop.1+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800926e:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8009270:	f007 fd46 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8009274:	b002      	add	sp, #8
 8009276:	f85d eb04 	ldr.w	lr, [sp], #4
 800927a:	b003      	add	sp, #12
 800927c:	4770      	bx	lr
 800927e:	bf00      	nop
 8009280:	08016fe0 	.word	0x08016fe0
 8009284:	200180c8 	.word	0x200180c8
 8009288:	f3af 8000 	nop.w
 800928c:	f3af 8000 	nop.w

08009290 <pbuf_alloced_custom>:
 *        big enough to hold 'length' plus the header size
 */
struct pbuf*
pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
                    void *payload_mem, u16_t payload_mem_len)
{
 8009290:	b570      	push	{r4, r5, r6, lr}
 8009292:	b082      	sub	sp, #8
 8009294:	9d06      	ldr	r5, [sp, #24]
 8009296:	f8bd 601c 	ldrh.w	r6, [sp, #28]
  u16_t offset;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (l) {
 800929a:	2803      	cmp	r0, #3
 800929c:	d822      	bhi.n	80092e4 <pbuf_alloced_custom+0x54>
 800929e:	e8df f000 	tbb	[pc, r0]
 80092a2:	181b      	.short	0x181b
 80092a4:	1e02      	.short	0x1e02
 80092a6:	2410      	movs	r4, #16
 80092a8:	2011      	movs	r0, #17
  default:
    LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
    return NULL;
  }

  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
 80092aa:	440c      	add	r4, r1
 80092ac:	42b4      	cmp	r4, r6
 80092ae:	dc2a      	bgt.n	8009306 <pbuf_alloced_custom+0x76>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
    return NULL;
  }

  p->pbuf.next = NULL;
 80092b0:	2400      	movs	r4, #0
 80092b2:	601c      	str	r4, [r3, #0]
  if (payload_mem != NULL) {
 80092b4:	b32d      	cbz	r5, 8009302 <pbuf_alloced_custom+0x72>
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
 80092b6:	f020 0003 	bic.w	r0, r0, #3
 80092ba:	4428      	add	r0, r5
 80092bc:	6058      	str	r0, [r3, #4]
    p->pbuf.payload = NULL;
  }
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
  p->pbuf.len = p->pbuf.tot_len = length;
  p->pbuf.type = type;
  p->pbuf.ref = 1;
 80092be:	2001      	movs	r0, #1
  if (payload_mem != NULL) {
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
  } else {
    p->pbuf.payload = NULL;
  }
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
 80092c0:	2402      	movs	r4, #2
  p->pbuf.len = p->pbuf.tot_len = length;
  p->pbuf.type = type;
  p->pbuf.ref = 1;
 80092c2:	81d8      	strh	r0, [r3, #14]
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
  } else {
    p->pbuf.payload = NULL;
  }
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
  p->pbuf.len = p->pbuf.tot_len = length;
 80092c4:	8119      	strh	r1, [r3, #8]
 80092c6:	8159      	strh	r1, [r3, #10]
  p->pbuf.type = type;
 80092c8:	731a      	strb	r2, [r3, #12]
  if (payload_mem != NULL) {
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
  } else {
    p->pbuf.payload = NULL;
  }
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
 80092ca:	735c      	strb	r4, [r3, #13]
  p->pbuf.len = p->pbuf.tot_len = length;
  p->pbuf.type = type;
  p->pbuf.ref = 1;
  return &p->pbuf;
 80092cc:	4618      	mov	r0, r3
}
 80092ce:	b002      	add	sp, #8
 80092d0:	bd70      	pop	{r4, r5, r6, pc}
{
  u16_t offset;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (l) {
 80092d2:	2424      	movs	r4, #36	; 0x24
 80092d4:	2025      	movs	r0, #37	; 0x25
 80092d6:	e7e8      	b.n	80092aa <pbuf_alloced_custom+0x1a>
 80092d8:	2438      	movs	r4, #56	; 0x38
 80092da:	2039      	movs	r0, #57	; 0x39
 80092dc:	e7e5      	b.n	80092aa <pbuf_alloced_custom+0x1a>
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    offset = 0;
    break;
 80092de:	2400      	movs	r4, #0
 80092e0:	2003      	movs	r0, #3
 80092e2:	e7e2      	b.n	80092aa <pbuf_alloced_custom+0x1a>
  default:
    LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
 80092e4:	4b09      	ldr	r3, [pc, #36]	; (800930c <pbuf_alloced_custom+0x7c>)
 80092e6:	9300      	str	r3, [sp, #0]
 80092e8:	4909      	ldr	r1, [pc, #36]	; (8009310 <pbuf_alloced_custom+0x80>)
 80092ea:	4a0a      	ldr	r2, [pc, #40]	; (8009314 <pbuf_alloced_custom+0x84>)
 80092ec:	480a      	ldr	r0, [pc, #40]	; (8009318 <pbuf_alloced_custom+0x88>)
 80092ee:	f240 1387 	movw	r3, #391	; 0x187
 80092f2:	f7ff ffb5 	bl	8009260 <chprintf.constprop.1>
 80092f6:	4807      	ldr	r0, [pc, #28]	; (8009314 <pbuf_alloced_custom+0x84>)
 80092f8:	f7f7 fe3a 	bl	8000f70 <chSysHalt>
    return NULL;
 80092fc:	2000      	movs	r0, #0
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
  p->pbuf.len = p->pbuf.tot_len = length;
  p->pbuf.type = type;
  p->pbuf.ref = 1;
  return &p->pbuf;
}
 80092fe:	b002      	add	sp, #8
 8009300:	bd70      	pop	{r4, r5, r6, pc}

  p->pbuf.next = NULL;
  if (payload_mem != NULL) {
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
  } else {
    p->pbuf.payload = NULL;
 8009302:	605d      	str	r5, [r3, #4]
 8009304:	e7db      	b.n	80092be <pbuf_alloced_custom+0x2e>
    return NULL;
  }

  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
    return NULL;
 8009306:	2000      	movs	r0, #0
 8009308:	e7e1      	b.n	80092ce <pbuf_alloced_custom+0x3e>
 800930a:	bf00      	nop
 800930c:	08017514 	.word	0x08017514
 8009310:	08016fe0 	.word	0x08016fe0
 8009314:	080174f0 	.word	0x080174f0
 8009318:	200180c8 	.word	0x200180c8
 800931c:	f3af 8000 	nop.w

08009320 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
 8009320:	b510      	push	{r4, lr}
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
 8009322:	4604      	mov	r4, r0
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
 8009324:	b082      	sub	sp, #8
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
 8009326:	2800      	cmp	r0, #0
 8009328:	d044      	beq.n	80093b4 <pbuf_header+0x94>
  if ((header_size_increment == 0) || (p == NULL)) {
 800932a:	2900      	cmp	r1, #0
 800932c:	d01a      	beq.n	8009364 <pbuf_header+0x44>
    return 0;
  }
 
  if (header_size_increment < 0){
 800932e:	db1c      	blt.n	800936a <pbuf_header+0x4a>
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
 8009330:	b28a      	uxth	r2, r1
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
 8009332:	7b23      	ldrb	r3, [r4, #12]
  /* remember current payload pointer */
  payload = p->payload;
 8009334:	6860      	ldr	r0, [r4, #4]

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
 8009336:	b143      	cbz	r3, 800934a <pbuf_header+0x2a>
 8009338:	2b03      	cmp	r3, #3
 800933a:	d006      	beq.n	800934a <pbuf_header+0x2a>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
 800933c:	3b01      	subs	r3, #1
 800933e:	2b01      	cmp	r3, #1
 8009340:	d82a      	bhi.n	8009398 <pbuf_header+0x78>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 8009342:	2900      	cmp	r1, #0
 8009344:	db44      	blt.n	80093d0 <pbuf_header+0xb0>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
 8009346:	2001      	movs	r0, #1
 8009348:	e00d      	b.n	8009366 <pbuf_header+0x46>
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
 800934a:	1a43      	subs	r3, r0, r1
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 800934c:	f104 0210 	add.w	r2, r4, #16
 8009350:	4293      	cmp	r3, r2
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
 8009352:	6063      	str	r3, [r4, #4]
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 8009354:	d31c      	bcc.n	8009390 <pbuf_header+0x70>
 8009356:	8963      	ldrh	r3, [r4, #10]
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  p->tot_len += header_size_increment;
 8009358:	8922      	ldrh	r2, [r4, #8]
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
 800935a:	b289      	uxth	r1, r1
 800935c:	440b      	add	r3, r1
  p->tot_len += header_size_increment;
 800935e:	4411      	add	r1, r2
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
 8009360:	8163      	strh	r3, [r4, #10]
  p->tot_len += header_size_increment;
 8009362:	8121      	strh	r1, [r4, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
 8009364:	2000      	movs	r0, #0
}
 8009366:	b002      	add	sp, #8
 8009368:	bd10      	pop	{r4, pc}
  if ((header_size_increment == 0) || (p == NULL)) {
    return 0;
  }
 
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
 800936a:	424a      	negs	r2, r1
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 800936c:	8963      	ldrh	r3, [r4, #10]
  if ((header_size_increment == 0) || (p == NULL)) {
    return 0;
  }
 
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
 800936e:	b292      	uxth	r2, r2
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 8009370:	4293      	cmp	r3, r2
 8009372:	d2de      	bcs.n	8009332 <pbuf_header+0x12>
 8009374:	4b19      	ldr	r3, [pc, #100]	; (80093dc <pbuf_header+0xbc>)
 8009376:	9300      	str	r3, [sp, #0]
 8009378:	4919      	ldr	r1, [pc, #100]	; (80093e0 <pbuf_header+0xc0>)
 800937a:	4a1a      	ldr	r2, [pc, #104]	; (80093e4 <pbuf_header+0xc4>)
 800937c:	481a      	ldr	r0, [pc, #104]	; (80093e8 <pbuf_header+0xc8>)
 800937e:	f240 230d 	movw	r3, #525	; 0x20d
 8009382:	f7ff ff6d 	bl	8009260 <chprintf.constprop.1>
 8009386:	4817      	ldr	r0, [pc, #92]	; (80093e4 <pbuf_header+0xc4>)
 8009388:	f7f7 fdf2 	bl	8000f70 <chSysHalt>
 800938c:	2001      	movs	r0, #1
 800938e:	e7ea      	b.n	8009366 <pbuf_header+0x46>
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload, (void *)(p + 1)));
      /* restore old payload pointer */
      p->payload = payload;
 8009390:	6060      	str	r0, [r4, #4]
      /* bail out unsuccesfully */
      return 1;
 8009392:	2001      	movs	r0, #1

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
}
 8009394:	b002      	add	sp, #8
 8009396:	bd10      	pop	{r4, pc}
       * bail out unsuccesfully */
      return 1;
    }
  } else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
 8009398:	4b10      	ldr	r3, [pc, #64]	; (80093dc <pbuf_header+0xbc>)
 800939a:	9300      	str	r3, [sp, #0]
 800939c:	4910      	ldr	r1, [pc, #64]	; (80093e0 <pbuf_header+0xc0>)
 800939e:	4a13      	ldr	r2, [pc, #76]	; (80093ec <pbuf_header+0xcc>)
 80093a0:	4811      	ldr	r0, [pc, #68]	; (80093e8 <pbuf_header+0xc8>)
 80093a2:	f240 233b 	movw	r3, #571	; 0x23b
 80093a6:	f7ff ff5b 	bl	8009260 <chprintf.constprop.1>
 80093aa:	4810      	ldr	r0, [pc, #64]	; (80093ec <pbuf_header+0xcc>)
 80093ac:	f7f7 fde0 	bl	8000f70 <chSysHalt>
    return 1;
 80093b0:	2001      	movs	r0, #1
 80093b2:	e7d8      	b.n	8009366 <pbuf_header+0x46>
{
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
 80093b4:	4b09      	ldr	r3, [pc, #36]	; (80093dc <pbuf_header+0xbc>)
 80093b6:	9300      	str	r3, [sp, #0]
 80093b8:	4909      	ldr	r1, [pc, #36]	; (80093e0 <pbuf_header+0xc0>)
 80093ba:	4a0d      	ldr	r2, [pc, #52]	; (80093f0 <pbuf_header+0xd0>)
 80093bc:	480a      	ldr	r0, [pc, #40]	; (80093e8 <pbuf_header+0xc8>)
 80093be:	f240 2305 	movw	r3, #517	; 0x205
 80093c2:	f7ff ff4d 	bl	8009260 <chprintf.constprop.1>
 80093c6:	480a      	ldr	r0, [pc, #40]	; (80093f0 <pbuf_header+0xd0>)
 80093c8:	f7f7 fdd2 	bl	8000f70 <chSysHalt>
  if ((header_size_increment == 0) || (p == NULL)) {
    return 0;
 80093cc:	4620      	mov	r0, r4
 80093ce:	e7ca      	b.n	8009366 <pbuf_header+0x46>
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 80093d0:	8963      	ldrh	r3, [r4, #10]
 80093d2:	429a      	cmp	r2, r3
 80093d4:	d8b7      	bhi.n	8009346 <pbuf_header+0x26>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
 80093d6:	1a40      	subs	r0, r0, r1
 80093d8:	6060      	str	r0, [r4, #4]
 80093da:	e7bd      	b.n	8009358 <pbuf_header+0x38>
 80093dc:	08017514 	.word	0x08017514
 80093e0:	08016fe0 	.word	0x08016fe0
 80093e4:	08017540 	.word	0x08017540
 80093e8:	200180c8 	.word	0x200180c8
 80093ec:	08017560 	.word	0x08017560
 80093f0:	08018be8 	.word	0x08018be8
 80093f4:	f3af 8000 	nop.w
 80093f8:	f3af 8000 	nop.w
 80093fc:	f3af 8000 	nop.w

08009400 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 8009400:	b5f0      	push	{r4, r5, r6, r7, lr}
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 8009402:	4604      	mov	r4, r0
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 8009404:	b083      	sub	sp, #12
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 8009406:	2800      	cmp	r0, #0
 8009408:	d05a      	beq.n	80094c0 <pbuf_free+0xc0>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
 800940a:	7b03      	ldrb	r3, [r0, #12]
 800940c:	2b03      	cmp	r3, #3
 800940e:	d84a      	bhi.n	80094a6 <pbuf_free+0xa6>
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 8009410:	2500      	movs	r5, #0
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 8009412:	4e32      	ldr	r6, [pc, #200]	; (80094dc <pbuf_free+0xdc>)
 8009414:	e008      	b.n	8009428 <pbuf_free+0x28>
      type = p->type;
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
        struct pbuf_custom *pc = (struct pbuf_custom*)p;
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
 8009416:	6923      	ldr	r3, [r4, #16]
 8009418:	2b00      	cmp	r3, #0
 800941a:	d037      	beq.n	800948c <pbuf_free+0x8c>
        pc->custom_free_function(p);
 800941c:	4620      	mov	r0, r4
 800941e:	4798      	blx	r3
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
        }
      }
      count++;
 8009420:	3501      	adds	r5, #1
 8009422:	b2ed      	uxtb	r5, r5
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 8009424:	b1c7      	cbz	r7, 8009458 <pbuf_free+0x58>
 8009426:	463c      	mov	r4, r7
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 8009428:	89e3      	ldrh	r3, [r4, #14]
 800942a:	b1c3      	cbz	r3, 800945e <pbuf_free+0x5e>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
 800942c:	3b01      	subs	r3, #1
 800942e:	b29b      	uxth	r3, r3
 8009430:	81e3      	strh	r3, [r4, #14]
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
 8009432:	b98b      	cbnz	r3, 8009458 <pbuf_free+0x58>
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 8009434:	7b62      	ldrb	r2, [r4, #13]
    ref = --(p->ref);
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
      /* remember next pbuf in chain for next iteration */
      q = p->next;
 8009436:	6827      	ldr	r7, [r4, #0]
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
 8009438:	7b23      	ldrb	r3, [r4, #12]
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 800943a:	0792      	lsls	r2, r2, #30
 800943c:	d4eb      	bmi.n	8009416 <pbuf_free+0x16>
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
      /* remember next pbuf in chain for next iteration */
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
 800943e:	b29b      	uxth	r3, r3
        pc->custom_free_function(p);
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
 8009440:	2b03      	cmp	r3, #3
 8009442:	d01e      	beq.n	8009482 <pbuf_free+0x82>
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 8009444:	3b01      	subs	r3, #1
 8009446:	2b01      	cmp	r3, #1
 8009448:	d916      	bls.n	8009478 <pbuf_free+0x78>
          memp_free(MEMP_PBUF, p);
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
 800944a:	4620      	mov	r0, r4
        }
      }
      count++;
 800944c:	3501      	adds	r5, #1
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
          memp_free(MEMP_PBUF, p);
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
 800944e:	f7ff fa47 	bl	80088e0 <mem_free>
        }
      }
      count++;
 8009452:	b2ed      	uxtb	r5, r5
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 8009454:	2f00      	cmp	r7, #0
 8009456:	d1e6      	bne.n	8009426 <pbuf_free+0x26>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
 8009458:	4628      	mov	r0, r5
}
 800945a:	b003      	add	sp, #12
 800945c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 800945e:	f240 238a 	movw	r3, #650	; 0x28a
 8009462:	491f      	ldr	r1, [pc, #124]	; (80094e0 <pbuf_free+0xe0>)
 8009464:	4a1f      	ldr	r2, [pc, #124]	; (80094e4 <pbuf_free+0xe4>)
 8009466:	9600      	str	r6, [sp, #0]
 8009468:	481f      	ldr	r0, [pc, #124]	; (80094e8 <pbuf_free+0xe8>)
 800946a:	f7ff fef9 	bl	8009260 <chprintf.constprop.1>
 800946e:	481d      	ldr	r0, [pc, #116]	; (80094e4 <pbuf_free+0xe4>)
 8009470:	f7f7 fd7e 	bl	8000f70 <chSysHalt>
 8009474:	89e3      	ldrh	r3, [r4, #14]
 8009476:	e7d9      	b.n	800942c <pbuf_free+0x2c>
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
          memp_free(MEMP_PBUF, p);
 8009478:	4621      	mov	r1, r4
 800947a:	200c      	movs	r0, #12
 800947c:	f7ff fda0 	bl	8008fc0 <memp_free>
 8009480:	e7ce      	b.n	8009420 <pbuf_free+0x20>
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
          memp_free(MEMP_PBUF_POOL, p);
 8009482:	4621      	mov	r1, r4
 8009484:	200d      	movs	r0, #13
 8009486:	f7ff fd9b 	bl	8008fc0 <memp_free>
 800948a:	e7c9      	b.n	8009420 <pbuf_free+0x20>
      type = p->type;
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
        struct pbuf_custom *pc = (struct pbuf_custom*)p;
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
 800948c:	f44f 7326 	mov.w	r3, #664	; 0x298
 8009490:	4913      	ldr	r1, [pc, #76]	; (80094e0 <pbuf_free+0xe0>)
 8009492:	4a16      	ldr	r2, [pc, #88]	; (80094ec <pbuf_free+0xec>)
 8009494:	9600      	str	r6, [sp, #0]
 8009496:	4814      	ldr	r0, [pc, #80]	; (80094e8 <pbuf_free+0xe8>)
 8009498:	f7ff fee2 	bl	8009260 <chprintf.constprop.1>
 800949c:	4813      	ldr	r0, [pc, #76]	; (80094ec <pbuf_free+0xec>)
 800949e:	f7f7 fd67 	bl	8000f70 <chSysHalt>
 80094a2:	6923      	ldr	r3, [r4, #16]
 80094a4:	e7ba      	b.n	800941c <pbuf_free+0x1c>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
 80094a6:	4b0d      	ldr	r3, [pc, #52]	; (80094dc <pbuf_free+0xdc>)
 80094a8:	9300      	str	r3, [sp, #0]
 80094aa:	490d      	ldr	r1, [pc, #52]	; (80094e0 <pbuf_free+0xe0>)
 80094ac:	4a10      	ldr	r2, [pc, #64]	; (80094f0 <pbuf_free+0xf0>)
 80094ae:	480e      	ldr	r0, [pc, #56]	; (80094e8 <pbuf_free+0xe8>)
 80094b0:	f240 237d 	movw	r3, #637	; 0x27d
 80094b4:	f7ff fed4 	bl	8009260 <chprintf.constprop.1>
 80094b8:	480d      	ldr	r0, [pc, #52]	; (80094f0 <pbuf_free+0xf0>)
 80094ba:	f7f7 fd59 	bl	8000f70 <chSysHalt>
 80094be:	e7a7      	b.n	8009410 <pbuf_free+0x10>
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
    LWIP_ASSERT("p != NULL", p != NULL);
 80094c0:	4b06      	ldr	r3, [pc, #24]	; (80094dc <pbuf_free+0xdc>)
 80094c2:	9300      	str	r3, [sp, #0]
 80094c4:	4906      	ldr	r1, [pc, #24]	; (80094e0 <pbuf_free+0xe0>)
 80094c6:	4a0b      	ldr	r2, [pc, #44]	; (80094f4 <pbuf_free+0xf4>)
 80094c8:	4807      	ldr	r0, [pc, #28]	; (80094e8 <pbuf_free+0xe8>)
 80094ca:	f240 2371 	movw	r3, #625	; 0x271
 80094ce:	f7ff fec7 	bl	8009260 <chprintf.constprop.1>
 80094d2:	4808      	ldr	r0, [pc, #32]	; (80094f4 <pbuf_free+0xf4>)
 80094d4:	f7f7 fd4c 	bl	8000f70 <chSysHalt>
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("pbuf_free(p == NULL) was called.\n"));
    return 0;
 80094d8:	4620      	mov	r0, r4
 80094da:	e7be      	b.n	800945a <pbuf_free+0x5a>
 80094dc:	08017514 	.word	0x08017514
 80094e0:	08016fe0 	.word	0x08016fe0
 80094e4:	08017588 	.word	0x08017588
 80094e8:	200180c8 	.word	0x200180c8
 80094ec:	080175a0 	.word	0x080175a0
 80094f0:	08017570 	.word	0x08017570
 80094f4:	08018be8 	.word	0x08018be8
 80094f8:	f3af 8000 	nop.w
 80094fc:	f3af 8000 	nop.w

08009500 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
 8009500:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8009504:	460f      	mov	r7, r1
 8009506:	b085      	sub	sp, #20
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (layer) {
 8009508:	2803      	cmp	r0, #3
 800950a:	f200 80b5 	bhi.w	8009678 <pbuf_alloc+0x178>
 800950e:	e8df f000 	tbb	[pc, r0]
 8009512:	9d9f      	.short	0x9d9f
 8009514:	a102      	.short	0xa102
    /* add room for IP layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
    break;
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
 8009516:	240e      	movs	r4, #14
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
 8009518:	2a03      	cmp	r2, #3
 800951a:	f200 809d 	bhi.w	8009658 <pbuf_alloc+0x158>
 800951e:	e8df f002 	tbb	[pc, r2]
 8009522:	6675      	.short	0x6675
 8009524:	0266      	.short	0x0266
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8009526:	200d      	movs	r0, #13
 8009528:	f7ff fcf2 	bl	8008f10 <memp_malloc>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
 800952c:	4605      	mov	r5, r0
 800952e:	2800      	cmp	r0, #0
 8009530:	f000 80d9 	beq.w	80096e6 <pbuf_alloc+0x1e6>
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 8009534:	1ce6      	adds	r6, r4, #3
 8009536:	f026 0603 	bic.w	r6, r6, #3
 800953a:	f5c6 66bd 	rsb	r6, r6, #1512	; 0x5e8
 800953e:	3604      	adds	r6, #4
    }
    p->type = type;
    p->next = NULL;

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 8009540:	4404      	add	r4, r0
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 8009542:	42be      	cmp	r6, r7
    }
    p->type = type;
    p->next = NULL;

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 8009544:	f104 0413 	add.w	r4, r4, #19
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 8009548:	bfa8      	it	ge
 800954a:	463e      	movge	r6, r7
    }
    p->type = type;
    p->next = NULL;

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 800954c:	f024 0403 	bic.w	r4, r4, #3
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 8009550:	19a3      	adds	r3, r4, r6
 8009552:	f200 58fc 	addw	r8, r0, #1532	; 0x5fc
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 8009556:	b2b6      	uxth	r6, r6
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
      PBUF_POOL_IS_EMPTY();
      return NULL;
    }
    p->type = type;
 8009558:	2103      	movs	r1, #3
    p->next = NULL;
 800955a:	2200      	movs	r2, #0
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 800955c:	4598      	cmp	r8, r3
    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
 800955e:	8107      	strh	r7, [r0, #8]
    }
    p->type = type;
    p->next = NULL;

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 8009560:	6044      	str	r4, [r0, #4]
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 8009562:	8146      	strh	r6, [r0, #10]
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
      PBUF_POOL_IS_EMPTY();
      return NULL;
    }
    p->type = type;
 8009564:	7301      	strb	r1, [r0, #12]
    p->next = NULL;
 8009566:	6002      	str	r2, [r0, #0]
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 8009568:	f0c0 80c9 	bcc.w	80096fe <pbuf_alloc+0x1fe>
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
 800956c:	1bbe      	subs	r6, r7, r6
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
 800956e:	2301      	movs	r3, #1
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 8009570:	2e00      	cmp	r6, #0
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
 8009572:	81eb      	strh	r3, [r5, #14]
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 8009574:	dd62      	ble.n	800963c <pbuf_alloc+0x13c>
      q->flags = 0;
      q->next = NULL;
      /* make previous pbuf point to this pbuf */
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
 8009576:	f8df 91b0 	ldr.w	r9, [pc, #432]	; 8009728 <pbuf_alloc+0x228>
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 800957a:	462f      	mov	r7, r5
 800957c:	e019      	b.n	80095b2 <pbuf_alloc+0xb2>
      q->next = NULL;
      /* make previous pbuf point to this pbuf */
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
 800957e:	b2b1      	uxth	r1, r6
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 8009580:	f240 52ec 	movw	r2, #1516	; 0x5ec
 8009584:	428a      	cmp	r2, r1
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 8009586:	f104 0310 	add.w	r3, r4, #16
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 800958a:	bf28      	it	cs
 800958c:	460a      	movcs	r2, r1
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 800958e:	6063      	str	r3, [r4, #4]
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 8009590:	079b      	lsls	r3, r3, #30
      q->next = NULL;
      /* make previous pbuf point to this pbuf */
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
 8009592:	8121      	strh	r1, [r4, #8]
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 8009594:	8162      	strh	r2, [r4, #10]
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 8009596:	f040 8099 	bne.w	80096cc <pbuf_alloc+0x1cc>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 800959a:	896b      	ldrh	r3, [r5, #10]
 800959c:	686a      	ldr	r2, [r5, #4]
 800959e:	4413      	add	r3, r2
 80095a0:	4598      	cmp	r8, r3
 80095a2:	f0c0 8086 	bcc.w	80096b2 <pbuf_alloc+0x1b2>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
 80095a6:	8962      	ldrh	r2, [r4, #10]
 80095a8:	1ab6      	subs	r6, r6, r2
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
 80095aa:	2301      	movs	r3, #1
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 80095ac:	2e00      	cmp	r6, #0
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
 80095ae:	81e3      	strh	r3, [r4, #14]
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 80095b0:	dd44      	ble.n	800963c <pbuf_alloc+0x13c>
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 80095b2:	200d      	movs	r0, #13
 80095b4:	f7ff fcac 	bl	8008f10 <memp_malloc>
        pbuf_free(p);
        /* bail out unsuccesfully */
        return NULL;
      }
      q->type = type;
      q->flags = 0;
 80095b8:	2300      	movs	r3, #0
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
      if (q == NULL) {
 80095ba:	4604      	mov	r4, r0
        /* free chain so far allocated */
        pbuf_free(p);
        /* bail out unsuccesfully */
        return NULL;
      }
      q->type = type;
 80095bc:	2103      	movs	r1, #3
      q->flags = 0;
      q->next = NULL;
      /* make previous pbuf point to this pbuf */
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
 80095be:	f64f 72ff 	movw	r2, #65535	; 0xffff
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
      if (q == NULL) {
 80095c2:	2800      	cmp	r0, #0
 80095c4:	d067      	beq.n	8009696 <pbuf_alloc+0x196>
      q->flags = 0;
      q->next = NULL;
      /* make previous pbuf point to this pbuf */
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
 80095c6:	4296      	cmp	r6, r2
        /* free chain so far allocated */
        pbuf_free(p);
        /* bail out unsuccesfully */
        return NULL;
      }
      q->type = type;
 80095c8:	7301      	strb	r1, [r0, #12]
      q->flags = 0;
 80095ca:	7343      	strb	r3, [r0, #13]
      q->next = NULL;
 80095cc:	6003      	str	r3, [r0, #0]
      /* make previous pbuf point to this pbuf */
      r->next = q;
 80095ce:	6038      	str	r0, [r7, #0]
 80095d0:	4607      	mov	r7, r0
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
 80095d2:	d1d4      	bne.n	800957e <pbuf_alloc+0x7e>
 80095d4:	f8cd 9000 	str.w	r9, [sp]
 80095d8:	4950      	ldr	r1, [pc, #320]	; (800971c <pbuf_alloc+0x21c>)
 80095da:	4a51      	ldr	r2, [pc, #324]	; (8009720 <pbuf_alloc+0x220>)
 80095dc:	4851      	ldr	r0, [pc, #324]	; (8009724 <pbuf_alloc+0x224>)
 80095de:	f44f 738f 	mov.w	r3, #286	; 0x11e
 80095e2:	f7ff fe3d 	bl	8009260 <chprintf.constprop.1>
 80095e6:	484e      	ldr	r0, [pc, #312]	; (8009720 <pbuf_alloc+0x220>)
 80095e8:	f7f7 fcc2 	bl	8000f70 <chSysHalt>
 80095ec:	e7c7      	b.n	800957e <pbuf_alloc+0x7e>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 80095ee:	200c      	movs	r0, #12
 80095f0:	9203      	str	r2, [sp, #12]
 80095f2:	f7ff fc8d 	bl	8008f10 <memp_malloc>
    if (p == NULL) {
 80095f6:	4605      	mov	r5, r0
 80095f8:	2800      	cmp	r0, #0
 80095fa:	d056      	beq.n	80096aa <pbuf_alloc+0x1aa>
                  ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
 80095fc:	2300      	movs	r3, #0
    p->len = p->tot_len = length;
    p->next = NULL;
    p->type = type;
 80095fe:	9a03      	ldr	r2, [sp, #12]
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
    p->len = p->tot_len = length;
 8009600:	8107      	strh	r7, [r0, #8]
 8009602:	8147      	strh	r7, [r0, #10]
    p->next = NULL;
    p->type = type;
 8009604:	7302      	strb	r2, [r0, #12]
                  ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
 8009606:	6043      	str	r3, [r0, #4]
    p->len = p->tot_len = length;
    p->next = NULL;
 8009608:	6003      	str	r3, [r0, #0]
    p->type = type;
    break;
 800960a:	e017      	b.n	800963c <pbuf_alloc+0x13c>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
 800960c:	f104 0013 	add.w	r0, r4, #19
 8009610:	1cfb      	adds	r3, r7, #3
 8009612:	f023 0303 	bic.w	r3, r3, #3
 8009616:	f020 0003 	bic.w	r0, r0, #3
 800961a:	4418      	add	r0, r3
 800961c:	b280      	uxth	r0, r0
 800961e:	f7ff fb1f 	bl	8008c60 <mem_malloc>
    if (p == NULL) {
 8009622:	4605      	mov	r5, r0
 8009624:	2800      	cmp	r0, #0
 8009626:	d040      	beq.n	80096aa <pbuf_alloc+0x1aa>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 8009628:	4404      	add	r4, r0
 800962a:	3413      	adds	r4, #19
    p->len = p->tot_len = length;
    p->next = NULL;
 800962c:	2300      	movs	r3, #0
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    if (p == NULL) {
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 800962e:	f024 0403 	bic.w	r4, r4, #3
 8009632:	6044      	str	r4, [r0, #4]
    p->len = p->tot_len = length;
 8009634:	8107      	strh	r7, [r0, #8]
 8009636:	8147      	strh	r7, [r0, #10]
    p->next = NULL;
 8009638:	6003      	str	r3, [r0, #0]
    p->type = type;
 800963a:	7303      	strb	r3, [r0, #12]
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
 800963c:	2201      	movs	r2, #1
  /* set flags */
  p->flags = 0;
 800963e:	2300      	movs	r3, #0
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
 8009640:	4628      	mov	r0, r5
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
 8009642:	81ea      	strh	r2, [r5, #14]
  /* set flags */
  p->flags = 0;
 8009644:	736b      	strb	r3, [r5, #13]
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
 8009646:	b005      	add	sp, #20
 8009648:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
    break;
  case PBUF_IP:
    /* add room for IP layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
 800964c:	2422      	movs	r4, #34	; 0x22
 800964e:	e763      	b.n	8009518 <pbuf_alloc+0x18>

  /* determine header offset */
  switch (layer) {
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 8009650:	2436      	movs	r4, #54	; 0x36
 8009652:	e761      	b.n	8009518 <pbuf_alloc+0x18>
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    offset = 0;
 8009654:	2400      	movs	r4, #0
    break;
 8009656:	e75f      	b.n	8009518 <pbuf_alloc+0x18>
    p->len = p->tot_len = length;
    p->next = NULL;
    p->type = type;
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
 8009658:	4b33      	ldr	r3, [pc, #204]	; (8009728 <pbuf_alloc+0x228>)
 800965a:	9300      	str	r3, [sp, #0]
 800965c:	492f      	ldr	r1, [pc, #188]	; (800971c <pbuf_alloc+0x21c>)
 800965e:	4a33      	ldr	r2, [pc, #204]	; (800972c <pbuf_alloc+0x22c>)
 8009660:	4830      	ldr	r0, [pc, #192]	; (8009724 <pbuf_alloc+0x224>)
 8009662:	f44f 73aa 	mov.w	r3, #340	; 0x154
 8009666:	f7ff fdfb 	bl	8009260 <chprintf.constprop.1>
 800966a:	4830      	ldr	r0, [pc, #192]	; (800972c <pbuf_alloc+0x22c>)
 800966c:	f7f7 fc80 	bl	8000f70 <chSysHalt>
    return NULL;
 8009670:	2000      	movs	r0, #0
  p->ref = 1;
  /* set flags */
  p->flags = 0;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
 8009672:	b005      	add	sp, #20
 8009674:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    break;
  case PBUF_RAW:
    offset = 0;
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
 8009678:	4b2b      	ldr	r3, [pc, #172]	; (8009728 <pbuf_alloc+0x228>)
 800967a:	9300      	str	r3, [sp, #0]
 800967c:	4927      	ldr	r1, [pc, #156]	; (800971c <pbuf_alloc+0x21c>)
 800967e:	4a2c      	ldr	r2, [pc, #176]	; (8009730 <pbuf_alloc+0x230>)
 8009680:	4828      	ldr	r0, [pc, #160]	; (8009724 <pbuf_alloc+0x224>)
 8009682:	23e8      	movs	r3, #232	; 0xe8
 8009684:	f7ff fdec 	bl	8009260 <chprintf.constprop.1>
 8009688:	4829      	ldr	r0, [pc, #164]	; (8009730 <pbuf_alloc+0x230>)
 800968a:	f7f7 fc71 	bl	8000f70 <chSysHalt>
    return NULL;
 800968e:	2000      	movs	r0, #0
  p->ref = 1;
  /* set flags */
  p->flags = 0;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
 8009690:	b005      	add	sp, #20
 8009692:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  SYS_ARCH_UNPROTECT(old_level);
#else /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
  u8_t queued;
  SYS_ARCH_DECL_PROTECT(old_level);
  SYS_ARCH_PROTECT(old_level);
  queued = pbuf_free_ooseq_pending;
 8009696:	4b27      	ldr	r3, [pc, #156]	; (8009734 <pbuf_alloc+0x234>)
 8009698:	781a      	ldrb	r2, [r3, #0]
  pbuf_free_ooseq_pending = 1;
 800969a:	2101      	movs	r1, #1
 800969c:	7019      	strb	r1, [r3, #0]
  SYS_ARCH_UNPROTECT(old_level);

  if(!queued) {
 800969e:	b90a      	cbnz	r2, 80096a4 <pbuf_alloc+0x1a4>
 80096a0:	f7ff fdce 	bl	8009240 <pbuf_pool_is_empty.part.0>
    while (rem_len > 0) {
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
      if (q == NULL) {
        PBUF_POOL_IS_EMPTY();
        /* free chain so far allocated */
        pbuf_free(p);
 80096a4:	4628      	mov	r0, r5
 80096a6:	f7ff feab 	bl	8009400 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
 80096aa:	2000      	movs	r0, #0
  p->ref = 1;
  /* set flags */
  p->flags = 0;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
 80096ac:	b005      	add	sp, #20
 80096ae:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 80096b2:	f8cd 9000 	str.w	r9, [sp]
 80096b6:	4919      	ldr	r1, [pc, #100]	; (800971c <pbuf_alloc+0x21c>)
 80096b8:	4a1f      	ldr	r2, [pc, #124]	; (8009738 <pbuf_alloc+0x238>)
 80096ba:	481a      	ldr	r0, [pc, #104]	; (8009724 <pbuf_alloc+0x224>)
 80096bc:	f240 1327 	movw	r3, #295	; 0x127
 80096c0:	f7ff fdce 	bl	8009260 <chprintf.constprop.1>
 80096c4:	481c      	ldr	r0, [pc, #112]	; (8009738 <pbuf_alloc+0x238>)
 80096c6:	f7f7 fc53 	bl	8000f70 <chSysHalt>
 80096ca:	e76c      	b.n	80095a6 <pbuf_alloc+0xa6>
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 80096cc:	f8cd 9000 	str.w	r9, [sp]
 80096d0:	4912      	ldr	r1, [pc, #72]	; (800971c <pbuf_alloc+0x21c>)
 80096d2:	4a1a      	ldr	r2, [pc, #104]	; (800973c <pbuf_alloc+0x23c>)
 80096d4:	4813      	ldr	r0, [pc, #76]	; (8009724 <pbuf_alloc+0x224>)
 80096d6:	f44f 7392 	mov.w	r3, #292	; 0x124
 80096da:	f7ff fdc1 	bl	8009260 <chprintf.constprop.1>
 80096de:	4817      	ldr	r0, [pc, #92]	; (800973c <pbuf_alloc+0x23c>)
 80096e0:	f7f7 fc46 	bl	8000f70 <chSysHalt>
 80096e4:	e759      	b.n	800959a <pbuf_alloc+0x9a>
  SYS_ARCH_UNPROTECT(old_level);
#else /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
  u8_t queued;
  SYS_ARCH_DECL_PROTECT(old_level);
  SYS_ARCH_PROTECT(old_level);
  queued = pbuf_free_ooseq_pending;
 80096e6:	4a13      	ldr	r2, [pc, #76]	; (8009734 <pbuf_alloc+0x234>)
 80096e8:	7813      	ldrb	r3, [r2, #0]
  pbuf_free_ooseq_pending = 1;
 80096ea:	2101      	movs	r1, #1
 80096ec:	7011      	strb	r1, [r2, #0]
  SYS_ARCH_UNPROTECT(old_level);

  if(!queued) {
 80096ee:	f003 05ff 	and.w	r5, r3, #255	; 0xff
 80096f2:	2b00      	cmp	r3, #0
 80096f4:	d1d9      	bne.n	80096aa <pbuf_alloc+0x1aa>
 80096f6:	f7ff fda3 	bl	8009240 <pbuf_pool_is_empty.part.0>
    /* allocate head of pbuf chain into p */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
      PBUF_POOL_IS_EMPTY();
      return NULL;
 80096fa:	4628      	mov	r0, r5
 80096fc:	e7b9      	b.n	8009672 <pbuf_alloc+0x172>
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 80096fe:	4b0a      	ldr	r3, [pc, #40]	; (8009728 <pbuf_alloc+0x228>)
 8009700:	9300      	str	r3, [sp, #0]
 8009702:	4906      	ldr	r1, [pc, #24]	; (800971c <pbuf_alloc+0x21c>)
 8009704:	4a0c      	ldr	r2, [pc, #48]	; (8009738 <pbuf_alloc+0x238>)
 8009706:	4807      	ldr	r0, [pc, #28]	; (8009724 <pbuf_alloc+0x224>)
 8009708:	f44f 7381 	mov.w	r3, #258	; 0x102
 800970c:	f7ff fda8 	bl	8009260 <chprintf.constprop.1>
 8009710:	4809      	ldr	r0, [pc, #36]	; (8009738 <pbuf_alloc+0x238>)
 8009712:	f7f7 fc2d 	bl	8000f70 <chSysHalt>
 8009716:	896e      	ldrh	r6, [r5, #10]
 8009718:	e728      	b.n	800956c <pbuf_alloc+0x6c>
 800971a:	bf00      	nop
 800971c:	08016fe0 	.word	0x08016fe0
 8009720:	08017614 	.word	0x08017614
 8009724:	200180c8 	.word	0x200180c8
 8009728:	08017514 	.word	0x08017514
 800972c:	08017658 	.word	0x08017658
 8009730:	080175c4 	.word	0x080175c4
 8009734:	2000c9f5 	.word	0x2000c9f5
 8009738:	080175e0 	.word	0x080175e0
 800973c:	08017628 	.word	0x08017628

08009740 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
 8009740:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009742:	460d      	mov	r5, r1
 8009744:	b083      	sub	sp, #12
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 8009746:	4604      	mov	r4, r0
 8009748:	2800      	cmp	r0, #0
 800974a:	d059      	beq.n	8009800 <pbuf_realloc+0xc0>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
 800974c:	7b23      	ldrb	r3, [r4, #12]
 800974e:	2b03      	cmp	r3, #3
 8009750:	d90b      	bls.n	800976a <pbuf_realloc+0x2a>
 8009752:	4b39      	ldr	r3, [pc, #228]	; (8009838 <pbuf_realloc+0xf8>)
 8009754:	9300      	str	r3, [sp, #0]
 8009756:	4839      	ldr	r0, [pc, #228]	; (800983c <pbuf_realloc+0xfc>)
 8009758:	4939      	ldr	r1, [pc, #228]	; (8009840 <pbuf_realloc+0x100>)
 800975a:	4a3a      	ldr	r2, [pc, #232]	; (8009844 <pbuf_realloc+0x104>)
 800975c:	f44f 73dc 	mov.w	r3, #440	; 0x1b8
 8009760:	f7ff fd7e 	bl	8009260 <chprintf.constprop.1>
 8009764:	4837      	ldr	r0, [pc, #220]	; (8009844 <pbuf_realloc+0x104>)
 8009766:	f7f7 fc03 	bl	8000f70 <chSysHalt>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
 800976a:	8926      	ldrh	r6, [r4, #8]
 800976c:	42ae      	cmp	r6, r5
 800976e:	d945      	bls.n	80097fc <pbuf_realloc+0xbc>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
 8009770:	1bae      	subs	r6, r5, r6
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
 8009772:	4f31      	ldr	r7, [pc, #196]	; (8009838 <pbuf_realloc+0xf8>)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 8009774:	e004      	b.n	8009780 <pbuf_realloc+0x40>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    q->tot_len += (u16_t)grow;
 8009776:	8923      	ldrh	r3, [r4, #8]
 8009778:	4433      	add	r3, r6
 800977a:	8123      	strh	r3, [r4, #8]
    /* proceed to next pbuf in chain */
    q = q->next;
 800977c:	6824      	ldr	r4, [r4, #0]
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
 800977e:	b1cc      	cbz	r4, 80097b4 <pbuf_realloc+0x74>

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 8009780:	8961      	ldrh	r1, [r4, #10]
 8009782:	428d      	cmp	r5, r1
 8009784:	d924      	bls.n	80097d0 <pbuf_realloc+0x90>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
 8009786:	f64f 73fe 	movw	r3, #65534	; 0xfffe
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
 800978a:	1a69      	subs	r1, r5, r1
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
 800978c:	429e      	cmp	r6, r3
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
 800978e:	b28d      	uxth	r5, r1
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
 8009790:	ddf1      	ble.n	8009776 <pbuf_realloc+0x36>
 8009792:	f44f 73e6 	mov.w	r3, #460	; 0x1cc
 8009796:	492a      	ldr	r1, [pc, #168]	; (8009840 <pbuf_realloc+0x100>)
 8009798:	4a2b      	ldr	r2, [pc, #172]	; (8009848 <pbuf_realloc+0x108>)
 800979a:	9700      	str	r7, [sp, #0]
 800979c:	4827      	ldr	r0, [pc, #156]	; (800983c <pbuf_realloc+0xfc>)
 800979e:	f7ff fd5f 	bl	8009260 <chprintf.constprop.1>
 80097a2:	4829      	ldr	r0, [pc, #164]	; (8009848 <pbuf_realloc+0x108>)
 80097a4:	f7f7 fbe4 	bl	8000f70 <chSysHalt>
    q->tot_len += (u16_t)grow;
 80097a8:	8923      	ldrh	r3, [r4, #8]
 80097aa:	4433      	add	r3, r6
 80097ac:	8123      	strh	r3, [r4, #8]
    /* proceed to next pbuf in chain */
    q = q->next;
 80097ae:	6824      	ldr	r4, [r4, #0]
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
 80097b0:	2c00      	cmp	r4, #0
 80097b2:	d1e5      	bne.n	8009780 <pbuf_realloc+0x40>
 80097b4:	4922      	ldr	r1, [pc, #136]	; (8009840 <pbuf_realloc+0x100>)
 80097b6:	4a25      	ldr	r2, [pc, #148]	; (800984c <pbuf_realloc+0x10c>)
 80097b8:	9700      	str	r7, [sp, #0]
 80097ba:	f44f 73e8 	mov.w	r3, #464	; 0x1d0
 80097be:	481f      	ldr	r0, [pc, #124]	; (800983c <pbuf_realloc+0xfc>)
 80097c0:	f7ff fd4e 	bl	8009260 <chprintf.constprop.1>
 80097c4:	4821      	ldr	r0, [pc, #132]	; (800984c <pbuf_realloc+0x10c>)
 80097c6:	f7f7 fbd3 	bl	8000f70 <chSysHalt>

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 80097ca:	8961      	ldrh	r1, [r4, #10]
 80097cc:	428d      	cmp	r5, r1
 80097ce:	d8da      	bhi.n	8009786 <pbuf_realloc+0x46>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
 80097d0:	7b23      	ldrb	r3, [r4, #12]
 80097d2:	4626      	mov	r6, r4
 80097d4:	b953      	cbnz	r3, 80097ec <pbuf_realloc+0xac>
 80097d6:	42a9      	cmp	r1, r5
 80097d8:	d008      	beq.n	80097ec <pbuf_realloc+0xac>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
 80097da:	6863      	ldr	r3, [r4, #4]
 80097dc:	1b1b      	subs	r3, r3, r4
 80097de:	18e9      	adds	r1, r5, r3
 80097e0:	b289      	uxth	r1, r1
 80097e2:	4620      	mov	r0, r4
 80097e4:	f7ff f974 	bl	8008ad0 <mem_trim>
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
 80097e8:	4606      	mov	r6, r0
 80097ea:	b1b0      	cbz	r0, 800981a <pbuf_realloc+0xda>
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  q->tot_len = q->len;

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
 80097ec:	6830      	ldr	r0, [r6, #0]
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
 80097ee:	8175      	strh	r5, [r6, #10]
  q->tot_len = q->len;
 80097f0:	8135      	strh	r5, [r6, #8]

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
 80097f2:	b108      	cbz	r0, 80097f8 <pbuf_realloc+0xb8>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
 80097f4:	f7ff fe04 	bl	8009400 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
 80097f8:	2300      	movs	r3, #0
 80097fa:	6033      	str	r3, [r6, #0]

}
 80097fc:	b003      	add	sp, #12
 80097fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
{
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 8009800:	4b0d      	ldr	r3, [pc, #52]	; (8009838 <pbuf_realloc+0xf8>)
 8009802:	9300      	str	r3, [sp, #0]
 8009804:	490e      	ldr	r1, [pc, #56]	; (8009840 <pbuf_realloc+0x100>)
 8009806:	4a12      	ldr	r2, [pc, #72]	; (8009850 <pbuf_realloc+0x110>)
 8009808:	480c      	ldr	r0, [pc, #48]	; (800983c <pbuf_realloc+0xfc>)
 800980a:	f44f 73da 	mov.w	r3, #436	; 0x1b4
 800980e:	f7ff fd27 	bl	8009260 <chprintf.constprop.1>
 8009812:	480f      	ldr	r0, [pc, #60]	; (8009850 <pbuf_realloc+0x110>)
 8009814:	f7f7 fbac 	bl	8000f70 <chSysHalt>
 8009818:	e798      	b.n	800974c <pbuf_realloc+0xc>
  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
 800981a:	4b07      	ldr	r3, [pc, #28]	; (8009838 <pbuf_realloc+0xf8>)
 800981c:	9300      	str	r3, [sp, #0]
 800981e:	4908      	ldr	r1, [pc, #32]	; (8009840 <pbuf_realloc+0x100>)
 8009820:	4a0c      	ldr	r2, [pc, #48]	; (8009854 <pbuf_realloc+0x114>)
 8009822:	4806      	ldr	r0, [pc, #24]	; (800983c <pbuf_realloc+0xfc>)
 8009824:	f44f 73ed 	mov.w	r3, #474	; 0x1da
 8009828:	f7ff fd1a 	bl	8009260 <chprintf.constprop.1>
 800982c:	4809      	ldr	r0, [pc, #36]	; (8009854 <pbuf_realloc+0x114>)
 800982e:	f7f7 fb9f 	bl	8000f70 <chSysHalt>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
 8009832:	8176      	strh	r6, [r6, #10]
 8009834:	deff      	udf	#255	; 0xff
 8009836:	bf00      	nop
 8009838:	08017514 	.word	0x08017514
 800983c:	200180c8 	.word	0x200180c8
 8009840:	08016fe0 	.word	0x08016fe0
 8009844:	0801768c 	.word	0x0801768c
 8009848:	080176a8 	.word	0x080176a8
 800984c:	080176bc 	.word	0x080176bc
 8009850:	08017674 	.word	0x08017674
 8009854:	080176d4 	.word	0x080176d4
 8009858:	f3af 8000 	nop.w
 800985c:	f3af 8000 	nop.w

08009860 <pbuf_clen>:
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
 8009860:	4603      	mov	r3, r0
 8009862:	b130      	cbz	r0, 8009872 <pbuf_clen+0x12>
 8009864:	2000      	movs	r0, #0
    ++len;
    p = p->next;
 8009866:	681b      	ldr	r3, [r3, #0]
{
  u8_t len;

  len = 0;
  while (p != NULL) {
    ++len;
 8009868:	3001      	adds	r0, #1
 800986a:	b2c0      	uxtb	r0, r0
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
 800986c:	2b00      	cmp	r3, #0
 800986e:	d1fa      	bne.n	8009866 <pbuf_clen+0x6>
 8009870:	4770      	bx	lr
    ++len;
    p = p->next;
  }
  return len;
}
 8009872:	4770      	bx	lr
 8009874:	f3af 8000 	nop.w
 8009878:	f3af 8000 	nop.w
 800987c:	f3af 8000 	nop.w

08009880 <pbuf_ref>:
void
pbuf_ref(struct pbuf *p)
{
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
 8009880:	b110      	cbz	r0, 8009888 <pbuf_ref+0x8>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
 8009882:	89c3      	ldrh	r3, [r0, #14]
 8009884:	3301      	adds	r3, #1
 8009886:	81c3      	strh	r3, [r0, #14]
 8009888:	4770      	bx	lr
 800988a:	bf00      	nop
 800988c:	f3af 8000 	nop.w

08009890 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
 8009890:	b570      	push	{r4, r5, r6, lr}
 8009892:	b082      	sub	sp, #8
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 8009894:	2800      	cmp	r0, #0
 8009896:	d032      	beq.n	80098fe <pbuf_cat+0x6e>
 8009898:	460d      	mov	r5, r1
 800989a:	2900      	cmp	r1, #0
 800989c:	d02f      	beq.n	80098fe <pbuf_cat+0x6e>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 800989e:	6804      	ldr	r4, [r0, #0]
 80098a0:	b90c      	cbnz	r4, 80098a6 <pbuf_cat+0x16>
 80098a2:	e03b      	b.n	800991c <pbuf_cat+0x8c>
 80098a4:	4614      	mov	r4, r2
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
 80098a6:	8903      	ldrh	r3, [r0, #8]
 80098a8:	8929      	ldrh	r1, [r5, #8]

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 80098aa:	6822      	ldr	r2, [r4, #0]
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
 80098ac:	440b      	add	r3, r1
 80098ae:	8103      	strh	r3, [r0, #8]
 80098b0:	4620      	mov	r0, r4

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 80098b2:	2a00      	cmp	r2, #0
 80098b4:	d1f6      	bne.n	80098a4 <pbuf_cat+0x14>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
 80098b6:	8962      	ldrh	r2, [r4, #10]
 80098b8:	8923      	ldrh	r3, [r4, #8]
 80098ba:	4293      	cmp	r3, r2
 80098bc:	d019      	beq.n	80098f2 <pbuf_cat+0x62>
 80098be:	4e18      	ldr	r6, [pc, #96]	; (8009920 <pbuf_cat+0x90>)
 80098c0:	4918      	ldr	r1, [pc, #96]	; (8009924 <pbuf_cat+0x94>)
 80098c2:	4a19      	ldr	r2, [pc, #100]	; (8009928 <pbuf_cat+0x98>)
 80098c4:	9600      	str	r6, [sp, #0]
 80098c6:	f240 23f6 	movw	r3, #758	; 0x2f6
 80098ca:	4818      	ldr	r0, [pc, #96]	; (800992c <pbuf_cat+0x9c>)
 80098cc:	f7ff fcc8 	bl	8009260 <chprintf.constprop.1>
 80098d0:	4815      	ldr	r0, [pc, #84]	; (8009928 <pbuf_cat+0x98>)
 80098d2:	f7f7 fb4d 	bl	8000f70 <chSysHalt>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
 80098d6:	6823      	ldr	r3, [r4, #0]
 80098d8:	b153      	cbz	r3, 80098f0 <pbuf_cat+0x60>
 80098da:	9600      	str	r6, [sp, #0]
 80098dc:	4813      	ldr	r0, [pc, #76]	; (800992c <pbuf_cat+0x9c>)
 80098de:	4911      	ldr	r1, [pc, #68]	; (8009924 <pbuf_cat+0x94>)
 80098e0:	4a13      	ldr	r2, [pc, #76]	; (8009930 <pbuf_cat+0xa0>)
 80098e2:	f240 23f7 	movw	r3, #759	; 0x2f7
 80098e6:	f7ff fcbb 	bl	8009260 <chprintf.constprop.1>
 80098ea:	4811      	ldr	r0, [pc, #68]	; (8009930 <pbuf_cat+0xa0>)
 80098ec:	f7f7 fb40 	bl	8000f70 <chSysHalt>
 80098f0:	8922      	ldrh	r2, [r4, #8]
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
 80098f2:	892b      	ldrh	r3, [r5, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 80098f4:	6025      	str	r5, [r4, #0]
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
 80098f6:	4413      	add	r3, r2
 80098f8:	8123      	strh	r3, [r4, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 80098fa:	b002      	add	sp, #8
 80098fc:	bd70      	pop	{r4, r5, r6, pc}
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 80098fe:	4b08      	ldr	r3, [pc, #32]	; (8009920 <pbuf_cat+0x90>)
 8009900:	9300      	str	r3, [sp, #0]
 8009902:	4908      	ldr	r1, [pc, #32]	; (8009924 <pbuf_cat+0x94>)
 8009904:	4a0b      	ldr	r2, [pc, #44]	; (8009934 <pbuf_cat+0xa4>)
 8009906:	4809      	ldr	r0, [pc, #36]	; (800992c <pbuf_cat+0x9c>)
 8009908:	f240 23ee 	movw	r3, #750	; 0x2ee
 800990c:	f7ff fca8 	bl	8009260 <chprintf.constprop.1>
 8009910:	4808      	ldr	r0, [pc, #32]	; (8009934 <pbuf_cat+0xa4>)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 8009912:	b002      	add	sp, #8
 8009914:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8009918:	f7f7 bb2a 	b.w	8000f70 <chSysHalt>

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 800991c:	4604      	mov	r4, r0
 800991e:	e7ca      	b.n	80098b6 <pbuf_cat+0x26>
 8009920:	08017514 	.word	0x08017514
 8009924:	08016fe0 	.word	0x08016fe0
 8009928:	08017728 	.word	0x08017728
 800992c:	200180c8 	.word	0x200180c8
 8009930:	08017758 	.word	0x08017758
 8009934:	080176f0 	.word	0x080176f0
 8009938:	f3af 8000 	nop.w
 800993c:	f3af 8000 	nop.w

08009940 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
 8009940:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 8009944:	4680      	mov	r8, r0
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
 8009946:	b083      	sub	sp, #12

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 8009948:	2800      	cmp	r0, #0
 800994a:	f000 80a5 	beq.w	8009a98 <pbuf_copy+0x158>
 800994e:	460d      	mov	r5, r1
 8009950:	2900      	cmp	r1, #0
 8009952:	f000 80a1 	beq.w	8009a98 <pbuf_copy+0x158>
 8009956:	8902      	ldrh	r2, [r0, #8]
 8009958:	890b      	ldrh	r3, [r1, #8]
 800995a:	429a      	cmp	r2, r3
 800995c:	f0c0 809c 	bcc.w	8009a98 <pbuf_copy+0x158>
 8009960:	f04f 0900 	mov.w	r9, #0
 8009964:	8943      	ldrh	r3, [r0, #10]
 8009966:	894a      	ldrh	r2, [r1, #10]
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 8009968:	4f52      	ldr	r7, [pc, #328]	; (8009ab4 <pbuf_copy+0x174>)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 800996a:	464e      	mov	r6, r9

  /* iterate through pbuf chain */
  do
  {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 800996c:	ebc9 0402 	rsb	r4, r9, r2
 8009970:	1b9b      	subs	r3, r3, r6
 8009972:	42a3      	cmp	r3, r4
      len = p_from->len - offset_from;
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 8009974:	f8d8 0004 	ldr.w	r0, [r8, #4]
 8009978:	6869      	ldr	r1, [r5, #4]
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
 800997a:	bfb4      	ite	lt
 800997c:	b29c      	uxthlt	r4, r3
  do
  {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
 800997e:	b2a4      	uxthge	r4, r4
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 8009980:	4430      	add	r0, r6
 8009982:	4449      	add	r1, r9
 8009984:	4622      	mov	r2, r4
 8009986:	f7f6 ff9b 	bl	80008c0 <memcpy>
    offset_to += len;
 800998a:	4426      	add	r6, r4
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 800998c:	f8b8 300a 	ldrh.w	r3, [r8, #10]
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
 8009990:	b2b6      	uxth	r6, r6
    offset_from += len;
 8009992:	444c      	add	r4, r9
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 8009994:	42b3      	cmp	r3, r6
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
 8009996:	fa1f f984 	uxth.w	r9, r4
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 800999a:	d33c      	bcc.n	8009a16 <pbuf_copy+0xd6>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 800999c:	896b      	ldrh	r3, [r5, #10]
 800999e:	4599      	cmp	r9, r3
 80099a0:	d82c      	bhi.n	80099fc <pbuf_copy+0xbc>
    if (offset_from >= p_from->len) {
 80099a2:	4599      	cmp	r9, r3
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
 80099a4:	f8b8 300a 	ldrh.w	r3, [r8, #10]
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
 80099a8:	bf24      	itt	cs
 80099aa:	682d      	ldrcs	r5, [r5, #0]
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
 80099ac:	f04f 0900 	movcs.w	r9, #0
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
 80099b0:	42b3      	cmp	r3, r6
 80099b2:	d011      	beq.n	80099d8 <pbuf_copy+0x98>
      offset_to = 0;
      p_to = p_to->next;
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 80099b4:	b1c5      	cbz	r5, 80099e8 <pbuf_copy+0xa8>
 80099b6:	896a      	ldrh	r2, [r5, #10]
 80099b8:	892b      	ldrh	r3, [r5, #8]
 80099ba:	429a      	cmp	r2, r3
 80099bc:	d037      	beq.n	8009a2e <pbuf_copy+0xee>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 80099be:	f8b8 300a 	ldrh.w	r3, [r8, #10]
 80099c2:	f8b8 1008 	ldrh.w	r1, [r8, #8]
 80099c6:	4299      	cmp	r1, r3
 80099c8:	d1d0      	bne.n	800996c <pbuf_copy+0x2c>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 80099ca:	f8d8 2000 	ldr.w	r2, [r8]
 80099ce:	2a00      	cmp	r2, #0
 80099d0:	d151      	bne.n	8009a76 <pbuf_copy+0x136>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
 80099d2:	b17d      	cbz	r5, 80099f4 <pbuf_copy+0xb4>
 80099d4:	896a      	ldrh	r2, [r5, #10]
 80099d6:	e7c9      	b.n	800996c <pbuf_copy+0x2c>
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
 80099d8:	f8d8 8000 	ldr.w	r8, [r8]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 80099dc:	f1b8 0f00 	cmp.w	r8, #0
 80099e0:	d039      	beq.n	8009a56 <pbuf_copy+0x116>
      offset_from = 0;
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
 80099e2:	2600      	movs	r6, #0
      p_to = p_to->next;
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 80099e4:	2d00      	cmp	r5, #0
 80099e6:	d1e6      	bne.n	80099b6 <pbuf_copy+0x76>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 80099e8:	f8b8 300a 	ldrh.w	r3, [r8, #10]
 80099ec:	f8b8 2008 	ldrh.w	r2, [r8, #8]
 80099f0:	429a      	cmp	r2, r3
 80099f2:	d0ea      	beq.n	80099ca <pbuf_copy+0x8a>
 80099f4:	b268      	sxtb	r0, r5
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
 80099f6:	b003      	add	sp, #12
 80099f8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 80099fc:	f240 336e 	movw	r3, #878	; 0x36e
 8009a00:	492d      	ldr	r1, [pc, #180]	; (8009ab8 <pbuf_copy+0x178>)
 8009a02:	4a2e      	ldr	r2, [pc, #184]	; (8009abc <pbuf_copy+0x17c>)
 8009a04:	9700      	str	r7, [sp, #0]
 8009a06:	482e      	ldr	r0, [pc, #184]	; (8009ac0 <pbuf_copy+0x180>)
 8009a08:	f7ff fc2a 	bl	8009260 <chprintf.constprop.1>
 8009a0c:	482b      	ldr	r0, [pc, #172]	; (8009abc <pbuf_copy+0x17c>)
 8009a0e:	f7f7 faaf 	bl	8000f70 <chSysHalt>
 8009a12:	896b      	ldrh	r3, [r5, #10]
 8009a14:	e7c5      	b.n	80099a2 <pbuf_copy+0x62>
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 8009a16:	9700      	str	r7, [sp, #0]
 8009a18:	4927      	ldr	r1, [pc, #156]	; (8009ab8 <pbuf_copy+0x178>)
 8009a1a:	4a2a      	ldr	r2, [pc, #168]	; (8009ac4 <pbuf_copy+0x184>)
 8009a1c:	4828      	ldr	r0, [pc, #160]	; (8009ac0 <pbuf_copy+0x180>)
 8009a1e:	f240 336d 	movw	r3, #877	; 0x36d
 8009a22:	f7ff fc1d 	bl	8009260 <chprintf.constprop.1>
 8009a26:	4827      	ldr	r0, [pc, #156]	; (8009ac4 <pbuf_copy+0x184>)
 8009a28:	f7f7 faa2 	bl	8000f70 <chSysHalt>
 8009a2c:	e7b6      	b.n	800999c <pbuf_copy+0x5c>
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 8009a2e:	682b      	ldr	r3, [r5, #0]
 8009a30:	2b00      	cmp	r3, #0
 8009a32:	d0c4      	beq.n	80099be <pbuf_copy+0x7e>
 8009a34:	4b1f      	ldr	r3, [pc, #124]	; (8009ab4 <pbuf_copy+0x174>)
 8009a36:	9300      	str	r3, [sp, #0]
 8009a38:	491f      	ldr	r1, [pc, #124]	; (8009ab8 <pbuf_copy+0x178>)
 8009a3a:	4a23      	ldr	r2, [pc, #140]	; (8009ac8 <pbuf_copy+0x188>)
 8009a3c:	4820      	ldr	r0, [pc, #128]	; (8009ac0 <pbuf_copy+0x180>)
 8009a3e:	f240 337e 	movw	r3, #894	; 0x37e
 8009a42:	f7ff fc0d 	bl	8009260 <chprintf.constprop.1>
 8009a46:	4820      	ldr	r0, [pc, #128]	; (8009ac8 <pbuf_copy+0x188>)
 8009a48:	f7f7 fa92 	bl	8000f70 <chSysHalt>
 8009a4c:	25fa      	movs	r5, #250	; 0xfa
 8009a4e:	b268      	sxtb	r0, r5
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
 8009a50:	b003      	add	sp, #12
 8009a52:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 8009a56:	2d00      	cmp	r5, #0
 8009a58:	d0cc      	beq.n	80099f4 <pbuf_copy+0xb4>
 8009a5a:	4b16      	ldr	r3, [pc, #88]	; (8009ab4 <pbuf_copy+0x174>)
 8009a5c:	9300      	str	r3, [sp, #0]
 8009a5e:	4916      	ldr	r1, [pc, #88]	; (8009ab8 <pbuf_copy+0x178>)
 8009a60:	4a1a      	ldr	r2, [pc, #104]	; (8009acc <pbuf_copy+0x18c>)
 8009a62:	4817      	ldr	r0, [pc, #92]	; (8009ac0 <pbuf_copy+0x180>)
 8009a64:	f44f 735e 	mov.w	r3, #888	; 0x378
 8009a68:	f7ff fbfa 	bl	8009260 <chprintf.constprop.1>
 8009a6c:	4817      	ldr	r0, [pc, #92]	; (8009acc <pbuf_copy+0x18c>)
 8009a6e:	f7f7 fa7f 	bl	8000f70 <chSysHalt>
 8009a72:	25f2      	movs	r5, #242	; 0xf2
 8009a74:	e7be      	b.n	80099f4 <pbuf_copy+0xb4>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 8009a76:	4b0f      	ldr	r3, [pc, #60]	; (8009ab4 <pbuf_copy+0x174>)
 8009a78:	9300      	str	r3, [sp, #0]
 8009a7a:	490f      	ldr	r1, [pc, #60]	; (8009ab8 <pbuf_copy+0x178>)
 8009a7c:	4a12      	ldr	r2, [pc, #72]	; (8009ac8 <pbuf_copy+0x188>)
 8009a7e:	4810      	ldr	r0, [pc, #64]	; (8009ac0 <pbuf_copy+0x180>)
 8009a80:	f240 3383 	movw	r3, #899	; 0x383
 8009a84:	f7ff fbec 	bl	8009260 <chprintf.constprop.1>
 8009a88:	480f      	ldr	r0, [pc, #60]	; (8009ac8 <pbuf_copy+0x188>)
 8009a8a:	f7f7 fa71 	bl	8000f70 <chSysHalt>
 8009a8e:	25fa      	movs	r5, #250	; 0xfa
 8009a90:	b268      	sxtb	r0, r5
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
 8009a92:	b003      	add	sp, #12
 8009a94:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 8009a98:	4b06      	ldr	r3, [pc, #24]	; (8009ab4 <pbuf_copy+0x174>)
 8009a9a:	9300      	str	r3, [sp, #0]
 8009a9c:	4906      	ldr	r1, [pc, #24]	; (8009ab8 <pbuf_copy+0x178>)
 8009a9e:	4a0c      	ldr	r2, [pc, #48]	; (8009ad0 <pbuf_copy+0x190>)
 8009aa0:	4807      	ldr	r0, [pc, #28]	; (8009ac0 <pbuf_copy+0x180>)
 8009aa2:	f240 335d 	movw	r3, #861	; 0x35d
 8009aa6:	f7ff fbdb 	bl	8009260 <chprintf.constprop.1>
 8009aaa:	4809      	ldr	r0, [pc, #36]	; (8009ad0 <pbuf_copy+0x190>)
 8009aac:	f7f7 fa60 	bl	8000f70 <chSysHalt>
 8009ab0:	25f2      	movs	r5, #242	; 0xf2
 8009ab2:	e79f      	b.n	80099f4 <pbuf_copy+0xb4>
 8009ab4:	08017514 	.word	0x08017514
 8009ab8:	08016fe0 	.word	0x08016fe0
 8009abc:	080177ec 	.word	0x080177ec
 8009ac0:	200180c8 	.word	0x200180c8
 8009ac4:	080177d4 	.word	0x080177d4
 8009ac8:	08017818 	.word	0x08017818
 8009acc:	08017808 	.word	0x08017808
 8009ad0:	080177a4 	.word	0x080177a4
 8009ad4:	f3af 8000 	nop.w
 8009ad8:	f3af 8000 	nop.w
 8009adc:	f3af 8000 	nop.w

08009ae0 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 8009ae0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 8009ae4:	4605      	mov	r5, r0
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 8009ae6:	b083      	sub	sp, #12
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 8009ae8:	2800      	cmp	r0, #0
 8009aea:	d031      	beq.n	8009b50 <pbuf_copy_partial+0x70>
 8009aec:	460e      	mov	r6, r1
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 8009aee:	2900      	cmp	r1, #0
 8009af0:	d03c      	beq.n	8009b6c <pbuf_copy_partial+0x8c>
 8009af2:	4617      	mov	r7, r2
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8009af4:	2a00      	cmp	r2, #0
 8009af6:	d047      	beq.n	8009b88 <pbuf_copy_partial+0xa8>
 8009af8:	f04f 0800 	mov.w	r8, #0
 8009afc:	46c1      	mov	r9, r8
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 8009afe:	eb06 0009 	add.w	r0, r6, r9
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
 8009b02:	896a      	ldrh	r2, [r5, #10]
 8009b04:	b15b      	cbz	r3, 8009b1e <pbuf_copy_partial+0x3e>
 8009b06:	429a      	cmp	r2, r3
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
 8009b08:	eba3 0102 	sub.w	r1, r3, r2
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
 8009b0c:	d807      	bhi.n	8009b1e <pbuf_copy_partial+0x3e>
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8009b0e:	682d      	ldr	r5, [r5, #0]
    if ((offset != 0) && (offset >= p->len)) {
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
 8009b10:	b28b      	uxth	r3, r1
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8009b12:	2d00      	cmp	r5, #0
 8009b14:	d1f3      	bne.n	8009afe <pbuf_copy_partial+0x1e>
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
 8009b16:	4640      	mov	r0, r8
}
 8009b18:	b003      	add	sp, #12
 8009b1a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if ((offset != 0) && (offset >= p->len)) {
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
 8009b1e:	1ad4      	subs	r4, r2, r3
 8009b20:	b2a4      	uxth	r4, r4
 8009b22:	42bc      	cmp	r4, r7
 8009b24:	bf28      	it	cs
 8009b26:	463c      	movcs	r4, r7
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 8009b28:	6869      	ldr	r1, [r5, #4]
      copied_total += buf_copy_len;
      left += buf_copy_len;
      len -= buf_copy_len;
 8009b2a:	1b3f      	subs	r7, r7, r4
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 8009b2c:	4622      	mov	r2, r4
      copied_total += buf_copy_len;
 8009b2e:	44a0      	add	r8, r4
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 8009b30:	4419      	add	r1, r3
      copied_total += buf_copy_len;
      left += buf_copy_len;
 8009b32:	444c      	add	r4, r9
      len -= buf_copy_len;
 8009b34:	b2bf      	uxth	r7, r7
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 8009b36:	f7f6 fec3 	bl	80008c0 <memcpy>
      copied_total += buf_copy_len;
 8009b3a:	fa1f f888 	uxth.w	r8, r8
      left += buf_copy_len;
 8009b3e:	fa1f f984 	uxth.w	r9, r4
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8009b42:	682d      	ldr	r5, [r5, #0]
 8009b44:	2f00      	cmp	r7, #0
 8009b46:	d0e6      	beq.n	8009b16 <pbuf_copy_partial+0x36>
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
      copied_total += buf_copy_len;
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
 8009b48:	2300      	movs	r3, #0
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8009b4a:	2d00      	cmp	r5, #0
 8009b4c:	d1d7      	bne.n	8009afe <pbuf_copy_partial+0x1e>
 8009b4e:	e7e2      	b.n	8009b16 <pbuf_copy_partial+0x36>
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 8009b50:	4b0e      	ldr	r3, [pc, #56]	; (8009b8c <pbuf_copy_partial+0xac>)
 8009b52:	9300      	str	r3, [sp, #0]
 8009b54:	490e      	ldr	r1, [pc, #56]	; (8009b90 <pbuf_copy_partial+0xb0>)
 8009b56:	4a0f      	ldr	r2, [pc, #60]	; (8009b94 <pbuf_copy_partial+0xb4>)
 8009b58:	480f      	ldr	r0, [pc, #60]	; (8009b98 <pbuf_copy_partial+0xb8>)
 8009b5a:	f240 339d 	movw	r3, #925	; 0x39d
 8009b5e:	f7ff fb7f 	bl	8009260 <chprintf.constprop.1>
 8009b62:	480c      	ldr	r0, [pc, #48]	; (8009b94 <pbuf_copy_partial+0xb4>)
 8009b64:	f7f7 fa04 	bl	8000f70 <chSysHalt>
 8009b68:	4628      	mov	r0, r5
 8009b6a:	e7d5      	b.n	8009b18 <pbuf_copy_partial+0x38>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 8009b6c:	4b07      	ldr	r3, [pc, #28]	; (8009b8c <pbuf_copy_partial+0xac>)
 8009b6e:	9300      	str	r3, [sp, #0]
 8009b70:	4907      	ldr	r1, [pc, #28]	; (8009b90 <pbuf_copy_partial+0xb0>)
 8009b72:	4a0a      	ldr	r2, [pc, #40]	; (8009b9c <pbuf_copy_partial+0xbc>)
 8009b74:	4808      	ldr	r0, [pc, #32]	; (8009b98 <pbuf_copy_partial+0xb8>)
 8009b76:	f240 339e 	movw	r3, #926	; 0x39e
 8009b7a:	f7ff fb71 	bl	8009260 <chprintf.constprop.1>
 8009b7e:	4807      	ldr	r0, [pc, #28]	; (8009b9c <pbuf_copy_partial+0xbc>)
 8009b80:	f7f7 f9f6 	bl	8000f70 <chSysHalt>
 8009b84:	4630      	mov	r0, r6
 8009b86:	e7c7      	b.n	8009b18 <pbuf_copy_partial+0x38>
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8009b88:	4690      	mov	r8, r2
 8009b8a:	e7c4      	b.n	8009b16 <pbuf_copy_partial+0x36>
 8009b8c:	08017514 	.word	0x08017514
 8009b90:	08016fe0 	.word	0x08016fe0
 8009b94:	08017844 	.word	0x08017844
 8009b98:	200180c8 	.word	0x200180c8
 8009b9c:	08017864 	.word	0x08017864

08009ba0 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
 8009ba0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  iphdr = (struct ip_hdr *)p->payload;
  proto = IPH_PROTO(iphdr);

  prev = NULL;
  pcb = raw_pcbs;
 8009ba4:	f8df 8068 	ldr.w	r8, [pc, #104]	; 8009c10 <raw_input+0x70>
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = (struct ip_hdr *)p->payload;
  proto = IPH_PROTO(iphdr);
 8009ba8:	6843      	ldr	r3, [r0, #4]

  prev = NULL;
  pcb = raw_pcbs;
 8009baa:	f8d8 4000 	ldr.w	r4, [r8]
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = (struct ip_hdr *)p->payload;
  proto = IPH_PROTO(iphdr);
 8009bae:	7a5e      	ldrb	r6, [r3, #9]

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
 8009bb0:	b344      	cbz	r4, 8009c04 <raw_input+0x64>
 8009bb2:	4682      	mov	sl, r0
 8009bb4:	2500      	movs	r5, #0
    if ((pcb->protocol == proto) &&
        (ip_addr_isany(&pcb->local_ip) ||
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
 8009bb6:	f8df 905c 	ldr.w	r9, [pc, #92]	; 8009c14 <raw_input+0x74>
 8009bba:	e003      	b.n	8009bc4 <raw_input+0x24>
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
 8009bbc:	68e3      	ldr	r3, [r4, #12]
 8009bbe:	4625      	mov	r5, r4

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
 8009bc0:	b303      	cbz	r3, 8009c04 <raw_input+0x64>
 8009bc2:	461c      	mov	r4, r3
    if ((pcb->protocol == proto) &&
 8009bc4:	7c23      	ldrb	r3, [r4, #16]
 8009bc6:	42b3      	cmp	r3, r6
 8009bc8:	d1f8      	bne.n	8009bbc <raw_input+0x1c>
        (ip_addr_isany(&pcb->local_ip) ||
 8009bca:	6820      	ldr	r0, [r4, #0]
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
 8009bcc:	4b0f      	ldr	r3, [pc, #60]	; (8009c0c <raw_input+0x6c>)
 8009bce:	4621      	mov	r1, r4
 8009bd0:	4652      	mov	r2, sl
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if ((pcb->protocol == proto) &&
        (ip_addr_isany(&pcb->local_ip) ||
 8009bd2:	b118      	cbz	r0, 8009bdc <raw_input+0x3c>
 8009bd4:	f8d9 7000 	ldr.w	r7, [r9]
 8009bd8:	42b8      	cmp	r0, r7
 8009bda:	d1ef      	bne.n	8009bbc <raw_input+0x1c>
      /* broadcast filter? */
      if (ip_get_option(pcb, SOF_BROADCAST) || !ip_addr_isbroadcast(&current_iphdr_dest, inp))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
 8009bdc:	f8d4 c014 	ldr.w	ip, [r4, #20]
 8009be0:	f1bc 0f00 	cmp.w	ip, #0
 8009be4:	d0ea      	beq.n	8009bbc <raw_input+0x1c>
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
 8009be6:	69a0      	ldr	r0, [r4, #24]
 8009be8:	47e0      	blx	ip
 8009bea:	2800      	cmp	r0, #0
 8009bec:	d0e6      	beq.n	8009bbc <raw_input+0x1c>
            /* receive function ate the packet */
            p = NULL;
            eaten = 1;
            if (prev != NULL) {
 8009bee:	b135      	cbz	r5, 8009bfe <raw_input+0x5e>
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
 8009bf0:	68e2      	ldr	r2, [r4, #12]
              pcb->next = raw_pcbs;
 8009bf2:	f8d8 3000 	ldr.w	r3, [r8]
            p = NULL;
            eaten = 1;
            if (prev != NULL) {
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
 8009bf6:	60ea      	str	r2, [r5, #12]
              pcb->next = raw_pcbs;
              raw_pcbs = pcb;
 8009bf8:	f8c8 4000 	str.w	r4, [r8]
            eaten = 1;
            if (prev != NULL) {
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
              pcb->next = raw_pcbs;
 8009bfc:	60e3      	str	r3, [r4, #12]
 8009bfe:	2001      	movs	r0, #1
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
 8009c00:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8009c04:	2000      	movs	r0, #0
 8009c06:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8009c0a:	bf00      	nop
 8009c0c:	2000cbac 	.word	0x2000cbac
 8009c10:	2000c9f8 	.word	0x2000c9f8
 8009c14:	2000cbb0 	.word	0x2000cbb0
 8009c18:	f3af 8000 	nop.w
 8009c1c:	f3af 8000 	nop.w

08009c20 <raw_bind>:
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, ip_addr_t *ipaddr)
{
  ip_addr_set(&pcb->local_ip, ipaddr);
 8009c20:	b101      	cbz	r1, 8009c24 <raw_bind+0x4>
 8009c22:	6809      	ldr	r1, [r1, #0]
 8009c24:	6001      	str	r1, [r0, #0]
  return ERR_OK;
}
 8009c26:	2000      	movs	r0, #0
 8009c28:	4770      	bx	lr
 8009c2a:	bf00      	nop
 8009c2c:	f3af 8000 	nop.w

08009c30 <raw_recv>:
 */
void
raw_recv(struct raw_pcb *pcb, raw_recv_fn recv, void *recv_arg)
{
  /* remember recv() callback and user data */
  pcb->recv = recv;
 8009c30:	6141      	str	r1, [r0, #20]
  pcb->recv_arg = recv_arg;
 8009c32:	6182      	str	r2, [r0, #24]
 8009c34:	4770      	bx	lr
 8009c36:	bf00      	nop
 8009c38:	f3af 8000 	nop.w
 8009c3c:	f3af 8000 	nop.w

08009c40 <raw_remove>:
void
raw_remove(struct raw_pcb *pcb)
{
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
 8009c40:	4b0d      	ldr	r3, [pc, #52]	; (8009c78 <raw_remove+0x38>)
 8009c42:	681a      	ldr	r2, [r3, #0]
 8009c44:	4282      	cmp	r2, r0
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
 8009c46:	4601      	mov	r1, r0
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
 8009c48:	d011      	beq.n	8009c6e <raw_remove+0x2e>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 8009c4a:	b13a      	cbz	r2, 8009c5c <raw_remove+0x1c>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 8009c4c:	68d3      	ldr	r3, [r2, #12]
 8009c4e:	b12b      	cbz	r3, 8009c5c <raw_remove+0x1c>
 8009c50:	4299      	cmp	r1, r3
 8009c52:	d006      	beq.n	8009c62 <raw_remove+0x22>
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
 8009c54:	461a      	mov	r2, r3
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 8009c56:	68d3      	ldr	r3, [r2, #12]
 8009c58:	2b00      	cmp	r3, #0
 8009c5a:	d1f9      	bne.n	8009c50 <raw_remove+0x10>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
 8009c5c:	2000      	movs	r0, #0
 8009c5e:	f7ff b9af 	b.w	8008fc0 <memp_free>
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
 8009c62:	68cb      	ldr	r3, [r1, #12]
 8009c64:	60d3      	str	r3, [r2, #12]
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 8009c66:	2b00      	cmp	r3, #0
 8009c68:	d0f8      	beq.n	8009c5c <raw_remove+0x1c>
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
 8009c6a:	461a      	mov	r2, r3
 8009c6c:	e7f3      	b.n	8009c56 <raw_remove+0x16>
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
 8009c6e:	68c2      	ldr	r2, [r0, #12]
 8009c70:	601a      	str	r2, [r3, #0]
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
 8009c72:	2000      	movs	r0, #0
 8009c74:	f7ff b9a4 	b.w	8008fc0 <memp_free>
 8009c78:	2000c9f8 	.word	0x2000c9f8
 8009c7c:	f3af 8000 	nop.w

08009c80 <raw_new>:
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto)
{
 8009c80:	b538      	push	{r3, r4, r5, lr}
 8009c82:	4605      	mov	r5, r0
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));

  pcb = (struct raw_pcb *)memp_malloc(MEMP_RAW_PCB);
 8009c84:	2000      	movs	r0, #0
 8009c86:	f7ff f943 	bl	8008f10 <memp_malloc>
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
 8009c8a:	4604      	mov	r4, r0
 8009c8c:	b150      	cbz	r0, 8009ca4 <raw_new+0x24>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
 8009c8e:	221c      	movs	r2, #28
 8009c90:	2100      	movs	r1, #0
 8009c92:	f00a f89d 	bl	8013dd0 <memset>
    pcb->protocol = proto;
    pcb->ttl = RAW_TTL;
    pcb->next = raw_pcbs;
 8009c96:	4b04      	ldr	r3, [pc, #16]	; (8009ca8 <raw_new+0x28>)
  pcb = (struct raw_pcb *)memp_malloc(MEMP_RAW_PCB);
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
    pcb->protocol = proto;
 8009c98:	7425      	strb	r5, [r4, #16]
    pcb->ttl = RAW_TTL;
    pcb->next = raw_pcbs;
 8009c9a:	681a      	ldr	r2, [r3, #0]
 8009c9c:	60e2      	str	r2, [r4, #12]
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
    pcb->protocol = proto;
    pcb->ttl = RAW_TTL;
 8009c9e:	22ff      	movs	r2, #255	; 0xff
    pcb->next = raw_pcbs;
    raw_pcbs = pcb;
 8009ca0:	601c      	str	r4, [r3, #0]
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
    pcb->protocol = proto;
    pcb->ttl = RAW_TTL;
 8009ca2:	72a2      	strb	r2, [r4, #10]
    pcb->next = raw_pcbs;
    raw_pcbs = pcb;
  }
  return pcb;
}
 8009ca4:	4620      	mov	r0, r4
 8009ca6:	bd38      	pop	{r3, r4, r5, pc}
 8009ca8:	2000c9f8 	.word	0x2000c9f8
 8009cac:	f3af 8000 	nop.w

08009cb0 <stats_init>:
#include <string.h>

struct stats_ lwip_stats;

void stats_init(void)
{
 8009cb0:	4770      	bx	lr
 8009cb2:	bf00      	nop
 8009cb4:	f3af 8000 	nop.w
 8009cb8:	f3af 8000 	nop.w
 8009cbc:	f3af 8000 	nop.w

08009cc0 <tcp_accept_null>:
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
 8009cc0:	f06f 0009 	mvn.w	r0, #9
 8009cc4:	4770      	bx	lr
 8009cc6:	bf00      	nop
 8009cc8:	f3af 8000 	nop.w
 8009ccc:	f3af 8000 	nop.w

08009cd0 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
 8009cd0:	b4f0      	push	{r4, r5, r6, r7}
 8009cd2:	4e12      	ldr	r6, [pc, #72]	; (8009d1c <tcp_new_port+0x4c>)
 8009cd4:	4f12      	ldr	r7, [pc, #72]	; (8009d20 <tcp_new_port+0x50>)
 8009cd6:	8830      	ldrh	r0, [r6, #0]
 8009cd8:	f44f 4480 	mov.w	r4, #16384	; 0x4000
  u8_t i;
  u16_t n = 0;
  struct tcp_pcb *pcb;
  
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
 8009cdc:	f64f 75ff 	movw	r5, #65535	; 0xffff
 8009ce0:	42a8      	cmp	r0, r5
 8009ce2:	bf18      	it	ne
 8009ce4:	3001      	addne	r0, #1
 8009ce6:	490f      	ldr	r1, [pc, #60]	; (8009d24 <tcp_new_port+0x54>)
 8009ce8:	bf14      	ite	ne
 8009cea:	b280      	uxthne	r0, r0
 8009cec:	f44f 4040 	moveq.w	r0, #49152	; 0xc000
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 8009cf0:	f851 3b04 	ldr.w	r3, [r1], #4
 8009cf4:	681b      	ldr	r3, [r3, #0]
 8009cf6:	b913      	cbnz	r3, 8009cfe <tcp_new_port+0x2e>
 8009cf8:	e00b      	b.n	8009d12 <tcp_new_port+0x42>
 8009cfa:	68db      	ldr	r3, [r3, #12]
 8009cfc:	b14b      	cbz	r3, 8009d12 <tcp_new_port+0x42>
      if (pcb->local_port == tcp_port) {
 8009cfe:	8b5a      	ldrh	r2, [r3, #26]
 8009d00:	4282      	cmp	r2, r0
 8009d02:	d1fa      	bne.n	8009cfa <tcp_new_port+0x2a>
 8009d04:	3c01      	subs	r4, #1
 8009d06:	b2a4      	uxth	r4, r4
        if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
 8009d08:	2c00      	cmp	r4, #0
 8009d0a:	d1e9      	bne.n	8009ce0 <tcp_new_port+0x10>
 8009d0c:	8030      	strh	r0, [r6, #0]
          return 0;
 8009d0e:	4620      	mov	r0, r4
 8009d10:	e002      	b.n	8009d18 <tcp_new_port+0x48>
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 8009d12:	42b9      	cmp	r1, r7
 8009d14:	d1ec      	bne.n	8009cf0 <tcp_new_port+0x20>
 8009d16:	8030      	strh	r0, [r6, #0]
        goto again;
      }
    }
  }
  return tcp_port;
}
 8009d18:	bcf0      	pop	{r4, r5, r6, r7}
 8009d1a:	4770      	bx	lr
 8009d1c:	200008b8 	.word	0x200008b8
 8009d20:	08017910 	.word	0x08017910
 8009d24:	08017900 	.word	0x08017900
 8009d28:	f3af 8000 	nop.w
 8009d2c:	f3af 8000 	nop.w

08009d30 <chprintf.constprop.4>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8009d30:	b40e      	push	{r1, r2, r3}
 8009d32:	b500      	push	{lr}
 8009d34:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8009d36:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 8009d38:	461a      	mov	r2, r3
 8009d3a:	4905      	ldr	r1, [pc, #20]	; (8009d50 <chprintf.constprop.4+0x20>)
 8009d3c:	4805      	ldr	r0, [pc, #20]	; (8009d54 <chprintf.constprop.4+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8009d3e:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8009d40:	f006 ffde 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8009d44:	b002      	add	sp, #8
 8009d46:	f85d eb04 	ldr.w	lr, [sp], #4
 8009d4a:	b003      	add	sp, #12
 8009d4c:	4770      	bx	lr
 8009d4e:	bf00      	nop
 8009d50:	08016fe0 	.word	0x08016fe0
 8009d54:	200180c8 	.word	0x200180c8
 8009d58:	f3af 8000 	nop.w
 8009d5c:	f3af 8000 	nop.w

08009d60 <tcp_init>:
/**
 * Initialize this module.
 */
void
tcp_init(void)
{
 8009d60:	4770      	bx	lr
 8009d62:	bf00      	nop
 8009d64:	f3af 8000 	nop.w
 8009d68:	f3af 8000 	nop.w
 8009d6c:	f3af 8000 	nop.w

08009d70 <tcp_bind>:
 *         ERR_VAL if bind failed because the PCB is not in a valid state
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 8009d70:	b5f0      	push	{r4, r5, r6, r7, lr}
  int i;
  int max_pcb_list = NUM_TCP_PCB_LISTS;
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 8009d72:	7e03      	ldrb	r3, [r0, #24]
 *         ERR_VAL if bind failed because the PCB is not in a valid state
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 8009d74:	b083      	sub	sp, #12
 8009d76:	4606      	mov	r6, r0
  int i;
  int max_pcb_list = NUM_TCP_PCB_LISTS;
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 8009d78:	2b00      	cmp	r3, #0
 8009d7a:	d131      	bne.n	8009de0 <tcp_bind+0x70>
 8009d7c:	460d      	mov	r5, r1
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
    max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
  }
#endif /* SO_REUSE */

  if (port == 0) {
 8009d7e:	b342      	cbz	r2, 8009dd2 <tcp_bind+0x62>
 8009d80:	491e      	ldr	r1, [pc, #120]	; (8009dfc <tcp_bind+0x8c>)
 8009d82:	f101 0710 	add.w	r7, r1, #16
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
    for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 8009d86:	f851 3b04 	ldr.w	r3, [r1], #4
 8009d8a:	681b      	ldr	r3, [r3, #0]
 8009d8c:	b913      	cbnz	r3, 8009d94 <tcp_bind+0x24>
 8009d8e:	e00f      	b.n	8009db0 <tcp_bind+0x40>
 8009d90:	68db      	ldr	r3, [r3, #12]
 8009d92:	b16b      	cbz	r3, 8009db0 <tcp_bind+0x40>
      if (cpcb->local_port == port) {
 8009d94:	8b5c      	ldrh	r4, [r3, #26]
 8009d96:	4294      	cmp	r4, r2
 8009d98:	d1fa      	bne.n	8009d90 <tcp_bind+0x20>
           tcp_connect. */
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
            !ip_get_option(cpcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          if (ip_addr_isany(&(cpcb->local_ip)) ||
 8009d9a:	6818      	ldr	r0, [r3, #0]
 8009d9c:	b120      	cbz	r0, 8009da8 <tcp_bind+0x38>
 8009d9e:	b11d      	cbz	r5, 8009da8 <tcp_bind+0x38>
              ip_addr_isany(ipaddr) ||
 8009da0:	682c      	ldr	r4, [r5, #0]
 8009da2:	b10c      	cbz	r4, 8009da8 <tcp_bind+0x38>
 8009da4:	42a0      	cmp	r0, r4
 8009da6:	d1f3      	bne.n	8009d90 <tcp_bind+0x20>
              ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
            return ERR_USE;
 8009da8:	20f8      	movs	r0, #248	; 0xf8
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
}
 8009daa:	b240      	sxtb	r0, r0
 8009dac:	b003      	add	sp, #12
 8009dae:	bdf0      	pop	{r4, r5, r6, r7, pc}
      return ERR_BUF;
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
 8009db0:	42b9      	cmp	r1, r7
 8009db2:	d1e8      	bne.n	8009d86 <tcp_bind+0x16>
        }
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
 8009db4:	b115      	cbz	r5, 8009dbc <tcp_bind+0x4c>
 8009db6:	682b      	ldr	r3, [r5, #0]
 8009db8:	b103      	cbz	r3, 8009dbc <tcp_bind+0x4c>
    pcb->local_ip = *ipaddr;
 8009dba:	6033      	str	r3, [r6, #0]
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
 8009dbc:	4b10      	ldr	r3, [pc, #64]	; (8009e00 <tcp_bind+0x90>)
  }

  if (!ip_addr_isany(ipaddr)) {
    pcb->local_ip = *ipaddr;
  }
  pcb->local_port = port;
 8009dbe:	8372      	strh	r2, [r6, #26]
  TCP_REG(&tcp_bound_pcbs, pcb);
 8009dc0:	681a      	ldr	r2, [r3, #0]
 8009dc2:	60f2      	str	r2, [r6, #12]
 8009dc4:	601e      	str	r6, [r3, #0]
 8009dc6:	f005 f873 	bl	800eeb0 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
 8009dca:	2000      	movs	r0, #0
}
 8009dcc:	b240      	sxtb	r0, r0
 8009dce:	b003      	add	sp, #12
 8009dd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
  }
#endif /* SO_REUSE */

  if (port == 0) {
    port = tcp_new_port();
 8009dd2:	f7ff ff7d 	bl	8009cd0 <tcp_new_port>
    if (port == 0) {
 8009dd6:	4602      	mov	r2, r0
 8009dd8:	2800      	cmp	r0, #0
 8009dda:	d1d1      	bne.n	8009d80 <tcp_bind+0x10>
      return ERR_BUF;
 8009ddc:	20fe      	movs	r0, #254	; 0xfe
 8009dde:	e7e4      	b.n	8009daa <tcp_bind+0x3a>
{
  int i;
  int max_pcb_list = NUM_TCP_PCB_LISTS;
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 8009de0:	4b08      	ldr	r3, [pc, #32]	; (8009e04 <tcp_bind+0x94>)
 8009de2:	9300      	str	r3, [sp, #0]
 8009de4:	4908      	ldr	r1, [pc, #32]	; (8009e08 <tcp_bind+0x98>)
 8009de6:	4a09      	ldr	r2, [pc, #36]	; (8009e0c <tcp_bind+0x9c>)
 8009de8:	4809      	ldr	r0, [pc, #36]	; (8009e10 <tcp_bind+0xa0>)
 8009dea:	f240 13b7 	movw	r3, #439	; 0x1b7
 8009dee:	f7ff ff9f 	bl	8009d30 <chprintf.constprop.4>
 8009df2:	4806      	ldr	r0, [pc, #24]	; (8009e0c <tcp_bind+0x9c>)
 8009df4:	f7f7 f8bc 	bl	8000f70 <chSysHalt>
 8009df8:	20fa      	movs	r0, #250	; 0xfa
 8009dfa:	e7d6      	b.n	8009daa <tcp_bind+0x3a>
 8009dfc:	08017900 	.word	0x08017900
 8009e00:	2000cb6c 	.word	0x2000cb6c
 8009e04:	08017948 	.word	0x08017948
 8009e08:	08016fe0 	.word	0x08016fe0
 8009e0c:	08017920 	.word	0x08017920
 8009e10:	200180c8 	.word	0x200180c8
 8009e14:	f3af 8000 	nop.w
 8009e18:	f3af 8000 	nop.w
 8009e1c:	f3af 8000 	nop.w

08009e20 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
 8009e20:	b530      	push	{r4, r5, lr}
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
 8009e22:	7e03      	ldrb	r3, [r0, #24]
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
 8009e24:	b083      	sub	sp, #12
 8009e26:	4604      	mov	r4, r0
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
 8009e28:	2b00      	cmp	r3, #0
 8009e2a:	d147      	bne.n	8009ebc <tcp_listen_with_backlog+0x9c>
        }
      }
    }
  }
#endif /* SO_REUSE */
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
 8009e2c:	2003      	movs	r0, #3
 8009e2e:	f7ff f86f 	bl	8008f10 <memp_malloc>
  if (lpcb == NULL) {
 8009e32:	4605      	mov	r5, r0
 8009e34:	2800      	cmp	r0, #0
 8009e36:	d034      	beq.n	8009ea2 <tcp_listen_with_backlog+0x82>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
 8009e38:	6923      	ldr	r3, [r4, #16]
  lpcb->local_port = pcb->local_port;
 8009e3a:	8b62      	ldrh	r2, [r4, #26]
#endif /* SO_REUSE */
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
  if (lpcb == NULL) {
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
 8009e3c:	6103      	str	r3, [r0, #16]
  lpcb->local_port = pcb->local_port;
  lpcb->state = LISTEN;
 8009e3e:	2301      	movs	r3, #1
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
  if (lpcb == NULL) {
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  lpcb->local_port = pcb->local_port;
 8009e40:	8342      	strh	r2, [r0, #26]
  lpcb->state = LISTEN;
 8009e42:	7603      	strb	r3, [r0, #24]
  lpcb->prio = pcb->prio;
 8009e44:	7e63      	ldrb	r3, [r4, #25]
 8009e46:	7643      	strb	r3, [r0, #25]
  lpcb->so_options = pcb->so_options;
  ip_set_option(lpcb, SOF_ACCEPTCONN);
 8009e48:	7a23      	ldrb	r3, [r4, #8]
 8009e4a:	f043 0302 	orr.w	r3, r3, #2
 8009e4e:	7203      	strb	r3, [r0, #8]
  lpcb->ttl = pcb->ttl;
 8009e50:	7aa3      	ldrb	r3, [r4, #10]
 8009e52:	7283      	strb	r3, [r0, #10]
  lpcb->tos = pcb->tos;
 8009e54:	7a63      	ldrb	r3, [r4, #9]
 8009e56:	7243      	strb	r3, [r0, #9]
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
  if (pcb->local_port != 0) {
 8009e58:	8b63      	ldrh	r3, [r4, #26]
  lpcb->prio = pcb->prio;
  lpcb->so_options = pcb->so_options;
  ip_set_option(lpcb, SOF_ACCEPTCONN);
  lpcb->ttl = pcb->ttl;
  lpcb->tos = pcb->tos;
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
 8009e5a:	6822      	ldr	r2, [r4, #0]
 8009e5c:	6002      	str	r2, [r0, #0]
  if (pcb->local_port != 0) {
 8009e5e:	b19b      	cbz	r3, 8009e88 <tcp_listen_with_backlog+0x68>
    TCP_RMV(&tcp_bound_pcbs, pcb);
 8009e60:	4b1d      	ldr	r3, [pc, #116]	; (8009ed8 <tcp_listen_with_backlog+0xb8>)
 8009e62:	681a      	ldr	r2, [r3, #0]
 8009e64:	42a2      	cmp	r2, r4
 8009e66:	d026      	beq.n	8009eb6 <tcp_listen_with_backlog+0x96>
 8009e68:	491c      	ldr	r1, [pc, #112]	; (8009edc <tcp_listen_with_backlog+0xbc>)
 8009e6a:	600a      	str	r2, [r1, #0]
 8009e6c:	b152      	cbz	r2, 8009e84 <tcp_listen_with_backlog+0x64>
 8009e6e:	68d3      	ldr	r3, [r2, #12]
 8009e70:	42a3      	cmp	r3, r4
 8009e72:	d01e      	beq.n	8009eb2 <tcp_listen_with_backlog+0x92>
 8009e74:	b12b      	cbz	r3, 8009e82 <tcp_listen_with_backlog+0x62>
 8009e76:	68da      	ldr	r2, [r3, #12]
 8009e78:	42a2      	cmp	r2, r4
 8009e7a:	d014      	beq.n	8009ea6 <tcp_listen_with_backlog+0x86>
 8009e7c:	4613      	mov	r3, r2
 8009e7e:	2b00      	cmp	r3, #0
 8009e80:	d1f9      	bne.n	8009e76 <tcp_listen_with_backlog+0x56>
 8009e82:	600b      	str	r3, [r1, #0]
 8009e84:	2300      	movs	r3, #0
 8009e86:	60e3      	str	r3, [r4, #12]
  }
  memp_free(MEMP_TCP_PCB, pcb);
 8009e88:	2002      	movs	r0, #2
 8009e8a:	4621      	mov	r1, r4
 8009e8c:	f7ff f898 	bl	8008fc0 <memp_free>
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
 8009e90:	4b13      	ldr	r3, [pc, #76]	; (8009ee0 <tcp_listen_with_backlog+0xc0>)
  if (pcb->local_port != 0) {
    TCP_RMV(&tcp_bound_pcbs, pcb);
  }
  memp_free(MEMP_TCP_PCB, pcb);
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
 8009e92:	4a14      	ldr	r2, [pc, #80]	; (8009ee4 <tcp_listen_with_backlog+0xc4>)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
 8009e94:	6819      	ldr	r1, [r3, #0]
 8009e96:	60e9      	str	r1, [r5, #12]
  if (pcb->local_port != 0) {
    TCP_RMV(&tcp_bound_pcbs, pcb);
  }
  memp_free(MEMP_TCP_PCB, pcb);
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
 8009e98:	616a      	str	r2, [r5, #20]
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
 8009e9a:	601d      	str	r5, [r3, #0]
 8009e9c:	f005 f808 	bl	800eeb0 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
 8009ea0:	4628      	mov	r0, r5
}
 8009ea2:	b003      	add	sp, #12
 8009ea4:	bd30      	pop	{r4, r5, pc}
 8009ea6:	600b      	str	r3, [r1, #0]
  ip_set_option(lpcb, SOF_ACCEPTCONN);
  lpcb->ttl = pcb->ttl;
  lpcb->tos = pcb->tos;
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
  if (pcb->local_port != 0) {
    TCP_RMV(&tcp_bound_pcbs, pcb);
 8009ea8:	68e2      	ldr	r2, [r4, #12]
 8009eaa:	60da      	str	r2, [r3, #12]
 8009eac:	2300      	movs	r3, #0
 8009eae:	60e3      	str	r3, [r4, #12]
 8009eb0:	e7ea      	b.n	8009e88 <tcp_listen_with_backlog+0x68>
 8009eb2:	4613      	mov	r3, r2
 8009eb4:	e7f8      	b.n	8009ea8 <tcp_listen_with_backlog+0x88>
 8009eb6:	68e2      	ldr	r2, [r4, #12]
 8009eb8:	601a      	str	r2, [r3, #0]
 8009eba:	e7e3      	b.n	8009e84 <tcp_listen_with_backlog+0x64>
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
 8009ebc:	4b0a      	ldr	r3, [pc, #40]	; (8009ee8 <tcp_listen_with_backlog+0xc8>)
 8009ebe:	9300      	str	r3, [sp, #0]
 8009ec0:	490a      	ldr	r1, [pc, #40]	; (8009eec <tcp_listen_with_backlog+0xcc>)
 8009ec2:	4a0b      	ldr	r2, [pc, #44]	; (8009ef0 <tcp_listen_with_backlog+0xd0>)
 8009ec4:	480b      	ldr	r0, [pc, #44]	; (8009ef4 <tcp_listen_with_backlog+0xd4>)
 8009ec6:	f44f 7303 	mov.w	r3, #524	; 0x20c
 8009eca:	f7ff ff31 	bl	8009d30 <chprintf.constprop.4>
 8009ece:	4808      	ldr	r0, [pc, #32]	; (8009ef0 <tcp_listen_with_backlog+0xd0>)
 8009ed0:	f7f7 f84e 	bl	8000f70 <chSysHalt>
 8009ed4:	2000      	movs	r0, #0
 8009ed6:	e7e4      	b.n	8009ea2 <tcp_listen_with_backlog+0x82>
 8009ed8:	2000cb6c 	.word	0x2000cb6c
 8009edc:	2000cb68 	.word	0x2000cb68
 8009ee0:	2000cb5c 	.word	0x2000cb5c
 8009ee4:	08009cc1 	.word	0x08009cc1
 8009ee8:	08017948 	.word	0x08017948
 8009eec:	08016fe0 	.word	0x08016fe0
 8009ef0:	08017974 	.word	0x08017974
 8009ef4:	200180c8 	.word	0x200180c8
 8009ef8:	f3af 8000 	nop.w
 8009efc:	f3af 8000 	nop.w

08009f00 <tcp_update_rcv_ann_wnd>:
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
 8009f00:	b570      	push	{r4, r5, r6, lr}
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 8009f02:	6b01      	ldr	r1, [r0, #48]	; 0x30
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 8009f04:	8d84      	ldrh	r4, [r0, #44]	; 0x2c

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 8009f06:	8ec2      	ldrh	r2, [r0, #54]	; 0x36
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 8009f08:	6a85      	ldr	r5, [r0, #40]	; 0x28

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 8009f0a:	f640 3668 	movw	r6, #2920	; 0xb68
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
 8009f0e:	4603      	mov	r3, r0
 8009f10:	1a60      	subs	r0, r4, r1
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 8009f12:	42b2      	cmp	r2, r6
 8009f14:	4428      	add	r0, r5
 8009f16:	bf94      	ite	ls
 8009f18:	1a82      	subls	r2, r0, r2
 8009f1a:	1b82      	subhi	r2, r0, r6
 8009f1c:	2a00      	cmp	r2, #0
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
 8009f1e:	b082      	sub	sp, #8
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 8009f20:	db02      	blt.n	8009f28 <tcp_update_rcv_ann_wnd+0x28>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 8009f22:	85dc      	strh	r4, [r3, #46]	; 0x2e
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    }
    return 0;
  }
}
 8009f24:	b002      	add	sp, #8
 8009f26:	bd70      	pop	{r4, r5, r6, pc}
  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
    return new_right_edge - pcb->rcv_ann_right_edge;
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 8009f28:	1a6a      	subs	r2, r5, r1
 8009f2a:	2a00      	cmp	r2, #0
 8009f2c:	dd03      	ble.n	8009f36 <tcp_update_rcv_ann_wnd+0x36>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
 8009f2e:	2000      	movs	r0, #0
 8009f30:	85d8      	strh	r0, [r3, #46]	; 0x2e
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    }
    return 0;
  }
}
 8009f32:	b002      	add	sp, #8
 8009f34:	bd70      	pop	{r4, r5, r6, pc}
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 8009f36:	1b4d      	subs	r5, r1, r5
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
 8009f38:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
 8009f3c:	461c      	mov	r4, r3
 8009f3e:	d203      	bcs.n	8009f48 <tcp_update_rcv_ann_wnd+0x48>
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    }
    return 0;
 8009f40:	2000      	movs	r0, #0
      pcb->rcv_ann_wnd = 0;
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
 8009f42:	85e5      	strh	r5, [r4, #46]	; 0x2e
    }
    return 0;
  }
}
 8009f44:	b002      	add	sp, #8
 8009f46:	bd70      	pop	{r4, r5, r6, pc}
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
 8009f48:	4b06      	ldr	r3, [pc, #24]	; (8009f64 <tcp_update_rcv_ann_wnd+0x64>)
 8009f4a:	9300      	str	r3, [sp, #0]
 8009f4c:	4906      	ldr	r1, [pc, #24]	; (8009f68 <tcp_update_rcv_ann_wnd+0x68>)
 8009f4e:	4a07      	ldr	r2, [pc, #28]	; (8009f6c <tcp_update_rcv_ann_wnd+0x6c>)
 8009f50:	4807      	ldr	r0, [pc, #28]	; (8009f70 <tcp_update_rcv_ann_wnd+0x70>)
 8009f52:	f240 2353 	movw	r3, #595	; 0x253
 8009f56:	f7ff feeb 	bl	8009d30 <chprintf.constprop.4>
 8009f5a:	4804      	ldr	r0, [pc, #16]	; (8009f6c <tcp_update_rcv_ann_wnd+0x6c>)
 8009f5c:	f7f7 f808 	bl	8000f70 <chSysHalt>
 8009f60:	e7ee      	b.n	8009f40 <tcp_update_rcv_ann_wnd+0x40>
 8009f62:	bf00      	nop
 8009f64:	08017948 	.word	0x08017948
 8009f68:	08016fe0 	.word	0x08016fe0
 8009f6c:	08017998 	.word	0x08017998
 8009f70:	200180c8 	.word	0x200180c8
 8009f74:	f3af 8000 	nop.w
 8009f78:	f3af 8000 	nop.w
 8009f7c:	f3af 8000 	nop.w

08009f80 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
 8009f80:	b530      	push	{r4, r5, lr}
  int wnd_inflation;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 8009f82:	7e03      	ldrb	r3, [r0, #24]
 8009f84:	2b01      	cmp	r3, #1
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
 8009f86:	b083      	sub	sp, #12
 8009f88:	4605      	mov	r5, r0
 8009f8a:	460c      	mov	r4, r1
  int wnd_inflation;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 8009f8c:	d02e      	beq.n	8009fec <tcp_recved+0x6c>
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
 8009f8e:	8daa      	ldrh	r2, [r5, #44]	; 0x2c
 8009f90:	f5c2 437f 	rsb	r3, r2, #65280	; 0xff00
 8009f94:	33ff      	adds	r3, #255	; 0xff
 8009f96:	429c      	cmp	r4, r3
 8009f98:	dc1a      	bgt.n	8009fd0 <tcp_recved+0x50>
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
 8009f9a:	4414      	add	r4, r2
  if (pcb->rcv_wnd > TCP_WND) {
 8009f9c:	f241 63d0 	movw	r3, #5840	; 0x16d0
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
 8009fa0:	b2a4      	uxth	r4, r4
  if (pcb->rcv_wnd > TCP_WND) {
 8009fa2:	429c      	cmp	r4, r3
    pcb->rcv_wnd = TCP_WND;
 8009fa4:	bf8c      	ite	hi
 8009fa6:	85ab      	strhhi	r3, [r5, #44]	; 0x2c
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
 8009fa8:	85ac      	strhls	r4, [r5, #44]	; 0x2c
  if (pcb->rcv_wnd > TCP_WND) {
    pcb->rcv_wnd = TCP_WND;
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 8009faa:	4628      	mov	r0, r5
 8009fac:	f7ff ffa8 	bl	8009f00 <tcp_update_rcv_ann_wnd>

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 8009fb0:	f240 53b3 	movw	r3, #1459	; 0x5b3
 8009fb4:	4298      	cmp	r0, r3
 8009fb6:	dc01      	bgt.n	8009fbc <tcp_recved+0x3c>
    tcp_output(pcb);
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
 8009fb8:	b003      	add	sp, #12
 8009fba:	bd30      	pop	{r4, r5, pc}
  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
    tcp_ack_now(pcb);
 8009fbc:	7fab      	ldrb	r3, [r5, #30]
    tcp_output(pcb);
 8009fbe:	4628      	mov	r0, r5
  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
    tcp_ack_now(pcb);
 8009fc0:	f043 0302 	orr.w	r3, r3, #2
 8009fc4:	77ab      	strb	r3, [r5, #30]
    tcp_output(pcb);
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
 8009fc6:	b003      	add	sp, #12
 8009fc8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
    tcp_ack_now(pcb);
    tcp_output(pcb);
 8009fcc:	f003 b870 	b.w	800d0b0 <tcp_output>
  int wnd_inflation;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
 8009fd0:	4b0d      	ldr	r3, [pc, #52]	; (800a008 <tcp_recved+0x88>)
 8009fd2:	4a0e      	ldr	r2, [pc, #56]	; (800a00c <tcp_recved+0x8c>)
 8009fd4:	9300      	str	r3, [sp, #0]
 8009fd6:	490e      	ldr	r1, [pc, #56]	; (800a010 <tcp_recved+0x90>)
 8009fd8:	480e      	ldr	r0, [pc, #56]	; (800a014 <tcp_recved+0x94>)
 8009fda:	f240 236b 	movw	r3, #619	; 0x26b
 8009fde:	f7ff fea7 	bl	8009d30 <chprintf.constprop.4>
 8009fe2:	480a      	ldr	r0, [pc, #40]	; (800a00c <tcp_recved+0x8c>)
 8009fe4:	f7f6 ffc4 	bl	8000f70 <chSysHalt>
 8009fe8:	8daa      	ldrh	r2, [r5, #44]	; 0x2c
 8009fea:	e7d6      	b.n	8009f9a <tcp_recved+0x1a>
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  int wnd_inflation;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 8009fec:	4b06      	ldr	r3, [pc, #24]	; (800a008 <tcp_recved+0x88>)
 8009fee:	9300      	str	r3, [sp, #0]
 8009ff0:	4907      	ldr	r1, [pc, #28]	; (800a010 <tcp_recved+0x90>)
 8009ff2:	4a09      	ldr	r2, [pc, #36]	; (800a018 <tcp_recved+0x98>)
 8009ff4:	4807      	ldr	r0, [pc, #28]	; (800a014 <tcp_recved+0x94>)
 8009ff6:	f240 2369 	movw	r3, #617	; 0x269
 8009ffa:	f7ff fe99 	bl	8009d30 <chprintf.constprop.4>
 8009ffe:	4806      	ldr	r0, [pc, #24]	; (800a018 <tcp_recved+0x98>)
 800a000:	f7f6 ffb6 	bl	8000f70 <chSysHalt>
 800a004:	e7c3      	b.n	8009f8e <tcp_recved+0xe>
 800a006:	bf00      	nop
 800a008:	08017948 	.word	0x08017948
 800a00c:	080179dc 	.word	0x080179dc
 800a010:	08016fe0 	.word	0x08016fe0
 800a014:	200180c8 	.word	0x200180c8
 800a018:	080179b4 	.word	0x080179b4
 800a01c:	f3af 8000 	nop.w

0800a020 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
 800a020:	b158      	cbz	r0, 800a03a <tcp_seg_free+0x1a>
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
 800a022:	b510      	push	{r4, lr}
 800a024:	4604      	mov	r4, r0
  if (seg != NULL) {
    if (seg->p != NULL) {
 800a026:	6840      	ldr	r0, [r0, #4]
 800a028:	b108      	cbz	r0, 800a02e <tcp_seg_free+0xe>
      pbuf_free(seg->p);
 800a02a:	f7ff f9e9 	bl	8009400 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 800a02e:	4621      	mov	r1, r4
 800a030:	2004      	movs	r0, #4
  }
}
 800a032:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      pbuf_free(seg->p);
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 800a036:	f7fe bfc3 	b.w	8008fc0 <memp_free>
 800a03a:	4770      	bx	lr
 800a03c:	f3af 8000 	nop.w

0800a040 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 800a040:	b138      	cbz	r0, 800a052 <tcp_segs_free+0x12>
 *
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
 800a042:	b510      	push	{r4, lr}
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 800a044:	6804      	ldr	r4, [r0, #0]
    tcp_seg_free(seg);
 800a046:	f7ff ffeb 	bl	800a020 <tcp_seg_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 800a04a:	4620      	mov	r0, r4
 800a04c:	2c00      	cmp	r4, #0
 800a04e:	d1f9      	bne.n	800a044 <tcp_segs_free+0x4>
 800a050:	bd10      	pop	{r4, pc}
 800a052:	4770      	bx	lr
 800a054:	f3af 8000 	nop.w
 800a058:	f3af 8000 	nop.w
 800a05c:	f3af 8000 	nop.w

0800a060 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
 800a060:	b538      	push	{r3, r4, r5, lr}
 800a062:	4605      	mov	r5, r0
  struct tcp_seg *cseg;

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
 800a064:	2004      	movs	r0, #4
 800a066:	f7fe ff53 	bl	8008f10 <memp_malloc>
  if (cseg == NULL) {
 800a06a:	4604      	mov	r4, r0
 800a06c:	b150      	cbz	r0, 800a084 <tcp_seg_copy+0x24>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
 800a06e:	6868      	ldr	r0, [r5, #4]
 800a070:	6829      	ldr	r1, [r5, #0]
 800a072:	68aa      	ldr	r2, [r5, #8]
 800a074:	68eb      	ldr	r3, [r5, #12]
 800a076:	6060      	str	r0, [r4, #4]
 800a078:	6021      	str	r1, [r4, #0]
 800a07a:	60a2      	str	r2, [r4, #8]
 800a07c:	60e3      	str	r3, [r4, #12]
  pbuf_ref(cseg->p);
 800a07e:	6860      	ldr	r0, [r4, #4]
 800a080:	f7ff fbfe 	bl	8009880 <pbuf_ref>
  return cseg;
}
 800a084:	4620      	mov	r0, r4
 800a086:	bd38      	pop	{r3, r4, r5, pc}
 800a088:	f3af 8000 	nop.w
 800a08c:	f3af 8000 	nop.w

0800a090 <tcp_arg>:
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->callback_arg = arg;
 800a090:	6101      	str	r1, [r0, #16]
 800a092:	4770      	bx	lr
 800a094:	f3af 8000 	nop.w
 800a098:	f3af 8000 	nop.w
 800a09c:	f3af 8000 	nop.w

0800a0a0 <tcp_recv>:
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
 800a0a0:	b530      	push	{r4, r5, lr}
  LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
 800a0a2:	7e03      	ldrb	r3, [r0, #24]
 800a0a4:	2b01      	cmp	r3, #1
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
 800a0a6:	b083      	sub	sp, #12
 800a0a8:	4604      	mov	r4, r0
 800a0aa:	460d      	mov	r5, r1
  LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
 800a0ac:	d003      	beq.n	800a0b6 <tcp_recv+0x16>
  pcb->recv = recv;
 800a0ae:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
}
 800a0b2:	b003      	add	sp, #12
 800a0b4:	bd30      	pop	{r4, r5, pc}
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
  LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
 800a0b6:	4b08      	ldr	r3, [pc, #32]	; (800a0d8 <tcp_recv+0x38>)
 800a0b8:	9300      	str	r3, [sp, #0]
 800a0ba:	4908      	ldr	r1, [pc, #32]	; (800a0dc <tcp_recv+0x3c>)
 800a0bc:	4a08      	ldr	r2, [pc, #32]	; (800a0e0 <tcp_recv+0x40>)
 800a0be:	4809      	ldr	r0, [pc, #36]	; (800a0e4 <tcp_recv+0x44>)
 800a0c0:	f240 5372 	movw	r3, #1394	; 0x572
 800a0c4:	f7ff fe34 	bl	8009d30 <chprintf.constprop.4>
 800a0c8:	4805      	ldr	r0, [pc, #20]	; (800a0e0 <tcp_recv+0x40>)
 800a0ca:	f7f6 ff51 	bl	8000f70 <chSysHalt>
  pcb->recv = recv;
 800a0ce:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
}
 800a0d2:	b003      	add	sp, #12
 800a0d4:	bd30      	pop	{r4, r5, pc}
 800a0d6:	bf00      	nop
 800a0d8:	08017948 	.word	0x08017948
 800a0dc:	08016fe0 	.word	0x08016fe0
 800a0e0:	08017a00 	.word	0x08017a00
 800a0e4:	200180c8 	.word	0x200180c8
 800a0e8:	f3af 8000 	nop.w
 800a0ec:	f3af 8000 	nop.w

0800a0f0 <tcp_sent>:
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
 800a0f0:	b530      	push	{r4, r5, lr}
  LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
 800a0f2:	7e03      	ldrb	r3, [r0, #24]
 800a0f4:	2b01      	cmp	r3, #1
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
 800a0f6:	b083      	sub	sp, #12
 800a0f8:	4604      	mov	r4, r0
 800a0fa:	460d      	mov	r5, r1
  LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
 800a0fc:	d002      	beq.n	800a104 <tcp_sent+0x14>
  pcb->sent = sent;
 800a0fe:	67e5      	str	r5, [r4, #124]	; 0x7c
}
 800a100:	b003      	add	sp, #12
 800a102:	bd30      	pop	{r4, r5, pc}
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
  LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
 800a104:	4b07      	ldr	r3, [pc, #28]	; (800a124 <tcp_sent+0x34>)
 800a106:	9300      	str	r3, [sp, #0]
 800a108:	4907      	ldr	r1, [pc, #28]	; (800a128 <tcp_sent+0x38>)
 800a10a:	4a08      	ldr	r2, [pc, #32]	; (800a12c <tcp_sent+0x3c>)
 800a10c:	4808      	ldr	r0, [pc, #32]	; (800a130 <tcp_sent+0x40>)
 800a10e:	f44f 63b0 	mov.w	r3, #1408	; 0x580
 800a112:	f7ff fe0d 	bl	8009d30 <chprintf.constprop.4>
 800a116:	4805      	ldr	r0, [pc, #20]	; (800a12c <tcp_sent+0x3c>)
 800a118:	f7f6 ff2a 	bl	8000f70 <chSysHalt>
  pcb->sent = sent;
 800a11c:	67e5      	str	r5, [r4, #124]	; 0x7c
}
 800a11e:	b003      	add	sp, #12
 800a120:	bd30      	pop	{r4, r5, pc}
 800a122:	bf00      	nop
 800a124:	08017948 	.word	0x08017948
 800a128:	08016fe0 	.word	0x08016fe0
 800a12c:	08017a28 	.word	0x08017a28
 800a130:	200180c8 	.word	0x200180c8
 800a134:	f3af 8000 	nop.w
 800a138:	f3af 8000 	nop.w
 800a13c:	f3af 8000 	nop.w

0800a140 <tcp_err>:
 * @param err callback function to call for this pcb when a fatal error
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
 800a140:	b530      	push	{r4, r5, lr}
  LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
 800a142:	7e03      	ldrb	r3, [r0, #24]
 800a144:	2b01      	cmp	r3, #1
 * @param err callback function to call for this pcb when a fatal error
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
 800a146:	b083      	sub	sp, #12
 800a148:	4604      	mov	r4, r0
 800a14a:	460d      	mov	r5, r1
  LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
 800a14c:	d003      	beq.n	800a156 <tcp_err+0x16>
  pcb->errf = err;
 800a14e:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
}
 800a152:	b003      	add	sp, #12
 800a154:	bd30      	pop	{r4, r5, pc}
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
  LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
 800a156:	4b08      	ldr	r3, [pc, #32]	; (800a178 <tcp_err+0x38>)
 800a158:	9300      	str	r3, [sp, #0]
 800a15a:	4908      	ldr	r1, [pc, #32]	; (800a17c <tcp_err+0x3c>)
 800a15c:	4a08      	ldr	r2, [pc, #32]	; (800a180 <tcp_err+0x40>)
 800a15e:	4809      	ldr	r0, [pc, #36]	; (800a184 <tcp_err+0x44>)
 800a160:	f240 538f 	movw	r3, #1423	; 0x58f
 800a164:	f7ff fde4 	bl	8009d30 <chprintf.constprop.4>
 800a168:	4805      	ldr	r0, [pc, #20]	; (800a180 <tcp_err+0x40>)
 800a16a:	f7f6 ff01 	bl	8000f70 <chSysHalt>
  pcb->errf = err;
 800a16e:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
}
 800a172:	b003      	add	sp, #12
 800a174:	bd30      	pop	{r4, r5, pc}
 800a176:	bf00      	nop
 800a178:	08017948 	.word	0x08017948
 800a17c:	08016fe0 	.word	0x08016fe0
 800a180:	08017a50 	.word	0x08017a50
 800a184:	200180c8 	.word	0x200180c8
 800a188:	f3af 8000 	nop.w
 800a18c:	f3af 8000 	nop.w

0800a190 <tcp_accept>:
void
tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
{
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->accept = accept;
 800a190:	6141      	str	r1, [r0, #20]
 800a192:	4770      	bx	lr
 800a194:	f3af 8000 	nop.w
 800a198:	f3af 8000 	nop.w
 800a19c:	f3af 8000 	nop.w

0800a1a0 <tcp_poll>:
 * timer interval, which is called twice a second.
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
 800a1a0:	b570      	push	{r4, r5, r6, lr}
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
 800a1a2:	7e03      	ldrb	r3, [r0, #24]
 800a1a4:	2b01      	cmp	r3, #1
 * timer interval, which is called twice a second.
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
 800a1a6:	b082      	sub	sp, #8
 800a1a8:	4604      	mov	r4, r0
 800a1aa:	460e      	mov	r6, r1
 800a1ac:	4615      	mov	r5, r2
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
 800a1ae:	d005      	beq.n	800a1bc <tcp_poll+0x1c>
#if LWIP_CALLBACK_API
  pcb->poll = poll;
 800a1b0:	f8c4 6088 	str.w	r6, [r4, #136]	; 0x88
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
 800a1b4:	f884 5020 	strb.w	r5, [r4, #32]
}
 800a1b8:	b002      	add	sp, #8
 800a1ba:	bd70      	pop	{r4, r5, r6, pc}
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
 800a1bc:	4b08      	ldr	r3, [pc, #32]	; (800a1e0 <tcp_poll+0x40>)
 800a1be:	9300      	str	r3, [sp, #0]
 800a1c0:	4908      	ldr	r1, [pc, #32]	; (800a1e4 <tcp_poll+0x44>)
 800a1c2:	4a09      	ldr	r2, [pc, #36]	; (800a1e8 <tcp_poll+0x48>)
 800a1c4:	4809      	ldr	r0, [pc, #36]	; (800a1ec <tcp_poll+0x4c>)
 800a1c6:	f240 53ae 	movw	r3, #1454	; 0x5ae
 800a1ca:	f7ff fdb1 	bl	8009d30 <chprintf.constprop.4>
 800a1ce:	4806      	ldr	r0, [pc, #24]	; (800a1e8 <tcp_poll+0x48>)
 800a1d0:	f7f6 fece 	bl	8000f70 <chSysHalt>
#if LWIP_CALLBACK_API
  pcb->poll = poll;
 800a1d4:	f8c4 6088 	str.w	r6, [r4, #136]	; 0x88
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
 800a1d8:	f884 5020 	strb.w	r5, [r4, #32]
}
 800a1dc:	b002      	add	sp, #8
 800a1de:	bd70      	pop	{r4, r5, r6, pc}
 800a1e0:	08017948 	.word	0x08017948
 800a1e4:	08016fe0 	.word	0x08016fe0
 800a1e8:	08017a78 	.word	0x08017a78
 800a1ec:	200180c8 	.word	0x200180c8

0800a1f0 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
 800a1f0:	b538      	push	{r3, r4, r5, lr}
  if (pcb->state != CLOSED &&
 800a1f2:	7e03      	ldrb	r3, [r0, #24]
 800a1f4:	2b01      	cmp	r3, #1
 800a1f6:	d92b      	bls.n	800a250 <tcp_pcb_purge+0x60>
 800a1f8:	2b0a      	cmp	r3, #10
 800a1fa:	d029      	beq.n	800a250 <tcp_pcb_purge+0x60>
 800a1fc:	4605      	mov	r5, r0
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
 800a1fe:	6f80      	ldr	r0, [r0, #120]	; 0x78
 800a200:	b118      	cbz	r0, 800a20a <tcp_pcb_purge+0x1a>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 800a202:	f7ff f8fd 	bl	8009400 <pbuf_free>
      pcb->refused_data = NULL;
 800a206:	2300      	movs	r3, #0
 800a208:	67ab      	str	r3, [r5, #120]	; 0x78
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    tcp_segs_free(pcb->ooseq);
 800a20a:	6f68      	ldr	r0, [r5, #116]	; 0x74
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 800a20c:	b128      	cbz	r0, 800a21a <tcp_pcb_purge+0x2a>
    struct tcp_seg *next = seg->next;
 800a20e:	6804      	ldr	r4, [r0, #0]
    tcp_seg_free(seg);
 800a210:	f7ff ff06 	bl	800a020 <tcp_seg_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 800a214:	4620      	mov	r0, r4
 800a216:	2c00      	cmp	r4, #0
 800a218:	d1f9      	bne.n	800a20e <tcp_pcb_purge+0x1e>

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
 800a21a:	6ee8      	ldr	r0, [r5, #108]	; 0x6c
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    tcp_segs_free(pcb->ooseq);
    pcb->ooseq = NULL;
 800a21c:	2200      	movs	r2, #0
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 800a21e:	f64f 73ff 	movw	r3, #65535	; 0xffff
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    tcp_segs_free(pcb->ooseq);
    pcb->ooseq = NULL;
 800a222:	676a      	str	r2, [r5, #116]	; 0x74
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 800a224:	86ab      	strh	r3, [r5, #52]	; 0x34
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 800a226:	b128      	cbz	r0, 800a234 <tcp_pcb_purge+0x44>
    struct tcp_seg *next = seg->next;
 800a228:	6804      	ldr	r4, [r0, #0]
    tcp_seg_free(seg);
 800a22a:	f7ff fef9 	bl	800a020 <tcp_seg_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 800a22e:	4620      	mov	r0, r4
 800a230:	2c00      	cmp	r4, #0
 800a232:	d1f9      	bne.n	800a228 <tcp_pcb_purge+0x38>
    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
 800a234:	6f28      	ldr	r0, [r5, #112]	; 0x70
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 800a236:	b128      	cbz	r0, 800a244 <tcp_pcb_purge+0x54>
    struct tcp_seg *next = seg->next;
 800a238:	6804      	ldr	r4, [r0, #0]
    tcp_seg_free(seg);
 800a23a:	f7ff fef1 	bl	800a020 <tcp_seg_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 800a23e:	4620      	mov	r0, r4
 800a240:	2c00      	cmp	r4, #0
 800a242:	d1f9      	bne.n	800a238 <tcp_pcb_purge+0x48>
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unacked = pcb->unsent = NULL;
 800a244:	2300      	movs	r3, #0
 800a246:	66eb      	str	r3, [r5, #108]	; 0x6c
 800a248:	672b      	str	r3, [r5, #112]	; 0x70
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 800a24a:	f8a5 306a 	strh.w	r3, [r5, #106]	; 0x6a
 800a24e:	bd38      	pop	{r3, r4, r5, pc}
 800a250:	bd38      	pop	{r3, r4, r5, pc}
 800a252:	bf00      	nop
 800a254:	f3af 8000 	nop.w
 800a258:	f3af 8000 	nop.w
 800a25c:	f3af 8000 	nop.w

0800a260 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
 800a260:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
 800a264:	4cb3      	ldr	r4, [pc, #716]	; (800a534 <tcp_slowtmr+0x2d4>)
  ++tcp_timer_ctr;
 800a266:	4db4      	ldr	r5, [pc, #720]	; (800a538 <tcp_slowtmr+0x2d8>)
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
 800a268:	6822      	ldr	r2, [r4, #0]
  ++tcp_timer_ctr;
 800a26a:	782b      	ldrb	r3, [r5, #0]
 800a26c:	f8df b2f0 	ldr.w	fp, [pc, #752]	; 800a560 <tcp_slowtmr+0x300>
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
 800a270:	3201      	adds	r2, #1
  ++tcp_timer_ctr;
 800a272:	3301      	adds	r3, #1
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
 800a274:	b085      	sub	sp, #20
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
 800a276:	6022      	str	r2, [r4, #0]
  ++tcp_timer_ctr;
 800a278:	702b      	strb	r3, [r5, #0]

tcp_slowtmr_start:
  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
 800a27a:	f8db 7000 	ldr.w	r7, [fp]
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 800a27e:	2f00      	cmp	r7, #0
 800a280:	f000 8086 	beq.w	800a390 <tcp_slowtmr+0x130>
 800a284:	2600      	movs	r6, #0
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 800a286:	7e3b      	ldrb	r3, [r7, #24]
 800a288:	2b00      	cmp	r3, #0
 800a28a:	f000 8107 	beq.w	800a49c <tcp_slowtmr+0x23c>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
 800a28e:	2b01      	cmp	r3, #1
 800a290:	f000 8114 	beq.w	800a4bc <tcp_slowtmr+0x25c>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
 800a294:	2b0a      	cmp	r3, #10
 800a296:	f000 8121 	beq.w	800a4dc <tcp_slowtmr+0x27c>
    if (pcb->last_timer == tcp_timer_ctr) {
 800a29a:	782b      	ldrb	r3, [r5, #0]
 800a29c:	f897 2021 	ldrb.w	r2, [r7, #33]	; 0x21
 800a2a0:	429a      	cmp	r2, r3
 800a2a2:	f000 812d 	beq.w	800a500 <tcp_slowtmr+0x2a0>
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
    pcb_reset = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 800a2a6:	7e3a      	ldrb	r2, [r7, #24]
    if (pcb->last_timer == tcp_timer_ctr) {
      /* skip this pcb, we have already processed it */
      pcb = pcb->next;
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;
 800a2a8:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21

    pcb_remove = 0;
    pcb_reset = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 800a2ac:	2a02      	cmp	r2, #2
 800a2ae:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 800a2b2:	f000 818f 	beq.w	800a5d4 <tcp_slowtmr+0x374>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
 800a2b6:	2b0c      	cmp	r3, #12
 800a2b8:	f000 8196 	beq.w	800a5e8 <tcp_slowtmr+0x388>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
 800a2bc:	f897 1095 	ldrb.w	r1, [r7, #149]	; 0x95
 800a2c0:	2900      	cmp	r1, #0
 800a2c2:	f000 8151 	beq.w	800a568 <tcp_slowtmr+0x308>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 800a2c6:	489d      	ldr	r0, [pc, #628]	; (800a53c <tcp_slowtmr+0x2dc>)
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
 800a2c8:	f897 3094 	ldrb.w	r3, [r7, #148]	; 0x94
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 800a2cc:	4408      	add	r0, r1
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
 800a2ce:	3301      	adds	r3, #1
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 800a2d0:	f810 0c01 	ldrb.w	r0, [r0, #-1]
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
 800a2d4:	b2db      	uxtb	r3, r3
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 800a2d6:	4298      	cmp	r0, r3
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
 800a2d8:	f887 3094 	strb.w	r3, [r7, #148]	; 0x94
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 800a2dc:	f200 8115 	bhi.w	800a50a <tcp_slowtmr+0x2aa>
          pcb->persist_cnt = 0;
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 800a2e0:	2906      	cmp	r1, #6
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
          pcb->persist_cnt = 0;
 800a2e2:	f04f 0300 	mov.w	r3, #0
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
            pcb->persist_backoff++;
 800a2e6:	bf98      	it	ls
 800a2e8:	3101      	addls	r1, #1
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
          pcb->persist_cnt = 0;
 800a2ea:	f887 3094 	strb.w	r3, [r7, #148]	; 0x94
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
            pcb->persist_backoff++;
 800a2ee:	bf98      	it	ls
 800a2f0:	f887 1095 	strbls.w	r1, [r7, #149]	; 0x95
          }
          tcp_zero_window_probe(pcb);
 800a2f4:	4638      	mov	r0, r7
 800a2f6:	f003 f993 	bl	800d620 <tcp_zero_window_probe>
 800a2fa:	7e3a      	ldrb	r2, [r7, #24]
      pcb = pcb->next;
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
 800a2fc:	f04f 0800 	mov.w	r8, #0
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
 800a300:	2a06      	cmp	r2, #6
 800a302:	f000 8107 	beq.w	800a514 <tcp_slowtmr+0x2b4>
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
 800a306:	7a3b      	ldrb	r3, [r7, #8]
 800a308:	f003 0308 	and.w	r3, r3, #8
 800a30c:	f003 09ff 	and.w	r9, r3, #255	; 0xff
 800a310:	b13b      	cbz	r3, 800a322 <tcp_slowtmr+0xc2>
 800a312:	2a04      	cmp	r2, #4
 800a314:	f000 816b 	beq.w	800a5ee <tcp_slowtmr+0x38e>
       ((pcb->state == ESTABLISHED) ||
 800a318:	2a07      	cmp	r2, #7
 800a31a:	f000 8168 	beq.w	800a5ee <tcp_slowtmr+0x38e>
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
    pcb_reset = 0;
 800a31e:	f04f 0900 	mov.w	r9, #0

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
 800a322:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800a324:	b148      	cbz	r0, 800a33a <tcp_slowtmr+0xda>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
 800a326:	6822      	ldr	r2, [r4, #0]
 800a328:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800a32a:	f9b7 3044 	ldrsh.w	r3, [r7, #68]	; 0x44
 800a32e:	1a52      	subs	r2, r2, r1
 800a330:	eb03 0343 	add.w	r3, r3, r3, lsl #1

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
 800a334:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
 800a338:	d25e      	bcs.n	800a3f8 <tcp_slowtmr+0x198>
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
 800a33a:	7e3b      	ldrb	r3, [r7, #24]
 800a33c:	2b03      	cmp	r3, #3
 800a33e:	d067      	beq.n	800a410 <tcp_slowtmr+0x1b0>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
 800a340:	2b09      	cmp	r3, #9
 800a342:	d06f      	beq.n	800a424 <tcp_slowtmr+0x1c4>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 800a344:	f1b8 0f00 	cmp.w	r8, #0
 800a348:	d171      	bne.n	800a42e <tcp_slowtmr+0x1ce>
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;

      /* We check if we should poll the connection. */
      ++prev->polltmr;
 800a34a:	7ffb      	ldrb	r3, [r7, #31]
      if (prev->polltmr >= prev->pollinterval) {
 800a34c:	f897 2020 	ldrb.w	r2, [r7, #32]
        goto tcp_slowtmr_start;
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;
 800a350:	f8d7 900c 	ldr.w	r9, [r7, #12]

      /* We check if we should poll the connection. */
      ++prev->polltmr;
 800a354:	3301      	adds	r3, #1
 800a356:	b2db      	uxtb	r3, r3
      if (prev->polltmr >= prev->pollinterval) {
 800a358:	429a      	cmp	r2, r3
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;

      /* We check if we should poll the connection. */
      ++prev->polltmr;
 800a35a:	77fb      	strb	r3, [r7, #31]
      if (prev->polltmr >= prev->pollinterval) {
 800a35c:	d813      	bhi.n	800a386 <tcp_slowtmr+0x126>
        prev->polltmr = 0;
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
 800a35e:	4e78      	ldr	r6, [pc, #480]	; (800a540 <tcp_slowtmr+0x2e0>)
        TCP_EVENT_POLL(prev, err);
 800a360:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
      pcb = pcb->next;

      /* We check if we should poll the connection. */
      ++prev->polltmr;
      if (prev->polltmr >= prev->pollinterval) {
        prev->polltmr = 0;
 800a364:	f887 801f 	strb.w	r8, [r7, #31]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
 800a368:	f886 8000 	strb.w	r8, [r6]
        TCP_EVENT_POLL(prev, err);
 800a36c:	2b00      	cmp	r3, #0
 800a36e:	f000 808c 	beq.w	800a48a <tcp_slowtmr+0x22a>
 800a372:	6938      	ldr	r0, [r7, #16]
 800a374:	4639      	mov	r1, r7
 800a376:	4798      	blx	r3
        if (tcp_active_pcbs_changed) {
 800a378:	7833      	ldrb	r3, [r6, #0]
 800a37a:	2b00      	cmp	r3, #0
 800a37c:	f47f af7d 	bne.w	800a27a <tcp_slowtmr+0x1a>
          goto tcp_slowtmr_start;
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
 800a380:	2800      	cmp	r0, #0
 800a382:	f000 8082 	beq.w	800a48a <tcp_slowtmr+0x22a>
 800a386:	463e      	mov	r6, r7
        goto tcp_slowtmr_start;
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;
 800a388:	464f      	mov	r7, r9
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 800a38a:	2f00      	cmp	r7, #0
 800a38c:	f47f af7b 	bne.w	800a286 <tcp_slowtmr+0x26>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
 800a390:	f8df 81d0 	ldr.w	r8, [pc, #464]	; 800a564 <tcp_slowtmr+0x304>
 800a394:	f8d8 5000 	ldr.w	r5, [r8]
  while (pcb != NULL) {
 800a398:	b35d      	cbz	r5, 800a3f2 <tcp_slowtmr+0x192>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800a39a:	4f6a      	ldr	r7, [pc, #424]	; (800a544 <tcp_slowtmr+0x2e4>)

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
 800a39c:	2600      	movs	r6, #0
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800a39e:	7e2b      	ldrb	r3, [r5, #24]
 800a3a0:	2b0a      	cmp	r3, #10
 800a3a2:	d00a      	beq.n	800a3ba <tcp_slowtmr+0x15a>
 800a3a4:	9700      	str	r7, [sp, #0]
 800a3a6:	4868      	ldr	r0, [pc, #416]	; (800a548 <tcp_slowtmr+0x2e8>)
 800a3a8:	4968      	ldr	r1, [pc, #416]	; (800a54c <tcp_slowtmr+0x2ec>)
 800a3aa:	4a69      	ldr	r2, [pc, #420]	; (800a550 <tcp_slowtmr+0x2f0>)
 800a3ac:	f240 33ee 	movw	r3, #1006	; 0x3ee
 800a3b0:	f7ff fcbe 	bl	8009d30 <chprintf.constprop.4>
 800a3b4:	4866      	ldr	r0, [pc, #408]	; (800a550 <tcp_slowtmr+0x2f0>)
 800a3b6:	f7f6 fddb 	bl	8000f70 <chSysHalt>
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 800a3ba:	6823      	ldr	r3, [r4, #0]
 800a3bc:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800a3be:	1a9b      	subs	r3, r3, r2
 800a3c0:	2bf0      	cmp	r3, #240	; 0xf0
 800a3c2:	f240 812c 	bls.w	800a61e <tcp_slowtmr+0x3be>


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
 800a3c6:	4628      	mov	r0, r5
 800a3c8:	f7ff ff12 	bl	800a1f0 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
 800a3cc:	2e00      	cmp	r6, #0
 800a3ce:	f000 8160 	beq.w	800a692 <tcp_slowtmr+0x432>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
 800a3d2:	f8d8 3000 	ldr.w	r3, [r8]
 800a3d6:	429d      	cmp	r5, r3
 800a3d8:	f000 817c 	beq.w	800a6d4 <tcp_slowtmr+0x474>
        prev->next = pcb->next;
 800a3dc:	68eb      	ldr	r3, [r5, #12]
 800a3de:	60f3      	str	r3, [r6, #12]
 800a3e0:	f8d5 900c 	ldr.w	r9, [r5, #12]
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
      }
      pcb2 = pcb;
      pcb = pcb->next;
      memp_free(MEMP_TCP_PCB, pcb2);
 800a3e4:	4629      	mov	r1, r5
 800a3e6:	2002      	movs	r0, #2
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
      }
      pcb2 = pcb;
      pcb = pcb->next;
 800a3e8:	464d      	mov	r5, r9
      memp_free(MEMP_TCP_PCB, pcb2);
 800a3ea:	f7fe fde9 	bl	8008fc0 <memp_free>

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
 800a3ee:	2d00      	cmp	r5, #0
 800a3f0:	d1d5      	bne.n	800a39e <tcp_slowtmr+0x13e>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
 800a3f2:	b005      	add	sp, #20
 800a3f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 800a3f8:	f8d0 a000 	ldr.w	sl, [r0]
    tcp_seg_free(seg);
 800a3fc:	f7ff fe10 	bl	800a020 <tcp_seg_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 800a400:	4650      	mov	r0, sl
 800a402:	2800      	cmp	r0, #0
 800a404:	d1f8      	bne.n	800a3f8 <tcp_slowtmr+0x198>
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
 800a406:	7e3b      	ldrb	r3, [r7, #24]
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
      pcb->ooseq = NULL;
 800a408:	f8c7 a074 	str.w	sl, [r7, #116]	; 0x74
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
 800a40c:	2b03      	cmp	r3, #3
 800a40e:	d197      	bne.n	800a340 <tcp_slowtmr+0xe0>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800a410:	6823      	ldr	r3, [r4, #0]
 800a412:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800a414:	1a9b      	subs	r3, r3, r2
 800a416:	2b28      	cmp	r3, #40	; 0x28
 800a418:	d994      	bls.n	800a344 <tcp_slowtmr+0xe4>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
 800a41a:	f108 0801 	add.w	r8, r8, #1
 800a41e:	fa5f f888 	uxtb.w	r8, r8
 800a422:	e78f      	b.n	800a344 <tcp_slowtmr+0xe4>
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 800a424:	6823      	ldr	r3, [r4, #0]
 800a426:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800a428:	1a9b      	subs	r3, r3, r2
 800a42a:	2bf0      	cmp	r3, #240	; 0xf0
 800a42c:	d98a      	bls.n	800a344 <tcp_slowtmr+0xe4>
    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
      struct tcp_pcb *pcb2;
      tcp_err_fn err_fn;
      void *err_arg;
      tcp_pcb_purge(pcb);
 800a42e:	4638      	mov	r0, r7
 800a430:	f7ff fede 	bl	800a1f0 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 800a434:	f8db 3000 	ldr.w	r3, [fp]
      struct tcp_pcb *pcb2;
      tcp_err_fn err_fn;
      void *err_arg;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
 800a438:	2e00      	cmp	r6, #0
 800a43a:	f000 8118 	beq.w	800a66e <tcp_slowtmr+0x40e>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 800a43e:	429f      	cmp	r7, r3
 800a440:	f000 813b 	beq.w	800a6ba <tcp_slowtmr+0x45a>
        prev->next = pcb->next;
 800a444:	68fb      	ldr	r3, [r7, #12]
 800a446:	60f3      	str	r3, [r6, #12]
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
      }

      if (pcb_reset) {
 800a448:	f1b9 0f00 	cmp.w	r9, #0
 800a44c:	f040 8104 	bne.w	800a658 <tcp_slowtmr+0x3f8>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
          pcb->local_port, pcb->remote_port);
      }

      err_fn = pcb->errf;
      err_arg = pcb->callback_arg;
 800a450:	693b      	ldr	r3, [r7, #16]
      if (pcb_reset) {
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
          pcb->local_port, pcb->remote_port);
      }

      err_fn = pcb->errf;
 800a452:	f8d7 a08c 	ldr.w	sl, [r7, #140]	; 0x8c
      err_arg = pcb->callback_arg;
      pcb2 = pcb;
      pcb = pcb->next;
      memp_free(MEMP_TCP_PCB, pcb2);

      tcp_active_pcbs_changed = 0;
 800a456:	f8df 80e8 	ldr.w	r8, [pc, #232]	; 800a540 <tcp_slowtmr+0x2e0>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
          pcb->local_port, pcb->remote_port);
      }

      err_fn = pcb->errf;
      err_arg = pcb->callback_arg;
 800a45a:	9303      	str	r3, [sp, #12]
      pcb2 = pcb;
      pcb = pcb->next;
      memp_free(MEMP_TCP_PCB, pcb2);
 800a45c:	2002      	movs	r0, #2
 800a45e:	4639      	mov	r1, r7
      }

      err_fn = pcb->errf;
      err_arg = pcb->callback_arg;
      pcb2 = pcb;
      pcb = pcb->next;
 800a460:	f8d7 900c 	ldr.w	r9, [r7, #12]
      memp_free(MEMP_TCP_PCB, pcb2);
 800a464:	f7fe fdac 	bl	8008fc0 <memp_free>

      tcp_active_pcbs_changed = 0;
 800a468:	2200      	movs	r2, #0
 800a46a:	f888 2000 	strb.w	r2, [r8]
      TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
 800a46e:	f1ba 0f00 	cmp.w	sl, #0
 800a472:	d089      	beq.n	800a388 <tcp_slowtmr+0x128>
 800a474:	9803      	ldr	r0, [sp, #12]
 800a476:	f06f 0109 	mvn.w	r1, #9
 800a47a:	47d0      	blx	sl
      if (tcp_active_pcbs_changed) {
 800a47c:	f898 3000 	ldrb.w	r3, [r8]
 800a480:	2b00      	cmp	r3, #0
 800a482:	f47f aefa 	bne.w	800a27a <tcp_slowtmr+0x1a>
        goto tcp_slowtmr_start;
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;
 800a486:	464f      	mov	r7, r9
 800a488:	e77f      	b.n	800a38a <tcp_slowtmr+0x12a>
        if (tcp_active_pcbs_changed) {
          goto tcp_slowtmr_start;
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
          tcp_output(prev);
 800a48a:	4638      	mov	r0, r7
 800a48c:	463e      	mov	r6, r7
        goto tcp_slowtmr_start;
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;
 800a48e:	464f      	mov	r7, r9
        if (tcp_active_pcbs_changed) {
          goto tcp_slowtmr_start;
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
          tcp_output(prev);
 800a490:	f002 fe0e 	bl	800d0b0 <tcp_output>
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 800a494:	2f00      	cmp	r7, #0
 800a496:	f47f aef6 	bne.w	800a286 <tcp_slowtmr+0x26>
 800a49a:	e779      	b.n	800a390 <tcp_slowtmr+0x130>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 800a49c:	4b29      	ldr	r3, [pc, #164]	; (800a544 <tcp_slowtmr+0x2e4>)
 800a49e:	9300      	str	r3, [sp, #0]
 800a4a0:	492a      	ldr	r1, [pc, #168]	; (800a54c <tcp_slowtmr+0x2ec>)
 800a4a2:	4a2c      	ldr	r2, [pc, #176]	; (800a554 <tcp_slowtmr+0x2f4>)
 800a4a4:	4828      	ldr	r0, [pc, #160]	; (800a548 <tcp_slowtmr+0x2e8>)
 800a4a6:	f240 332a 	movw	r3, #810	; 0x32a
 800a4aa:	f7ff fc41 	bl	8009d30 <chprintf.constprop.4>
 800a4ae:	4829      	ldr	r0, [pc, #164]	; (800a554 <tcp_slowtmr+0x2f4>)
 800a4b0:	f7f6 fd5e 	bl	8000f70 <chSysHalt>
 800a4b4:	7e3b      	ldrb	r3, [r7, #24]
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
 800a4b6:	2b01      	cmp	r3, #1
 800a4b8:	f47f aeec 	bne.w	800a294 <tcp_slowtmr+0x34>
 800a4bc:	4b21      	ldr	r3, [pc, #132]	; (800a544 <tcp_slowtmr+0x2e4>)
 800a4be:	9300      	str	r3, [sp, #0]
 800a4c0:	4922      	ldr	r1, [pc, #136]	; (800a54c <tcp_slowtmr+0x2ec>)
 800a4c2:	4a25      	ldr	r2, [pc, #148]	; (800a558 <tcp_slowtmr+0x2f8>)
 800a4c4:	4820      	ldr	r0, [pc, #128]	; (800a548 <tcp_slowtmr+0x2e8>)
 800a4c6:	f240 332b 	movw	r3, #811	; 0x32b
 800a4ca:	f7ff fc31 	bl	8009d30 <chprintf.constprop.4>
 800a4ce:	4822      	ldr	r0, [pc, #136]	; (800a558 <tcp_slowtmr+0x2f8>)
 800a4d0:	f7f6 fd4e 	bl	8000f70 <chSysHalt>
 800a4d4:	7e3b      	ldrb	r3, [r7, #24]
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
 800a4d6:	2b0a      	cmp	r3, #10
 800a4d8:	f47f aedf 	bne.w	800a29a <tcp_slowtmr+0x3a>
 800a4dc:	4b19      	ldr	r3, [pc, #100]	; (800a544 <tcp_slowtmr+0x2e4>)
 800a4de:	4a1f      	ldr	r2, [pc, #124]	; (800a55c <tcp_slowtmr+0x2fc>)
 800a4e0:	9300      	str	r3, [sp, #0]
 800a4e2:	491a      	ldr	r1, [pc, #104]	; (800a54c <tcp_slowtmr+0x2ec>)
 800a4e4:	4818      	ldr	r0, [pc, #96]	; (800a548 <tcp_slowtmr+0x2e8>)
 800a4e6:	f44f 734b 	mov.w	r3, #812	; 0x32c
 800a4ea:	f7ff fc21 	bl	8009d30 <chprintf.constprop.4>
 800a4ee:	481b      	ldr	r0, [pc, #108]	; (800a55c <tcp_slowtmr+0x2fc>)
 800a4f0:	f7f6 fd3e 	bl	8000f70 <chSysHalt>
    if (pcb->last_timer == tcp_timer_ctr) {
 800a4f4:	782b      	ldrb	r3, [r5, #0]
 800a4f6:	f897 2021 	ldrb.w	r2, [r7, #33]	; 0x21
 800a4fa:	429a      	cmp	r2, r3
 800a4fc:	f47f aed3 	bne.w	800a2a6 <tcp_slowtmr+0x46>
      /* skip this pcb, we have already processed it */
      pcb = pcb->next;
 800a500:	68ff      	ldr	r7, [r7, #12]
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 800a502:	2f00      	cmp	r7, #0
 800a504:	f47f aebf 	bne.w	800a286 <tcp_slowtmr+0x26>
 800a508:	e742      	b.n	800a390 <tcp_slowtmr+0x130>
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
 800a50a:	2a06      	cmp	r2, #6
      pcb = pcb->next;
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
 800a50c:	f04f 0800 	mov.w	r8, #0
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
 800a510:	f47f aef9 	bne.w	800a306 <tcp_slowtmr+0xa6>
      /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
      if (pcb->flags & TF_RXCLOSED) {
 800a514:	7fbb      	ldrb	r3, [r7, #30]
 800a516:	06db      	lsls	r3, r3, #27
 800a518:	f57f af01 	bpl.w	800a31e <tcp_slowtmr+0xbe>
        /* PCB was fully closed (either through close() or SHUT_RDWR):
           normal FIN-WAIT timeout handling. */
        if ((u32_t)(tcp_ticks - pcb->tmr) >
 800a51c:	6823      	ldr	r3, [r4, #0]
 800a51e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800a520:	1a9b      	subs	r3, r3, r2
 800a522:	2b28      	cmp	r3, #40	; 0x28
 800a524:	f67f aefb 	bls.w	800a31e <tcp_slowtmr+0xbe>
            TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
          ++pcb_remove;
 800a528:	f108 0801 	add.w	r8, r8, #1
 800a52c:	fa5f f888 	uxtb.w	r8, r8
 800a530:	e6f5      	b.n	800a31e <tcp_slowtmr+0xbe>
 800a532:	bf00      	nop
 800a534:	2000cb54 	.word	0x2000cb54
 800a538:	2000cb64 	.word	0x2000cb64
 800a53c:	08017d30 	.word	0x08017d30
 800a540:	2000cb4c 	.word	0x2000cb4c
 800a544:	08017948 	.word	0x08017948
 800a548:	200180c8 	.word	0x200180c8
 800a54c:	08016fe0 	.word	0x08016fe0
 800a550:	08017b78 	.word	0x08017b78
 800a554:	08017a98 	.word	0x08017a98
 800a558:	08017ac4 	.word	0x08017ac4
 800a55c:	08017af0 	.word	0x08017af0
 800a560:	2000cb60 	.word	0x2000cb60
 800a564:	2000cb50 	.word	0x2000cb50
          }
          tcp_zero_window_probe(pcb);
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0) {
 800a568:	8eb9      	ldrh	r1, [r7, #52]	; 0x34
 800a56a:	0408      	lsls	r0, r1, #16
          ++pcb->rtime;
 800a56c:	bf5c      	itt	pl
 800a56e:	3101      	addpl	r1, #1
 800a570:	86b9      	strhpl	r1, [r7, #52]	; 0x34
        }

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
 800a572:	6f39      	ldr	r1, [r7, #112]	; 0x70
 800a574:	2900      	cmp	r1, #0
 800a576:	d0c8      	beq.n	800a50a <tcp_slowtmr+0x2aa>
 800a578:	f9b7 0034 	ldrsh.w	r0, [r7, #52]	; 0x34
 800a57c:	f9b7 1044 	ldrsh.w	r1, [r7, #68]	; 0x44
 800a580:	4288      	cmp	r0, r1
 800a582:	dbc2      	blt.n	800a50a <tcp_slowtmr+0x2aa>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
 800a584:	2a02      	cmp	r2, #2
 800a586:	d00a      	beq.n	800a59e <tcp_slowtmr+0x33e>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
 800a588:	4958      	ldr	r1, [pc, #352]	; (800a6ec <tcp_slowtmr+0x48c>)
 800a58a:	f9b7 0040 	ldrsh.w	r0, [r7, #64]	; 0x40
 800a58e:	f9b7 2042 	ldrsh.w	r2, [r7, #66]	; 0x42
 800a592:	5cc9      	ldrb	r1, [r1, r3]
 800a594:	eb02 03e0 	add.w	r3, r2, r0, asr #3
 800a598:	408b      	lsls	r3, r1
 800a59a:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44

          /* Reset the retransmission timer. */
          pcb->rtime = 0;

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 800a59e:	f8b7 104c 	ldrh.w	r1, [r7, #76]	; 0x4c
 800a5a2:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
          pcb->ssthresh = eff_wnd >> 1;
          if (pcb->ssthresh < (pcb->mss << 1)) {
 800a5a6:	8efa      	ldrh	r2, [r7, #54]	; 0x36
            pcb->ssthresh = (pcb->mss << 1);
          }
          pcb->cwnd = pcb->mss;
 800a5a8:	f8a7 204c 	strh.w	r2, [r7, #76]	; 0x4c
          /* Reset the retransmission timer. */
          pcb->rtime = 0;

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
 800a5ac:	428b      	cmp	r3, r1
 800a5ae:	bf28      	it	cs
 800a5b0:	460b      	movcs	r3, r1
 800a5b2:	085b      	lsrs	r3, r3, #1
          if (pcb->ssthresh < (pcb->mss << 1)) {
 800a5b4:	0051      	lsls	r1, r2, #1
          if (pcb->state != SYN_SENT) {
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
 800a5b6:	2000      	movs	r0, #0

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
          if (pcb->ssthresh < (pcb->mss << 1)) {
 800a5b8:	428b      	cmp	r3, r1
          /* Reset the retransmission timer. */
          pcb->rtime = 0;

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
 800a5ba:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
          if (pcb->state != SYN_SENT) {
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
 800a5be:	86b8      	strh	r0, [r7, #52]	; 0x34

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
          if (pcb->ssthresh < (pcb->mss << 1)) {
            pcb->ssthresh = (pcb->mss << 1);
 800a5c0:	bfb8      	it	lt
 800a5c2:	f8a7 104e 	strhlt.w	r1, [r7, #78]	; 0x4e
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
 800a5c6:	4638      	mov	r0, r7
 800a5c8:	f002 ff82 	bl	800d4d0 <tcp_rexmit_rto>
      pcb = pcb->next;
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
 800a5cc:	f04f 0800 	mov.w	r8, #0
 800a5d0:	7e3a      	ldrb	r2, [r7, #24]
 800a5d2:	e695      	b.n	800a300 <tcp_slowtmr+0xa0>
    pcb_reset = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 800a5d4:	2b06      	cmp	r3, #6
 800a5d6:	d002      	beq.n	800a5de <tcp_slowtmr+0x37e>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
 800a5d8:	2b0c      	cmp	r3, #12
 800a5da:	f47f ae6f 	bne.w	800a2bc <tcp_slowtmr+0x5c>
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
    pcb_reset = 0;
 800a5de:	f04f 0900 	mov.w	r9, #0

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
 800a5e2:	f04f 0801 	mov.w	r8, #1
 800a5e6:	e69c      	b.n	800a322 <tcp_slowtmr+0xc2>
      ++pcb_remove;
 800a5e8:	f04f 0801 	mov.w	r8, #1
 800a5ec:	e688      	b.n	800a300 <tcp_slowtmr+0xa0>
    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 800a5ee:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
 800a5f2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800a5f4:	9203      	str	r2, [sp, #12]
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 800a5f6:	f500 2324 	add.w	r3, r0, #671744	; 0xa4000
 800a5fa:	4a3d      	ldr	r2, [pc, #244]	; (800a6f0 <tcp_slowtmr+0x490>)

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
 800a5fc:	6821      	ldr	r1, [r4, #0]
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 800a5fe:	f603 43b8 	addw	r3, r3, #3256	; 0xcb8
 800a602:	fba2 2303 	umull	r2, r3, r2, r3

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
 800a606:	9a03      	ldr	r2, [sp, #12]
 800a608:	1a8a      	subs	r2, r1, r2
 800a60a:	ebb2 1f53 	cmp.w	r2, r3, lsr #5
 800a60e:	d90c      	bls.n	800a62a <tcp_slowtmr+0x3ca>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
 800a610:	f108 0801 	add.w	r8, r8, #1
 800a614:	fa5f f888 	uxtb.w	r8, r8
        ++pcb_reset;
 800a618:	f04f 0901 	mov.w	r9, #1
 800a61c:	e681      	b.n	800a322 <tcp_slowtmr+0xc2>
      pcb2 = pcb;
      pcb = pcb->next;
      memp_free(MEMP_TCP_PCB, pcb2);
    } else {
      prev = pcb;
      pcb = pcb->next;
 800a61e:	462e      	mov	r6, r5
 800a620:	68ed      	ldr	r5, [r5, #12]

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
 800a622:	2d00      	cmp	r5, #0
 800a624:	f47f aebb 	bne.w	800a39e <tcp_slowtmr+0x13e>
 800a628:	e6e3      	b.n	800a3f2 <tcp_slowtmr+0x192>
        
        ++pcb_remove;
        ++pcb_reset;
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 800a62a:	f897 1096 	ldrb.w	r1, [r7, #150]	; 0x96
 800a62e:	4b31      	ldr	r3, [pc, #196]	; (800a6f4 <tcp_slowtmr+0x494>)
 800a630:	fb03 0301 	mla	r3, r3, r1, r0
              / TCP_SLOW_INTERVAL)
 800a634:	492e      	ldr	r1, [pc, #184]	; (800a6f0 <tcp_slowtmr+0x490>)
 800a636:	fba1 1303 	umull	r1, r3, r1, r3
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
        ++pcb_reset;
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
 800a63a:	ebb2 1f53 	cmp.w	r2, r3, lsr #5
 800a63e:	f67f ae6e 	bls.w	800a31e <tcp_slowtmr+0xbe>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
              / TCP_SLOW_INTERVAL)
      {
        tcp_keepalive(pcb);
 800a642:	4638      	mov	r0, r7
 800a644:	f002 ffb4 	bl	800d5b0 <tcp_keepalive>
        pcb->keep_cnt_sent++;
 800a648:	f897 3096 	ldrb.w	r3, [r7, #150]	; 0x96
 800a64c:	3301      	adds	r3, #1
 800a64e:	f887 3096 	strb.w	r3, [r7, #150]	; 0x96
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
    pcb_reset = 0;
 800a652:	f04f 0900 	mov.w	r9, #0
 800a656:	e664      	b.n	800a322 <tcp_slowtmr+0xc2>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
      }

      if (pcb_reset) {
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 800a658:	8b7b      	ldrh	r3, [r7, #26]
 800a65a:	6d38      	ldr	r0, [r7, #80]	; 0x50
 800a65c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800a65e:	9300      	str	r3, [sp, #0]
 800a660:	8bbb      	ldrh	r3, [r7, #28]
 800a662:	9301      	str	r3, [sp, #4]
 800a664:	463a      	mov	r2, r7
 800a666:	1d3b      	adds	r3, r7, #4
 800a668:	f002 fec2 	bl	800d3f0 <tcp_rst>
 800a66c:	e6f0      	b.n	800a450 <tcp_slowtmr+0x1f0>
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
 800a66e:	42bb      	cmp	r3, r7
 800a670:	d00b      	beq.n	800a68a <tcp_slowtmr+0x42a>
 800a672:	4b21      	ldr	r3, [pc, #132]	; (800a6f8 <tcp_slowtmr+0x498>)
 800a674:	9300      	str	r3, [sp, #0]
 800a676:	4821      	ldr	r0, [pc, #132]	; (800a6fc <tcp_slowtmr+0x49c>)
 800a678:	4921      	ldr	r1, [pc, #132]	; (800a700 <tcp_slowtmr+0x4a0>)
 800a67a:	4a22      	ldr	r2, [pc, #136]	; (800a704 <tcp_slowtmr+0x4a4>)
 800a67c:	f240 33be 	movw	r3, #958	; 0x3be
 800a680:	f7ff fb56 	bl	8009d30 <chprintf.constprop.4>
 800a684:	481f      	ldr	r0, [pc, #124]	; (800a704 <tcp_slowtmr+0x4a4>)
 800a686:	f7f6 fc73 	bl	8000f70 <chSysHalt>
        tcp_active_pcbs = pcb->next;
 800a68a:	68fb      	ldr	r3, [r7, #12]
 800a68c:	f8cb 3000 	str.w	r3, [fp]
 800a690:	e6da      	b.n	800a448 <tcp_slowtmr+0x1e8>
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
        prev->next = pcb->next;
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
 800a692:	f8d8 3000 	ldr.w	r3, [r8]
 800a696:	42ab      	cmp	r3, r5
 800a698:	d00a      	beq.n	800a6b0 <tcp_slowtmr+0x450>
 800a69a:	9700      	str	r7, [sp, #0]
 800a69c:	4817      	ldr	r0, [pc, #92]	; (800a6fc <tcp_slowtmr+0x49c>)
 800a69e:	4918      	ldr	r1, [pc, #96]	; (800a700 <tcp_slowtmr+0x4a0>)
 800a6a0:	4a19      	ldr	r2, [pc, #100]	; (800a708 <tcp_slowtmr+0x4a8>)
 800a6a2:	f240 4302 	movw	r3, #1026	; 0x402
 800a6a6:	f7ff fb43 	bl	8009d30 <chprintf.constprop.4>
 800a6aa:	4817      	ldr	r0, [pc, #92]	; (800a708 <tcp_slowtmr+0x4a8>)
 800a6ac:	f7f6 fc60 	bl	8000f70 <chSysHalt>
        tcp_tw_pcbs = pcb->next;
 800a6b0:	68eb      	ldr	r3, [r5, #12]
 800a6b2:	f8c8 3000 	str.w	r3, [r8]
 800a6b6:	4699      	mov	r9, r3
 800a6b8:	e694      	b.n	800a3e4 <tcp_slowtmr+0x184>
      tcp_err_fn err_fn;
      void *err_arg;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 800a6ba:	4b0f      	ldr	r3, [pc, #60]	; (800a6f8 <tcp_slowtmr+0x498>)
 800a6bc:	9300      	str	r3, [sp, #0]
 800a6be:	4910      	ldr	r1, [pc, #64]	; (800a700 <tcp_slowtmr+0x4a0>)
 800a6c0:	4a12      	ldr	r2, [pc, #72]	; (800a70c <tcp_slowtmr+0x4ac>)
 800a6c2:	480e      	ldr	r0, [pc, #56]	; (800a6fc <tcp_slowtmr+0x49c>)
 800a6c4:	f240 33ba 	movw	r3, #954	; 0x3ba
 800a6c8:	f7ff fb32 	bl	8009d30 <chprintf.constprop.4>
 800a6cc:	480f      	ldr	r0, [pc, #60]	; (800a70c <tcp_slowtmr+0x4ac>)
 800a6ce:	f7f6 fc4f 	bl	8000f70 <chSysHalt>
 800a6d2:	e6b7      	b.n	800a444 <tcp_slowtmr+0x1e4>
    if (pcb_remove) {
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
 800a6d4:	9700      	str	r7, [sp, #0]
 800a6d6:	490a      	ldr	r1, [pc, #40]	; (800a700 <tcp_slowtmr+0x4a0>)
 800a6d8:	4a0d      	ldr	r2, [pc, #52]	; (800a710 <tcp_slowtmr+0x4b0>)
 800a6da:	4808      	ldr	r0, [pc, #32]	; (800a6fc <tcp_slowtmr+0x49c>)
 800a6dc:	f240 33fe 	movw	r3, #1022	; 0x3fe
 800a6e0:	f7ff fb26 	bl	8009d30 <chprintf.constprop.4>
 800a6e4:	480a      	ldr	r0, [pc, #40]	; (800a710 <tcp_slowtmr+0x4b0>)
 800a6e6:	f7f6 fc43 	bl	8000f70 <chSysHalt>
 800a6ea:	e677      	b.n	800a3dc <tcp_slowtmr+0x17c>
 800a6ec:	08017910 	.word	0x08017910
 800a6f0:	10624dd3 	.word	0x10624dd3
 800a6f4:	000124f8 	.word	0x000124f8
 800a6f8:	08017948 	.word	0x08017948
 800a6fc:	200180c8 	.word	0x200180c8
 800a700:	08016fe0 	.word	0x08016fe0
 800a704:	08017b4c 	.word	0x08017b4c
 800a708:	08017bd0 	.word	0x08017bd0
 800a70c:	08017b20 	.word	0x08017b20
 800a710:	08017ba8 	.word	0x08017ba8
 800a714:	f3af 8000 	nop.w
 800a718:	f3af 8000 	nop.w
 800a71c:	f3af 8000 	nop.w

0800a720 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 800a720:	b510      	push	{r4, lr}
  TCP_RMV(pcblist, pcb);
 800a722:	6802      	ldr	r2, [r0, #0]
 800a724:	428a      	cmp	r2, r1
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 800a726:	b082      	sub	sp, #8
 800a728:	460c      	mov	r4, r1
  TCP_RMV(pcblist, pcb);
 800a72a:	d056      	beq.n	800a7da <tcp_pcb_remove+0xba>
 800a72c:	492d      	ldr	r1, [pc, #180]	; (800a7e4 <tcp_pcb_remove+0xc4>)
 800a72e:	600a      	str	r2, [r1, #0]
 800a730:	b152      	cbz	r2, 800a748 <tcp_pcb_remove+0x28>
 800a732:	68d3      	ldr	r3, [r2, #12]
 800a734:	42a3      	cmp	r3, r4
 800a736:	d053      	beq.n	800a7e0 <tcp_pcb_remove+0xc0>
 800a738:	b12b      	cbz	r3, 800a746 <tcp_pcb_remove+0x26>
 800a73a:	68da      	ldr	r2, [r3, #12]
 800a73c:	42a2      	cmp	r2, r4
 800a73e:	d03e      	beq.n	800a7be <tcp_pcb_remove+0x9e>
 800a740:	4613      	mov	r3, r2
 800a742:	2b00      	cmp	r3, #0
 800a744:	d1f9      	bne.n	800a73a <tcp_pcb_remove+0x1a>
 800a746:	600b      	str	r3, [r1, #0]
 800a748:	2300      	movs	r3, #0
 800a74a:	60e3      	str	r3, [r4, #12]

  tcp_pcb_purge(pcb);
 800a74c:	4620      	mov	r0, r4
 800a74e:	f7ff fd4f 	bl	800a1f0 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
 800a752:	7e23      	ldrb	r3, [r4, #24]
 800a754:	2b0a      	cmp	r3, #10
 800a756:	d004      	beq.n	800a762 <tcp_pcb_remove+0x42>
 800a758:	2b01      	cmp	r3, #1
 800a75a:	d02c      	beq.n	800a7b6 <tcp_pcb_remove+0x96>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
 800a75c:	7fa3      	ldrb	r3, [r4, #30]

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
 800a75e:	07da      	lsls	r2, r3, #31
 800a760:	d431      	bmi.n	800a7c6 <tcp_pcb_remove+0xa6>
    pcb->flags |= TF_ACK_NOW;
    tcp_output(pcb);
  }

  if (pcb->state != LISTEN) {
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
 800a762:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800a764:	b15b      	cbz	r3, 800a77e <tcp_pcb_remove+0x5e>
 800a766:	4b20      	ldr	r3, [pc, #128]	; (800a7e8 <tcp_pcb_remove+0xc8>)
 800a768:	9300      	str	r3, [sp, #0]
 800a76a:	4820      	ldr	r0, [pc, #128]	; (800a7ec <tcp_pcb_remove+0xcc>)
 800a76c:	4920      	ldr	r1, [pc, #128]	; (800a7f0 <tcp_pcb_remove+0xd0>)
 800a76e:	4a21      	ldr	r2, [pc, #132]	; (800a7f4 <tcp_pcb_remove+0xd4>)
 800a770:	f240 6311 	movw	r3, #1553	; 0x611
 800a774:	f7ff fadc 	bl	8009d30 <chprintf.constprop.4>
 800a778:	481e      	ldr	r0, [pc, #120]	; (800a7f4 <tcp_pcb_remove+0xd4>)
 800a77a:	f7f6 fbf9 	bl	8000f70 <chSysHalt>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
 800a77e:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800a780:	b15b      	cbz	r3, 800a79a <tcp_pcb_remove+0x7a>
 800a782:	4b19      	ldr	r3, [pc, #100]	; (800a7e8 <tcp_pcb_remove+0xc8>)
 800a784:	9300      	str	r3, [sp, #0]
 800a786:	4819      	ldr	r0, [pc, #100]	; (800a7ec <tcp_pcb_remove+0xcc>)
 800a788:	4919      	ldr	r1, [pc, #100]	; (800a7f0 <tcp_pcb_remove+0xd0>)
 800a78a:	4a1b      	ldr	r2, [pc, #108]	; (800a7f8 <tcp_pcb_remove+0xd8>)
 800a78c:	f240 6312 	movw	r3, #1554	; 0x612
 800a790:	f7ff face 	bl	8009d30 <chprintf.constprop.4>
 800a794:	4818      	ldr	r0, [pc, #96]	; (800a7f8 <tcp_pcb_remove+0xd8>)
 800a796:	f7f6 fbeb 	bl	8000f70 <chSysHalt>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
 800a79a:	6f63      	ldr	r3, [r4, #116]	; 0x74
 800a79c:	b15b      	cbz	r3, 800a7b6 <tcp_pcb_remove+0x96>
 800a79e:	4b12      	ldr	r3, [pc, #72]	; (800a7e8 <tcp_pcb_remove+0xc8>)
 800a7a0:	9300      	str	r3, [sp, #0]
 800a7a2:	4812      	ldr	r0, [pc, #72]	; (800a7ec <tcp_pcb_remove+0xcc>)
 800a7a4:	4912      	ldr	r1, [pc, #72]	; (800a7f0 <tcp_pcb_remove+0xd0>)
 800a7a6:	4a15      	ldr	r2, [pc, #84]	; (800a7fc <tcp_pcb_remove+0xdc>)
 800a7a8:	f240 6314 	movw	r3, #1556	; 0x614
 800a7ac:	f7ff fac0 	bl	8009d30 <chprintf.constprop.4>
 800a7b0:	4812      	ldr	r0, [pc, #72]	; (800a7fc <tcp_pcb_remove+0xdc>)
 800a7b2:	f7f6 fbdd 	bl	8000f70 <chSysHalt>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 800a7b6:	2300      	movs	r3, #0
 800a7b8:	7623      	strb	r3, [r4, #24]

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
 800a7ba:	b002      	add	sp, #8
 800a7bc:	bd10      	pop	{r4, pc}
 800a7be:	600b      	str	r3, [r1, #0]
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
 800a7c0:	68e2      	ldr	r2, [r4, #12]
 800a7c2:	60da      	str	r2, [r3, #12]
 800a7c4:	e7c0      	b.n	800a748 <tcp_pcb_remove+0x28>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
 800a7c6:	f043 0302 	orr.w	r3, r3, #2
 800a7ca:	77a3      	strb	r3, [r4, #30]
    tcp_output(pcb);
 800a7cc:	4620      	mov	r0, r4
 800a7ce:	f002 fc6f 	bl	800d0b0 <tcp_output>
  }

  if (pcb->state != LISTEN) {
 800a7d2:	7e23      	ldrb	r3, [r4, #24]
 800a7d4:	2b01      	cmp	r3, #1
 800a7d6:	d1c4      	bne.n	800a762 <tcp_pcb_remove+0x42>
 800a7d8:	e7ed      	b.n	800a7b6 <tcp_pcb_remove+0x96>
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
 800a7da:	68cb      	ldr	r3, [r1, #12]
 800a7dc:	6003      	str	r3, [r0, #0]
 800a7de:	e7b3      	b.n	800a748 <tcp_pcb_remove+0x28>
 800a7e0:	4613      	mov	r3, r2
 800a7e2:	e7ed      	b.n	800a7c0 <tcp_pcb_remove+0xa0>
 800a7e4:	2000cb68 	.word	0x2000cb68
 800a7e8:	08017948 	.word	0x08017948
 800a7ec:	200180c8 	.word	0x200180c8
 800a7f0:	08016fe0 	.word	0x08016fe0
 800a7f4:	08017bf8 	.word	0x08017bf8
 800a7f8:	08017c10 	.word	0x08017c10
 800a7fc:	08017c2c 	.word	0x08017c2c

0800a800 <tcp_close_shutdown>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
 800a800:	b530      	push	{r4, r5, lr}
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 800a802:	7e03      	ldrb	r3, [r0, #24]
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
 800a804:	b083      	sub	sp, #12
 800a806:	4604      	mov	r4, r0
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 800a808:	b119      	cbz	r1, 800a812 <tcp_close_shutdown+0x12>
 800a80a:	2b04      	cmp	r3, #4
 800a80c:	d01e      	beq.n	800a84c <tcp_close_shutdown+0x4c>
 800a80e:	2b07      	cmp	r3, #7
 800a810:	d01c      	beq.n	800a84c <tcp_close_shutdown+0x4c>
      }
      return ERR_OK;
    }
  }

  switch (pcb->state) {
 800a812:	2b07      	cmp	r3, #7
 800a814:	d80e      	bhi.n	800a834 <tcp_close_shutdown+0x34>
 800a816:	e8df f003 	tbb	[pc, r3]
 800a81a:	543f      	.short	0x543f
 800a81c:	0d11115d 	.word	0x0d11115d
 800a820:	040d      	.short	0x040d
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_fin(pcb);
 800a822:	4620      	mov	r0, r4
 800a824:	f002 fbec 	bl	800d000 <tcp_send_fin>
    if (err == ERR_OK) {
 800a828:	b928      	cbnz	r0, 800a836 <tcp_close_shutdown+0x36>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
 800a82a:	2309      	movs	r3, #9
 800a82c:	7623      	strb	r3, [r4, #24]
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent and acked before close returns.
       This can only be valid for sequential APIs, not for the raw API. */
    tcp_output(pcb);
 800a82e:	4620      	mov	r0, r4
 800a830:	f002 fc3e 	bl	800d0b0 <tcp_output>
 800a834:	2000      	movs	r0, #0
 800a836:	b240      	sxtb	r0, r0
  }
  return err;
}
 800a838:	b003      	add	sp, #12
 800a83a:	bd30      	pop	{r4, r5, pc}
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  case SYN_RCVD:
    err = tcp_send_fin(pcb);
 800a83c:	4620      	mov	r0, r4
 800a83e:	f002 fbdf 	bl	800d000 <tcp_send_fin>
    if (err == ERR_OK) {
 800a842:	2800      	cmp	r0, #0
 800a844:	d1f7      	bne.n	800a836 <tcp_close_shutdown+0x36>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
 800a846:	2305      	movs	r3, #5
 800a848:	7623      	strb	r3, [r4, #24]
 800a84a:	e7f0      	b.n	800a82e <tcp_close_shutdown+0x2e>
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
 800a84c:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 800a84e:	2a00      	cmp	r2, #0
 800a850:	f000 808a 	beq.w	800a968 <tcp_close_shutdown+0x168>
      /* Not all data received by application, send RST to tell the remote
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
 800a854:	7fa3      	ldrb	r3, [r4, #30]
 800a856:	06db      	lsls	r3, r3, #27
 800a858:	d548      	bpl.n	800a8ec <tcp_close_shutdown+0xec>

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 800a85a:	8b62      	ldrh	r2, [r4, #26]
 800a85c:	8ba3      	ldrh	r3, [r4, #28]
 800a85e:	6d20      	ldr	r0, [r4, #80]	; 0x50
 800a860:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800a862:	e88d 000c 	stmia.w	sp, {r2, r3}
 800a866:	4622      	mov	r2, r4
 800a868:	1d23      	adds	r3, r4, #4
 800a86a:	f002 fdc1 	bl	800d3f0 <tcp_rst>
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
 800a86e:	4620      	mov	r0, r4
 800a870:	f7ff fcbe 	bl	800a1f0 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 800a874:	4b41      	ldr	r3, [pc, #260]	; (800a97c <tcp_close_shutdown+0x17c>)
 800a876:	681a      	ldr	r2, [r3, #0]
 800a878:	42a2      	cmp	r2, r4
 800a87a:	d06b      	beq.n	800a954 <tcp_close_shutdown+0x154>
 800a87c:	4940      	ldr	r1, [pc, #256]	; (800a980 <tcp_close_shutdown+0x180>)
 800a87e:	600a      	str	r2, [r1, #0]
 800a880:	2a00      	cmp	r2, #0
 800a882:	d042      	beq.n	800a90a <tcp_close_shutdown+0x10a>
 800a884:	68d3      	ldr	r3, [r2, #12]
 800a886:	42a3      	cmp	r3, r4
 800a888:	d067      	beq.n	800a95a <tcp_close_shutdown+0x15a>
 800a88a:	2b00      	cmp	r3, #0
 800a88c:	d056      	beq.n	800a93c <tcp_close_shutdown+0x13c>
 800a88e:	68da      	ldr	r2, [r3, #12]
 800a890:	42a2      	cmp	r2, r4
 800a892:	d037      	beq.n	800a904 <tcp_close_shutdown+0x104>
 800a894:	4613      	mov	r3, r2
 800a896:	e7f8      	b.n	800a88a <tcp_close_shutdown+0x8a>
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    if (pcb->local_port != 0) {
 800a898:	8b63      	ldrh	r3, [r4, #26]
 800a89a:	2b00      	cmp	r3, #0
 800a89c:	d049      	beq.n	800a932 <tcp_close_shutdown+0x132>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 800a89e:	4b39      	ldr	r3, [pc, #228]	; (800a984 <tcp_close_shutdown+0x184>)
 800a8a0:	681a      	ldr	r2, [r3, #0]
 800a8a2:	42a2      	cmp	r2, r4
 800a8a4:	d041      	beq.n	800a92a <tcp_close_shutdown+0x12a>
 800a8a6:	4936      	ldr	r1, [pc, #216]	; (800a980 <tcp_close_shutdown+0x180>)
 800a8a8:	600a      	str	r2, [r1, #0]
 800a8aa:	2a00      	cmp	r2, #0
 800a8ac:	d03f      	beq.n	800a92e <tcp_close_shutdown+0x12e>
 800a8ae:	68d3      	ldr	r3, [r2, #12]
 800a8b0:	42a3      	cmp	r3, r4
 800a8b2:	d056      	beq.n	800a962 <tcp_close_shutdown+0x162>
 800a8b4:	2b00      	cmp	r3, #0
 800a8b6:	d05e      	beq.n	800a976 <tcp_close_shutdown+0x176>
 800a8b8:	68da      	ldr	r2, [r3, #12]
 800a8ba:	42a2      	cmp	r2, r4
 800a8bc:	d04f      	beq.n	800a95e <tcp_close_shutdown+0x15e>
 800a8be:	4613      	mov	r3, r2
 800a8c0:	e7f8      	b.n	800a8b4 <tcp_close_shutdown+0xb4>
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 800a8c2:	4621      	mov	r1, r4
 800a8c4:	4830      	ldr	r0, [pc, #192]	; (800a988 <tcp_close_shutdown+0x188>)
 800a8c6:	f7ff ff2b 	bl	800a720 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 800a8ca:	4621      	mov	r1, r4
 800a8cc:	2003      	movs	r0, #3
 800a8ce:	f7fe fb77 	bl	8008fc0 <memp_free>
    pcb = NULL;
    break;
 800a8d2:	e7af      	b.n	800a834 <tcp_close_shutdown+0x34>
  case SYN_SENT:
    err = ERR_OK;
    TCP_PCB_REMOVE_ACTIVE(pcb);
 800a8d4:	4621      	mov	r1, r4
 800a8d6:	4829      	ldr	r0, [pc, #164]	; (800a97c <tcp_close_shutdown+0x17c>)
 800a8d8:	f7ff ff22 	bl	800a720 <tcp_pcb_remove>
 800a8dc:	4b2b      	ldr	r3, [pc, #172]	; (800a98c <tcp_close_shutdown+0x18c>)
 800a8de:	2201      	movs	r2, #1
    memp_free(MEMP_TCP_PCB, pcb);
 800a8e0:	4621      	mov	r1, r4
 800a8e2:	2002      	movs	r0, #2
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  case SYN_SENT:
    err = ERR_OK;
    TCP_PCB_REMOVE_ACTIVE(pcb);
 800a8e4:	701a      	strb	r2, [r3, #0]
    memp_free(MEMP_TCP_PCB, pcb);
 800a8e6:	f7fe fb6b 	bl	8008fc0 <memp_free>
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
 800a8ea:	e7a3      	b.n	800a834 <tcp_close_shutdown+0x34>

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
      /* Not all data received by application, send RST to tell the remote
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
 800a8ec:	4b28      	ldr	r3, [pc, #160]	; (800a990 <tcp_close_shutdown+0x190>)
 800a8ee:	9300      	str	r3, [sp, #0]
 800a8f0:	4928      	ldr	r1, [pc, #160]	; (800a994 <tcp_close_shutdown+0x194>)
 800a8f2:	4a29      	ldr	r2, [pc, #164]	; (800a998 <tcp_close_shutdown+0x198>)
 800a8f4:	4829      	ldr	r0, [pc, #164]	; (800a99c <tcp_close_shutdown+0x19c>)
 800a8f6:	23b2      	movs	r3, #178	; 0xb2
 800a8f8:	f7ff fa1a 	bl	8009d30 <chprintf.constprop.4>
 800a8fc:	4826      	ldr	r0, [pc, #152]	; (800a998 <tcp_close_shutdown+0x198>)
 800a8fe:	f7f6 fb37 	bl	8000f70 <chSysHalt>
 800a902:	e7aa      	b.n	800a85a <tcp_close_shutdown+0x5a>
 800a904:	600b      	str	r3, [r1, #0]
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 800a906:	68e2      	ldr	r2, [r4, #12]
 800a908:	60da      	str	r2, [r3, #12]
      if (pcb->state == ESTABLISHED) {
 800a90a:	7e23      	ldrb	r3, [r4, #24]
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 800a90c:	4a1f      	ldr	r2, [pc, #124]	; (800a98c <tcp_close_shutdown+0x18c>)
 800a90e:	2101      	movs	r1, #1
 800a910:	2500      	movs	r5, #0
      if (pcb->state == ESTABLISHED) {
 800a912:	2b04      	cmp	r3, #4
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 800a914:	7011      	strb	r1, [r2, #0]
 800a916:	60e5      	str	r5, [r4, #12]
      if (pcb->state == ESTABLISHED) {
 800a918:	d012      	beq.n	800a940 <tcp_close_shutdown+0x140>
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
        memp_free(MEMP_TCP_PCB, pcb);
 800a91a:	4621      	mov	r1, r4
 800a91c:	2002      	movs	r0, #2
 800a91e:	f7fe fb4f 	bl	8008fc0 <memp_free>
      }
      return ERR_OK;
 800a922:	4628      	mov	r0, r5
 800a924:	b240      	sxtb	r0, r0
       If SOF_LINGER is set, the data should be sent and acked before close returns.
       This can only be valid for sequential APIs, not for the raw API. */
    tcp_output(pcb);
  }
  return err;
}
 800a926:	b003      	add	sp, #12
 800a928:	bd30      	pop	{r4, r5, pc}
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    if (pcb->local_port != 0) {
      TCP_RMV(&tcp_bound_pcbs, pcb);
 800a92a:	68e2      	ldr	r2, [r4, #12]
 800a92c:	601a      	str	r2, [r3, #0]
 800a92e:	2300      	movs	r3, #0
 800a930:	60e3      	str	r3, [r4, #12]
    }
    memp_free(MEMP_TCP_PCB, pcb);
 800a932:	4621      	mov	r1, r4
 800a934:	2002      	movs	r0, #2
 800a936:	f7fe fb43 	bl	8008fc0 <memp_free>
    pcb = NULL;
    break;
 800a93a:	e77b      	b.n	800a834 <tcp_close_shutdown+0x34>
 800a93c:	600b      	str	r3, [r1, #0]
 800a93e:	e7e4      	b.n	800a90a <tcp_close_shutdown+0x10a>
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      if (pcb->state == ESTABLISHED) {
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
 800a940:	4b17      	ldr	r3, [pc, #92]	; (800a9a0 <tcp_close_shutdown+0x1a0>)

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      if (pcb->state == ESTABLISHED) {
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
 800a942:	220a      	movs	r2, #10
        TCP_REG(&tcp_tw_pcbs, pcb);
 800a944:	6819      	ldr	r1, [r3, #0]
 800a946:	60e1      	str	r1, [r4, #12]

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      if (pcb->state == ESTABLISHED) {
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
 800a948:	7622      	strb	r2, [r4, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
 800a94a:	601c      	str	r4, [r3, #0]
 800a94c:	f004 fab0 	bl	800eeb0 <tcp_timer_needed>
      } else {
        /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
        memp_free(MEMP_TCP_PCB, pcb);
      }
      return ERR_OK;
 800a950:	4628      	mov	r0, r5
 800a952:	e770      	b.n	800a836 <tcp_close_shutdown+0x36>
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 800a954:	68e2      	ldr	r2, [r4, #12]
 800a956:	601a      	str	r2, [r3, #0]
 800a958:	e7d7      	b.n	800a90a <tcp_close_shutdown+0x10a>
 800a95a:	4613      	mov	r3, r2
 800a95c:	e7d3      	b.n	800a906 <tcp_close_shutdown+0x106>
 800a95e:	461a      	mov	r2, r3
 800a960:	600b      	str	r3, [r1, #0]
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    if (pcb->local_port != 0) {
      TCP_RMV(&tcp_bound_pcbs, pcb);
 800a962:	68e3      	ldr	r3, [r4, #12]
 800a964:	60d3      	str	r3, [r2, #12]
 800a966:	e7e2      	b.n	800a92e <tcp_close_shutdown+0x12e>
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
 800a968:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
 800a96a:	f241 62d0 	movw	r2, #5840	; 0x16d0
 800a96e:	4291      	cmp	r1, r2
 800a970:	f47f af70 	bne.w	800a854 <tcp_close_shutdown+0x54>
 800a974:	e74d      	b.n	800a812 <tcp_close_shutdown+0x12>
 800a976:	600b      	str	r3, [r1, #0]
 800a978:	e7d9      	b.n	800a92e <tcp_close_shutdown+0x12e>
 800a97a:	bf00      	nop
 800a97c:	2000cb60 	.word	0x2000cb60
 800a980:	2000cb68 	.word	0x2000cb68
 800a984:	2000cb6c 	.word	0x2000cb6c
 800a988:	2000cb5c 	.word	0x2000cb5c
 800a98c:	2000cb4c 	.word	0x2000cb4c
 800a990:	08017948 	.word	0x08017948
 800a994:	08016fe0 	.word	0x08016fe0
 800a998:	08017c44 	.word	0x08017c44
 800a99c:	200180c8 	.word	0x200180c8
 800a9a0:	2000cb50 	.word	0x2000cb50
 800a9a4:	f3af 8000 	nop.w
 800a9a8:	f3af 8000 	nop.w
 800a9ac:	f3af 8000 	nop.w

0800a9b0 <tcp_close>:
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  if (pcb->state != LISTEN) {
 800a9b0:	7e03      	ldrb	r3, [r0, #24]
 800a9b2:	2b01      	cmp	r3, #1
 800a9b4:	d003      	beq.n	800a9be <tcp_close+0xe>
    /* Set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
 800a9b6:	7f83      	ldrb	r3, [r0, #30]
 800a9b8:	f043 0310 	orr.w	r3, r3, #16
 800a9bc:	7783      	strb	r3, [r0, #30]
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
 800a9be:	2101      	movs	r1, #1
 800a9c0:	f7ff bf1e 	b.w	800a800 <tcp_close_shutdown>
 800a9c4:	f3af 8000 	nop.w
 800a9c8:	f3af 8000 	nop.w
 800a9cc:	f3af 8000 	nop.w

0800a9d0 <tcp_recv_null>:
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
 800a9d0:	b152      	cbz	r2, 800a9e8 <tcp_recv_null+0x18>
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 800a9d2:	b510      	push	{r4, lr}
 800a9d4:	4608      	mov	r0, r1
 800a9d6:	4614      	mov	r4, r2
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
    tcp_recved(pcb, p->tot_len);
 800a9d8:	8911      	ldrh	r1, [r2, #8]
 800a9da:	f7ff fad1 	bl	8009f80 <tcp_recved>
    pbuf_free(p);
 800a9de:	4620      	mov	r0, r4
 800a9e0:	f7fe fd0e 	bl	8009400 <pbuf_free>
  } else if (err == ERR_OK) {
    return tcp_close(pcb);
  }
  return ERR_OK;
}
 800a9e4:	2000      	movs	r0, #0
 800a9e6:	bd10      	pop	{r4, pc}
{
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
    tcp_recved(pcb, p->tot_len);
    pbuf_free(p);
  } else if (err == ERR_OK) {
 800a9e8:	b10b      	cbz	r3, 800a9ee <tcp_recv_null+0x1e>
    return tcp_close(pcb);
  }
  return ERR_OK;
}
 800a9ea:	2000      	movs	r0, #0
 800a9ec:	4770      	bx	lr
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
    tcp_recved(pcb, p->tot_len);
    pbuf_free(p);
  } else if (err == ERR_OK) {
    return tcp_close(pcb);
 800a9ee:	4608      	mov	r0, r1
 800a9f0:	f7ff bfde 	b.w	800a9b0 <tcp_close>
 800a9f4:	f3af 8000 	nop.w
 800a9f8:	f3af 8000 	nop.w
 800a9fc:	f3af 8000 	nop.w

0800aa00 <tcp_process_refused_data>:
}

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
 800aa00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  err_t err;
  u8_t refused_flags = pcb->refused_data->flags;
 800aa02:	6f85      	ldr	r5, [r0, #120]	; 0x78
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
  pcb->refused_data = NULL;
  /* Notify again application with data previously received. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 800aa04:	f8d0 6080 	ldr.w	r6, [r0, #128]	; 0x80
/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
  err_t err;
  u8_t refused_flags = pcb->refused_data->flags;
 800aa08:	7b6f      	ldrb	r7, [r5, #13]
  /* set pcb->refused_data to NULL in case the callback frees it and then
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
  pcb->refused_data = NULL;
 800aa0a:	2300      	movs	r3, #0
}

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
 800aa0c:	4604      	mov	r4, r0
  err_t err;
  u8_t refused_flags = pcb->refused_data->flags;
  /* set pcb->refused_data to NULL in case the callback frees it and then
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
  pcb->refused_data = NULL;
 800aa0e:	6783      	str	r3, [r0, #120]	; 0x78
  /* Notify again application with data previously received. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 800aa10:	b30e      	cbz	r6, 800aa56 <tcp_process_refused_data+0x56>
 800aa12:	6900      	ldr	r0, [r0, #16]
 800aa14:	4621      	mov	r1, r4
 800aa16:	462a      	mov	r2, r5
 800aa18:	47b0      	blx	r6
  if (err == ERR_OK) {
 800aa1a:	b9a8      	cbnz	r0, 800aa48 <tcp_process_refused_data+0x48>
    /* did refused_data include a FIN? */
    if (refused_flags & PBUF_FLAG_TCP_FIN) {
 800aa1c:	06bb      	lsls	r3, r7, #26
 800aa1e:	d510      	bpl.n	800aa42 <tcp_process_refused_data+0x42>
      /* correct rcv_wnd as the application won't call tcp_recved()
         for the FIN's seqno */
      if (pcb->rcv_wnd != TCP_WND) {
 800aa20:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
        pcb->rcv_wnd++;
      }
      TCP_EVENT_CLOSED(pcb, err);
 800aa22:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
  if (err == ERR_OK) {
    /* did refused_data include a FIN? */
    if (refused_flags & PBUF_FLAG_TCP_FIN) {
      /* correct rcv_wnd as the application won't call tcp_recved()
         for the FIN's seqno */
      if (pcb->rcv_wnd != TCP_WND) {
 800aa26:	f241 62d0 	movw	r2, #5840	; 0x16d0
 800aa2a:	4293      	cmp	r3, r2
        pcb->rcv_wnd++;
 800aa2c:	bf1c      	itt	ne
 800aa2e:	3301      	addne	r3, #1
 800aa30:	85a3      	strhne	r3, [r4, #44]	; 0x2c
      }
      TCP_EVENT_CLOSED(pcb, err);
 800aa32:	b135      	cbz	r5, 800aa42 <tcp_process_refused_data+0x42>
 800aa34:	2200      	movs	r2, #0
 800aa36:	4613      	mov	r3, r2
 800aa38:	6920      	ldr	r0, [r4, #16]
 800aa3a:	4621      	mov	r1, r4
 800aa3c:	47a8      	blx	r5
      if (err == ERR_ABRT) {
 800aa3e:	300a      	adds	r0, #10
 800aa40:	d010      	beq.n	800aa64 <tcp_process_refused_data+0x64>
    return ERR_ABRT;
  } else {
    /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
    pcb->refused_data = refused_data;
  }
  return ERR_OK;
 800aa42:	2000      	movs	r0, #0
}
 800aa44:	b240      	sxtb	r0, r0
 800aa46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      TCP_EVENT_CLOSED(pcb, err);
      if (err == ERR_ABRT) {
        return ERR_ABRT;
      }
    }
  } else if (err == ERR_ABRT) {
 800aa48:	b240      	sxtb	r0, r0
 800aa4a:	300a      	adds	r0, #10
 800aa4c:	d00a      	beq.n	800aa64 <tcp_process_refused_data+0x64>
       segment contains data). */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
    return ERR_ABRT;
  } else {
    /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
    pcb->refused_data = refused_data;
 800aa4e:	67a5      	str	r5, [r4, #120]	; 0x78
  }
  return ERR_OK;
 800aa50:	2000      	movs	r0, #0
}
 800aa52:	b240      	sxtb	r0, r0
 800aa54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
  pcb->refused_data = NULL;
  /* Notify again application with data previously received. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 800aa56:	4630      	mov	r0, r6
 800aa58:	4633      	mov	r3, r6
 800aa5a:	4621      	mov	r1, r4
 800aa5c:	462a      	mov	r2, r5
 800aa5e:	f7ff ffb7 	bl	800a9d0 <tcp_recv_null>
 800aa62:	e7da      	b.n	800aa1a <tcp_process_refused_data+0x1a>
      if (pcb->rcv_wnd != TCP_WND) {
        pcb->rcv_wnd++;
      }
      TCP_EVENT_CLOSED(pcb, err);
      if (err == ERR_ABRT) {
        return ERR_ABRT;
 800aa64:	20f6      	movs	r0, #246	; 0xf6
 800aa66:	e7f4      	b.n	800aa52 <tcp_process_refused_data+0x52>
 800aa68:	f3af 8000 	nop.w
 800aa6c:	f3af 8000 	nop.w

0800aa70 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
 800aa70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
 800aa74:	4d17      	ldr	r5, [pc, #92]	; (800aad4 <tcp_fasttmr+0x64>)
 800aa76:	4f18      	ldr	r7, [pc, #96]	; (800aad8 <tcp_fasttmr+0x68>)
 800aa78:	782b      	ldrb	r3, [r5, #0]

      next = pcb->next;

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
        tcp_active_pcbs_changed = 0;
 800aa7a:	f8df 8060 	ldr.w	r8, [pc, #96]	; 800aadc <tcp_fasttmr+0x6c>
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
 800aa7e:	3301      	adds	r3, #1
 800aa80:	702b      	strb	r3, [r5, #0]

      next = pcb->next;

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
        tcp_active_pcbs_changed = 0;
 800aa82:	2600      	movs	r6, #0
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;
 800aa84:	683c      	ldr	r4, [r7, #0]

  while(pcb != NULL) {
 800aa86:	b12c      	cbz	r4, 800aa94 <tcp_fasttmr+0x24>
    if (pcb->last_timer != tcp_timer_ctr) {
 800aa88:	782b      	ldrb	r3, [r5, #0]
 800aa8a:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
 800aa8e:	429a      	cmp	r2, r3
 800aa90:	d102      	bne.n	800aa98 <tcp_fasttmr+0x28>
 800aa92:	e7fe      	b.n	800aa92 <tcp_fasttmr+0x22>
 800aa94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
 800aa98:	7fa2      	ldrb	r2, [r4, #30]
  pcb = tcp_active_pcbs;

  while(pcb != NULL) {
    if (pcb->last_timer != tcp_timer_ctr) {
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
 800aa9a:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
 800aa9e:	07d3      	lsls	r3, r2, #31
 800aaa0:	d40d      	bmi.n	800aabe <tcp_fasttmr+0x4e>
      }

      next = pcb->next;

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
 800aaa2:	6fa3      	ldr	r3, [r4, #120]	; 0x78
        tcp_active_pcbs_changed = 0;
        tcp_process_refused_data(pcb);
 800aaa4:	4620      	mov	r0, r4
        tcp_ack_now(pcb);
        tcp_output(pcb);
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
      }

      next = pcb->next;
 800aaa6:	68e4      	ldr	r4, [r4, #12]

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
 800aaa8:	2b00      	cmp	r3, #0
 800aaaa:	d0ec      	beq.n	800aa86 <tcp_fasttmr+0x16>
        tcp_active_pcbs_changed = 0;
 800aaac:	f888 6000 	strb.w	r6, [r8]
        tcp_process_refused_data(pcb);
 800aab0:	f7ff ffa6 	bl	800aa00 <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
 800aab4:	f898 3000 	ldrb.w	r3, [r8]
 800aab8:	2b00      	cmp	r3, #0
 800aaba:	d0e4      	beq.n	800aa86 <tcp_fasttmr+0x16>
 800aabc:	e7e2      	b.n	800aa84 <tcp_fasttmr+0x14>
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
 800aabe:	f042 0202 	orr.w	r2, r2, #2
 800aac2:	77a2      	strb	r2, [r4, #30]
        tcp_output(pcb);
 800aac4:	4620      	mov	r0, r4
 800aac6:	f002 faf3 	bl	800d0b0 <tcp_output>
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 800aaca:	7fa3      	ldrb	r3, [r4, #30]
 800aacc:	f023 0303 	bic.w	r3, r3, #3
 800aad0:	77a3      	strb	r3, [r4, #30]
 800aad2:	e7e6      	b.n	800aaa2 <tcp_fasttmr+0x32>
 800aad4:	2000cb64 	.word	0x2000cb64
 800aad8:	2000cb60 	.word	0x2000cb60
 800aadc:	2000cb4c 	.word	0x2000cb4c

0800aae0 <tcp_tmr>:
/**
 * Called periodically to dispatch TCP timers.
 */
void
tcp_tmr(void)
{
 800aae0:	b508      	push	{r3, lr}
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
 800aae2:	f7ff ffc5 	bl	800aa70 <tcp_fasttmr>

  if (++tcp_timer & 1) {
 800aae6:	4a06      	ldr	r2, [pc, #24]	; (800ab00 <tcp_tmr+0x20>)
 800aae8:	7813      	ldrb	r3, [r2, #0]
 800aaea:	3301      	adds	r3, #1
 800aaec:	b2db      	uxtb	r3, r3
 800aaee:	7013      	strb	r3, [r2, #0]
 800aaf0:	07db      	lsls	r3, r3, #31
 800aaf2:	d400      	bmi.n	800aaf6 <tcp_tmr+0x16>
 800aaf4:	bd08      	pop	{r3, pc}
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  }
}
 800aaf6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  tcp_fasttmr();

  if (++tcp_timer & 1) {
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
 800aafa:	f7ff bbb1 	b.w	800a260 <tcp_slowtmr>
 800aafe:	bf00      	nop
 800ab00:	2000cb58 	.word	0x2000cb58
 800ab04:	f3af 8000 	nop.w
 800ab08:	f3af 8000 	nop.w
 800ab0c:	f3af 8000 	nop.w

0800ab10 <tcp_shutdown>:
 * @return ERR_OK if shutdown succeeded (or the PCB has already been shut down)
 *         another err_t on error.
 */
err_t
tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
{
 800ab10:	b538      	push	{r3, r4, r5, lr}
  if (pcb->state == LISTEN) {
 800ab12:	7e03      	ldrb	r3, [r0, #24]
 800ab14:	2b01      	cmp	r3, #1
 * @return ERR_OK if shutdown succeeded (or the PCB has already been shut down)
 *         another err_t on error.
 */
err_t
tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
{
 800ab16:	4605      	mov	r5, r0
  if (pcb->state == LISTEN) {
 800ab18:	d023      	beq.n	800ab62 <tcp_shutdown+0x52>
    return ERR_CONN;
  }
  if (shut_rx) {
 800ab1a:	b169      	cbz	r1, 800ab38 <tcp_shutdown+0x28>
    /* shut down the receive side: set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
 800ab1c:	7f83      	ldrb	r3, [r0, #30]
 800ab1e:	f043 0310 	orr.w	r3, r3, #16
 800ab22:	7783      	strb	r3, [r0, #30]
    if (shut_tx) {
 800ab24:	b9c2      	cbnz	r2, 800ab58 <tcp_shutdown+0x48>
      /* shutting down the tx AND rx side is the same as closing for the raw API */
      return tcp_close_shutdown(pcb, 1);
    }
    /* ... and free buffered data */
    if (pcb->refused_data != NULL) {
 800ab26:	6f80      	ldr	r0, [r0, #120]	; 0x78
 800ab28:	b118      	cbz	r0, 800ab32 <tcp_shutdown+0x22>
 800ab2a:	4614      	mov	r4, r2
      pbuf_free(pcb->refused_data);
 800ab2c:	f7fe fc68 	bl	8009400 <pbuf_free>
      pcb->refused_data = NULL;
 800ab30:	67ac      	str	r4, [r5, #120]	; 0x78
      /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
        into CLOSED state, where the PCB is deallocated. */
      return ERR_CONN;
    }
  }
  return ERR_OK;
 800ab32:	2000      	movs	r0, #0
 800ab34:	b240      	sxtb	r0, r0
}
 800ab36:	bd38      	pop	{r3, r4, r5, pc}
    if (pcb->refused_data != NULL) {
      pbuf_free(pcb->refused_data);
      pcb->refused_data = NULL;
    }
  }
  if (shut_tx) {
 800ab38:	2a00      	cmp	r2, #0
 800ab3a:	d0fa      	beq.n	800ab32 <tcp_shutdown+0x22>
 800ab3c:	3b03      	subs	r3, #3
 800ab3e:	b2db      	uxtb	r3, r3
 800ab40:	2b04      	cmp	r3, #4
 800ab42:	d80e      	bhi.n	800ab62 <tcp_shutdown+0x52>
 800ab44:	2201      	movs	r2, #1
 800ab46:	fa02 f303 	lsl.w	r3, r2, r3
 800ab4a:	f013 0f13 	tst.w	r3, #19
 800ab4e:	d008      	beq.n	800ab62 <tcp_shutdown+0x52>
        into CLOSED state, where the PCB is deallocated. */
      return ERR_CONN;
    }
  }
  return ERR_OK;
}
 800ab50:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
       Only close in these states as the others directly deallocate the PCB */
    switch (pcb->state) {
    case SYN_RCVD:
    case ESTABLISHED:
    case CLOSE_WAIT:
      return tcp_close_shutdown(pcb, shut_rx);
 800ab54:	f7ff be54 	b.w	800a800 <tcp_close_shutdown>
  if (shut_rx) {
    /* shut down the receive side: set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
    if (shut_tx) {
      /* shutting down the tx AND rx side is the same as closing for the raw API */
      return tcp_close_shutdown(pcb, 1);
 800ab58:	2101      	movs	r1, #1
        into CLOSED state, where the PCB is deallocated. */
      return ERR_CONN;
    }
  }
  return ERR_OK;
}
 800ab5a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  if (shut_rx) {
    /* shut down the receive side: set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
    if (shut_tx) {
      /* shutting down the tx AND rx side is the same as closing for the raw API */
      return tcp_close_shutdown(pcb, 1);
 800ab5e:	f7ff be4f 	b.w	800a800 <tcp_close_shutdown>
 */
err_t
tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
{
  if (pcb->state == LISTEN) {
    return ERR_CONN;
 800ab62:	20f3      	movs	r0, #243	; 0xf3
 800ab64:	e7e6      	b.n	800ab34 <tcp_shutdown+0x24>
 800ab66:	bf00      	nop
 800ab68:	f3af 8000 	nop.w
 800ab6c:	f3af 8000 	nop.w

0800ab70 <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
 800ab70:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  tcp_err_fn errf;
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 800ab74:	7e03      	ldrb	r3, [r0, #24]
 800ab76:	2b01      	cmp	r3, #1
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
 800ab78:	b082      	sub	sp, #8
 800ab7a:	4604      	mov	r4, r0
 800ab7c:	460e      	mov	r6, r1
  tcp_err_fn errf;
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 800ab7e:	d056      	beq.n	800ac2e <tcp_abandon+0xbe>
    pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
 800ab80:	2b0a      	cmp	r3, #10
 800ab82:	d049      	beq.n	800ac18 <tcp_abandon+0xa8>
    ackno = pcb->rcv_nxt;
#if LWIP_CALLBACK_API
    errf = pcb->errf;
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
    TCP_PCB_REMOVE_ACTIVE(pcb);
 800ab84:	4831      	ldr	r0, [pc, #196]	; (800ac4c <tcp_abandon+0xdc>)
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
  } else {
    seqno = pcb->snd_nxt;
 800ab86:	f8d4 9050 	ldr.w	r9, [r4, #80]	; 0x50
    ackno = pcb->rcv_nxt;
 800ab8a:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
#if LWIP_CALLBACK_API
    errf = pcb->errf;
 800ab8e:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
 800ab92:	6927      	ldr	r7, [r4, #16]
    TCP_PCB_REMOVE_ACTIVE(pcb);
 800ab94:	4621      	mov	r1, r4
 800ab96:	f7ff fdc3 	bl	800a720 <tcp_pcb_remove>
 800ab9a:	4b2d      	ldr	r3, [pc, #180]	; (800ac50 <tcp_abandon+0xe0>)
    if (pcb->unacked != NULL) {
 800ab9c:	6f20      	ldr	r0, [r4, #112]	; 0x70
    ackno = pcb->rcv_nxt;
#if LWIP_CALLBACK_API
    errf = pcb->errf;
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
    TCP_PCB_REMOVE_ACTIVE(pcb);
 800ab9e:	2201      	movs	r2, #1
 800aba0:	701a      	strb	r2, [r3, #0]
    if (pcb->unacked != NULL) {
 800aba2:	b130      	cbz	r0, 800abb2 <tcp_abandon+0x42>
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 800aba4:	f8d0 a000 	ldr.w	sl, [r0]
    tcp_seg_free(seg);
 800aba8:	f7ff fa3a 	bl	800a020 <tcp_seg_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 800abac:	4650      	mov	r0, sl
 800abae:	2800      	cmp	r0, #0
 800abb0:	d1f8      	bne.n	800aba4 <tcp_abandon+0x34>
    errf_arg = pcb->callback_arg;
    TCP_PCB_REMOVE_ACTIVE(pcb);
    if (pcb->unacked != NULL) {
      tcp_segs_free(pcb->unacked);
    }
    if (pcb->unsent != NULL) {
 800abb2:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800abb4:	b130      	cbz	r0, 800abc4 <tcp_abandon+0x54>
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 800abb6:	f8d0 a000 	ldr.w	sl, [r0]
    tcp_seg_free(seg);
 800abba:	f7ff fa31 	bl	800a020 <tcp_seg_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 800abbe:	4650      	mov	r0, sl
 800abc0:	2800      	cmp	r0, #0
 800abc2:	d1f8      	bne.n	800abb6 <tcp_abandon+0x46>
    }
    if (pcb->unsent != NULL) {
      tcp_segs_free(pcb->unsent);
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
 800abc4:	6f60      	ldr	r0, [r4, #116]	; 0x74
 800abc6:	b130      	cbz	r0, 800abd6 <tcp_abandon+0x66>
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 800abc8:	f8d0 a000 	ldr.w	sl, [r0]
    tcp_seg_free(seg);
 800abcc:	f7ff fa28 	bl	800a020 <tcp_seg_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 800abd0:	4650      	mov	r0, sl
 800abd2:	2800      	cmp	r0, #0
 800abd4:	d1f8      	bne.n	800abc8 <tcp_abandon+0x58>
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
      tcp_segs_free(pcb->ooseq);
    }
#endif /* TCP_QUEUE_OOSEQ */
    if (reset) {
 800abd6:	b966      	cbnz	r6, 800abf2 <tcp_abandon+0x82>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    }
    memp_free(MEMP_TCP_PCB, pcb);
 800abd8:	4621      	mov	r1, r4
 800abda:	2002      	movs	r0, #2
 800abdc:	f7fe f9f0 	bl	8008fc0 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 800abe0:	b1bd      	cbz	r5, 800ac12 <tcp_abandon+0xa2>
 800abe2:	4638      	mov	r0, r7
 800abe4:	f06f 0109 	mvn.w	r1, #9
 800abe8:	462b      	mov	r3, r5
  }
}
 800abea:	b002      	add	sp, #8
 800abec:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if (reset) {
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    }
    memp_free(MEMP_TCP_PCB, pcb);
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 800abf0:	4718      	bx	r3
      tcp_segs_free(pcb->ooseq);
    }
#endif /* TCP_QUEUE_OOSEQ */
    if (reset) {
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
 800abf2:	8b62      	ldrh	r2, [r4, #26]
 800abf4:	8ba3      	ldrh	r3, [r4, #28]
 800abf6:	9301      	str	r3, [sp, #4]
 800abf8:	9200      	str	r2, [sp, #0]
 800abfa:	4648      	mov	r0, r9
 800abfc:	4641      	mov	r1, r8
 800abfe:	4622      	mov	r2, r4
 800ac00:	1d23      	adds	r3, r4, #4
 800ac02:	f002 fbf5 	bl	800d3f0 <tcp_rst>
    }
    memp_free(MEMP_TCP_PCB, pcb);
 800ac06:	4621      	mov	r1, r4
 800ac08:	2002      	movs	r0, #2
 800ac0a:	f7fe f9d9 	bl	8008fc0 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 800ac0e:	2d00      	cmp	r5, #0
 800ac10:	d1e7      	bne.n	800abe2 <tcp_abandon+0x72>
  }
}
 800ac12:	b002      	add	sp, #8
 800ac14:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 800ac18:	4621      	mov	r1, r4
 800ac1a:	480e      	ldr	r0, [pc, #56]	; (800ac54 <tcp_abandon+0xe4>)
 800ac1c:	f7ff fd80 	bl	800a720 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
 800ac20:	4621      	mov	r1, r4
 800ac22:	2002      	movs	r0, #2
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    }
    memp_free(MEMP_TCP_PCB, pcb);
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  }
}
 800ac24:	b002      	add	sp, #8
 800ac26:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
 800ac2a:	f7fe b9c9 	b.w	8008fc0 <memp_free>
  tcp_err_fn errf;
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 800ac2e:	4b0a      	ldr	r3, [pc, #40]	; (800ac58 <tcp_abandon+0xe8>)
 800ac30:	9300      	str	r3, [sp, #0]
 800ac32:	490a      	ldr	r1, [pc, #40]	; (800ac5c <tcp_abandon+0xec>)
 800ac34:	4a0a      	ldr	r2, [pc, #40]	; (800ac60 <tcp_abandon+0xf0>)
 800ac36:	480b      	ldr	r0, [pc, #44]	; (800ac64 <tcp_abandon+0xf4>)
 800ac38:	f240 136f 	movw	r3, #367	; 0x16f
 800ac3c:	f7ff f878 	bl	8009d30 <chprintf.constprop.4>
 800ac40:	4807      	ldr	r0, [pc, #28]	; (800ac60 <tcp_abandon+0xf0>)
 800ac42:	f7f6 f995 	bl	8000f70 <chSysHalt>
 800ac46:	7e23      	ldrb	r3, [r4, #24]
 800ac48:	e79a      	b.n	800ab80 <tcp_abandon+0x10>
 800ac4a:	bf00      	nop
 800ac4c:	2000cb60 	.word	0x2000cb60
 800ac50:	2000cb4c 	.word	0x2000cb4c
 800ac54:	2000cb50 	.word	0x2000cb50
 800ac58:	08017948 	.word	0x08017948
 800ac5c:	08016fe0 	.word	0x08016fe0
 800ac60:	08017c60 	.word	0x08017c60
 800ac64:	200180c8 	.word	0x200180c8
 800ac68:	f3af 8000 	nop.w
 800ac6c:	f3af 8000 	nop.w

0800ac70 <tcp_abort>:
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  tcp_abandon(pcb, 1);
 800ac70:	2101      	movs	r1, #1
 800ac72:	f7ff bf7d 	b.w	800ab70 <tcp_abandon>
 800ac76:	bf00      	nop
 800ac78:	f3af 8000 	nop.w
 800ac7c:	f3af 8000 	nop.w

0800ac80 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
 800ac80:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ac84:	4607      	mov	r7, r0
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800ac86:	2002      	movs	r0, #2
 800ac88:	f7fe f942 	bl	8008f10 <memp_malloc>
  if (pcb == NULL) {
 800ac8c:	4604      	mov	r4, r0
 800ac8e:	2800      	cmp	r0, #0
 800ac90:	d044      	beq.n	800ad1c <tcp_alloc+0x9c>
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
 800ac92:	2100      	movs	r1, #0
 800ac94:	2298      	movs	r2, #152	; 0x98
 800ac96:	4620      	mov	r0, r4
 800ac98:	f009 f89a 	bl	8013dd0 <memset>
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 800ac9c:	4d42      	ldr	r5, [pc, #264]	; (800ada8 <tcp_alloc+0x128>)
 800ac9e:	4b43      	ldr	r3, [pc, #268]	; (800adac <tcp_alloc+0x12c>)
    pcb->snd_wl2 = iss;
    pcb->snd_nxt = iss;
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
    pcb->last_timer = tcp_timer_ctr;
 800aca0:	4a43      	ldr	r2, [pc, #268]	; (800adb0 <tcp_alloc+0x130>)
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 800aca2:	681e      	ldr	r6, [r3, #0]
 800aca4:	682b      	ldr	r3, [r5, #0]
    pcb->snd_wl2 = iss;
    pcb->snd_nxt = iss;
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
    pcb->last_timer = tcp_timer_ctr;
 800aca6:	f892 a000 	ldrb.w	sl, [r2]

    pcb->polltmr = 0;

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
 800acaa:	f8df c114 	ldr.w	ip, [pc, #276]	; 800adc0 <tcp_alloc+0x140>
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 800acae:	f8df e114 	ldr.w	lr, [pc, #276]	; 800adc4 <tcp_alloc+0x144>
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
 800acb2:	7667      	strb	r7, [r4, #25]
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 800acb4:	4433      	add	r3, r6
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
 800acb6:	2200      	movs	r2, #0
    pcb->rcv_wnd = TCP_WND;
 800acb8:	f241 60d0 	movw	r0, #5840	; 0x16d0
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 800acbc:	2106      	movs	r1, #6
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
 800acbe:	f640 3b68 	movw	fp, #2920	; 0xb68
    pcb->snd_queuelen = 0;
    pcb->rcv_wnd = TCP_WND;
    pcb->rcv_ann_wnd = TCP_WND;
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
 800acc2:	f04f 09ff 	mov.w	r9, #255	; 0xff
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 800acc6:	f44f 7806 	mov.w	r8, #536	; 0x218
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    pcb->rtime = -1;
 800acca:	f64f 77ff 	movw	r7, #65535	; 0xffff
    iss = tcp_next_iss();
    pcb->snd_wl2 = iss;
    pcb->snd_nxt = iss;
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
 800acce:	6266      	str	r6, [r4, #36]	; 0x24
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    pcb->rtime = -1;
    pcb->cwnd = 1;
 800acd0:	2601      	movs	r6, #1
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 800acd2:	602b      	str	r3, [r5, #0]
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    pcb->rtime = -1;
    pcb->cwnd = 1;
    iss = tcp_next_iss();
    pcb->snd_wl2 = iss;
 800acd4:	65a3      	str	r3, [r4, #88]	; 0x58
    pcb->snd_nxt = iss;
 800acd6:	6523      	str	r3, [r4, #80]	; 0x50
    pcb->lastack = iss;
 800acd8:	64a3      	str	r3, [r4, #72]	; 0x48
    pcb->snd_lbb = iss;   
 800acda:	65e3      	str	r3, [r4, #92]	; 0x5c
    pcb->tmr = tcp_ticks;
    pcb->last_timer = tcp_timer_ctr;
 800acdc:	f884 a021 	strb.w	sl, [r4, #33]	; 0x21
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
 800ace0:	f8a4 b066 	strh.w	fp, [r4, #102]	; 0x66
    pcb->snd_queuelen = 0;
 800ace4:	f8a4 2068 	strh.w	r2, [r4, #104]	; 0x68
    pcb->rcv_wnd = TCP_WND;
    pcb->rcv_ann_wnd = TCP_WND;
    pcb->tos = 0;
 800ace8:	7262      	strb	r2, [r4, #9]
    pcb->ttl = TCP_TTL;
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    pcb->sa = 0;
 800acea:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
    pcb->last_timer = tcp_timer_ctr;

    pcb->polltmr = 0;
 800acee:	77e2      	strb	r2, [r4, #31]
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
 800acf0:	f884 2096 	strb.w	r2, [r4, #150]	; 0x96
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
    pcb->rcv_wnd = TCP_WND;
 800acf4:	85a0      	strh	r0, [r4, #44]	; 0x2c
    pcb->rcv_ann_wnd = TCP_WND;
 800acf6:	85e0      	strh	r0, [r4, #46]	; 0x2e
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
 800acf8:	f884 900a 	strb.w	r9, [r4, #10]
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 800acfc:	f8a4 8036 	strh.w	r8, [r4, #54]	; 0x36
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 800ad00:	f8a4 1044 	strh.w	r1, [r4, #68]	; 0x44
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 800ad04:	f8a4 1042 	strh.w	r1, [r4, #66]	; 0x42
    pcb->rtime = -1;
 800ad08:	86a7      	strh	r7, [r4, #52]	; 0x34
    pcb->cwnd = 1;
 800ad0a:	f8a4 604c 	strh.w	r6, [r4, #76]	; 0x4c
    pcb->last_timer = tcp_timer_ctr;

    pcb->polltmr = 0;

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
 800ad0e:	f8c4 c080 	str.w	ip, [r4, #128]	; 0x80
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 800ad12:	f8c4 e090 	str.w	lr, [r4, #144]	; 0x90
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  }
  return pcb;
}
 800ad16:	4620      	mov	r0, r4
 800ad18:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800ad1c:	4b25      	ldr	r3, [pc, #148]	; (800adb4 <tcp_alloc+0x134>)
 800ad1e:	6818      	ldr	r0, [r3, #0]
 800ad20:	b188      	cbz	r0, 800ad46 <tcp_alloc+0xc6>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800ad22:	4b22      	ldr	r3, [pc, #136]	; (800adac <tcp_alloc+0x12c>)
 800ad24:	6a41      	ldr	r1, [r0, #36]	; 0x24
 800ad26:	681c      	ldr	r4, [r3, #0]
 800ad28:	4603      	mov	r3, r0
 800ad2a:	1a61      	subs	r1, r4, r1
 800ad2c:	e005      	b.n	800ad3a <tcp_alloc+0xba>
 800ad2e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ad30:	1aa2      	subs	r2, r4, r2
 800ad32:	428a      	cmp	r2, r1
 800ad34:	bf24      	itt	cs
 800ad36:	4611      	movcs	r1, r2
 800ad38:	4618      	movcs	r0, r3
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800ad3a:	68db      	ldr	r3, [r3, #12]
 800ad3c:	2b00      	cmp	r3, #0
 800ad3e:	d1f6      	bne.n	800ad2e <tcp_alloc+0xae>
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  tcp_abandon(pcb, 1);
 800ad40:	2101      	movs	r1, #1
 800ad42:	f7ff ff15 	bl	800ab70 <tcp_abandon>
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800ad46:	2002      	movs	r0, #2
 800ad48:	f7fe f8e2 	bl	8008f10 <memp_malloc>
    if (pcb == NULL) {
 800ad4c:	4604      	mov	r4, r0
 800ad4e:	b130      	cbz	r0, 800ad5e <tcp_alloc+0xde>
 800ad50:	4a19      	ldr	r2, [pc, #100]	; (800adb8 <tcp_alloc+0x138>)
 800ad52:	f8b2 30cc 	ldrh.w	r3, [r2, #204]	; 0xcc
        MEMP_STATS_DEC(err, MEMP_TCP_PCB);
      }
    }
    if (pcb != NULL) {
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 800ad56:	3b01      	subs	r3, #1
 800ad58:	f8a2 30cc 	strh.w	r3, [r2, #204]	; 0xcc
 800ad5c:	e799      	b.n	800ac92 <tcp_alloc+0x12>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800ad5e:	4b17      	ldr	r3, [pc, #92]	; (800adbc <tcp_alloc+0x13c>)
 800ad60:	681b      	ldr	r3, [r3, #0]
 800ad62:	b1ab      	cbz	r3, 800ad90 <tcp_alloc+0x110>
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800ad64:	4a11      	ldr	r2, [pc, #68]	; (800adac <tcp_alloc+0x12c>)
 800ad66:	6816      	ldr	r6, [r2, #0]
 800ad68:	257f      	movs	r5, #127	; 0x7f
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
 800ad6a:	7e5a      	ldrb	r2, [r3, #25]
 800ad6c:	4297      	cmp	r7, r2
 800ad6e:	d308      	bcc.n	800ad82 <tcp_alloc+0x102>
 800ad70:	42aa      	cmp	r2, r5
 800ad72:	d806      	bhi.n	800ad82 <tcp_alloc+0x102>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800ad74:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800ad76:	1a71      	subs	r1, r6, r1
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
 800ad78:	42a1      	cmp	r1, r4
 800ad7a:	d302      	bcc.n	800ad82 <tcp_alloc+0x102>
 800ad7c:	4615      	mov	r5, r2
 800ad7e:	460c      	mov	r4, r1
 800ad80:	4618      	mov	r0, r3
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800ad82:	68db      	ldr	r3, [r3, #12]
 800ad84:	2b00      	cmp	r3, #0
 800ad86:	d1f0      	bne.n	800ad6a <tcp_alloc+0xea>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
 800ad88:	b110      	cbz	r0, 800ad90 <tcp_alloc+0x110>
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  tcp_abandon(pcb, 1);
 800ad8a:	2101      	movs	r1, #1
 800ad8c:	f7ff fef0 	bl	800ab70 <tcp_abandon>
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800ad90:	2002      	movs	r0, #2
 800ad92:	f7fe f8bd 	bl	8008f10 <memp_malloc>
      if (pcb != NULL) {
 800ad96:	4604      	mov	r4, r0
 800ad98:	2800      	cmp	r0, #0
 800ad9a:	d0bc      	beq.n	800ad16 <tcp_alloc+0x96>
        /* adjust err stats: memp_malloc failed twice before */
        MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 800ad9c:	4a06      	ldr	r2, [pc, #24]	; (800adb8 <tcp_alloc+0x138>)
 800ad9e:	f8b2 30cc 	ldrh.w	r3, [r2, #204]	; 0xcc
 800ada2:	3b01      	subs	r3, #1
 800ada4:	b29b      	uxth	r3, r3
 800ada6:	e7d6      	b.n	800ad56 <tcp_alloc+0xd6>
 800ada8:	200008bc 	.word	0x200008bc
 800adac:	2000cb54 	.word	0x2000cb54
 800adb0:	2000cb64 	.word	0x2000cb64
 800adb4:	2000cb50 	.word	0x2000cb50
 800adb8:	2000c9fc 	.word	0x2000c9fc
 800adbc:	2000cb60 	.word	0x2000cb60
 800adc0:	0800a9d1 	.word	0x0800a9d1
 800adc4:	006ddd00 	.word	0x006ddd00
 800adc8:	f3af 8000 	nop.w
 800adcc:	f3af 8000 	nop.w

0800add0 <tcp_new>:
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  return tcp_alloc(TCP_PRIO_NORMAL);
 800add0:	2040      	movs	r0, #64	; 0x40
 800add2:	f7ff bf55 	b.w	800ac80 <tcp_alloc>
 800add6:	bf00      	nop
 800add8:	f3af 8000 	nop.w
 800addc:	f3af 8000 	nop.w

0800ade0 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
{
 800ade0:	b510      	push	{r4, lr}
 800ade2:	4604      	mov	r4, r0
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
 800ade4:	4608      	mov	r0, r1
 800ade6:	f003 f90b 	bl	800e000 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
 800adea:	b130      	cbz	r0, 800adfa <tcp_eff_send_mss+0x1a>
 800adec:	8c03      	ldrh	r3, [r0, #32]
 800adee:	b123      	cbz	r3, 800adfa <tcp_eff_send_mss+0x1a>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
 800adf0:	3b28      	subs	r3, #40	; 0x28
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
 800adf2:	b29b      	uxth	r3, r3
 800adf4:	429c      	cmp	r4, r3
 800adf6:	bf28      	it	cs
 800adf8:	461c      	movcs	r4, r3
  }
  return sendmss;
}
 800adfa:	4620      	mov	r0, r4
 800adfc:	bd10      	pop	{r4, pc}
 800adfe:	bf00      	nop

0800ae00 <tcp_oos_insert_segment>:
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
 800ae00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  struct tcp_seg *old_seg;

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 800ae04:	68c3      	ldr	r3, [r0, #12]
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
 800ae06:	4605      	mov	r5, r0
  struct tcp_seg *old_seg;

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 800ae08:	8998      	ldrh	r0, [r3, #12]
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
 800ae0a:	460f      	mov	r7, r1
  struct tcp_seg *old_seg;

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 800ae0c:	f003 ffd0 	bl	800edb0 <lwip_ntohs>
 800ae10:	07c2      	lsls	r2, r0, #31
 800ae12:	d448      	bmi.n	800aea6 <tcp_oos_insert_segment+0xa6>
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
 800ae14:	2f00      	cmp	r7, #0
 800ae16:	d036      	beq.n	800ae86 <tcp_oos_insert_segment+0x86>
           TCP_SEQ_GEQ((seqno + cseg->len),
 800ae18:	68f9      	ldr	r1, [r7, #12]
 800ae1a:	4e25      	ldr	r6, [pc, #148]	; (800aeb0 <tcp_oos_insert_segment+0xb0>)
 800ae1c:	f8d1 e004 	ldr.w	lr, [r1, #4]
 800ae20:	892b      	ldrh	r3, [r5, #8]
 800ae22:	6830      	ldr	r0, [r6, #0]
 800ae24:	893a      	ldrh	r2, [r7, #8]
 800ae26:	ebce 0303 	rsb	r3, lr, r3
 800ae2a:	4403      	add	r3, r0
 800ae2c:	1a9a      	subs	r2, r3, r2
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
 800ae2e:	2a00      	cmp	r2, #0
 800ae30:	bfb8      	it	lt
 800ae32:	463c      	movlt	r4, r7
 800ae34:	da12      	bge.n	800ae5c <tcp_oos_insert_segment+0x5c>
 800ae36:	e02a      	b.n	800ae8e <tcp_oos_insert_segment+0x8e>
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
      }
      old_seg = next;
      next = next->next;
 800ae38:	683c      	ldr	r4, [r7, #0]
      tcp_seg_free(old_seg);
 800ae3a:	4638      	mov	r0, r7
 800ae3c:	f7ff f8f0 	bl	800a020 <tcp_seg_free>
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
 800ae40:	b30c      	cbz	r4, 800ae86 <tcp_oos_insert_segment+0x86>
           TCP_SEQ_GEQ((seqno + cseg->len),
 800ae42:	68e1      	ldr	r1, [r4, #12]
 800ae44:	892b      	ldrh	r3, [r5, #8]
 800ae46:	f8d1 e004 	ldr.w	lr, [r1, #4]
 800ae4a:	6830      	ldr	r0, [r6, #0]
 800ae4c:	8922      	ldrh	r2, [r4, #8]
 800ae4e:	ebce 0303 	rsb	r3, lr, r3
 800ae52:	4403      	add	r3, r0
 800ae54:	1a9a      	subs	r2, r3, r2
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
 800ae56:	2a00      	cmp	r2, #0
 800ae58:	db19      	blt.n	800ae8e <tcp_oos_insert_segment+0x8e>
 800ae5a:	4627      	mov	r7, r4
           TCP_SEQ_GEQ((seqno + cseg->len),
                      (next->tcphdr->seqno + next->len))) {
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 800ae5c:	8988      	ldrh	r0, [r1, #12]
 800ae5e:	f003 ffa7 	bl	800edb0 <lwip_ntohs>
 800ae62:	07c3      	lsls	r3, r0, #31
 800ae64:	d5e8      	bpl.n	800ae38 <tcp_oos_insert_segment+0x38>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 800ae66:	f8d5 800c 	ldr.w	r8, [r5, #12]
 800ae6a:	2001      	movs	r0, #1
 800ae6c:	f8b8 400c 	ldrh.w	r4, [r8, #12]
 800ae70:	f003 ff96 	bl	800eda0 <lwip_htons>
 800ae74:	4320      	orrs	r0, r4
      }
      old_seg = next;
      next = next->next;
 800ae76:	683c      	ldr	r4, [r7, #0]
    while (next &&
           TCP_SEQ_GEQ((seqno + cseg->len),
                      (next->tcphdr->seqno + next->len))) {
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 800ae78:	f8a8 000c 	strh.w	r0, [r8, #12]
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
 800ae7c:	4638      	mov	r0, r7
 800ae7e:	f7ff f8cf 	bl	800a020 <tcp_seg_free>
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
 800ae82:	2c00      	cmp	r4, #0
 800ae84:	d1dd      	bne.n	800ae42 <tcp_oos_insert_segment+0x42>
  struct tcp_seg *old_seg;

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    /* received segment overlaps all following segments */
    tcp_segs_free(next);
    next = NULL;
 800ae86:	2400      	movs	r4, #0
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
      pbuf_realloc(cseg->p, cseg->len);
    }
  }
  cseg->next = next;
 800ae88:	602c      	str	r4, [r5, #0]
 800ae8a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
 800ae8e:	2b00      	cmp	r3, #0
 800ae90:	ddfa      	ble.n	800ae88 <tcp_oos_insert_segment+0x88>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
 800ae92:	ebc0 000e 	rsb	r0, r0, lr
 800ae96:	b281      	uxth	r1, r0
 800ae98:	8129      	strh	r1, [r5, #8]
      pbuf_realloc(cseg->p, cseg->len);
 800ae9a:	6868      	ldr	r0, [r5, #4]
 800ae9c:	f7fe fc50 	bl	8009740 <pbuf_realloc>
    }
  }
  cseg->next = next;
 800aea0:	602c      	str	r4, [r5, #0]
 800aea2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
  struct tcp_seg *old_seg;

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    /* received segment overlaps all following segments */
    tcp_segs_free(next);
 800aea6:	4638      	mov	r0, r7
 800aea8:	f7ff f8ca 	bl	800a040 <tcp_segs_free>
 800aeac:	e7eb      	b.n	800ae86 <tcp_oos_insert_segment+0x86>
 800aeae:	bf00      	nop
 800aeb0:	2000cb70 	.word	0x2000cb70
 800aeb4:	f3af 8000 	nop.w
 800aeb8:	f3af 8000 	nop.w
 800aebc:	f3af 8000 	nop.w

0800aec0 <tcp_parseopt.isra.0>:
 * Currently, only the MSS option is supported!
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
 800aec0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
 800aec2:	4c22      	ldr	r4, [pc, #136]	; (800af4c <tcp_parseopt.isra.0+0x8c>)
 800aec4:	6825      	ldr	r5, [r4, #0]
 * Currently, only the MSS option is supported!
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
 800aec6:	4606      	mov	r6, r0
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
 800aec8:	89a8      	ldrh	r0, [r5, #12]
 800aeca:	f003 ff71 	bl	800edb0 <lwip_ntohs>
 800aece:	f3c0 300f 	ubfx	r0, r0, #12, #16
 800aed2:	2805      	cmp	r0, #5
 800aed4:	d800      	bhi.n	800aed8 <tcp_parseopt.isra.0+0x18>
 800aed6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
 800aed8:	6823      	ldr	r3, [r4, #0]
 800aeda:	8998      	ldrh	r0, [r3, #12]
 800aedc:	f003 ff68 	bl	800edb0 <lwip_ntohs>
 800aee0:	0b00      	lsrs	r0, r0, #12
 800aee2:	3805      	subs	r0, #5
 800aee4:	0080      	lsls	r0, r0, #2
 800aee6:	b280      	uxth	r0, r0
    for (c = 0; c < max_c; ) {
 800aee8:	2800      	cmp	r0, #0
 800aeea:	d0f4      	beq.n	800aed6 <tcp_parseopt.isra.0+0x16>
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
 800aeec:	f105 0214 	add.w	r2, r5, #20
 800aef0:	2300      	movs	r3, #0
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 800aef2:	f240 57b3 	movw	r7, #1459	; 0x5b3
  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
      opt = opts[c];
      switch (opt) {
 800aef6:	5cd1      	ldrb	r1, [r2, r3]
 800aef8:	2901      	cmp	r1, #1
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 800aefa:	f240 55b4 	movw	r5, #1460	; 0x5b4
  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
      opt = opts[c];
      switch (opt) {
 800aefe:	d01b      	beq.n	800af38 <tcp_parseopt.isra.0+0x78>
 800af00:	d3e9      	bcc.n	800aed6 <tcp_parseopt.isra.0+0x16>
 800af02:	2902      	cmp	r1, #2
 800af04:	d11b      	bne.n	800af3e <tcp_parseopt.isra.0+0x7e>
        ++c;
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
        break;
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
 800af06:	18d4      	adds	r4, r2, r3
 800af08:	7861      	ldrb	r1, [r4, #1]
 800af0a:	2904      	cmp	r1, #4
 800af0c:	d1e3      	bne.n	800aed6 <tcp_parseopt.isra.0+0x16>
 800af0e:	1cd9      	adds	r1, r3, #3
 800af10:	4281      	cmp	r1, r0
 800af12:	dae0      	bge.n	800aed6 <tcp_parseopt.isra.0+0x16>
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
 800af14:	f894 e002 	ldrb.w	lr, [r4, #2]
 800af18:	78e1      	ldrb	r1, [r4, #3]
 800af1a:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 800af1e:	1e4c      	subs	r4, r1, #1
 800af20:	b2a4      	uxth	r4, r4
        /* Advance to next option */
        c += 0x04;
 800af22:	3304      	adds	r3, #4
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 800af24:	42bc      	cmp	r4, r7
 800af26:	bf88      	it	hi
 800af28:	4629      	movhi	r1, r5
        /* Advance to next option */
        c += 0x04;
 800af2a:	b29b      	uxth	r3, r3
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 800af2c:	8031      	strh	r1, [r6, #0]
  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
 800af2e:	4298      	cmp	r0, r3
 800af30:	d9d1      	bls.n	800aed6 <tcp_parseopt.isra.0+0x16>
      opt = opts[c];
      switch (opt) {
 800af32:	5cd1      	ldrb	r1, [r2, r3]
 800af34:	2901      	cmp	r1, #1
 800af36:	d1e3      	bne.n	800af00 <tcp_parseopt.isra.0+0x40>
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
      case 0x01:
        /* NOP option. */
        ++c;
 800af38:	3301      	adds	r3, #1
 800af3a:	b29b      	uxth	r3, r3
 800af3c:	e7f7      	b.n	800af2e <tcp_parseopt.isra.0+0x6e>
        c += 0x0A;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
 800af3e:	18d1      	adds	r1, r2, r3
 800af40:	7849      	ldrb	r1, [r1, #1]
 800af42:	2900      	cmp	r1, #0
 800af44:	d0c7      	beq.n	800aed6 <tcp_parseopt.isra.0+0x16>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
 800af46:	440b      	add	r3, r1
 800af48:	b29b      	uxth	r3, r3
 800af4a:	e7f0      	b.n	800af2e <tcp_parseopt.isra.0+0x6e>
 800af4c:	2000cb84 	.word	0x2000cb84

0800af50 <chprintf.constprop.1>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 800af50:	b40e      	push	{r1, r2, r3}
 800af52:	b500      	push	{lr}
 800af54:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800af56:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 800af58:	461a      	mov	r2, r3
 800af5a:	4905      	ldr	r1, [pc, #20]	; (800af70 <chprintf.constprop.1+0x20>)
 800af5c:	4805      	ldr	r0, [pc, #20]	; (800af74 <chprintf.constprop.1+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800af5e:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800af60:	f005 fece 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 800af64:	b002      	add	sp, #8
 800af66:	f85d eb04 	ldr.w	lr, [sp], #4
 800af6a:	b003      	add	sp, #12
 800af6c:	4770      	bx	lr
 800af6e:	bf00      	nop
 800af70:	08016fe0 	.word	0x08016fe0
 800af74:	200180c8 	.word	0x200180c8
 800af78:	f3af 8000 	nop.w
 800af7c:	f3af 8000 	nop.w

0800af80 <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
 800af80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
  u32_t ooseq_blen;
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 800af84:	7e03      	ldrb	r3, [r0, #24]
 800af86:	2b03      	cmp	r3, #3
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
 800af88:	b085      	sub	sp, #20
 800af8a:	4604      	mov	r4, r0
#if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
  u32_t ooseq_blen;
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 800af8c:	f240 8100 	bls.w	800b190 <tcp_receive+0x210>

  if (flags & TCP_ACK) {
 800af90:	4bb5      	ldr	r3, [pc, #724]	; (800b268 <tcp_receive+0x2e8>)
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 800af92:	f8df 8300 	ldr.w	r8, [pc, #768]	; 800b294 <tcp_receive+0x314>
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
 800af96:	781b      	ldrb	r3, [r3, #0]
 800af98:	06dd      	lsls	r5, r3, #27
 800af9a:	d41b      	bmi.n	800afd4 <tcp_receive+0x54>
 800af9c:	f8df 92f8 	ldr.w	r9, [pc, #760]	; 800b298 <tcp_receive+0x318>

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapeter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
 800afa0:	f8b9 3000 	ldrh.w	r3, [r9]
 800afa4:	b11b      	cbz	r3, 800afae <tcp_receive+0x2e>
 800afa6:	7e22      	ldrb	r2, [r4, #24]
 800afa8:	2a06      	cmp	r2, #6
 800afaa:	f240 80a7 	bls.w	800b0fc <tcp_receive+0x17c>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
 800afae:	f8d8 3000 	ldr.w	r3, [r8]
 800afb2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800afb4:	1a5a      	subs	r2, r3, r1
 800afb6:	2a00      	cmp	r2, #0
 800afb8:	db05      	blt.n	800afc6 <tcp_receive+0x46>
 800afba:	1c5a      	adds	r2, r3, #1
 800afbc:	8da0      	ldrh	r0, [r4, #44]	; 0x2c
 800afbe:	1a53      	subs	r3, r2, r1
 800afc0:	1a1b      	subs	r3, r3, r0
 800afc2:	2b00      	cmp	r3, #0
 800afc4:	dd03      	ble.n	800afce <tcp_receive+0x4e>
      tcp_ack_now(pcb);
 800afc6:	7fa3      	ldrb	r3, [r4, #30]
 800afc8:	f043 0302 	orr.w	r3, r3, #2
 800afcc:	77a3      	strb	r3, [r4, #30]
    }
  }
}
 800afce:	b005      	add	sp, #20
 800afd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 800afd4:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800afd6:	f8d8 2000 	ldr.w	r2, [r8]
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 800afda:	f8b4 5060 	ldrh.w	r5, [r4, #96]	; 0x60
 800afde:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800afe0:	4ea2      	ldr	r6, [pc, #648]	; (800b26c <tcp_receive+0x2ec>)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 800afe2:	1a99      	subs	r1, r3, r2
 800afe4:	2900      	cmp	r1, #0
 800afe6:	f2c0 80e4 	blt.w	800b1b2 <tcp_receive+0x232>
 800afea:	4293      	cmp	r3, r2
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800afec:	6833      	ldr	r3, [r6, #0]

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 800afee:	f000 80dc 	beq.w	800b1aa <tcp_receive+0x22a>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800aff2:	4298      	cmp	r0, r3
 800aff4:	f000 81d2 	beq.w	800b39c <tcp_receive+0x41c>
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 800aff8:	6ca7      	ldr	r7, [r4, #72]	; 0x48
 800affa:	1bda      	subs	r2, r3, r7
 800affc:	2a00      	cmp	r2, #0
 800affe:	f340 81b2 	ble.w	800b366 <tcp_receive+0x3e6>
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
        pcb->dupacks = 0;
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
 800b002:	6d21      	ldr	r1, [r4, #80]	; 0x50
 800b004:	1a59      	subs	r1, r3, r1
 800b006:	2900      	cmp	r1, #0
 800b008:	f340 81d0 	ble.w	800b3ac <tcp_receive+0x42c>
        pcb->rtime = 0;

      pcb->polltmr = 0;
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
 800b00c:	2300      	movs	r3, #0
 800b00e:	f8df 9288 	ldr.w	r9, [pc, #648]	; 800b298 <tcp_receive+0x318>
 800b012:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 800b016:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 800b018:	4f94      	ldr	r7, [pc, #592]	; (800b26c <tcp_receive+0x2ec>)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 800b01a:	2b00      	cmp	r3, #0
 800b01c:	d041      	beq.n	800b0a2 <tcp_receive+0x122>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 800b01e:	68db      	ldr	r3, [r3, #12]
 800b020:	6835      	ldr	r5, [r6, #0]
 800b022:	6858      	ldr	r0, [r3, #4]
 800b024:	f003 fed4 	bl	800edd0 <lwip_ntohl>
 800b028:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800b02a:	68d9      	ldr	r1, [r3, #12]
 800b02c:	f8b3 b008 	ldrh.w	fp, [r3, #8]
 800b030:	4682      	mov	sl, r0
 800b032:	8988      	ldrh	r0, [r1, #12]
 800b034:	f003 febc 	bl	800edb0 <lwip_ntohs>
 800b038:	f010 0003 	ands.w	r0, r0, #3
 800b03c:	bf18      	it	ne
 800b03e:	2001      	movne	r0, #1
 800b040:	ebca 0505 	rsb	r5, sl, r5
 800b044:	4458      	add	r0, fp
 800b046:	1a2d      	subs	r5, r5, r0
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 800b048:	2d00      	cmp	r5, #0
 800b04a:	db2a      	blt.n	800b0a2 <tcp_receive+0x122>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 800b04c:	683b      	ldr	r3, [r7, #0]
 800b04e:	6d22      	ldr	r2, [r4, #80]	; 0x50
 800b050:	1a9b      	subs	r3, r3, r2
 800b052:	2b00      	cmp	r3, #0
 800b054:	dc25      	bgt.n	800b0a2 <tcp_receive+0x122>
                           TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
 800b056:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
      pcb->unsent = pcb->unsent->next;
 800b058:	682b      	ldr	r3, [r5, #0]
 800b05a:	66e3      	str	r3, [r4, #108]	; 0x6c
#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
 800b05c:	2b00      	cmp	r3, #0
 800b05e:	f000 8083 	beq.w	800b168 <tcp_receive+0x1e8>
        pcb->unsent_oversize = 0;
      }
#endif /* TCP_OVERSIZE */ 
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 800b062:	6868      	ldr	r0, [r5, #4]
 800b064:	f8b4 b068 	ldrh.w	fp, [r4, #104]	; 0x68
 800b068:	f7fe fbfa 	bl	8009860 <pbuf_clen>
 800b06c:	b280      	uxth	r0, r0
 800b06e:	4583      	cmp	fp, r0
 800b070:	d36d      	bcc.n	800b14e <tcp_receive+0x1ce>
      /* Prevent ACK for FIN to generate a sent event */
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 800b072:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 800b076:	2b00      	cmp	r3, #0
 800b078:	d15d      	bne.n	800b136 <tcp_receive+0x1b6>
        pcb->acked--;
      }
      pcb->snd_queuelen -= pbuf_clen(next->p);
 800b07a:	6868      	ldr	r0, [r5, #4]
 800b07c:	f7fe fbf0 	bl	8009860 <pbuf_clen>
 800b080:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 800b084:	1a18      	subs	r0, r3, r0
 800b086:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
      tcp_seg_free(next);
 800b08a:	4628      	mov	r0, r5
 800b08c:	f7fe ffc8 	bl	800a020 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
 800b090:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 800b094:	b113      	cbz	r3, 800b09c <tcp_receive+0x11c>
        LWIP_ASSERT("tcp_receive: valid queue length",
 800b096:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800b098:	2b00      	cmp	r3, #0
 800b09a:	d068      	beq.n	800b16e <tcp_receive+0x1ee>
 800b09c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 800b09e:	2b00      	cmp	r3, #0
 800b0a0:	d1bd      	bne.n	800b01e <tcp_receive+0x9e>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 800b0a2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b0a4:	2b00      	cmp	r3, #0
 800b0a6:	f43f af7b 	beq.w	800afa0 <tcp_receive+0x20>
 800b0aa:	6831      	ldr	r1, [r6, #0]
 800b0ac:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800b0ae:	1a52      	subs	r2, r2, r1
 800b0b0:	2a00      	cmp	r2, #0
 800b0b2:	f6bf af75 	bge.w	800afa0 <tcp_receive+0x20>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
 800b0b6:	496e      	ldr	r1, [pc, #440]	; (800b270 <tcp_receive+0x2f0>)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
 800b0b8:	f8b4 2040 	ldrh.w	r2, [r4, #64]	; 0x40
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
 800b0bc:	6808      	ldr	r0, [r1, #0]

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
 800b0be:	f342 01cc 	sbfx	r1, r2, #3, #13
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
 800b0c2:	1ac3      	subs	r3, r0, r3

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
 800b0c4:	1a59      	subs	r1, r3, r1
 800b0c6:	b289      	uxth	r1, r1
      pcb->sa += m;
 800b0c8:	188b      	adds	r3, r1, r2

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
 800b0ca:	b28a      	uxth	r2, r1
      pcb->sa += m;
      if (m < 0) {
 800b0cc:	0410      	lsls	r0, r2, #16
        m = -m;
 800b0ce:	bf44      	itt	mi
 800b0d0:	4249      	negmi	r1, r1
 800b0d2:	b28a      	uxthmi	r2, r1
      }
      m = m - (pcb->sv >> 2);
 800b0d4:	f8b4 1042 	ldrh.w	r1, [r4, #66]	; 0x42
 800b0d8:	f341 008d 	sbfx	r0, r1, #2, #14
 800b0dc:	1a09      	subs	r1, r1, r0
      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
      pcb->sa += m;
 800b0de:	b29b      	uxth	r3, r3
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
      pcb->sv += m;
 800b0e0:	440a      	add	r2, r1
 800b0e2:	b292      	uxth	r2, r2
      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
      pcb->sa += m;
 800b0e4:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
      pcb->sv += m;
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 800b0e8:	f343 03cc 	sbfx	r3, r3, #3, #13
 800b0ec:	4413      	add	r3, r2

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
 800b0ee:	2100      	movs	r1, #0
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
      pcb->sv += m;
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 800b0f0:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
      pcb->sa += m;
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
      pcb->sv += m;
 800b0f4:	f8a4 2042 	strh.w	r2, [r4, #66]	; 0x42
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
 800b0f8:	63a1      	str	r1, [r4, #56]	; 0x38
 800b0fa:	e751      	b.n	800afa0 <tcp_receive+0x20>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
 800b0fc:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800b0fe:	f8d8 2000 	ldr.w	r2, [r8]
 800b102:	1a8e      	subs	r6, r1, r2
 800b104:	2e01      	cmp	r6, #1
 800b106:	d405      	bmi.n	800b114 <tcp_receive+0x194>
 800b108:	1c48      	adds	r0, r1, #1
 800b10a:	1a80      	subs	r0, r0, r2
 800b10c:	1ac3      	subs	r3, r0, r3
 800b10e:	2b00      	cmp	r3, #0
 800b110:	f340 81e8 	ble.w	800b4e4 <tcp_receive+0x564>
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
 800b114:	1a53      	subs	r3, r2, r1
 800b116:	2b00      	cmp	r3, #0
 800b118:	f2c0 80a0 	blt.w	800b25c <tcp_receive+0x2dc>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 800b11c:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 800b11e:	f1c3 0301 	rsb	r3, r3, #1
 800b122:	4413      	add	r3, r2
 800b124:	1a5b      	subs	r3, r3, r1
 800b126:	2b00      	cmp	r3, #0
 800b128:	dd5f      	ble.n	800b1ea <tcp_receive+0x26a>
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
#endif /* TCP_QUEUE_OOSEQ */
      }
    } else {
      /* The incoming segment is not withing the window. */
      tcp_send_empty_ack(pcb);
 800b12a:	4620      	mov	r0, r4
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
}
 800b12c:	b005      	add	sp, #20
 800b12e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
#endif /* TCP_QUEUE_OOSEQ */
      }
    } else {
      /* The incoming segment is not withing the window. */
      tcp_send_empty_ack(pcb);
 800b132:	f001 bf8d 	b.w	800d050 <tcp_send_empty_ack>
      }
#endif /* TCP_OVERSIZE */ 
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
      /* Prevent ACK for FIN to generate a sent event */
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 800b136:	68eb      	ldr	r3, [r5, #12]
 800b138:	8998      	ldrh	r0, [r3, #12]
 800b13a:	f003 fe39 	bl	800edb0 <lwip_ntohs>
 800b13e:	07c3      	lsls	r3, r0, #31
 800b140:	d59b      	bpl.n	800b07a <tcp_receive+0xfa>
        pcb->acked--;
 800b142:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 800b146:	3b01      	subs	r3, #1
 800b148:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 800b14c:	e795      	b.n	800b07a <tcp_receive+0xfa>
      if (pcb->unsent == NULL) {
        pcb->unsent_oversize = 0;
      }
#endif /* TCP_OVERSIZE */ 
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 800b14e:	4b49      	ldr	r3, [pc, #292]	; (800b274 <tcp_receive+0x2f4>)
 800b150:	9300      	str	r3, [sp, #0]
 800b152:	4949      	ldr	r1, [pc, #292]	; (800b278 <tcp_receive+0x2f8>)
 800b154:	4a49      	ldr	r2, [pc, #292]	; (800b27c <tcp_receive+0x2fc>)
 800b156:	484a      	ldr	r0, [pc, #296]	; (800b280 <tcp_receive+0x300>)
 800b158:	f240 432e 	movw	r3, #1070	; 0x42e
 800b15c:	f7ff fef8 	bl	800af50 <chprintf.constprop.1>
 800b160:	4846      	ldr	r0, [pc, #280]	; (800b27c <tcp_receive+0x2fc>)
 800b162:	f7f5 ff05 	bl	8000f70 <chSysHalt>
 800b166:	e784      	b.n	800b072 <tcp_receive+0xf2>

      next = pcb->unsent;
      pcb->unsent = pcb->unsent->next;
#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
        pcb->unsent_oversize = 0;
 800b168:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
 800b16c:	e779      	b.n	800b062 <tcp_receive+0xe2>
      }
      pcb->snd_queuelen -= pbuf_clen(next->p);
      tcp_seg_free(next);
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
        LWIP_ASSERT("tcp_receive: valid queue length",
 800b16e:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800b170:	2b00      	cmp	r3, #0
 800b172:	f47f af52 	bne.w	800b01a <tcp_receive+0x9a>
 800b176:	4b3f      	ldr	r3, [pc, #252]	; (800b274 <tcp_receive+0x2f4>)
 800b178:	9300      	str	r3, [sp, #0]
 800b17a:	493f      	ldr	r1, [pc, #252]	; (800b278 <tcp_receive+0x2f8>)
 800b17c:	4a41      	ldr	r2, [pc, #260]	; (800b284 <tcp_receive+0x304>)
 800b17e:	4840      	ldr	r0, [pc, #256]	; (800b280 <tcp_receive+0x300>)
 800b180:	f44f 6387 	mov.w	r3, #1080	; 0x438
 800b184:	f7ff fee4 	bl	800af50 <chprintf.constprop.1>
 800b188:	483e      	ldr	r0, [pc, #248]	; (800b284 <tcp_receive+0x304>)
 800b18a:	f7f5 fef1 	bl	8000f70 <chSysHalt>
 800b18e:	e785      	b.n	800b09c <tcp_receive+0x11c>
#if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
  u32_t ooseq_blen;
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 800b190:	4b38      	ldr	r3, [pc, #224]	; (800b274 <tcp_receive+0x2f4>)
 800b192:	9300      	str	r3, [sp, #0]
 800b194:	4938      	ldr	r1, [pc, #224]	; (800b278 <tcp_receive+0x2f8>)
 800b196:	4a3c      	ldr	r2, [pc, #240]	; (800b288 <tcp_receive+0x308>)
 800b198:	4839      	ldr	r0, [pc, #228]	; (800b280 <tcp_receive+0x300>)
 800b19a:	f44f 7358 	mov.w	r3, #864	; 0x360
 800b19e:	f7ff fed7 	bl	800af50 <chprintf.constprop.1>
 800b1a2:	4839      	ldr	r0, [pc, #228]	; (800b288 <tcp_receive+0x308>)
 800b1a4:	f7f5 fee4 	bl	8000f70 <chSysHalt>
 800b1a8:	e6f2      	b.n	800af90 <tcp_receive+0x10>
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800b1aa:	1ac1      	subs	r1, r0, r3
 800b1ac:	2900      	cmp	r1, #0
 800b1ae:	f6bf af20 	bge.w	800aff2 <tcp_receive+0x72>
 800b1b2:	4936      	ldr	r1, [pc, #216]	; (800b28c <tcp_receive+0x30c>)
 800b1b4:	6833      	ldr	r3, [r6, #0]
 800b1b6:	6809      	ldr	r1, [r1, #0]
 800b1b8:	89c9      	ldrh	r1, [r1, #14]
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
      pcb->snd_wnd = tcphdr->wnd;
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < tcphdr->wnd) {
 800b1ba:	f8b4 7062 	ldrh.w	r7, [r4, #98]	; 0x62
        pcb->snd_wnd_max = tcphdr->wnd;
      }
      pcb->snd_wl1 = seqno;
 800b1be:	6562      	str	r2, [r4, #84]	; 0x54
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
      pcb->snd_wnd = tcphdr->wnd;
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < tcphdr->wnd) {
 800b1c0:	428f      	cmp	r7, r1

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
      pcb->snd_wnd = tcphdr->wnd;
 800b1c2:	f8a4 1060 	strh.w	r1, [r4, #96]	; 0x60
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < tcphdr->wnd) {
        pcb->snd_wnd_max = tcphdr->wnd;
 800b1c6:	bf38      	it	cc
 800b1c8:	f8a4 1062 	strhcc.w	r1, [r4, #98]	; 0x62
      }
      pcb->snd_wl1 = seqno;
      pcb->snd_wl2 = ackno;
 800b1cc:	65a3      	str	r3, [r4, #88]	; 0x58
      if (pcb->snd_wnd == 0) {
        if (pcb->persist_backoff == 0) {
 800b1ce:	f894 2095 	ldrb.w	r2, [r4, #149]	; 0x95
      if (pcb->snd_wnd_max < tcphdr->wnd) {
        pcb->snd_wnd_max = tcphdr->wnd;
      }
      pcb->snd_wl1 = seqno;
      pcb->snd_wl2 = ackno;
      if (pcb->snd_wnd == 0) {
 800b1d2:	2900      	cmp	r1, #0
 800b1d4:	f040 80db 	bne.w	800b38e <tcp_receive+0x40e>
        if (pcb->persist_backoff == 0) {
 800b1d8:	2a00      	cmp	r2, #0
 800b1da:	f47f af0d 	bne.w	800aff8 <tcp_receive+0x78>
          /* start persist timer */
          pcb->persist_cnt = 0;
          pcb->persist_backoff = 1;
 800b1de:	2201      	movs	r2, #1
      pcb->snd_wl1 = seqno;
      pcb->snd_wl2 = ackno;
      if (pcb->snd_wnd == 0) {
        if (pcb->persist_backoff == 0) {
          /* start persist timer */
          pcb->persist_cnt = 0;
 800b1e0:	f884 1094 	strb.w	r1, [r4, #148]	; 0x94
          pcb->persist_backoff = 1;
 800b1e4:	f884 2095 	strb.w	r2, [r4, #149]	; 0x95
 800b1e8:	e706      	b.n	800aff8 <tcp_receive+0x78>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 800b1ea:	428a      	cmp	r2, r1
 800b1ec:	f000 81f3 	beq.w	800b5d6 <tcp_receive+0x656>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_send_empty_ack(pcb);
 800b1f0:	4620      	mov	r0, r4
 800b1f2:	f001 ff2d 	bl	800d050 <tcp_send_empty_ack>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
 800b1f6:	6f65      	ldr	r5, [r4, #116]	; 0x74
 800b1f8:	2d00      	cmp	r5, #0
 800b1fa:	f000 841f 	beq.w	800ba3c <tcp_receive+0xabc>
 800b1fe:	f8d8 0000 	ldr.w	r0, [r8]
 800b202:	2600      	movs	r6, #0
 800b204:	f100 3eff 	add.w	lr, r0, #4294967295
 800b208:	1c47      	adds	r7, r0, #1
 800b20a:	e00e      	b.n	800b22a <tcp_receive+0x2aa>
                  break;
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
 800b20c:	68f3      	ldr	r3, [r6, #12]
 800b20e:	685b      	ldr	r3, [r3, #4]
 800b210:	ebc3 030e 	rsb	r3, r3, lr
 800b214:	2b00      	cmp	r3, #0
 800b216:	db03      	blt.n	800b220 <tcp_receive+0x2a0>
 800b218:	f1bc 0f00 	cmp.w	ip, #0
 800b21c:	f340 831d 	ble.w	800b85a <tcp_receive+0x8da>
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
 800b220:	682b      	ldr	r3, [r5, #0]
 800b222:	462e      	mov	r6, r5
 800b224:	2b00      	cmp	r3, #0
 800b226:	d039      	beq.n	800b29c <tcp_receive+0x31c>
 800b228:	461d      	mov	r5, r3
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
 800b22a:	68e9      	ldr	r1, [r5, #12]
 800b22c:	684a      	ldr	r2, [r1, #4]
 800b22e:	4282      	cmp	r2, r0
                  break;
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
 800b230:	ebc2 0c07 	rsb	ip, r2, r7
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
 800b234:	f000 82e0 	beq.w	800b7f8 <tcp_receive+0x878>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
 800b238:	2e00      	cmp	r6, #0
 800b23a:	d1e7      	bne.n	800b20c <tcp_receive+0x28c>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
 800b23c:	1a83      	subs	r3, r0, r2
 800b23e:	2b00      	cmp	r3, #0
 800b240:	daee      	bge.n	800b220 <tcp_receive+0x2a0>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */
                  cseg = tcp_seg_copy(&inseg);
 800b242:	4813      	ldr	r0, [pc, #76]	; (800b290 <tcp_receive+0x310>)
 800b244:	f7fe ff0c 	bl	800a060 <tcp_seg_copy>
                  if (cseg != NULL) {
 800b248:	2800      	cmp	r0, #0
 800b24a:	f43f aec0 	beq.w	800afce <tcp_receive+0x4e>
                    pcb->ooseq = cseg;
 800b24e:	6760      	str	r0, [r4, #116]	; 0x74
                    tcp_oos_insert_segment(cseg, next);
 800b250:	4629      	mov	r1, r5
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
}
 800b252:	b005      	add	sp, #20
 800b254:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                     queue. We put the incoming segment first on the
                     queue. */
                  cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
                    pcb->ooseq = cseg;
                    tcp_oos_insert_segment(cseg, next);
 800b258:	f7ff bdd2 	b.w	800ae00 <tcp_oos_insert_segment>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
 800b25c:	7fa3      	ldrb	r3, [r4, #30]
 800b25e:	f043 0302 	orr.w	r3, r3, #2
 800b262:	77a3      	strb	r3, [r4, #30]
 800b264:	e761      	b.n	800b12a <tcp_receive+0x1aa>
 800b266:	bf00      	nop
 800b268:	2000cb80 	.word	0x2000cb80
 800b26c:	2000cb7c 	.word	0x2000cb7c
 800b270:	2000cb54 	.word	0x2000cb54
 800b274:	08017d5c 	.word	0x08017d5c
 800b278:	08016fe0 	.word	0x08016fe0
 800b27c:	08017d8c 	.word	0x08017d8c
 800b280:	200180c8 	.word	0x200180c8
 800b284:	08017db4 	.word	0x08017db4
 800b288:	08017d40 	.word	0x08017d40
 800b28c:	2000cb84 	.word	0x2000cb84
 800b290:	2000cb8c 	.word	0x2000cb8c
 800b294:	2000cb70 	.word	0x2000cb70
 800b298:	2000cb78 	.word	0x2000cb78
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
 800b29c:	1a82      	subs	r2, r0, r2
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
 800b29e:	2a00      	cmp	r2, #0
 800b2a0:	f77f ae95 	ble.w	800afce <tcp_receive+0x4e>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 800b2a4:	8988      	ldrh	r0, [r1, #12]
 800b2a6:	f003 fd83 	bl	800edb0 <lwip_ntohs>
 800b2aa:	07c2      	lsls	r2, r0, #31
 800b2ac:	f53f ae8f 	bmi.w	800afce <tcp_receive+0x4e>
                  /* segment "next" already contains all data */
                  break;
                }
                next->next = tcp_seg_copy(&inseg);
 800b2b0:	48bb      	ldr	r0, [pc, #748]	; (800b5a0 <tcp_receive+0x620>)
 800b2b2:	f7fe fed5 	bl	800a060 <tcp_seg_copy>
 800b2b6:	6028      	str	r0, [r5, #0]
                if (next->next != NULL) {
 800b2b8:	2800      	cmp	r0, #0
 800b2ba:	f43f ae88 	beq.w	800afce <tcp_receive+0x4e>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
 800b2be:	68e9      	ldr	r1, [r5, #12]
 800b2c0:	f8d8 3000 	ldr.w	r3, [r8]
 800b2c4:	892a      	ldrh	r2, [r5, #8]
 800b2c6:	6849      	ldr	r1, [r1, #4]
 800b2c8:	4eb6      	ldr	r6, [pc, #728]	; (800b5a4 <tcp_receive+0x624>)
 800b2ca:	1ad2      	subs	r2, r2, r3
 800b2cc:	440a      	add	r2, r1
 800b2ce:	2a00      	cmp	r2, #0
 800b2d0:	dd06      	ble.n	800b2e0 <tcp_receive+0x360>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
 800b2d2:	1a5b      	subs	r3, r3, r1
 800b2d4:	b299      	uxth	r1, r3
 800b2d6:	8129      	strh	r1, [r5, #8]
                    pbuf_realloc(next->p, next->len);
 800b2d8:	6868      	ldr	r0, [r5, #4]
 800b2da:	f7fe fa31 	bl	8009740 <pbuf_realloc>
 800b2de:	6833      	ldr	r3, [r6, #0]
                  }
                  /* check if the remote side overruns our receive window */
                  if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
 800b2e0:	f8b9 1000 	ldrh.w	r1, [r9]
 800b2e4:	8da0      	ldrh	r0, [r4, #44]	; 0x2c
 800b2e6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800b2e8:	440b      	add	r3, r1
 800b2ea:	4402      	add	r2, r0
 800b2ec:	4293      	cmp	r3, r2
 800b2ee:	f67f ae6e 	bls.w	800afce <tcp_receive+0x4e>
                    LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                                ("tcp_receive: other end overran receive window"
                                 "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                                 seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
 800b2f2:	682b      	ldr	r3, [r5, #0]
 800b2f4:	68db      	ldr	r3, [r3, #12]
 800b2f6:	8998      	ldrh	r0, [r3, #12]
 800b2f8:	f003 fd5a 	bl	800edb0 <lwip_ntohs>
 800b2fc:	07c3      	lsls	r3, r0, #31
 800b2fe:	f100 83bb 	bmi.w	800ba78 <tcp_receive+0xaf8>
                      /* Must remove the FIN from the header as we're trimming 
                       * that byte of sequence-space from the packet */
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
 800b302:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800b304:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 800b306:	f8d8 1000 	ldr.w	r1, [r8]
 800b30a:	682a      	ldr	r2, [r5, #0]
 800b30c:	4403      	add	r3, r0
 800b30e:	1a59      	subs	r1, r3, r1
 800b310:	b289      	uxth	r1, r1
 800b312:	8111      	strh	r1, [r2, #8]
                    pbuf_realloc(next->next->p, next->next->len);
 800b314:	6850      	ldr	r0, [r2, #4]
 800b316:	f7fe fa13 	bl	8009740 <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
 800b31a:	682b      	ldr	r3, [r5, #0]
 800b31c:	68da      	ldr	r2, [r3, #12]
 800b31e:	891d      	ldrh	r5, [r3, #8]
 800b320:	8990      	ldrh	r0, [r2, #12]
 800b322:	f003 fd45 	bl	800edb0 <lwip_ntohs>
 800b326:	f010 0003 	ands.w	r0, r0, #3
 800b32a:	bf18      	it	ne
 800b32c:	2001      	movne	r0, #1
 800b32e:	182b      	adds	r3, r5, r0
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 800b330:	f8d8 1000 	ldr.w	r1, [r8]
 800b334:	8da0      	ldrh	r0, [r4, #44]	; 0x2c
 800b336:	6aa2      	ldr	r2, [r4, #40]	; 0x28
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
                    pbuf_realloc(next->next->p, next->next->len);
                    tcplen = TCP_TCPLEN(next->next);
 800b338:	b29b      	uxth	r3, r3
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 800b33a:	4419      	add	r1, r3
 800b33c:	4402      	add	r2, r0
 800b33e:	4291      	cmp	r1, r2
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
                    pbuf_realloc(next->next->p, next->next->len);
                    tcplen = TCP_TCPLEN(next->next);
 800b340:	f8a9 3000 	strh.w	r3, [r9]
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 800b344:	f43f ae43 	beq.w	800afce <tcp_receive+0x4e>
 800b348:	4b97      	ldr	r3, [pc, #604]	; (800b5a8 <tcp_receive+0x628>)
 800b34a:	9300      	str	r3, [sp, #0]
 800b34c:	4997      	ldr	r1, [pc, #604]	; (800b5ac <tcp_receive+0x62c>)
 800b34e:	4a98      	ldr	r2, [pc, #608]	; (800b5b0 <tcp_receive+0x630>)
 800b350:	4898      	ldr	r0, [pc, #608]	; (800b5b4 <tcp_receive+0x634>)
 800b352:	f240 53ca 	movw	r3, #1482	; 0x5ca
 800b356:	f7ff fdfb 	bl	800af50 <chprintf.constprop.1>
 800b35a:	4895      	ldr	r0, [pc, #596]	; (800b5b0 <tcp_receive+0x630>)
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
}
 800b35c:	b005      	add	sp, #20
 800b35e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b362:	f7f5 be05 	b.w	8000f70 <chSysHalt>

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
      pcb->acked = 0;
      /* Clause 2 */
      if (tcplen == 0) {
 800b366:	f8df 925c 	ldr.w	r9, [pc, #604]	; 800b5c4 <tcp_receive+0x644>
 800b36a:	f8b9 2000 	ldrh.w	r2, [r9]
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
      pcb->acked = 0;
 800b36e:	2100      	movs	r1, #0
 800b370:	f8a4 1064 	strh.w	r1, [r4, #100]	; 0x64
      /* Clause 2 */
      if (tcplen == 0) {
 800b374:	b93a      	cbnz	r2, 800b386 <tcp_receive+0x406>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
 800b376:	f8b4 1060 	ldrh.w	r1, [r4, #96]	; 0x60
 800b37a:	6da2      	ldr	r2, [r4, #88]	; 0x58
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 800b37c:	4428      	add	r0, r5
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
      pcb->acked = 0;
      /* Clause 2 */
      if (tcplen == 0) {
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
 800b37e:	440a      	add	r2, r1
 800b380:	4282      	cmp	r2, r0
 800b382:	f000 80ed 	beq.w	800b560 <tcp_receive+0x5e0>
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
        pcb->dupacks = 0;
 800b386:	2300      	movs	r3, #0
 800b388:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
 800b38c:	e643      	b.n	800b016 <tcp_receive+0x96>
        if (pcb->persist_backoff == 0) {
          /* start persist timer */
          pcb->persist_cnt = 0;
          pcb->persist_backoff = 1;
        }
      } else if (pcb->persist_backoff > 0) {
 800b38e:	2a00      	cmp	r2, #0
 800b390:	f43f ae32 	beq.w	800aff8 <tcp_receive+0x78>
        /* stop persist timer */
          pcb->persist_backoff = 0;
 800b394:	2200      	movs	r2, #0
 800b396:	f884 2095 	strb.w	r2, [r4, #149]	; 0x95
 800b39a:	e62d      	b.n	800aff8 <tcp_receive+0x78>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
 800b39c:	4b86      	ldr	r3, [pc, #536]	; (800b5b8 <tcp_receive+0x638>)
 800b39e:	681b      	ldr	r3, [r3, #0]
 800b3a0:	89d9      	ldrh	r1, [r3, #14]
 800b3a2:	428d      	cmp	r5, r1
 800b3a4:	4603      	mov	r3, r0
 800b3a6:	f4bf ae27 	bcs.w	800aff8 <tcp_receive+0x78>
 800b3aa:	e706      	b.n	800b1ba <tcp_receive+0x23a>
      /* We come here when the ACK acknowledges new data. */

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
 800b3ac:	7fa1      	ldrb	r1, [r4, #30]
 800b3ae:	0748      	lsls	r0, r1, #29
 800b3b0:	d506      	bpl.n	800b3c0 <tcp_receive+0x440>
        pcb->flags &= ~TF_INFR;
 800b3b2:	f021 0104 	bic.w	r1, r1, #4
        pcb->cwnd = pcb->ssthresh;
 800b3b6:	f8b4 004e 	ldrh.w	r0, [r4, #78]	; 0x4e

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
        pcb->flags &= ~TF_INFR;
 800b3ba:	77a1      	strb	r1, [r4, #30]
        pcb->cwnd = pcb->ssthresh;
 800b3bc:	f8a4 004c 	strh.w	r0, [r4, #76]	; 0x4c
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);

      pcb->snd_buf += pcb->acked;
 800b3c0:	f8b4 0066 	ldrh.w	r0, [r4, #102]	; 0x66

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 800b3c4:	f8b4 1042 	ldrh.w	r1, [r4, #66]	; 0x42
 800b3c8:	f9b4 7040 	ldrsh.w	r7, [r4, #64]	; 0x40
      pcb->dupacks = 0;
      pcb->lastack = ackno;

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 800b3cc:	7e25      	ldrb	r5, [r4, #24]

      pcb->snd_buf += pcb->acked;

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
      pcb->lastack = ackno;
 800b3ce:	64a3      	str	r3, [r4, #72]	; 0x48

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
 800b3d0:	b292      	uxth	r2, r2

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 800b3d2:	eb01 03e7 	add.w	r3, r1, r7, asr #3

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);

      pcb->snd_buf += pcb->acked;
 800b3d6:	4410      	add	r0, r2
        pcb->flags &= ~TF_INFR;
        pcb->cwnd = pcb->ssthresh;
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
 800b3d8:	2100      	movs	r1, #0
      pcb->dupacks = 0;
      pcb->lastack = ackno;

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 800b3da:	2d03      	cmp	r5, #3

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
 800b3dc:	f8a4 2064 	strh.w	r2, [r4, #100]	; 0x64

      pcb->snd_buf += pcb->acked;
 800b3e0:	f8a4 0066 	strh.w	r0, [r4, #102]	; 0x66

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 800b3e4:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
        pcb->flags &= ~TF_INFR;
        pcb->cwnd = pcb->ssthresh;
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
 800b3e8:	f884 1046 	strb.w	r1, [r4, #70]	; 0x46
      pcb->acked = (u16_t)(ackno - pcb->lastack);

      pcb->snd_buf += pcb->acked;

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
 800b3ec:	f884 1047 	strb.w	r1, [r4, #71]	; 0x47
      pcb->lastack = ackno;

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 800b3f0:	d90f      	bls.n	800b412 <tcp_receive+0x492>
        if (pcb->cwnd < pcb->ssthresh) {
 800b3f2:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
 800b3f6:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
 800b3fa:	4293      	cmp	r3, r2
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 800b3fc:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
            pcb->cwnd += pcb->mss;
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
 800b3fe:	bf9c      	itt	ls
 800b400:	435b      	mulls	r3, r3
 800b402:	fb93 f3f2 	sdivls	r3, r3, r2
 800b406:	4413      	add	r3, r2
 800b408:	b29b      	uxth	r3, r3
          if (new_cwnd > pcb->cwnd) {
 800b40a:	429a      	cmp	r2, r3
            pcb->cwnd = new_cwnd;
 800b40c:	bf38      	it	cc
 800b40e:	f8a4 304c 	strhcc.w	r3, [r4, #76]	; 0x4c
 800b412:	6f23      	ldr	r3, [r4, #112]	; 0x70

        next = pcb->unacked;
        pcb->unacked = pcb->unacked->next;

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 800b414:	4f64      	ldr	r7, [pc, #400]	; (800b5a8 <tcp_receive+0x628>)
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
 800b416:	2b00      	cmp	r3, #0
 800b418:	d037      	beq.n	800b48a <tcp_receive+0x50a>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
 800b41a:	68db      	ldr	r3, [r3, #12]
 800b41c:	6858      	ldr	r0, [r3, #4]
 800b41e:	f003 fcd7 	bl	800edd0 <lwip_ntohl>
 800b422:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800b424:	68da      	ldr	r2, [r3, #12]
 800b426:	f8b3 9008 	ldrh.w	r9, [r3, #8]
 800b42a:	4605      	mov	r5, r0
 800b42c:	8990      	ldrh	r0, [r2, #12]
 800b42e:	f003 fcbf 	bl	800edb0 <lwip_ntohs>
 800b432:	6833      	ldr	r3, [r6, #0]
 800b434:	f010 0003 	ands.w	r0, r0, #3
 800b438:	bf18      	it	ne
 800b43a:	2001      	movne	r0, #1
 800b43c:	4448      	add	r0, r9
 800b43e:	1aeb      	subs	r3, r5, r3
 800b440:	4418      	add	r0, r3
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
 800b442:	2800      	cmp	r0, #0
 800b444:	f300 80c0 	bgt.w	800b5c8 <tcp_receive+0x648>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
 800b448:	6f25      	ldr	r5, [r4, #112]	; 0x70
        pcb->unacked = pcb->unacked->next;

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 800b44a:	f8b4 9068 	ldrh.w	r9, [r4, #104]	; 0x68
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
        pcb->unacked = pcb->unacked->next;
 800b44e:	682b      	ldr	r3, [r5, #0]
 800b450:	6723      	str	r3, [r4, #112]	; 0x70

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 800b452:	6868      	ldr	r0, [r5, #4]
 800b454:	f7fe fa04 	bl	8009860 <pbuf_clen>
 800b458:	b280      	uxth	r0, r0
 800b45a:	4581      	cmp	r9, r0
 800b45c:	d336      	bcc.n	800b4cc <tcp_receive+0x54c>
        /* Prevent ACK for FIN to generate a sent event */
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 800b45e:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 800b462:	bb3b      	cbnz	r3, 800b4b4 <tcp_receive+0x534>
          pcb->acked--;
        }

        pcb->snd_queuelen -= pbuf_clen(next->p);
 800b464:	6868      	ldr	r0, [r5, #4]
 800b466:	f7fe f9fb 	bl	8009860 <pbuf_clen>
 800b46a:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 800b46e:	1a18      	subs	r0, r3, r0
 800b470:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
        tcp_seg_free(next);
 800b474:	4628      	mov	r0, r5
 800b476:	f7fe fdd3 	bl	800a020 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
 800b47a:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 800b47e:	b1bb      	cbz	r3, 800b4b0 <tcp_receive+0x530>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
 800b480:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800b482:	2b00      	cmp	r3, #0
 800b484:	d1c7      	bne.n	800b416 <tcp_receive+0x496>
 800b486:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800b488:	b13b      	cbz	r3, 800b49a <tcp_receive+0x51a>
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
        pcb->rtime = -1;
 800b48a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b48e:	86a3      	strh	r3, [r4, #52]	; 0x34
      else
        pcb->rtime = 0;

      pcb->polltmr = 0;
 800b490:	2300      	movs	r3, #0
 800b492:	77e3      	strb	r3, [r4, #31]
 800b494:	f8df 912c 	ldr.w	r9, [pc, #300]	; 800b5c4 <tcp_receive+0x644>
 800b498:	e5bd      	b.n	800b016 <tcp_receive+0x96>
        pcb->snd_queuelen -= pbuf_clen(next->p);
        tcp_seg_free(next);

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
 800b49a:	9700      	str	r7, [sp, #0]
 800b49c:	4845      	ldr	r0, [pc, #276]	; (800b5b4 <tcp_receive+0x634>)
 800b49e:	4943      	ldr	r1, [pc, #268]	; (800b5ac <tcp_receive+0x62c>)
 800b4a0:	4a46      	ldr	r2, [pc, #280]	; (800b5bc <tcp_receive+0x63c>)
 800b4a2:	f44f 6381 	mov.w	r3, #1032	; 0x408
 800b4a6:	f7ff fd53 	bl	800af50 <chprintf.constprop.1>
 800b4aa:	4844      	ldr	r0, [pc, #272]	; (800b5bc <tcp_receive+0x63c>)
 800b4ac:	f7f5 fd60 	bl	8000f70 <chSysHalt>
 800b4b0:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800b4b2:	e7b0      	b.n	800b416 <tcp_receive+0x496>
        pcb->unacked = pcb->unacked->next;

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
        /* Prevent ACK for FIN to generate a sent event */
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 800b4b4:	68eb      	ldr	r3, [r5, #12]
 800b4b6:	8998      	ldrh	r0, [r3, #12]
 800b4b8:	f003 fc7a 	bl	800edb0 <lwip_ntohs>
 800b4bc:	07c2      	lsls	r2, r0, #31
 800b4be:	d5d1      	bpl.n	800b464 <tcp_receive+0x4e4>
          pcb->acked--;
 800b4c0:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 800b4c4:	3b01      	subs	r3, #1
 800b4c6:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 800b4ca:	e7cb      	b.n	800b464 <tcp_receive+0x4e4>

        next = pcb->unacked;
        pcb->unacked = pcb->unacked->next;

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 800b4cc:	9700      	str	r7, [sp, #0]
 800b4ce:	4937      	ldr	r1, [pc, #220]	; (800b5ac <tcp_receive+0x62c>)
 800b4d0:	4a3b      	ldr	r2, [pc, #236]	; (800b5c0 <tcp_receive+0x640>)
 800b4d2:	4838      	ldr	r0, [pc, #224]	; (800b5b4 <tcp_receive+0x634>)
 800b4d4:	f44f 737f 	mov.w	r3, #1020	; 0x3fc
 800b4d8:	f7ff fd3a 	bl	800af50 <chprintf.constprop.1>
 800b4dc:	4838      	ldr	r0, [pc, #224]	; (800b5c0 <tcp_receive+0x640>)
 800b4de:	f7f5 fd47 	bl	8000f70 <chSysHalt>
 800b4e2:	e7bc      	b.n	800b45e <tcp_receive+0x4de>
         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
 800b4e4:	4f2e      	ldr	r7, [pc, #184]	; (800b5a0 <tcp_receive+0x620>)
 800b4e6:	687d      	ldr	r5, [r7, #4]

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
 800b4e8:	46b2      	mov	sl, r6
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
 800b4ea:	2d00      	cmp	r5, #0
 800b4ec:	f000 825c 	beq.w	800b9a8 <tcp_receive+0xa28>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
 800b4f0:	f647 73fe 	movw	r3, #32766	; 0x7ffe
 800b4f4:	429e      	cmp	r6, r3
 800b4f6:	f300 81a3 	bgt.w	800b840 <tcp_receive+0x8c0>
      if (inseg.p->len < off) {
 800b4fa:	6878      	ldr	r0, [r7, #4]
 800b4fc:	f8df b0a0 	ldr.w	fp, [pc, #160]	; 800b5a0 <tcp_receive+0x620>
 800b500:	8943      	ldrh	r3, [r0, #10]
 800b502:	429e      	cmp	r6, r3
 800b504:	f340 8188 	ble.w	800b818 <tcp_receive+0x898>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
 800b508:	8902      	ldrh	r2, [r0, #8]
 800b50a:	4296      	cmp	r6, r2
 800b50c:	f300 81d6 	bgt.w	800b8bc <tcp_receive+0x93c>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
 800b510:	896b      	ldrh	r3, [r5, #10]
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
 800b512:	1b92      	subs	r2, r2, r6
        while (p->len < off) {
 800b514:	429e      	cmp	r6, r3
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
 800b516:	b292      	uxth	r2, r2
        while (p->len < off) {
 800b518:	dd08      	ble.n	800b52c <tcp_receive+0x5ac>
          off -= p->len;
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
 800b51a:	2100      	movs	r1, #0
 800b51c:	8169      	strh	r1, [r5, #10]
        while (p->len < off) {
          off -= p->len;
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
 800b51e:	812a      	strh	r2, [r5, #8]
          p->len = 0;
          p = p->next;
 800b520:	682d      	ldr	r5, [r5, #0]
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
          off -= p->len;
 800b522:	ebc3 0a0a 	rsb	sl, r3, sl
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
 800b526:	896b      	ldrh	r3, [r5, #10]
 800b528:	4553      	cmp	r3, sl
 800b52a:	dbf7      	blt.n	800b51c <tcp_receive+0x59c>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
 800b52c:	f1ca 0100 	rsb	r1, sl, #0
 800b530:	b209      	sxth	r1, r1
 800b532:	4628      	mov	r0, r5
 800b534:	f7fd fef4 	bl	8009320 <pbuf_header>
 800b538:	2800      	cmp	r0, #0
 800b53a:	f040 81cf 	bne.w	800b8dc <tcp_receive+0x95c>
        if(pbuf_header(inseg.p, (s16_t)-off)) {
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 800b53e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800b540:	f8d8 0000 	ldr.w	r0, [r8]
 800b544:	893b      	ldrh	r3, [r7, #8]
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 800b546:	68fd      	ldr	r5, [r7, #12]
 800b548:	f8c8 2000 	str.w	r2, [r8]
 800b54c:	4403      	add	r3, r0
 800b54e:	1a90      	subs	r0, r2, r2
        if(pbuf_header(inseg.p, (s16_t)-off)) {
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 800b550:	1a9b      	subs	r3, r3, r2
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 800b552:	2800      	cmp	r0, #0
        if(pbuf_header(inseg.p, (s16_t)-off)) {
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 800b554:	813b      	strh	r3, [r7, #8]
 800b556:	4611      	mov	r1, r2
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 800b558:	606a      	str	r2, [r5, #4]
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 800b55a:	f6bf addf 	bge.w	800b11c <tcp_receive+0x19c>
 800b55e:	e5e4      	b.n	800b12a <tcp_receive+0x1aa>
      /* Clause 2 */
      if (tcplen == 0) {
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
          /* Clause 4 */
          if (pcb->rtime >= 0) {
 800b560:	f9b4 2034 	ldrsh.w	r2, [r4, #52]	; 0x34
 800b564:	2a00      	cmp	r2, #0
 800b566:	f6ff af0e 	blt.w	800b386 <tcp_receive+0x406>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
 800b56a:	429f      	cmp	r7, r3
 800b56c:	f47f af0b 	bne.w	800b386 <tcp_receive+0x406>
              found_dupack = 1;
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 800b570:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
 800b574:	1c53      	adds	r3, r2, #1
 800b576:	b2db      	uxtb	r3, r3
 800b578:	429a      	cmp	r2, r3
                ++pcb->dupacks;
 800b57a:	bf3c      	itt	cc
 800b57c:	461a      	movcc	r2, r3
 800b57e:	f884 3047 	strbcc.w	r3, [r4, #71]	; 0x47
              }
              if (pcb->dupacks > 3) {
 800b582:	2a03      	cmp	r2, #3
 800b584:	f240 826e 	bls.w	800ba64 <tcp_receive+0xae4>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 800b588:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
 800b58c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800b58e:	4413      	add	r3, r2
 800b590:	b29b      	uxth	r3, r3
 800b592:	429a      	cmp	r2, r3
 800b594:	f4bf ad3f 	bcs.w	800b016 <tcp_receive+0x96>
                  pcb->cwnd += pcb->mss;
 800b598:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
 800b59c:	e53b      	b.n	800b016 <tcp_receive+0x96>
 800b59e:	bf00      	nop
 800b5a0:	2000cb8c 	.word	0x2000cb8c
 800b5a4:	2000cb70 	.word	0x2000cb70
 800b5a8:	08017d5c 	.word	0x08017d5c
 800b5ac:	08016fe0 	.word	0x08016fe0
 800b5b0:	08017e18 	.word	0x08017e18
 800b5b4:	200180c8 	.word	0x200180c8
 800b5b8:	2000cb84 	.word	0x2000cb84
 800b5bc:	08017db4 	.word	0x08017db4
 800b5c0:	08017d8c 	.word	0x08017d8c
 800b5c4:	2000cb78 	.word	0x2000cb78
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
 800b5c8:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800b5ca:	2b00      	cmp	r3, #0
 800b5cc:	f43f af5d 	beq.w	800b48a <tcp_receive+0x50a>
        pcb->rtime = -1;
      else
        pcb->rtime = 0;
 800b5d0:	2300      	movs	r3, #0
 800b5d2:	86a3      	strh	r3, [r4, #52]	; 0x34
 800b5d4:	e75c      	b.n	800b490 <tcp_receive+0x510>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 800b5d6:	4fb0      	ldr	r7, [pc, #704]	; (800b898 <tcp_receive+0x918>)
 800b5d8:	68fb      	ldr	r3, [r7, #12]
 800b5da:	893d      	ldrh	r5, [r7, #8]
 800b5dc:	8998      	ldrh	r0, [r3, #12]
 800b5de:	f003 fbe7 	bl	800edb0 <lwip_ntohs>
 800b5e2:	f010 0003 	ands.w	r0, r0, #3
 800b5e6:	bf18      	it	ne
 800b5e8:	2001      	movne	r0, #1
 800b5ea:	182b      	adds	r3, r5, r0

        if (tcplen > pcb->rcv_wnd) {
 800b5ec:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 800b5ee:	b29b      	uxth	r3, r3

        if (tcplen > pcb->rcv_wnd) {
 800b5f0:	429a      	cmp	r2, r3
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 800b5f2:	f8a9 3000 	strh.w	r3, [r9]

        if (tcplen > pcb->rcv_wnd) {
 800b5f6:	f0c0 817e 	bcc.w	800b8f6 <tcp_receive+0x976>
        }
#if TCP_QUEUE_OOSEQ
        /* Received in-sequence data, adjust ooseq data if:
           - FIN has been received or
           - inseq overlaps with ooseq */
        if (pcb->ooseq != NULL) {
 800b5fa:	6f63      	ldr	r3, [r4, #116]	; 0x74
 800b5fc:	2b00      	cmp	r3, #0
 800b5fe:	d063      	beq.n	800b6c8 <tcp_receive+0x748>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800b600:	68fb      	ldr	r3, [r7, #12]
 800b602:	8998      	ldrh	r0, [r3, #12]
 800b604:	f003 fbd4 	bl	800edb0 <lwip_ntohs>
 800b608:	07c0      	lsls	r0, r0, #31
 800b60a:	d45a      	bmi.n	800b6c2 <tcp_receive+0x742>
              struct tcp_seg *old_ooseq = pcb->ooseq;
              pcb->ooseq = pcb->ooseq->next;
              tcp_seg_free(old_ooseq);
            }
          } else {
            next = pcb->ooseq;
 800b60c:	f8d4 a074 	ldr.w	sl, [r4, #116]	; 0x74
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 800b610:	f1ba 0f00 	cmp.w	sl, #0
 800b614:	f000 81bb 	beq.w	800b98e <tcp_receive+0xa0e>
                   TCP_SEQ_GEQ(seqno + tcplen,
 800b618:	f8da e00c 	ldr.w	lr, [sl, #12]
 800b61c:	f8b9 2000 	ldrh.w	r2, [r9]
 800b620:	f8de c004 	ldr.w	ip, [lr, #4]
 800b624:	f8d8 0000 	ldr.w	r0, [r8]
 800b628:	f8ba 1008 	ldrh.w	r1, [sl, #8]
 800b62c:	ebcc 0302 	rsb	r3, ip, r2
 800b630:	4403      	add	r3, r0
 800b632:	1a59      	subs	r1, r3, r1
            }
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 800b634:	2900      	cmp	r1, #0
 800b636:	f2c0 81b2 	blt.w	800b99e <tcp_receive+0xa1e>
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 800b63a:	4e97      	ldr	r6, [pc, #604]	; (800b898 <tcp_receive+0x918>)
 800b63c:	e018      	b.n	800b670 <tcp_receive+0x6f0>
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
                tcplen = TCP_TCPLEN(&inseg);
              }
              prev = next;
              next = next->next;
 800b63e:	f8da 5000 	ldr.w	r5, [sl]
              tcp_seg_free(prev);
 800b642:	4650      	mov	r0, sl
 800b644:	f7fe fcec 	bl	800a020 <tcp_seg_free>
            }
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 800b648:	2d00      	cmp	r5, #0
 800b64a:	f000 81a0 	beq.w	800b98e <tcp_receive+0xa0e>
                   TCP_SEQ_GEQ(seqno + tcplen,
 800b64e:	f8d5 e00c 	ldr.w	lr, [r5, #12]
 800b652:	f8b9 2000 	ldrh.w	r2, [r9]
 800b656:	f8de c004 	ldr.w	ip, [lr, #4]
 800b65a:	f8d8 0000 	ldr.w	r0, [r8]
 800b65e:	8929      	ldrh	r1, [r5, #8]
 800b660:	ebcc 0302 	rsb	r3, ip, r2
 800b664:	4403      	add	r3, r0
 800b666:	1a59      	subs	r1, r3, r1
            }
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 800b668:	2900      	cmp	r1, #0
 800b66a:	f2c0 8199 	blt.w	800b9a0 <tcp_receive+0xa20>
 800b66e:	46aa      	mov	sl, r5
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
 800b670:	f8be 000c 	ldrh.w	r0, [lr, #12]
 800b674:	f003 fb9c 	bl	800edb0 <lwip_ntohs>
 800b678:	07c1      	lsls	r1, r0, #31
 800b67a:	d5e0      	bpl.n	800b63e <tcp_receive+0x6be>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 800b67c:	68fb      	ldr	r3, [r7, #12]
 800b67e:	8998      	ldrh	r0, [r3, #12]
 800b680:	f003 fb96 	bl	800edb0 <lwip_ntohs>
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
 800b684:	0782      	lsls	r2, r0, #30
 800b686:	d4da      	bmi.n	800b63e <tcp_receive+0x6be>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
 800b688:	f8d6 b00c 	ldr.w	fp, [r6, #12]
 800b68c:	2001      	movs	r0, #1
 800b68e:	f8bb 500c 	ldrh.w	r5, [fp, #12]
 800b692:	f003 fb85 	bl	800eda0 <lwip_htons>
                tcplen = TCP_TCPLEN(&inseg);
 800b696:	68f2      	ldr	r2, [r6, #12]
 800b698:	8933      	ldrh	r3, [r6, #8]
 800b69a:	9303      	str	r3, [sp, #12]
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
 800b69c:	4328      	orrs	r0, r5
 800b69e:	f8ab 000c 	strh.w	r0, [fp, #12]
                tcplen = TCP_TCPLEN(&inseg);
 800b6a2:	8990      	ldrh	r0, [r2, #12]
 800b6a4:	f003 fb84 	bl	800edb0 <lwip_ntohs>
 800b6a8:	9b03      	ldr	r3, [sp, #12]
 800b6aa:	f010 0003 	ands.w	r0, r0, #3
 800b6ae:	bf18      	it	ne
 800b6b0:	2001      	movne	r0, #1
 800b6b2:	4418      	add	r0, r3
 800b6b4:	f8a9 0000 	strh.w	r0, [r9]
 800b6b8:	e7c1      	b.n	800b63e <tcp_receive+0x6be>
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
              pcb->ooseq = pcb->ooseq->next;
 800b6ba:	6803      	ldr	r3, [r0, #0]
 800b6bc:	6763      	str	r3, [r4, #116]	; 0x74
              tcp_seg_free(old_ooseq);
 800b6be:	f7fe fcaf 	bl	800a020 <tcp_seg_free>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
 800b6c2:	6f60      	ldr	r0, [r4, #116]	; 0x74
 800b6c4:	2800      	cmp	r0, #0
 800b6c6:	d1f8      	bne.n	800b6ba <tcp_receive+0x73a>
 800b6c8:	f8b9 2000 	ldrh.w	r2, [r9]
 800b6cc:	f8d8 3000 	ldr.w	r3, [r8]
 800b6d0:	4413      	add	r3, r2
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
 800b6d2:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
            pcb->ooseq = next;
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
 800b6d4:	62a3      	str	r3, [r4, #40]	; 0x28

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
 800b6d6:	4291      	cmp	r1, r2
 800b6d8:	f0c0 8149 	bcc.w	800b96e <tcp_receive+0x9ee>
        pcb->rcv_wnd -= tcplen;
 800b6dc:	1a8a      	subs	r2, r1, r2
 800b6de:	85a2      	strh	r2, [r4, #44]	; 0x2c

        tcp_update_rcv_ann_wnd(pcb);
 800b6e0:	4620      	mov	r0, r4
 800b6e2:	f7fe fc0d 	bl	8009f00 <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
 800b6e6:	687b      	ldr	r3, [r7, #4]
 800b6e8:	496b      	ldr	r1, [pc, #428]	; (800b898 <tcp_receive+0x918>)
 800b6ea:	891a      	ldrh	r2, [r3, #8]
 800b6ec:	b11a      	cbz	r2, 800b6f6 <tcp_receive+0x776>
          recv_data = inseg.p;
 800b6ee:	486b      	ldr	r0, [pc, #428]	; (800b89c <tcp_receive+0x91c>)
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 800b6f0:	2200      	movs	r2, #0

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
          recv_data = inseg.p;
 800b6f2:	6003      	str	r3, [r0, #0]
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 800b6f4:	604a      	str	r2, [r1, #4]
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800b6f6:	68fb      	ldr	r3, [r7, #12]
 800b6f8:	8998      	ldrh	r0, [r3, #12]
 800b6fa:	f003 fb59 	bl	800edb0 <lwip_ntohs>
 800b6fe:	07c5      	lsls	r5, r0, #31
 800b700:	d504      	bpl.n	800b70c <tcp_receive+0x78c>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
 800b702:	4a67      	ldr	r2, [pc, #412]	; (800b8a0 <tcp_receive+0x920>)
 800b704:	7813      	ldrb	r3, [r2, #0]
 800b706:	f043 0320 	orr.w	r3, r3, #32
 800b70a:	7013      	strb	r3, [r2, #0]
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
 800b70c:	6f65      	ldr	r5, [r4, #116]	; 0x74
 800b70e:	2d00      	cmp	r5, #0
 800b710:	d068      	beq.n	800b7e4 <tcp_receive+0x864>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 800b712:	68ea      	ldr	r2, [r5, #12]
 800b714:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800b716:	6851      	ldr	r1, [r2, #4]
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
 800b718:	4299      	cmp	r1, r3
 800b71a:	d163      	bne.n	800b7e4 <tcp_receive+0x864>

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
 800b71c:	4e61      	ldr	r6, [pc, #388]	; (800b8a4 <tcp_receive+0x924>)
 800b71e:	e036      	b.n	800b78e <tcp_receive+0x80e>
                      pcb->rcv_wnd >= TCP_TCPLEN(cseg));
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
 800b720:	68eb      	ldr	r3, [r5, #12]
 800b722:	892f      	ldrh	r7, [r5, #8]
 800b724:	8998      	ldrh	r0, [r3, #12]
 800b726:	f003 fb43 	bl	800edb0 <lwip_ntohs>
 800b72a:	f010 0003 	ands.w	r0, r0, #3
 800b72e:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 800b730:	bf18      	it	ne
 800b732:	2001      	movne	r0, #1
 800b734:	4438      	add	r0, r7
 800b736:	1a18      	subs	r0, r3, r0
 800b738:	85a0      	strh	r0, [r4, #44]	; 0x2c

          tcp_update_rcv_ann_wnd(pcb);
 800b73a:	4620      	mov	r0, r4
 800b73c:	f7fe fbe0 	bl	8009f00 <tcp_update_rcv_ann_wnd>

          if (cseg->p->tot_len > 0) {
 800b740:	6869      	ldr	r1, [r5, #4]
 800b742:	890b      	ldrh	r3, [r1, #8]
 800b744:	b13b      	cbz	r3, 800b756 <tcp_receive+0x7d6>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
 800b746:	4b55      	ldr	r3, [pc, #340]	; (800b89c <tcp_receive+0x91c>)
 800b748:	6818      	ldr	r0, [r3, #0]
 800b74a:	2800      	cmp	r0, #0
 800b74c:	d048      	beq.n	800b7e0 <tcp_receive+0x860>
              pbuf_cat(recv_data, cseg->p);
 800b74e:	f7fe f89f 	bl	8009890 <pbuf_cat>
            } else {
              recv_data = cseg->p;
            }
            cseg->p = NULL;
 800b752:	2300      	movs	r3, #0
 800b754:	606b      	str	r3, [r5, #4]
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 800b756:	68eb      	ldr	r3, [r5, #12]
 800b758:	8998      	ldrh	r0, [r3, #12]
 800b75a:	f003 fb29 	bl	800edb0 <lwip_ntohs>
 800b75e:	07c1      	lsls	r1, r0, #31
 800b760:	d509      	bpl.n	800b776 <tcp_receive+0x7f6>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
 800b762:	4a4f      	ldr	r2, [pc, #316]	; (800b8a0 <tcp_receive+0x920>)
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
 800b764:	7e21      	ldrb	r1, [r4, #24]
            }
            cseg->p = NULL;
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
 800b766:	7813      	ldrb	r3, [r2, #0]
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
 800b768:	2904      	cmp	r1, #4
            }
            cseg->p = NULL;
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
 800b76a:	f043 0320 	orr.w	r3, r3, #32
 800b76e:	7013      	strb	r3, [r2, #0]
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
              pcb->state = CLOSE_WAIT;
 800b770:	bf04      	itt	eq
 800b772:	2307      	moveq	r3, #7
 800b774:	7623      	strbeq	r3, [r4, #24]
            } 
          }

          pcb->ooseq = cseg->next;
 800b776:	682b      	ldr	r3, [r5, #0]
 800b778:	6763      	str	r3, [r4, #116]	; 0x74
          tcp_seg_free(cseg);
 800b77a:	4628      	mov	r0, r5
 800b77c:	f7fe fc50 	bl	800a020 <tcp_seg_free>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
 800b780:	6f65      	ldr	r5, [r4, #116]	; 0x74
 800b782:	b37d      	cbz	r5, 800b7e4 <tcp_receive+0x864>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 800b784:	68ea      	ldr	r2, [r5, #12]
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
 800b786:	6aa1      	ldr	r1, [r4, #40]	; 0x28
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 800b788:	6853      	ldr	r3, [r2, #4]
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
 800b78a:	428b      	cmp	r3, r1
 800b78c:	d12a      	bne.n	800b7e4 <tcp_receive+0x864>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
 800b78e:	f8c8 3000 	str.w	r3, [r8]

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 800b792:	8990      	ldrh	r0, [r2, #12]
 800b794:	f8b5 a008 	ldrh.w	sl, [r5, #8]
 800b798:	f003 fb0a 	bl	800edb0 <lwip_ntohs>
 800b79c:	f010 0003 	ands.w	r0, r0, #3
 800b7a0:	bf18      	it	ne
 800b7a2:	2001      	movne	r0, #1
 800b7a4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
 800b7a6:	68ea      	ldr	r2, [r5, #12]
 800b7a8:	f8b5 9008 	ldrh.w	r9, [r5, #8]
 800b7ac:	8da7      	ldrh	r7, [r4, #44]	; 0x2c
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 800b7ae:	4450      	add	r0, sl
 800b7b0:	4418      	add	r0, r3
 800b7b2:	62a0      	str	r0, [r4, #40]	; 0x28
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
 800b7b4:	8990      	ldrh	r0, [r2, #12]
 800b7b6:	f003 fafb 	bl	800edb0 <lwip_ntohs>
 800b7ba:	f010 0003 	ands.w	r0, r0, #3
 800b7be:	bf18      	it	ne
 800b7c0:	2001      	movne	r0, #1
 800b7c2:	4448      	add	r0, r9
 800b7c4:	4287      	cmp	r7, r0
 800b7c6:	daab      	bge.n	800b720 <tcp_receive+0x7a0>
 800b7c8:	9600      	str	r6, [sp, #0]
 800b7ca:	4937      	ldr	r1, [pc, #220]	; (800b8a8 <tcp_receive+0x928>)
 800b7cc:	4a37      	ldr	r2, [pc, #220]	; (800b8ac <tcp_receive+0x92c>)
 800b7ce:	4838      	ldr	r0, [pc, #224]	; (800b8b0 <tcp_receive+0x930>)
 800b7d0:	f240 5337 	movw	r3, #1335	; 0x537
 800b7d4:	f7ff fbbc 	bl	800af50 <chprintf.constprop.1>
 800b7d8:	4834      	ldr	r0, [pc, #208]	; (800b8ac <tcp_receive+0x92c>)
 800b7da:	f7f5 fbc9 	bl	8000f70 <chSysHalt>
 800b7de:	e79f      	b.n	800b720 <tcp_receive+0x7a0>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
              pbuf_cat(recv_data, cseg->p);
            } else {
              recv_data = cseg->p;
 800b7e0:	6019      	str	r1, [r3, #0]
 800b7e2:	e7b6      	b.n	800b752 <tcp_receive+0x7d2>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 800b7e4:	7fa3      	ldrb	r3, [r4, #30]
 800b7e6:	07d8      	lsls	r0, r3, #31
 800b7e8:	d550      	bpl.n	800b88c <tcp_receive+0x90c>
 800b7ea:	f023 0301 	bic.w	r3, r3, #1
 800b7ee:	f043 0302 	orr.w	r3, r3, #2
 800b7f2:	77a3      	strb	r3, [r4, #30]
 800b7f4:	f7ff bbeb 	b.w	800afce <tcp_receive+0x4e>
            if (seqno == next->tcphdr->seqno) {
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
 800b7f8:	4827      	ldr	r0, [pc, #156]	; (800b898 <tcp_receive+0x918>)
 800b7fa:	892b      	ldrh	r3, [r5, #8]
 800b7fc:	8902      	ldrh	r2, [r0, #8]
 800b7fe:	429a      	cmp	r2, r3
 800b800:	f67f abe5 	bls.w	800afce <tcp_receive+0x4e>
                /* The incoming segment is larger than the old
                   segment. We replace some segments with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
 800b804:	f7fe fc2c 	bl	800a060 <tcp_seg_copy>
                if (cseg != NULL) {
 800b808:	2800      	cmp	r0, #0
 800b80a:	f43f abe0 	beq.w	800afce <tcp_receive+0x4e>
                  if (prev != NULL) {
 800b80e:	2e00      	cmp	r6, #0
 800b810:	f000 812f 	beq.w	800ba72 <tcp_receive+0xaf2>
                    prev->next = cseg;
 800b814:	6030      	str	r0, [r6, #0]
 800b816:	e51b      	b.n	800b250 <tcp_receive+0x2d0>
        if(pbuf_header(p, (s16_t)-off)) {
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
 800b818:	4271      	negs	r1, r6
 800b81a:	b209      	sxth	r1, r1
 800b81c:	f7fd fd80 	bl	8009320 <pbuf_header>
 800b820:	2800      	cmp	r0, #0
 800b822:	f43f ae8c 	beq.w	800b53e <tcp_receive+0x5be>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
 800b826:	4b1f      	ldr	r3, [pc, #124]	; (800b8a4 <tcp_receive+0x924>)
 800b828:	9300      	str	r3, [sp, #0]
 800b82a:	491f      	ldr	r1, [pc, #124]	; (800b8a8 <tcp_receive+0x928>)
 800b82c:	4a21      	ldr	r2, [pc, #132]	; (800b8b4 <tcp_receive+0x934>)
 800b82e:	4820      	ldr	r0, [pc, #128]	; (800b8b0 <tcp_receive+0x930>)
 800b830:	f240 43ab 	movw	r3, #1195	; 0x4ab
 800b834:	f7ff fb8c 	bl	800af50 <chprintf.constprop.1>
 800b838:	481e      	ldr	r0, [pc, #120]	; (800b8b4 <tcp_receive+0x934>)
 800b83a:	f7f5 fb99 	bl	8000f70 <chSysHalt>
 800b83e:	e67e      	b.n	800b53e <tcp_receive+0x5be>
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
 800b840:	4b18      	ldr	r3, [pc, #96]	; (800b8a4 <tcp_receive+0x924>)
 800b842:	9300      	str	r3, [sp, #0]
 800b844:	4918      	ldr	r1, [pc, #96]	; (800b8a8 <tcp_receive+0x928>)
 800b846:	4a1c      	ldr	r2, [pc, #112]	; (800b8b8 <tcp_receive+0x938>)
 800b848:	4819      	ldr	r0, [pc, #100]	; (800b8b0 <tcp_receive+0x930>)
 800b84a:	f240 4397 	movw	r3, #1175	; 0x497
 800b84e:	f7ff fb7f 	bl	800af50 <chprintf.constprop.1>
 800b852:	4819      	ldr	r0, [pc, #100]	; (800b8b8 <tcp_receive+0x938>)
 800b854:	f7f5 fb8c 	bl	8000f70 <chSysHalt>
 800b858:	e64f      	b.n	800b4fa <tcp_receive+0x57a>
                  /* The sequence number of the incoming segment is in
                     between the sequence numbers of the previous and
                     the next segment on ->ooseq. We trim trim the previous
                     segment, delete next segments that included in received segment
                     and trim received, if needed. */
                  cseg = tcp_seg_copy(&inseg);
 800b85a:	480f      	ldr	r0, [pc, #60]	; (800b898 <tcp_receive+0x918>)
 800b85c:	f7fe fc00 	bl	800a060 <tcp_seg_copy>
                  if (cseg != NULL) {
 800b860:	4604      	mov	r4, r0
 800b862:	2800      	cmp	r0, #0
 800b864:	f43f abb3 	beq.w	800afce <tcp_receive+0x4e>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
 800b868:	68f1      	ldr	r1, [r6, #12]
 800b86a:	f8d8 3000 	ldr.w	r3, [r8]
 800b86e:	8932      	ldrh	r2, [r6, #8]
 800b870:	6849      	ldr	r1, [r1, #4]
 800b872:	1ad2      	subs	r2, r2, r3
 800b874:	440a      	add	r2, r1
 800b876:	2a00      	cmp	r2, #0
 800b878:	dd05      	ble.n	800b886 <tcp_receive+0x906>
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
 800b87a:	1a5b      	subs	r3, r3, r1
 800b87c:	b299      	uxth	r1, r3
 800b87e:	8131      	strh	r1, [r6, #8]
                      pbuf_realloc(prev->p, prev->len);
 800b880:	6870      	ldr	r0, [r6, #4]
 800b882:	f7fd ff5d 	bl	8009740 <pbuf_realloc>
                    }
                    prev->next = cseg;
 800b886:	6034      	str	r4, [r6, #0]
                    tcp_oos_insert_segment(cseg, next);
 800b888:	4620      	mov	r0, r4
 800b88a:	e4e1      	b.n	800b250 <tcp_receive+0x2d0>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 800b88c:	f043 0301 	orr.w	r3, r3, #1
 800b890:	77a3      	strb	r3, [r4, #30]
 800b892:	f7ff bb9c 	b.w	800afce <tcp_receive+0x4e>
 800b896:	bf00      	nop
 800b898:	2000cb8c 	.word	0x2000cb8c
 800b89c:	2000cb88 	.word	0x2000cb88
 800b8a0:	2000cb81 	.word	0x2000cb81
 800b8a4:	08017d5c 	.word	0x08017d5c
 800b8a8:	08016fe0 	.word	0x08016fe0
 800b8ac:	08017eac 	.word	0x08017eac
 800b8b0:	200180c8 	.word	0x200180c8
 800b8b4:	08017e04 	.word	0x08017e04
 800b8b8:	08017de4 	.word	0x08017de4
      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
 800b8bc:	4b76      	ldr	r3, [pc, #472]	; (800ba98 <tcp_receive+0xb18>)
 800b8be:	4a77      	ldr	r2, [pc, #476]	; (800ba9c <tcp_receive+0xb1c>)
 800b8c0:	9300      	str	r3, [sp, #0]
 800b8c2:	4977      	ldr	r1, [pc, #476]	; (800baa0 <tcp_receive+0xb20>)
 800b8c4:	4877      	ldr	r0, [pc, #476]	; (800baa4 <tcp_receive+0xb24>)
 800b8c6:	f240 4399 	movw	r3, #1177	; 0x499
 800b8ca:	f7ff fb41 	bl	800af50 <chprintf.constprop.1>
 800b8ce:	4873      	ldr	r0, [pc, #460]	; (800ba9c <tcp_receive+0xb1c>)
 800b8d0:	f7f5 fb4e 	bl	8000f70 <chSysHalt>
 800b8d4:	f8db 3004 	ldr.w	r3, [fp, #4]
 800b8d8:	891a      	ldrh	r2, [r3, #8]
 800b8da:	e619      	b.n	800b510 <tcp_receive+0x590>
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
 800b8dc:	4b6e      	ldr	r3, [pc, #440]	; (800ba98 <tcp_receive+0xb18>)
 800b8de:	9300      	str	r3, [sp, #0]
 800b8e0:	496f      	ldr	r1, [pc, #444]	; (800baa0 <tcp_receive+0xb20>)
 800b8e2:	4a71      	ldr	r2, [pc, #452]	; (800baa8 <tcp_receive+0xb28>)
 800b8e4:	486f      	ldr	r0, [pc, #444]	; (800baa4 <tcp_receive+0xb24>)
 800b8e6:	f240 43a6 	movw	r3, #1190	; 0x4a6
 800b8ea:	f7ff fb31 	bl	800af50 <chprintf.constprop.1>
 800b8ee:	486e      	ldr	r0, [pc, #440]	; (800baa8 <tcp_receive+0xb28>)
 800b8f0:	f7f5 fb3e 	bl	8000f70 <chSysHalt>
 800b8f4:	e623      	b.n	800b53e <tcp_receive+0x5be>
        if (tcplen > pcb->rcv_wnd) {
          LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800b8f6:	68fb      	ldr	r3, [r7, #12]
 800b8f8:	8998      	ldrh	r0, [r3, #12]
 800b8fa:	f003 fa59 	bl	800edb0 <lwip_ntohs>
 800b8fe:	07c3      	lsls	r3, r0, #31
 800b900:	f100 80a2 	bmi.w	800ba48 <tcp_receive+0xac8>
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
 800b904:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800b906:	68fb      	ldr	r3, [r7, #12]
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
 800b908:	813a      	strh	r2, [r7, #8]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800b90a:	8998      	ldrh	r0, [r3, #12]
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
 800b90c:	4d67      	ldr	r5, [pc, #412]	; (800baac <tcp_receive+0xb2c>)
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800b90e:	f003 fa4f 	bl	800edb0 <lwip_ntohs>
            inseg.len -= 1;
 800b912:	8929      	ldrh	r1, [r5, #8]
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800b914:	0786      	lsls	r6, r0, #30
            inseg.len -= 1;
 800b916:	bf44      	itt	mi
 800b918:	f101 31ff 	addmi.w	r1, r1, #4294967295
 800b91c:	b289      	uxthmi	r1, r1
          }
          pbuf_realloc(inseg.p, inseg.len);
 800b91e:	6878      	ldr	r0, [r7, #4]
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
            inseg.len -= 1;
 800b920:	bf48      	it	mi
 800b922:	8129      	strhmi	r1, [r5, #8]
          }
          pbuf_realloc(inseg.p, inseg.len);
 800b924:	f7fd ff0c 	bl	8009740 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 800b928:	68fb      	ldr	r3, [r7, #12]
 800b92a:	893d      	ldrh	r5, [r7, #8]
 800b92c:	8998      	ldrh	r0, [r3, #12]
 800b92e:	f003 fa3f 	bl	800edb0 <lwip_ntohs>
 800b932:	f010 0003 	ands.w	r0, r0, #3
 800b936:	bf18      	it	ne
 800b938:	2001      	movne	r0, #1
 800b93a:	182b      	adds	r3, r5, r0
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 800b93c:	f8d8 1000 	ldr.w	r1, [r8]
 800b940:	8da0      	ldrh	r0, [r4, #44]	; 0x2c
 800b942:	6aa2      	ldr	r2, [r4, #40]	; 0x28
          inseg.len = pcb->rcv_wnd;
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
            inseg.len -= 1;
          }
          pbuf_realloc(inseg.p, inseg.len);
          tcplen = TCP_TCPLEN(&inseg);
 800b944:	b29b      	uxth	r3, r3
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 800b946:	4419      	add	r1, r3
 800b948:	4402      	add	r2, r0
 800b94a:	4291      	cmp	r1, r2
          inseg.len = pcb->rcv_wnd;
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
            inseg.len -= 1;
          }
          pbuf_realloc(inseg.p, inseg.len);
          tcplen = TCP_TCPLEN(&inseg);
 800b94c:	f8a9 3000 	strh.w	r3, [r9]
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 800b950:	f43f ae53 	beq.w	800b5fa <tcp_receive+0x67a>
 800b954:	4b50      	ldr	r3, [pc, #320]	; (800ba98 <tcp_receive+0xb18>)
 800b956:	9300      	str	r3, [sp, #0]
 800b958:	4951      	ldr	r1, [pc, #324]	; (800baa0 <tcp_receive+0xb20>)
 800b95a:	4a55      	ldr	r2, [pc, #340]	; (800bab0 <tcp_receive+0xb30>)
 800b95c:	4851      	ldr	r0, [pc, #324]	; (800baa4 <tcp_receive+0xb24>)
 800b95e:	f44f 639b 	mov.w	r3, #1240	; 0x4d8
 800b962:	f7ff faf5 	bl	800af50 <chprintf.constprop.1>
 800b966:	4852      	ldr	r0, [pc, #328]	; (800bab0 <tcp_receive+0xb30>)
 800b968:	f7f5 fb02 	bl	8000f70 <chSysHalt>
 800b96c:	e645      	b.n	800b5fa <tcp_receive+0x67a>
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
 800b96e:	4b4a      	ldr	r3, [pc, #296]	; (800ba98 <tcp_receive+0xb18>)
 800b970:	494b      	ldr	r1, [pc, #300]	; (800baa0 <tcp_receive+0xb20>)
 800b972:	4a50      	ldr	r2, [pc, #320]	; (800bab4 <tcp_receive+0xb34>)
 800b974:	9300      	str	r3, [sp, #0]
 800b976:	484b      	ldr	r0, [pc, #300]	; (800baa4 <tcp_receive+0xb24>)
 800b978:	f240 5312 	movw	r3, #1298	; 0x512
 800b97c:	f7ff fae8 	bl	800af50 <chprintf.constprop.1>
 800b980:	484c      	ldr	r0, [pc, #304]	; (800bab4 <tcp_receive+0xb34>)
 800b982:	f7f5 faf5 	bl	8000f70 <chSysHalt>
 800b986:	f8b9 2000 	ldrh.w	r2, [r9]
 800b98a:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
 800b98c:	e6a6      	b.n	800b6dc <tcp_receive+0x75c>
 800b98e:	f8b9 2000 	ldrh.w	r2, [r9]
 800b992:	f8d8 3000 	ldr.w	r3, [r8]
 800b996:	2500      	movs	r5, #0
 800b998:	4413      	add	r3, r2
              pbuf_realloc(inseg.p, inseg.len);
              tcplen = TCP_TCPLEN(&inseg);
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
                          (seqno + tcplen) == next->tcphdr->seqno);
            }
            pcb->ooseq = next;
 800b99a:	6765      	str	r5, [r4, #116]	; 0x74
 800b99c:	e699      	b.n	800b6d2 <tcp_receive+0x752>
            }
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 800b99e:	4655      	mov	r5, sl
              next = next->next;
              tcp_seg_free(prev);
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
 800b9a0:	2b00      	cmp	r3, #0
 800b9a2:	dc0e      	bgt.n	800b9c2 <tcp_receive+0xa42>
 800b9a4:	1883      	adds	r3, r0, r2
 800b9a6:	e7f8      	b.n	800b99a <tcp_receive+0xa1a>
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
 800b9a8:	4b3b      	ldr	r3, [pc, #236]	; (800ba98 <tcp_receive+0xb18>)
 800b9aa:	9300      	str	r3, [sp, #0]
 800b9ac:	493c      	ldr	r1, [pc, #240]	; (800baa0 <tcp_receive+0xb20>)
 800b9ae:	4a42      	ldr	r2, [pc, #264]	; (800bab8 <tcp_receive+0xb38>)
 800b9b0:	483c      	ldr	r0, [pc, #240]	; (800baa4 <tcp_receive+0xb24>)
 800b9b2:	f240 4396 	movw	r3, #1174	; 0x496
 800b9b6:	f7ff facb 	bl	800af50 <chprintf.constprop.1>
 800b9ba:	483f      	ldr	r0, [pc, #252]	; (800bab8 <tcp_receive+0xb38>)
 800b9bc:	f7f5 fad8 	bl	8000f70 <chSysHalt>
 800b9c0:	e596      	b.n	800b4f0 <tcp_receive+0x570>
             * segment on ooseq */
            if (next &&
                TCP_SEQ_GT(seqno + tcplen,
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
 800b9c2:	ebc0 030c 	rsb	r3, r0, ip
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800b9c6:	68fa      	ldr	r2, [r7, #12]
             * segment on ooseq */
            if (next &&
                TCP_SEQ_GT(seqno + tcplen,
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
 800b9c8:	813b      	strh	r3, [r7, #8]
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800b9ca:	8990      	ldrh	r0, [r2, #12]
             * segment on ooseq */
            if (next &&
                TCP_SEQ_GT(seqno + tcplen,
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
 800b9cc:	4e37      	ldr	r6, [pc, #220]	; (800baac <tcp_receive+0xb2c>)
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
                inseg.len -= 1;
              }
              pbuf_realloc(inseg.p, inseg.len);
              tcplen = TCP_TCPLEN(&inseg);
 800b9ce:	f8df a0f4 	ldr.w	sl, [pc, #244]	; 800bac4 <tcp_receive+0xb44>
            if (next &&
                TCP_SEQ_GT(seqno + tcplen,
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800b9d2:	f003 f9ed 	bl	800edb0 <lwip_ntohs>
                inseg.len -= 1;
 800b9d6:	8931      	ldrh	r1, [r6, #8]
            if (next &&
                TCP_SEQ_GT(seqno + tcplen,
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800b9d8:	0783      	lsls	r3, r0, #30
                inseg.len -= 1;
 800b9da:	bf44      	itt	mi
 800b9dc:	f101 31ff 	addmi.w	r1, r1, #4294967295
 800b9e0:	b289      	uxthmi	r1, r1
              }
              pbuf_realloc(inseg.p, inseg.len);
 800b9e2:	6878      	ldr	r0, [r7, #4]
                TCP_SEQ_GT(seqno + tcplen,
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
                inseg.len -= 1;
 800b9e4:	bf48      	it	mi
 800b9e6:	8131      	strhmi	r1, [r6, #8]
              }
              pbuf_realloc(inseg.p, inseg.len);
 800b9e8:	f7fd feaa 	bl	8009740 <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
 800b9ec:	68fb      	ldr	r3, [r7, #12]
 800b9ee:	f8b7 b008 	ldrh.w	fp, [r7, #8]
 800b9f2:	8998      	ldrh	r0, [r3, #12]
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
 800b9f4:	4e31      	ldr	r6, [pc, #196]	; (800babc <tcp_receive+0xb3c>)
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
                inseg.len -= 1;
              }
              pbuf_realloc(inseg.p, inseg.len);
              tcplen = TCP_TCPLEN(&inseg);
 800b9f6:	f003 f9db 	bl	800edb0 <lwip_ntohs>
 800b9fa:	f010 0003 	ands.w	r0, r0, #3
 800b9fe:	bf18      	it	ne
 800ba00:	2001      	movne	r0, #1
 800ba02:	eb0b 0200 	add.w	r2, fp, r0
 800ba06:	b292      	uxth	r2, r2
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
 800ba08:	68eb      	ldr	r3, [r5, #12]
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
                inseg.len -= 1;
              }
              pbuf_realloc(inseg.p, inseg.len);
              tcplen = TCP_TCPLEN(&inseg);
 800ba0a:	f8a9 2000 	strh.w	r2, [r9]
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
 800ba0e:	f8d8 1000 	ldr.w	r1, [r8]
 800ba12:	685b      	ldr	r3, [r3, #4]
 800ba14:	4411      	add	r1, r2
 800ba16:	4299      	cmp	r1, r3
 800ba18:	d0bf      	beq.n	800b99a <tcp_receive+0xa1a>
 800ba1a:	4b1f      	ldr	r3, [pc, #124]	; (800ba98 <tcp_receive+0xb18>)
 800ba1c:	4a28      	ldr	r2, [pc, #160]	; (800bac0 <tcp_receive+0xb40>)
 800ba1e:	9300      	str	r3, [sp, #0]
 800ba20:	491f      	ldr	r1, [pc, #124]	; (800baa0 <tcp_receive+0xb20>)
 800ba22:	4820      	ldr	r0, [pc, #128]	; (800baa4 <tcp_receive+0xb24>)
 800ba24:	f44f 63a1 	mov.w	r3, #1288	; 0x508
 800ba28:	f7ff fa92 	bl	800af50 <chprintf.constprop.1>
 800ba2c:	4824      	ldr	r0, [pc, #144]	; (800bac0 <tcp_receive+0xb40>)
 800ba2e:	f7f5 fa9f 	bl	8000f70 <chSysHalt>
 800ba32:	f8ba 2000 	ldrh.w	r2, [sl]
 800ba36:	6833      	ldr	r3, [r6, #0]
 800ba38:	4413      	add	r3, r2
 800ba3a:	e7ae      	b.n	800b99a <tcp_receive+0xa1a>
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_send_empty_ack(pcb);
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
          pcb->ooseq = tcp_seg_copy(&inseg);
 800ba3c:	481b      	ldr	r0, [pc, #108]	; (800baac <tcp_receive+0xb2c>)
 800ba3e:	f7fe fb0f 	bl	800a060 <tcp_seg_copy>
 800ba42:	6760      	str	r0, [r4, #116]	; 0x74
 800ba44:	f7ff bac3 	b.w	800afce <tcp_receive+0x4e>
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
 800ba48:	68fe      	ldr	r6, [r7, #12]
 800ba4a:	89b5      	ldrh	r5, [r6, #12]
 800ba4c:	4628      	mov	r0, r5
 800ba4e:	f003 f9af 	bl	800edb0 <lwip_ntohs>
 800ba52:	f000 003e 	and.w	r0, r0, #62	; 0x3e
 800ba56:	f003 f9a3 	bl	800eda0 <lwip_htons>
 800ba5a:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
 800ba5e:	4328      	orrs	r0, r5
 800ba60:	81b0      	strh	r0, [r6, #12]
 800ba62:	e74f      	b.n	800b904 <tcp_receive+0x984>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
                  pcb->cwnd += pcb->mss;
                }
              } else if (pcb->dupacks == 3) {
 800ba64:	f47f aad7 	bne.w	800b016 <tcp_receive+0x96>
                /* Do fast retransmit */
                tcp_rexmit_fast(pcb);
 800ba68:	4620      	mov	r0, r4
 800ba6a:	f001 fd79 	bl	800d560 <tcp_rexmit_fast>
 800ba6e:	f7ff bad2 	b.w	800b016 <tcp_receive+0x96>
                cseg = tcp_seg_copy(&inseg);
                if (cseg != NULL) {
                  if (prev != NULL) {
                    prev->next = cseg;
                  } else {
                    pcb->ooseq = cseg;
 800ba72:	6760      	str	r0, [r4, #116]	; 0x74
 800ba74:	f7ff bbec 	b.w	800b250 <tcp_receive+0x2d0>
                                 "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                                 seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
                      /* Must remove the FIN from the header as we're trimming 
                       * that byte of sequence-space from the packet */
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
 800ba78:	682b      	ldr	r3, [r5, #0]
 800ba7a:	68df      	ldr	r7, [r3, #12]
 800ba7c:	89be      	ldrh	r6, [r7, #12]
 800ba7e:	4630      	mov	r0, r6
 800ba80:	f003 f996 	bl	800edb0 <lwip_ntohs>
 800ba84:	f000 003e 	and.w	r0, r0, #62	; 0x3e
 800ba88:	f003 f98a 	bl	800eda0 <lwip_htons>
 800ba8c:	f426 567c 	bic.w	r6, r6, #16128	; 0x3f00
 800ba90:	4330      	orrs	r0, r6
 800ba92:	81b8      	strh	r0, [r7, #12]
 800ba94:	e435      	b.n	800b302 <tcp_receive+0x382>
 800ba96:	bf00      	nop
 800ba98:	08017d5c 	.word	0x08017d5c
 800ba9c:	08017df4 	.word	0x08017df4
 800baa0:	08016fe0 	.word	0x08016fe0
 800baa4:	200180c8 	.word	0x200180c8
 800baa8:	08017e04 	.word	0x08017e04
 800baac:	2000cb8c 	.word	0x2000cb8c
 800bab0:	08017e18 	.word	0x08017e18
 800bab4:	08017e8c 	.word	0x08017e8c
 800bab8:	08017dd4 	.word	0x08017dd4
 800babc:	2000cb70 	.word	0x2000cb70
 800bac0:	08017e50 	.word	0x08017e50
 800bac4:	2000cb78 	.word	0x2000cb78
 800bac8:	f3af 8000 	nop.w
 800bacc:	f3af 8000 	nop.w

0800bad0 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 800bad0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  u8_t hdrlen;
  err_t err;

  PERF_START;

  TCP_STATS_INC(tcp.recv);
 800bad4:	4ca0      	ldr	r4, [pc, #640]	; (800bd58 <tcp_input+0x288>)
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
 800bad6:	6843      	ldr	r3, [r0, #4]
  u8_t hdrlen;
  err_t err;

  PERF_START;

  TCP_STATS_INC(tcp.recv);
 800bad8:	f8b4 2092 	ldrh.w	r2, [r4, #146]	; 0x92
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
 800badc:	4f9f      	ldr	r7, [pc, #636]	; (800bd5c <tcp_input+0x28c>)
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
 800bade:	4ea0      	ldr	r6, [pc, #640]	; (800bd60 <tcp_input+0x290>)
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
 800bae0:	603b      	str	r3, [r7, #0]
  u8_t hdrlen;
  err_t err;

  PERF_START;

  TCP_STATS_INC(tcp.recv);
 800bae2:	3201      	adds	r2, #1
 800bae4:	f8a4 2092 	strh.w	r2, [r4, #146]	; 0x92
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
 800bae8:	781a      	ldrb	r2, [r3, #0]
 800baea:	f002 020f 	and.w	r2, r2, #15
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
 800baee:	ea4f 0e82 	mov.w	lr, r2, lsl #2
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 800baf2:	b083      	sub	sp, #12
 800baf4:	460f      	mov	r7, r1

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
 800baf6:	eb03 0382 	add.w	r3, r3, r2, lsl #2
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
 800bafa:	f1ce 0100 	rsb	r1, lr, #0
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 800bafe:	4605      	mov	r5, r0

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
 800bb00:	6033      	str	r3, [r6, #0]
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
 800bb02:	f7fd fc0d 	bl	8009320 <pbuf_header>
 800bb06:	b910      	cbnz	r0, 800bb0e <tcp_input+0x3e>
 800bb08:	892b      	ldrh	r3, [r5, #8]
 800bb0a:	2b13      	cmp	r3, #19
 800bb0c:	d80f      	bhi.n	800bb2e <tcp_input+0x5e>
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  if(pbuf_header(p, -(hdrlen * 4))){
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
 800bb0e:	f8b4 309a 	ldrh.w	r3, [r4, #154]	; 0x9a
 800bb12:	3301      	adds	r3, #1
 800bb14:	f8a4 309a 	strh.w	r3, [r4, #154]	; 0x9a

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
dropped:
  TCP_STATS_INC(tcp.drop);
 800bb18:	f8b4 3096 	ldrh.w	r3, [r4, #150]	; 0x96
 800bb1c:	3301      	adds	r3, #1
  snmp_inc_tcpinerrs();
  pbuf_free(p);
 800bb1e:	4628      	mov	r0, r5

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
dropped:
  TCP_STATS_INC(tcp.drop);
 800bb20:	f8a4 3096 	strh.w	r3, [r4, #150]	; 0x96
  snmp_inc_tcpinerrs();
  pbuf_free(p);
}
 800bb24:	b003      	add	sp, #12
 800bb26:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  PERF_STOP("tcp_input");
  return;
dropped:
  TCP_STATS_INC(tcp.drop);
  snmp_inc_tcpinerrs();
  pbuf_free(p);
 800bb2a:	f7fd bc69 	b.w	8009400 <pbuf_free>
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
 800bb2e:	f8df 8268 	ldr.w	r8, [pc, #616]	; 800bd98 <tcp_input+0x2c8>
 800bb32:	4639      	mov	r1, r7
 800bb34:	f8d8 0000 	ldr.w	r0, [r8]
 800bb38:	f002 fc92 	bl	800e460 <ip4_addr_isbroadcast>
 800bb3c:	b9a0      	cbnz	r0, 800bb68 <tcp_input+0x98>
      ip_addr_ismulticast(&current_iphdr_dest)) {
 800bb3e:	f8d8 3000 	ldr.w	r3, [r8]
 800bb42:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
 800bb46:	2be0      	cmp	r3, #224	; 0xe0
 800bb48:	d00e      	beq.n	800bb68 <tcp_input+0x98>
    goto dropped;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
 800bb4a:	892b      	ldrh	r3, [r5, #8]
 800bb4c:	9300      	str	r3, [sp, #0]
 800bb4e:	4628      	mov	r0, r5
 800bb50:	4984      	ldr	r1, [pc, #528]	; (800bd64 <tcp_input+0x294>)
 800bb52:	4642      	mov	r2, r8
 800bb54:	2306      	movs	r3, #6
 800bb56:	f002 f9c3 	bl	800dee0 <inet_chksum_pseudo>
 800bb5a:	b158      	cbz	r0, 800bb74 <tcp_input+0xa4>
        inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
      IP_PROTO_TCP, p->tot_len)));
#if TCP_DEBUG
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
 800bb5c:	f8b4 3098 	ldrh.w	r3, [r4, #152]	; 0x98
 800bb60:	3301      	adds	r3, #1
 800bb62:	f8a4 3098 	strh.w	r3, [r4, #152]	; 0x98
    goto dropped;
 800bb66:	e7d7      	b.n	800bb18 <tcp_input+0x48>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
      ip_addr_ismulticast(&current_iphdr_dest)) {
    TCP_STATS_INC(tcp.proterr);
 800bb68:	f8b4 30a0 	ldrh.w	r3, [r4, #160]	; 0xa0
 800bb6c:	3301      	adds	r3, #1
 800bb6e:	f8a4 30a0 	strh.w	r3, [r4, #160]	; 0xa0
    goto dropped;
 800bb72:	e7d1      	b.n	800bb18 <tcp_input+0x48>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
 800bb74:	6833      	ldr	r3, [r6, #0]
 800bb76:	8998      	ldrh	r0, [r3, #12]
 800bb78:	f003 f91a 	bl	800edb0 <lwip_ntohs>
 800bb7c:	0b00      	lsrs	r0, r0, #12
  if(pbuf_header(p, -(hdrlen * 4))){
 800bb7e:	ebc0 3080 	rsb	r0, r0, r0, lsl #14
 800bb82:	0081      	lsls	r1, r0, #2
 800bb84:	b209      	sxth	r1, r1
 800bb86:	4628      	mov	r0, r5
 800bb88:	f7fd fbca 	bl	8009320 <pbuf_header>
 800bb8c:	4681      	mov	r9, r0
 800bb8e:	2800      	cmp	r0, #0
 800bb90:	d1bd      	bne.n	800bb0e <tcp_input+0x3e>
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
 800bb92:	6837      	ldr	r7, [r6, #0]
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 800bb94:	f8df a204 	ldr.w	sl, [pc, #516]	; 800bd9c <tcp_input+0x2cc>
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
 800bb98:	8838      	ldrh	r0, [r7, #0]
 800bb9a:	f003 f909 	bl	800edb0 <lwip_ntohs>
  tcphdr->dest = ntohs(tcphdr->dest);
 800bb9e:	f8d6 b000 	ldr.w	fp, [r6]
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
 800bba2:	8038      	strh	r0, [r7, #0]
  tcphdr->dest = ntohs(tcphdr->dest);
 800bba4:	f8bb 0002 	ldrh.w	r0, [fp, #2]
 800bba8:	f003 f902 	bl	800edb0 <lwip_ntohs>
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
 800bbac:	6837      	ldr	r7, [r6, #0]
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
 800bbae:	f8ab 0002 	strh.w	r0, [fp, #2]
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
 800bbb2:	6878      	ldr	r0, [r7, #4]
 800bbb4:	f003 f90c 	bl	800edd0 <lwip_ntohl>
 800bbb8:	4b6b      	ldr	r3, [pc, #428]	; (800bd68 <tcp_input+0x298>)
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 800bbba:	f8d6 b000 	ldr.w	fp, [r6]
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
 800bbbe:	6018      	str	r0, [r3, #0]
 800bbc0:	6078      	str	r0, [r7, #4]
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 800bbc2:	f8db 0008 	ldr.w	r0, [fp, #8]
 800bbc6:	f003 f903 	bl	800edd0 <lwip_ntohl>
  tcphdr->wnd = ntohs(tcphdr->wnd);
 800bbca:	6837      	ldr	r7, [r6, #0]

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 800bbcc:	f8cb 0008 	str.w	r0, [fp, #8]
 800bbd0:	f8ca 0000 	str.w	r0, [sl]
  tcphdr->wnd = ntohs(tcphdr->wnd);
 800bbd4:	89f8      	ldrh	r0, [r7, #14]
 800bbd6:	f003 f8eb 	bl	800edb0 <lwip_ntohs>

  flags = TCPH_FLAGS(tcphdr);
 800bbda:	6833      	ldr	r3, [r6, #0]
  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  tcphdr->wnd = ntohs(tcphdr->wnd);
 800bbdc:	81f8      	strh	r0, [r7, #14]

  flags = TCPH_FLAGS(tcphdr);
 800bbde:	8998      	ldrh	r0, [r3, #12]
 800bbe0:	f003 f8e6 	bl	800edb0 <lwip_ntohs>
 800bbe4:	b2c0      	uxtb	r0, r0
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 800bbe6:	f010 0203 	ands.w	r2, r0, #3
 800bbea:	892b      	ldrh	r3, [r5, #8]
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800bbec:	495f      	ldr	r1, [pc, #380]	; (800bd6c <tcp_input+0x29c>)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  tcphdr->wnd = ntohs(tcphdr->wnd);

  flags = TCPH_FLAGS(tcphdr);
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 800bbee:	bf18      	it	ne
 800bbf0:	2201      	movne	r2, #1
 800bbf2:	4413      	add	r3, r2
 800bbf4:	4a5e      	ldr	r2, [pc, #376]	; (800bd70 <tcp_input+0x2a0>)
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800bbf6:	680f      	ldr	r7, [r1, #0]
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  tcphdr->wnd = ntohs(tcphdr->wnd);

  flags = TCPH_FLAGS(tcphdr);
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 800bbf8:	8013      	strh	r3, [r2, #0]
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  tcphdr->wnd = ntohs(tcphdr->wnd);

  flags = TCPH_FLAGS(tcphdr);
 800bbfa:	4b5e      	ldr	r3, [pc, #376]	; (800bd74 <tcp_input+0x2a4>)
 800bbfc:	f000 003f 	and.w	r0, r0, #63	; 0x3f
 800bc00:	7018      	strb	r0, [r3, #0]
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800bc02:	2f00      	cmp	r7, #0
 800bc04:	f000 80a0 	beq.w	800bd48 <tcp_input+0x278>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 800bc08:	f8df b194 	ldr.w	fp, [pc, #404]	; 800bda0 <tcp_input+0x2d0>
 800bc0c:	e00f      	b.n	800bc2e <tcp_input+0x15e>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 800bc0e:	2b0a      	cmp	r3, #10
 800bc10:	f000 808d 	beq.w	800bd2e <tcp_input+0x25e>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 800bc14:	2b01      	cmp	r3, #1
 800bc16:	d07e      	beq.n	800bd16 <tcp_input+0x246>
    if (pcb->remote_port == tcphdr->src &&
 800bc18:	6833      	ldr	r3, [r6, #0]
 800bc1a:	8bb9      	ldrh	r1, [r7, #28]
 800bc1c:	881a      	ldrh	r2, [r3, #0]
 800bc1e:	4291      	cmp	r1, r2
 800bc20:	d015      	beq.n	800bc4e <tcp_input+0x17e>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800bc22:	68fb      	ldr	r3, [r7, #12]
 800bc24:	46b9      	mov	r9, r7
 800bc26:	2b00      	cmp	r3, #0
 800bc28:	f000 808e 	beq.w	800bd48 <tcp_input+0x278>
 800bc2c:	461f      	mov	r7, r3
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 800bc2e:	7e3b      	ldrb	r3, [r7, #24]
 800bc30:	2b00      	cmp	r3, #0
 800bc32:	d1ec      	bne.n	800bc0e <tcp_input+0x13e>
 800bc34:	23ab      	movs	r3, #171	; 0xab
 800bc36:	4950      	ldr	r1, [pc, #320]	; (800bd78 <tcp_input+0x2a8>)
 800bc38:	4a50      	ldr	r2, [pc, #320]	; (800bd7c <tcp_input+0x2ac>)
 800bc3a:	f8cd b000 	str.w	fp, [sp]
 800bc3e:	4850      	ldr	r0, [pc, #320]	; (800bd80 <tcp_input+0x2b0>)
 800bc40:	f7ff f986 	bl	800af50 <chprintf.constprop.1>
 800bc44:	484d      	ldr	r0, [pc, #308]	; (800bd7c <tcp_input+0x2ac>)
 800bc46:	f7f5 f993 	bl	8000f70 <chSysHalt>
 800bc4a:	7e3b      	ldrb	r3, [r7, #24]
 800bc4c:	e7df      	b.n	800bc0e <tcp_input+0x13e>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
 800bc4e:	885b      	ldrh	r3, [r3, #2]
 800bc50:	8b7a      	ldrh	r2, [r7, #26]
 800bc52:	429a      	cmp	r2, r3
 800bc54:	d1e5      	bne.n	800bc22 <tcp_input+0x152>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 800bc56:	4b43      	ldr	r3, [pc, #268]	; (800bd64 <tcp_input+0x294>)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
 800bc58:	687a      	ldr	r2, [r7, #4]
 800bc5a:	681b      	ldr	r3, [r3, #0]
 800bc5c:	429a      	cmp	r2, r3
 800bc5e:	d1e0      	bne.n	800bc22 <tcp_input+0x152>
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 800bc60:	683a      	ldr	r2, [r7, #0]
 800bc62:	f8d8 3000 	ldr.w	r3, [r8]
 800bc66:	429a      	cmp	r2, r3
 800bc68:	d1db      	bne.n	800bc22 <tcp_input+0x152>
       ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 800bc6a:	68fb      	ldr	r3, [r7, #12]
 800bc6c:	42bb      	cmp	r3, r7
 800bc6e:	f000 8491 	beq.w	800c594 <tcp_input+0xac4>
      if (prev != NULL) {
 800bc72:	f1b9 0f00 	cmp.w	r9, #0
 800bc76:	d007      	beq.n	800bc88 <tcp_input+0x1b8>
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
 800bc78:	4a3c      	ldr	r2, [pc, #240]	; (800bd6c <tcp_input+0x29c>)
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
        prev->next = pcb->next;
 800bc7a:	f8c9 300c 	str.w	r3, [r9, #12]
        pcb->next = tcp_active_pcbs;
 800bc7e:	6812      	ldr	r2, [r2, #0]
        tcp_active_pcbs = pcb;
 800bc80:	4b3a      	ldr	r3, [pc, #232]	; (800bd6c <tcp_input+0x29c>)
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
 800bc82:	60fa      	str	r2, [r7, #12]
        tcp_active_pcbs = pcb;
 800bc84:	601f      	str	r7, [r3, #0]
 800bc86:	4613      	mov	r3, r2
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
 800bc88:	42bb      	cmp	r3, r7
 800bc8a:	f000 846c 	beq.w	800c566 <tcp_input+0xa96>
    inseg.tcphdr = tcphdr;

    recv_data = NULL;
    recv_flags = 0;

    if (flags & TCP_PSH) {
 800bc8e:	4b39      	ldr	r3, [pc, #228]	; (800bd74 <tcp_input+0x2a4>)
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 800bc90:	f8df b0f4 	ldr.w	fp, [pc, #244]	; 800bd88 <tcp_input+0x2b8>
    inseg.tcphdr = tcphdr;

    recv_data = NULL;
    recv_flags = 0;

    if (flags & TCP_PSH) {
 800bc94:	781a      	ldrb	r2, [r3, #0]
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
    inseg.len = p->tot_len;
 800bc96:	892b      	ldrh	r3, [r5, #8]
    inseg.p = p;
    inseg.tcphdr = tcphdr;

    recv_data = NULL;
 800bc98:	f8df 9108 	ldr.w	r9, [pc, #264]	; 800bda4 <tcp_input+0x2d4>
    recv_flags = 0;
 800bc9c:	f8df 8108 	ldr.w	r8, [pc, #264]	; 800bda8 <tcp_input+0x2d8>
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
    inseg.len = p->tot_len;
 800bca0:	f8ab 3008 	strh.w	r3, [fp, #8]
    inseg.p = p;
    inseg.tcphdr = tcphdr;
 800bca4:	6833      	ldr	r3, [r6, #0]
 800bca6:	f8cb 300c 	str.w	r3, [fp, #12]

    recv_data = NULL;
    recv_flags = 0;

    if (flags & TCP_PSH) {
 800bcaa:	0712      	lsls	r2, r2, #28
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 800bcac:	f04f 0300 	mov.w	r3, #0
    inseg.len = p->tot_len;
    inseg.p = p;
 800bcb0:	f8cb 5004 	str.w	r5, [fp, #4]
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 800bcb4:	f8cb 3000 	str.w	r3, [fp]
    inseg.len = p->tot_len;
    inseg.p = p;
    inseg.tcphdr = tcphdr;

    recv_data = NULL;
 800bcb8:	f8c9 3000 	str.w	r3, [r9]
    recv_flags = 0;
 800bcbc:	f888 3000 	strb.w	r3, [r8]

    if (flags & TCP_PSH) {
 800bcc0:	d503      	bpl.n	800bcca <tcp_input+0x1fa>
      p->flags |= PBUF_FLAG_PUSH;
 800bcc2:	7b6b      	ldrb	r3, [r5, #13]
 800bcc4:	f043 0301 	orr.w	r3, r3, #1
 800bcc8:	736b      	strb	r3, [r5, #13]
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
 800bcca:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800bccc:	2b00      	cmp	r3, #0
 800bcce:	f000 80ae 	beq.w	800be2e <tcp_input+0x35e>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 800bcd2:	4638      	mov	r0, r7
 800bcd4:	f7fe fe94 	bl	800aa00 <tcp_process_refused_data>
 800bcd8:	300a      	adds	r0, #10
 800bcda:	d008      	beq.n	800bcee <tcp_input+0x21e>
 800bcdc:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800bcde:	2b00      	cmp	r3, #0
 800bce0:	f000 80a5 	beq.w	800be2e <tcp_input+0x35e>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
 800bce4:	4b22      	ldr	r3, [pc, #136]	; (800bd70 <tcp_input+0x2a0>)
 800bce6:	881b      	ldrh	r3, [r3, #0]
 800bce8:	2b00      	cmp	r3, #0
 800bcea:	f000 80a0 	beq.w	800be2e <tcp_input+0x35e>
        /* pcb has been aborted or refused data is still refused and the new
           segment contains data */
        TCP_STATS_INC(tcp.drop);
 800bcee:	f8b4 3096 	ldrh.w	r3, [r4, #150]	; 0x96
 800bcf2:	4d24      	ldr	r5, [pc, #144]	; (800bd84 <tcp_input+0x2b4>)
 800bcf4:	3301      	adds	r3, #1
 800bcf6:	f8a4 3096 	strh.w	r3, [r4, #150]	; 0x96
aborted:
    tcp_input_pcb = NULL;
    recv_data = NULL;

    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
 800bcfa:	f8db 0004 	ldr.w	r0, [fp, #4]
 800bcfe:	4e22      	ldr	r6, [pc, #136]	; (800bd88 <tcp_input+0x2b8>)
      }
    }
    /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
       Below this line, 'pcb' may not be dereferenced! */
aborted:
    tcp_input_pcb = NULL;
 800bd00:	2400      	movs	r4, #0
 800bd02:	602c      	str	r4, [r5, #0]
    recv_data = NULL;
 800bd04:	f8c9 4000 	str.w	r4, [r9]

    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
 800bd08:	b110      	cbz	r0, 800bd10 <tcp_input+0x240>
    {
      pbuf_free(inseg.p);
 800bd0a:	f7fd fb79 	bl	8009400 <pbuf_free>
      inseg.p = NULL;
 800bd0e:	6074      	str	r4, [r6, #4]
  return;
dropped:
  TCP_STATS_INC(tcp.drop);
  snmp_inc_tcpinerrs();
  pbuf_free(p);
}
 800bd10:	b003      	add	sp, #12
 800bd12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 800bd16:	f8cd b000 	str.w	fp, [sp]
 800bd1a:	4917      	ldr	r1, [pc, #92]	; (800bd78 <tcp_input+0x2a8>)
 800bd1c:	4a1b      	ldr	r2, [pc, #108]	; (800bd8c <tcp_input+0x2bc>)
 800bd1e:	4818      	ldr	r0, [pc, #96]	; (800bd80 <tcp_input+0x2b0>)
 800bd20:	23ad      	movs	r3, #173	; 0xad
 800bd22:	f7ff f915 	bl	800af50 <chprintf.constprop.1>
 800bd26:	4819      	ldr	r0, [pc, #100]	; (800bd8c <tcp_input+0x2bc>)
 800bd28:	f7f5 f922 	bl	8000f70 <chSysHalt>
 800bd2c:	e774      	b.n	800bc18 <tcp_input+0x148>
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 800bd2e:	23ac      	movs	r3, #172	; 0xac
 800bd30:	4911      	ldr	r1, [pc, #68]	; (800bd78 <tcp_input+0x2a8>)
 800bd32:	4a17      	ldr	r2, [pc, #92]	; (800bd90 <tcp_input+0x2c0>)
 800bd34:	f8cd b000 	str.w	fp, [sp]
 800bd38:	4811      	ldr	r0, [pc, #68]	; (800bd80 <tcp_input+0x2b0>)
 800bd3a:	f7ff f909 	bl	800af50 <chprintf.constprop.1>
 800bd3e:	4814      	ldr	r0, [pc, #80]	; (800bd90 <tcp_input+0x2c0>)
 800bd40:	f7f5 f916 	bl	8000f70 <chSysHalt>
 800bd44:	7e3b      	ldrb	r3, [r7, #24]
 800bd46:	e765      	b.n	800bc14 <tcp_input+0x144>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800bd48:	4b12      	ldr	r3, [pc, #72]	; (800bd94 <tcp_input+0x2c4>)
 800bd4a:	681f      	ldr	r7, [r3, #0]
 800bd4c:	2f00      	cmp	r7, #0
 800bd4e:	f000 80b2 	beq.w	800beb6 <tcp_input+0x3e6>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800bd52:	f8df 904c 	ldr.w	r9, [pc, #76]	; 800bda0 <tcp_input+0x2d0>
 800bd56:	e02d      	b.n	800bdb4 <tcp_input+0x2e4>
 800bd58:	2000c9fc 	.word	0x2000c9fc
 800bd5c:	2000cb74 	.word	0x2000cb74
 800bd60:	2000cb84 	.word	0x2000cb84
 800bd64:	2000cbac 	.word	0x2000cbac
 800bd68:	2000cb70 	.word	0x2000cb70
 800bd6c:	2000cb60 	.word	0x2000cb60
 800bd70:	2000cb78 	.word	0x2000cb78
 800bd74:	2000cb80 	.word	0x2000cb80
 800bd78:	08016fe0 	.word	0x08016fe0
 800bd7c:	08017ed4 	.word	0x08017ed4
 800bd80:	200180c8 	.word	0x200180c8
 800bd84:	2000cb9c 	.word	0x2000cb9c
 800bd88:	2000cb8c 	.word	0x2000cb8c
 800bd8c:	08017f28 	.word	0x08017f28
 800bd90:	08017efc 	.word	0x08017efc
 800bd94:	2000cb50 	.word	0x2000cb50
 800bd98:	2000cbb0 	.word	0x2000cbb0
 800bd9c:	2000cb7c 	.word	0x2000cb7c
 800bda0:	08017d5c 	.word	0x08017d5c
 800bda4:	2000cb88 	.word	0x2000cb88
 800bda8:	2000cb81 	.word	0x2000cb81
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800bdac:	68ff      	ldr	r7, [r7, #12]
 800bdae:	2f00      	cmp	r7, #0
 800bdb0:	f000 8081 	beq.w	800beb6 <tcp_input+0x3e6>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800bdb4:	f897 e018 	ldrb.w	lr, [r7, #24]
 800bdb8:	48b1      	ldr	r0, [pc, #708]	; (800c080 <tcp_input+0x5b0>)
 800bdba:	49b2      	ldr	r1, [pc, #712]	; (800c084 <tcp_input+0x5b4>)
 800bdbc:	4ab2      	ldr	r2, [pc, #712]	; (800c088 <tcp_input+0x5b8>)
 800bdbe:	f1be 0f0a 	cmp.w	lr, #10
 800bdc2:	f04f 03c6 	mov.w	r3, #198	; 0xc6
 800bdc6:	d006      	beq.n	800bdd6 <tcp_input+0x306>
 800bdc8:	f8cd 9000 	str.w	r9, [sp]
 800bdcc:	f7ff f8c0 	bl	800af50 <chprintf.constprop.1>
 800bdd0:	48ad      	ldr	r0, [pc, #692]	; (800c088 <tcp_input+0x5b8>)
 800bdd2:	f7f5 f8cd 	bl	8000f70 <chSysHalt>
      if (pcb->remote_port == tcphdr->src &&
 800bdd6:	6833      	ldr	r3, [r6, #0]
 800bdd8:	8bb9      	ldrh	r1, [r7, #28]
 800bdda:	881a      	ldrh	r2, [r3, #0]
 800bddc:	428a      	cmp	r2, r1
 800bdde:	d1e5      	bne.n	800bdac <tcp_input+0x2dc>
 800bde0:	f8b3 e002 	ldrh.w	lr, [r3, #2]
         pcb->local_port == tcphdr->dest &&
 800bde4:	8b7b      	ldrh	r3, [r7, #26]
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
 800bde6:	459e      	cmp	lr, r3
 800bde8:	d1e0      	bne.n	800bdac <tcp_input+0x2dc>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 800bdea:	4ba8      	ldr	r3, [pc, #672]	; (800c08c <tcp_input+0x5bc>)
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
 800bdec:	6878      	ldr	r0, [r7, #4]
 800bdee:	6819      	ldr	r1, [r3, #0]
 800bdf0:	4288      	cmp	r0, r1
 800bdf2:	d1db      	bne.n	800bdac <tcp_input+0x2dc>
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 800bdf4:	6838      	ldr	r0, [r7, #0]
 800bdf6:	f8d8 1000 	ldr.w	r1, [r8]
 800bdfa:	4288      	cmp	r0, r1
 800bdfc:	d1d6      	bne.n	800bdac <tcp_input+0x2dc>
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST)  {
 800bdfe:	49a4      	ldr	r1, [pc, #656]	; (800c090 <tcp_input+0x5c0>)
 800be00:	7809      	ldrb	r1, [r1, #0]
 800be02:	0748      	lsls	r0, r1, #29
 800be04:	d411      	bmi.n	800be2a <tcp_input+0x35a>
    return ERR_OK;
  }
  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
 800be06:	078e      	lsls	r6, r1, #30
 800be08:	f140 833e 	bpl.w	800c488 <tcp_input+0x9b8>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
 800be0c:	49a1      	ldr	r1, [pc, #644]	; (800c094 <tcp_input+0x5c4>)
 800be0e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800be10:	6809      	ldr	r1, [r1, #0]
 800be12:	1a08      	subs	r0, r1, r0
 800be14:	d404      	bmi.n	800be20 <tcp_input+0x350>
 800be16:	8dbc      	ldrh	r4, [r7, #44]	; 0x2c
 800be18:	1b00      	subs	r0, r0, r4
 800be1a:	2800      	cmp	r0, #0
 800be1c:	f340 8374 	ble.w	800c508 <tcp_input+0xa38>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
  }

  if ((tcplen > 0))  {
 800be20:	4b9d      	ldr	r3, [pc, #628]	; (800c098 <tcp_input+0x5c8>)
 800be22:	881b      	ldrh	r3, [r3, #0]
 800be24:	2b00      	cmp	r3, #0
 800be26:	f040 83ab 	bne.w	800c580 <tcp_input+0xab0>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
 800be2a:	4628      	mov	r0, r5
 800be2c:	e67a      	b.n	800bb24 <tcp_input+0x54>
  err_t err;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
 800be2e:	4b98      	ldr	r3, [pc, #608]	; (800c090 <tcp_input+0x5c0>)
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        goto aborted;
      }
    }
    tcp_input_pcb = pcb;
 800be30:	4d9a      	ldr	r5, [pc, #616]	; (800c09c <tcp_input+0x5cc>)
  err_t err;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
 800be32:	781b      	ldrb	r3, [r3, #0]
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        goto aborted;
      }
    }
    tcp_input_pcb = pcb;
 800be34:	602f      	str	r7, [r5, #0]
  err_t err;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
 800be36:	075a      	lsls	r2, r3, #29
 800be38:	d521      	bpl.n	800be7e <tcp_input+0x3ae>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
 800be3a:	7e3a      	ldrb	r2, [r7, #24]
 800be3c:	2a02      	cmp	r2, #2
 800be3e:	f000 8224 	beq.w	800c28a <tcp_input+0x7ba>
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 800be42:	4b94      	ldr	r3, [pc, #592]	; (800c094 <tcp_input+0x5c4>)
 800be44:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800be46:	681b      	ldr	r3, [r3, #0]
 800be48:	1a5b      	subs	r3, r3, r1
 800be4a:	d404      	bmi.n	800be56 <tcp_input+0x386>
 800be4c:	8db9      	ldrh	r1, [r7, #44]	; 0x2c
 800be4e:	1a5b      	subs	r3, r3, r1
 800be50:	2b00      	cmp	r3, #0
 800be52:	f340 8320 	ble.w	800c496 <tcp_input+0x9c6>
    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
 800be56:	f898 3000 	ldrb.w	r3, [r8]
 800be5a:	071e      	lsls	r6, r3, #28
 800be5c:	d51c      	bpl.n	800be98 <tcp_input+0x3c8>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
 800be5e:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800be62:	b11b      	cbz	r3, 800be6c <tcp_input+0x39c>
 800be64:	6938      	ldr	r0, [r7, #16]
 800be66:	f06f 010a 	mvn.w	r1, #10
 800be6a:	4798      	blx	r3
          /* Connection closed although the application has only shut down the
             tx side: call the PCB's err callback and indicate the closure to
             ensure the application doesn't continue using the PCB. */
          TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
        }
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 800be6c:	4639      	mov	r1, r7
 800be6e:	488c      	ldr	r0, [pc, #560]	; (800c0a0 <tcp_input+0x5d0>)
 800be70:	f7fe fc56 	bl	800a720 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 800be74:	4639      	mov	r1, r7
 800be76:	2002      	movs	r0, #2
 800be78:	f7fd f8a2 	bl	8008fc0 <memp_free>
 800be7c:	e73d      	b.n	800bcfa <tcp_input+0x22a>
       seqno, pcb->rcv_nxt));
      return ERR_OK;
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
 800be7e:	079b      	lsls	r3, r3, #30
 800be80:	f140 80b0 	bpl.w	800bfe4 <tcp_input+0x514>
 800be84:	7e3b      	ldrb	r3, [r7, #24]
 800be86:	3b02      	subs	r3, #2
 800be88:	2b01      	cmp	r3, #1
 800be8a:	f240 80ab 	bls.w	800bfe4 <tcp_input+0x514>
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
      if (err == ERR_ABRT) {
        return ERR_ABRT;
      }
      tcp_ack_now(pcb);
 800be8e:	7fbb      	ldrb	r3, [r7, #30]
 800be90:	f043 0302 	orr.w	r3, r3, #2
 800be94:	77bb      	strb	r3, [r7, #30]
 800be96:	e7de      	b.n	800be56 <tcp_input+0x386>
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
        memp_free(MEMP_TCP_PCB, pcb);
      } else if (recv_flags & TF_CLOSED) {
 800be98:	06dc      	lsls	r4, r3, #27
 800be9a:	f140 81b2 	bpl.w	800c202 <tcp_input+0x732>
        /* The connection has been closed and we will deallocate the
           PCB. */
        if (!(pcb->flags & TF_RXCLOSED)) {
 800be9e:	7fbb      	ldrb	r3, [r7, #30]
 800bea0:	06d8      	lsls	r0, r3, #27
 800bea2:	d4e3      	bmi.n	800be6c <tcp_input+0x39c>
          /* Connection closed although the application has only shut down the
             tx side: call the PCB's err callback and indicate the closure to
             ensure the application doesn't continue using the PCB. */
          TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
 800bea4:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800bea8:	2b00      	cmp	r3, #0
 800beaa:	d0df      	beq.n	800be6c <tcp_input+0x39c>
 800beac:	6938      	ldr	r0, [r7, #16]
 800beae:	f06f 010b 	mvn.w	r1, #11
 800beb2:	4798      	blx	r3
 800beb4:	e7da      	b.n	800be6c <tcp_input+0x39c>
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800beb6:	f8df e1f8 	ldr.w	lr, [pc, #504]	; 800c0b0 <tcp_input+0x5e0>
 800beba:	f8de 7000 	ldr.w	r7, [lr]
 800bebe:	2f00      	cmp	r7, #0
 800bec0:	f000 8176 	beq.w	800c1b0 <tcp_input+0x6e0>
 800bec4:	f8d6 c000 	ldr.w	ip, [r6]
          /* found an ANY-match */
          lpcb_any = lpcb;
          lpcb_prev = prev;
        }
#else /* SO_REUSE */
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
 800bec8:	f8d8 0000 	ldr.w	r0, [r8]
 800becc:	f8bc 2002 	ldrh.w	r2, [ip, #2]
 800bed0:	46b9      	mov	r9, r7
 800bed2:	2100      	movs	r1, #0
 800bed4:	e006      	b.n	800bee4 <tcp_input+0x414>
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800bed6:	f8d9 300c 	ldr.w	r3, [r9, #12]
 800beda:	4649      	mov	r1, r9
 800bedc:	2b00      	cmp	r3, #0
 800bede:	f000 8167 	beq.w	800c1b0 <tcp_input+0x6e0>
 800bee2:	4699      	mov	r9, r3
      if (lpcb->local_port == tcphdr->dest) {
 800bee4:	f8b9 301a 	ldrh.w	r3, [r9, #26]
 800bee8:	4293      	cmp	r3, r2
 800beea:	d1f4      	bne.n	800bed6 <tcp_input+0x406>
          /* found an ANY-match */
          lpcb_any = lpcb;
          lpcb_prev = prev;
        }
#else /* SO_REUSE */
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
 800beec:	f8d9 3000 	ldr.w	r3, [r9]
 800bef0:	4283      	cmp	r3, r0
 800bef2:	d001      	beq.n	800bef8 <tcp_input+0x428>
            ip_addr_isany(&(lpcb->local_ip))) {
 800bef4:	2b00      	cmp	r3, #0
 800bef6:	d1ee      	bne.n	800bed6 <tcp_input+0x406>
#endif /* SO_REUSE */
    if (lpcb != NULL) {
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
 800bef8:	b131      	cbz	r1, 800bf08 <tcp_input+0x438>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 800befa:	f8d9 300c 	ldr.w	r3, [r9, #12]
 800befe:	60cb      	str	r3, [r1, #12]
              /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
              /* put this listening pcb at the head of the listening list */
        tcp_listen_pcbs.listen_pcbs = lpcb;
 800bf00:	f8ce 9000 	str.w	r9, [lr]
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
              /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
 800bf04:	f8c9 700c 	str.w	r7, [r9, #12]
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
  struct tcp_pcb *npcb;
  err_t rc;

  if (flags & TCP_RST) {
 800bf08:	4b61      	ldr	r3, [pc, #388]	; (800c090 <tcp_input+0x5c0>)
 800bf0a:	781b      	ldrb	r3, [r3, #0]
 800bf0c:	0758      	lsls	r0, r3, #29
 800bf0e:	d48c      	bmi.n	800be2a <tcp_input+0x35a>
    return ERR_OK;
  }

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
 800bf10:	f003 0110 	and.w	r1, r3, #16
 800bf14:	f001 07ff 	and.w	r7, r1, #255	; 0xff
 800bf18:	2900      	cmp	r1, #0
 800bf1a:	f040 8312 	bne.w	800c542 <tcp_input+0xa72>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
 800bf1e:	0799      	lsls	r1, r3, #30
 800bf20:	d583      	bpl.n	800be2a <tcp_input+0x35a>
    if (pcb->accepts_pending >= pcb->backlog) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
 800bf22:	f899 0019 	ldrb.w	r0, [r9, #25]
 800bf26:	f7fe feab 	bl	800ac80 <tcp_alloc>
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
 800bf2a:	4682      	mov	sl, r0
 800bf2c:	2800      	cmp	r0, #0
 800bf2e:	f000 8300 	beq.w	800c532 <tcp_input+0xa62>
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
 800bf32:	6830      	ldr	r0, [r6, #0]
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
 800bf34:	4b57      	ldr	r3, [pc, #348]	; (800c094 <tcp_input+0x5c4>)
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
 800bf36:	7804      	ldrb	r4, [r0, #0]
 800bf38:	7846      	ldrb	r6, [r0, #1]
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
 800bf3a:	681b      	ldr	r3, [r3, #0]
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
 800bf3c:	4a53      	ldr	r2, [pc, #332]	; (800c08c <tcp_input+0x5bc>)
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
 800bf3e:	f8d8 1000 	ldr.w	r1, [r8]
    npcb->local_port = pcb->local_port;
 800bf42:	f8b9 e01a 	ldrh.w	lr, [r9, #26]
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
 800bf46:	6812      	ldr	r2, [r2, #0]
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
 800bf48:	f8ca 1000 	str.w	r1, [sl]
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
 800bf4c:	ea44 2106 	orr.w	r1, r4, r6, lsl #8
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
 800bf50:	1c5c      	adds	r4, r3, #1
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
 800bf52:	2603      	movs	r6, #3
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
 800bf54:	f8aa e01a 	strh.w	lr, [sl, #26]
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
 800bf58:	f8aa 101c 	strh.w	r1, [sl, #28]
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
 800bf5c:	f8ca 2004 	str.w	r2, [sl, #4]
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
 800bf60:	f8ca 4028 	str.w	r4, [sl, #40]	; 0x28
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 800bf64:	f8ca 4030 	str.w	r4, [sl, #48]	; 0x30
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
 800bf68:	f88a 6018 	strb.w	r6, [sl, #24]
    npcb->rcv_nxt = seqno + 1;
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    npcb->snd_wnd = tcphdr->wnd;
 800bf6c:	89c0      	ldrh	r0, [r0, #14]
    npcb->snd_wnd_max = tcphdr->wnd;
    npcb->ssthresh = npcb->snd_wnd;
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
    npcb->callback_arg = pcb->callback_arg;
 800bf6e:	f8d9 1010 	ldr.w	r1, [r9, #16]
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
 800bf72:	f8d9 2014 	ldr.w	r2, [r9, #20]
 800bf76:	f8ca 2014 	str.w	r2, [sl, #20]
    npcb->rcv_nxt = seqno + 1;
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    npcb->snd_wnd = tcphdr->wnd;
    npcb->snd_wnd_max = tcphdr->wnd;
    npcb->ssthresh = npcb->snd_wnd;
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 800bf7a:	3b01      	subs	r3, #1
    npcb->callback_arg = pcb->callback_arg;
 800bf7c:	f8ca 1010 	str.w	r1, [sl, #16]
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    npcb->snd_wnd = tcphdr->wnd;
 800bf80:	f8aa 0060 	strh.w	r0, [sl, #96]	; 0x60
    npcb->snd_wnd_max = tcphdr->wnd;
 800bf84:	f8aa 0062 	strh.w	r0, [sl, #98]	; 0x62
    npcb->ssthresh = npcb->snd_wnd;
 800bf88:	f8aa 004e 	strh.w	r0, [sl, #78]	; 0x4e
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 800bf8c:	f8ca 3054 	str.w	r3, [sl, #84]	; 0x54
    npcb->callback_arg = pcb->callback_arg;
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 800bf90:	f899 3008 	ldrb.w	r3, [r9, #8]
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
 800bf94:	4a42      	ldr	r2, [pc, #264]	; (800c0a0 <tcp_input+0x5d0>)
    npcb->callback_arg = pcb->callback_arg;
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 800bf96:	f023 0373 	bic.w	r3, r3, #115	; 0x73
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
 800bf9a:	6812      	ldr	r2, [r2, #0]
    npcb->callback_arg = pcb->callback_arg;
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 800bf9c:	f88a 3008 	strb.w	r3, [sl, #8]
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
 800bfa0:	4b3f      	ldr	r3, [pc, #252]	; (800c0a0 <tcp_input+0x5d0>)
 800bfa2:	f8ca 200c 	str.w	r2, [sl, #12]
 800bfa6:	f8c3 a000 	str.w	sl, [r3]
 800bfaa:	f002 ff81 	bl	800eeb0 <tcp_timer_needed>
 800bfae:	4b3d      	ldr	r3, [pc, #244]	; (800c0a4 <tcp_input+0x5d4>)
 800bfb0:	2201      	movs	r2, #1

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
 800bfb2:	f10a 0036 	add.w	r0, sl, #54	; 0x36
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
 800bfb6:	701a      	strb	r2, [r3, #0]

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
 800bfb8:	f7fe ff82 	bl	800aec0 <tcp_parseopt.isra.0>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
 800bfbc:	f10a 0104 	add.w	r1, sl, #4
 800bfc0:	f8ba 0036 	ldrh.w	r0, [sl, #54]	; 0x36
 800bfc4:	f7fe ff0c 	bl	800ade0 <tcp_eff_send_mss>
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 800bfc8:	2112      	movs	r1, #18
    TCP_REG_ACTIVE(npcb);

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
 800bfca:	f8aa 0036 	strh.w	r0, [sl, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 800bfce:	4650      	mov	r0, sl
 800bfd0:	f000 ff2e 	bl	800ce30 <tcp_enqueue_flags>
    if (rc != ERR_OK) {
 800bfd4:	2800      	cmp	r0, #0
 800bfd6:	f040 82a5 	bne.w	800c524 <tcp_input+0xa54>
      tcp_abandon(npcb, 0);
      return rc;
    }
    return tcp_output(npcb);
 800bfda:	4650      	mov	r0, sl
 800bfdc:	f001 f868 	bl	800d0b0 <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
 800bfe0:	4628      	mov	r0, r5
 800bfe2:	e59f      	b.n	800bb24 <tcp_input+0x54>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
    return ERR_OK;
  }
  
  if ((pcb->flags & TF_RXCLOSED) == 0) {
 800bfe4:	7fbb      	ldrb	r3, [r7, #30]
 800bfe6:	06dc      	lsls	r4, r3, #27
 800bfe8:	d402      	bmi.n	800bff0 <tcp_input+0x520>
    /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    pcb->tmr = tcp_ticks;
 800bfea:	4b2f      	ldr	r3, [pc, #188]	; (800c0a8 <tcp_input+0x5d8>)
 800bfec:	681b      	ldr	r3, [r3, #0]
 800bfee:	627b      	str	r3, [r7, #36]	; 0x24
  }
  pcb->keep_cnt_sent = 0;
 800bff0:	2300      	movs	r3, #0
 800bff2:	f887 3096 	strb.w	r3, [r7, #150]	; 0x96

  tcp_parseopt(pcb);
 800bff6:	f107 0036 	add.w	r0, r7, #54	; 0x36
 800bffa:	f7fe ff61 	bl	800aec0 <tcp_parseopt.isra.0>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
 800bffe:	7e3b      	ldrb	r3, [r7, #24]
 800c000:	3b02      	subs	r3, #2
 800c002:	2b07      	cmp	r3, #7
 800c004:	f63f af27 	bhi.w	800be56 <tcp_input+0x386>
 800c008:	e8df f003 	tbb	[pc, r3]
 800c00c:	738d9cbb 	.word	0x738d9cbb
 800c010:	04198d54 	.word	0x04198d54
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
 800c014:	4638      	mov	r0, r7
 800c016:	f7fe ffb3 	bl	800af80 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 800c01a:	4b1d      	ldr	r3, [pc, #116]	; (800c090 <tcp_input+0x5c0>)
 800c01c:	781b      	ldrb	r3, [r3, #0]
 800c01e:	06db      	lsls	r3, r3, #27
 800c020:	f57f af19 	bpl.w	800be56 <tcp_input+0x386>
 800c024:	f8da 3000 	ldr.w	r3, [sl]
 800c028:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800c02a:	429a      	cmp	r2, r3
 800c02c:	f47f af13 	bne.w	800be56 <tcp_input+0x386>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
 800c030:	f898 3000 	ldrb.w	r3, [r8]
 800c034:	f043 0310 	orr.w	r3, r3, #16
 800c038:	f888 3000 	strb.w	r3, [r8]
 800c03c:	e70b      	b.n	800be56 <tcp_input+0x386>
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
 800c03e:	4638      	mov	r0, r7
 800c040:	f7fe ff9e 	bl	800af80 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 800c044:	4b12      	ldr	r3, [pc, #72]	; (800c090 <tcp_input+0x5c0>)
 800c046:	781b      	ldrb	r3, [r3, #0]
 800c048:	06da      	lsls	r2, r3, #27
 800c04a:	f57f af04 	bpl.w	800be56 <tcp_input+0x386>
 800c04e:	f8da 3000 	ldr.w	r3, [sl]
 800c052:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800c054:	429a      	cmp	r2, r3
 800c056:	f47f aefe 	bne.w	800be56 <tcp_input+0x386>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
 800c05a:	4638      	mov	r0, r7
 800c05c:	f7fe f8c8 	bl	800a1f0 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 800c060:	4b0f      	ldr	r3, [pc, #60]	; (800c0a0 <tcp_input+0x5d0>)
 800c062:	681a      	ldr	r2, [r3, #0]
 800c064:	42ba      	cmp	r2, r7
 800c066:	f000 81dc 	beq.w	800c422 <tcp_input+0x952>
 800c06a:	4b10      	ldr	r3, [pc, #64]	; (800c0ac <tcp_input+0x5dc>)
 800c06c:	601a      	str	r2, [r3, #0]
 800c06e:	2a00      	cmp	r2, #0
 800c070:	f000 8208 	beq.w	800c484 <tcp_input+0x9b4>
 800c074:	68d1      	ldr	r1, [r2, #12]
 800c076:	42b9      	cmp	r1, r7
 800c078:	f000 8200 	beq.w	800c47c <tcp_input+0x9ac>
 800c07c:	460a      	mov	r2, r1
 800c07e:	e7f6      	b.n	800c06e <tcp_input+0x59e>
 800c080:	200180c8 	.word	0x200180c8
 800c084:	08016fe0 	.word	0x08016fe0
 800c088:	08017fa8 	.word	0x08017fa8
 800c08c:	2000cbac 	.word	0x2000cbac
 800c090:	2000cb80 	.word	0x2000cb80
 800c094:	2000cb70 	.word	0x2000cb70
 800c098:	2000cb78 	.word	0x2000cb78
 800c09c:	2000cb9c 	.word	0x2000cb9c
 800c0a0:	2000cb60 	.word	0x2000cb60
 800c0a4:	2000cb4c 	.word	0x2000cb4c
 800c0a8:	2000cb54 	.word	0x2000cb54
 800c0ac:	2000cb68 	.word	0x2000cb68
 800c0b0:	2000cb5c 	.word	0x2000cb5c
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
 800c0b4:	4638      	mov	r0, r7
 800c0b6:	f7fe ff63 	bl	800af80 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 800c0ba:	f898 3000 	ldrb.w	r3, [r8]
 800c0be:	0699      	lsls	r1, r3, #26
 800c0c0:	f57f aec9 	bpl.w	800be56 <tcp_input+0x386>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
 800c0c4:	7fbb      	ldrb	r3, [r7, #30]
 800c0c6:	f043 0302 	orr.w	r3, r3, #2
 800c0ca:	77bb      	strb	r3, [r7, #30]
      tcp_pcb_purge(pcb);
 800c0cc:	4638      	mov	r0, r7
 800c0ce:	f7fe f88f 	bl	800a1f0 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 800c0d2:	4b97      	ldr	r3, [pc, #604]	; (800c330 <tcp_input+0x860>)
 800c0d4:	681a      	ldr	r2, [r3, #0]
 800c0d6:	42ba      	cmp	r2, r7
 800c0d8:	f000 81a3 	beq.w	800c422 <tcp_input+0x952>
 800c0dc:	4b95      	ldr	r3, [pc, #596]	; (800c334 <tcp_input+0x864>)
 800c0de:	601a      	str	r2, [r3, #0]
 800c0e0:	2a00      	cmp	r2, #0
 800c0e2:	f000 81cf 	beq.w	800c484 <tcp_input+0x9b4>
 800c0e6:	68d1      	ldr	r1, [r2, #12]
 800c0e8:	42b9      	cmp	r1, r7
 800c0ea:	f000 81c7 	beq.w	800c47c <tcp_input+0x9ac>
 800c0ee:	460a      	mov	r2, r1
 800c0f0:	e7f6      	b.n	800c0e0 <tcp_input+0x610>
      tcp_ack_now(pcb);
      pcb->state = CLOSE_WAIT;
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
 800c0f2:	4638      	mov	r0, r7
 800c0f4:	f7fe ff44 	bl	800af80 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 800c0f8:	f898 3000 	ldrb.w	r3, [r8]
 800c0fc:	f013 0f20 	tst.w	r3, #32
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 800c100:	4b8d      	ldr	r3, [pc, #564]	; (800c338 <tcp_input+0x868>)
 800c102:	781b      	ldrb	r3, [r3, #0]
      pcb->state = CLOSE_WAIT;
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) {
 800c104:	f000 819b 	beq.w	800c43e <tcp_input+0x96e>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 800c108:	06dc      	lsls	r4, r3, #27
 800c10a:	d505      	bpl.n	800c118 <tcp_input+0x648>
 800c10c:	f8da 3000 	ldr.w	r3, [sl]
 800c110:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800c112:	429a      	cmp	r2, r3
 800c114:	f000 819f 	beq.w	800c456 <tcp_input+0x986>
        tcp_pcb_purge(pcb);
        TCP_RMV_ACTIVE(pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
 800c118:	7fbb      	ldrb	r3, [r7, #30]
        pcb->state = CLOSING;
 800c11a:	2208      	movs	r2, #8
        tcp_pcb_purge(pcb);
        TCP_RMV_ACTIVE(pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
 800c11c:	f043 0302 	orr.w	r3, r3, #2
 800c120:	77bb      	strb	r3, [r7, #30]
        pcb->state = CLOSING;
 800c122:	763a      	strb	r2, [r7, #24]
 800c124:	e697      	b.n	800be56 <tcp_input+0x386>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
 800c126:	4638      	mov	r0, r7
 800c128:	f7fe ff2a 	bl	800af80 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) { /* passive close */
 800c12c:	f898 3000 	ldrb.w	r3, [r8]
 800c130:	069e      	lsls	r6, r3, #26
 800c132:	f57f ae90 	bpl.w	800be56 <tcp_input+0x386>
      tcp_ack_now(pcb);
 800c136:	7fbb      	ldrb	r3, [r7, #30]
      pcb->state = CLOSE_WAIT;
 800c138:	2207      	movs	r2, #7
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) { /* passive close */
      tcp_ack_now(pcb);
 800c13a:	f043 0302 	orr.w	r3, r3, #2
 800c13e:	77bb      	strb	r3, [r7, #30]
      pcb->state = CLOSE_WAIT;
 800c140:	763a      	strb	r2, [r7, #24]
 800c142:	e688      	b.n	800be56 <tcp_input+0x386>
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
 800c144:	4b7c      	ldr	r3, [pc, #496]	; (800c338 <tcp_input+0x868>)
 800c146:	781b      	ldrb	r3, [r3, #0]
 800c148:	06d9      	lsls	r1, r3, #27
 800c14a:	f140 80bf 	bpl.w	800c2cc <tcp_input+0x7fc>
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 800c14e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800c150:	f8da 0000 	ldr.w	r0, [sl]
 800c154:	43db      	mvns	r3, r3
 800c156:	42c3      	cmn	r3, r0
 800c158:	d404      	bmi.n	800c164 <tcp_input+0x694>
 800c15a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800c15c:	1ac3      	subs	r3, r0, r3
 800c15e:	2b00      	cmp	r3, #0
 800c160:	f340 80c2 	ble.w	800c2e8 <tcp_input+0x818>
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 800c164:	4a75      	ldr	r2, [pc, #468]	; (800c33c <tcp_input+0x86c>)
                tcphdr->dest, tcphdr->src);
 800c166:	6833      	ldr	r3, [r6, #0]
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 800c168:	8811      	ldrh	r1, [r2, #0]
 800c16a:	4a75      	ldr	r2, [pc, #468]	; (800c340 <tcp_input+0x870>)
 800c16c:	885c      	ldrh	r4, [r3, #2]
 800c16e:	6812      	ldr	r2, [r2, #0]
 800c170:	9400      	str	r4, [sp, #0]
 800c172:	881b      	ldrh	r3, [r3, #0]
 800c174:	9301      	str	r3, [sp, #4]
 800c176:	4411      	add	r1, r2
 800c178:	4b72      	ldr	r3, [pc, #456]	; (800c344 <tcp_input+0x874>)
 800c17a:	4a73      	ldr	r2, [pc, #460]	; (800c348 <tcp_input+0x878>)
 800c17c:	f001 f938 	bl	800d3f0 <tcp_rst>
 800c180:	e669      	b.n	800be56 <tcp_input+0x386>
  switch (pcb->state) {
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
 800c182:	4b6d      	ldr	r3, [pc, #436]	; (800c338 <tcp_input+0x868>)
 800c184:	781b      	ldrb	r3, [r3, #0]
 800c186:	f003 0312 	and.w	r3, r3, #18
 800c18a:	2b12      	cmp	r3, #18
 800c18c:	f000 80e8 	beq.w	800c360 <tcp_input+0x890>
        return ERR_ABRT;
      }
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
 800c190:	4b69      	ldr	r3, [pc, #420]	; (800c338 <tcp_input+0x868>)
 800c192:	781b      	ldrb	r3, [r3, #0]
 800c194:	06d8      	lsls	r0, r3, #27
 800c196:	f57f ae5e 	bpl.w	800be56 <tcp_input+0x386>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 800c19a:	4a68      	ldr	r2, [pc, #416]	; (800c33c <tcp_input+0x86c>)
        tcphdr->dest, tcphdr->src);
 800c19c:	6833      	ldr	r3, [r6, #0]
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 800c19e:	8811      	ldrh	r1, [r2, #0]
 800c1a0:	4a67      	ldr	r2, [pc, #412]	; (800c340 <tcp_input+0x870>)
 800c1a2:	8858      	ldrh	r0, [r3, #2]
 800c1a4:	6812      	ldr	r2, [r2, #0]
 800c1a6:	9000      	str	r0, [sp, #0]
 800c1a8:	881b      	ldrh	r3, [r3, #0]
 800c1aa:	f8da 0000 	ldr.w	r0, [sl]
 800c1ae:	e7e1      	b.n	800c174 <tcp_input+0x6a4>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 800c1b0:	6833      	ldr	r3, [r6, #0]
 800c1b2:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 800c35c <tcp_input+0x88c>
 800c1b6:	8998      	ldrh	r0, [r3, #12]
 800c1b8:	f002 fdfa 	bl	800edb0 <lwip_ntohs>
 800c1bc:	0743      	lsls	r3, r0, #29
 800c1be:	f53f ae34 	bmi.w	800be2a <tcp_input+0x35a>
      TCP_STATS_INC(tcp.proterr);
 800c1c2:	f8b4 70a0 	ldrh.w	r7, [r4, #160]	; 0xa0
      TCP_STATS_INC(tcp.drop);
 800c1c6:	f8b4 6096 	ldrh.w	r6, [r4, #150]	; 0x96
      tcp_rst(ackno, seqno + tcplen,
 800c1ca:	4b5c      	ldr	r3, [pc, #368]	; (800c33c <tcp_input+0x86c>)
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
 800c1cc:	f8d8 e000 	ldr.w	lr, [r8]
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
 800c1d0:	f8b3 c000 	ldrh.w	ip, [r3]
 800c1d4:	4b5a      	ldr	r3, [pc, #360]	; (800c340 <tcp_input+0x870>)
 800c1d6:	f8da 0000 	ldr.w	r0, [sl]
 800c1da:	6819      	ldr	r1, [r3, #0]
 800c1dc:	4a5a      	ldr	r2, [pc, #360]	; (800c348 <tcp_input+0x878>)
 800c1de:	4b59      	ldr	r3, [pc, #356]	; (800c344 <tcp_input+0x874>)

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
 800c1e0:	3701      	adds	r7, #1
      TCP_STATS_INC(tcp.drop);
 800c1e2:	3601      	adds	r6, #1

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
 800c1e4:	f8a4 70a0 	strh.w	r7, [r4, #160]	; 0xa0
      TCP_STATS_INC(tcp.drop);
 800c1e8:	f8a4 6096 	strh.w	r6, [r4, #150]	; 0x96
      tcp_rst(ackno, seqno + tcplen,
 800c1ec:	f8be 4002 	ldrh.w	r4, [lr, #2]
 800c1f0:	9400      	str	r4, [sp, #0]
 800c1f2:	f8be 4000 	ldrh.w	r4, [lr]
 800c1f6:	9401      	str	r4, [sp, #4]
 800c1f8:	4461      	add	r1, ip
 800c1fa:	f001 f8f9 	bl	800d3f0 <tcp_rst>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
 800c1fe:	4628      	mov	r0, r5
 800c200:	e490      	b.n	800bb24 <tcp_input+0x54>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
 800c202:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 800c206:	b13a      	cbz	r2, 800c218 <tcp_input+0x748>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
 800c208:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800c20a:	b12b      	cbz	r3, 800c218 <tcp_input+0x748>
 800c20c:	6938      	ldr	r0, [r7, #16]
 800c20e:	4639      	mov	r1, r7
 800c210:	4798      	blx	r3
          if (err == ERR_ABRT) {
 800c212:	300a      	adds	r0, #10
 800c214:	f43f ad71 	beq.w	800bcfa <tcp_input+0x22a>
            goto aborted;
          }
        }

        if (recv_data != NULL) {
 800c218:	f8d9 3000 	ldr.w	r3, [r9]
 800c21c:	b323      	cbz	r3, 800c268 <tcp_input+0x798>
          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
 800c21e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800c220:	b15b      	cbz	r3, 800c23a <tcp_input+0x76a>
 800c222:	4b4a      	ldr	r3, [pc, #296]	; (800c34c <tcp_input+0x87c>)
 800c224:	9300      	str	r3, [sp, #0]
 800c226:	484a      	ldr	r0, [pc, #296]	; (800c350 <tcp_input+0x880>)
 800c228:	494a      	ldr	r1, [pc, #296]	; (800c354 <tcp_input+0x884>)
 800c22a:	4a4b      	ldr	r2, [pc, #300]	; (800c358 <tcp_input+0x888>)
 800c22c:	f44f 73aa 	mov.w	r3, #340	; 0x154
 800c230:	f7fe fe8e 	bl	800af50 <chprintf.constprop.1>
 800c234:	4848      	ldr	r0, [pc, #288]	; (800c358 <tcp_input+0x888>)
 800c236:	f7f4 fe9b 	bl	8000f70 <chSysHalt>
          if (pcb->flags & TF_RXCLOSED) {
 800c23a:	7fba      	ldrb	r2, [r7, #30]
 800c23c:	f002 0210 	and.w	r2, r2, #16
 800c240:	f002 03ff 	and.w	r3, r2, #255	; 0xff
 800c244:	2a00      	cmp	r2, #0
 800c246:	d139      	bne.n	800c2bc <tcp_input+0x7ec>
            tcp_abort(pcb);
            goto aborted;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 800c248:	f8d7 4080 	ldr.w	r4, [r7, #128]	; 0x80
 800c24c:	b374      	cbz	r4, 800c2ac <tcp_input+0x7dc>
 800c24e:	6938      	ldr	r0, [r7, #16]
 800c250:	f8d9 2000 	ldr.w	r2, [r9]
 800c254:	4639      	mov	r1, r7
 800c256:	47a0      	blx	r4
          if (err == ERR_ABRT) {
 800c258:	b243      	sxtb	r3, r0
 800c25a:	330a      	adds	r3, #10
 800c25c:	f43f ad4d 	beq.w	800bcfa <tcp_input+0x22a>
            goto aborted;
          }

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
 800c260:	b110      	cbz	r0, 800c268 <tcp_input+0x798>
            pcb->refused_data = recv_data;
 800c262:	f8d9 3000 	ldr.w	r3, [r9]
 800c266:	67bb      	str	r3, [r7, #120]	; 0x78
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
 800c268:	f898 3000 	ldrb.w	r3, [r8]
 800c26c:	0699      	lsls	r1, r3, #26
 800c26e:	d506      	bpl.n	800c27e <tcp_input+0x7ae>
          if (pcb->refused_data != NULL) {
 800c270:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800c272:	2b00      	cmp	r3, #0
 800c274:	d048      	beq.n	800c308 <tcp_input+0x838>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
 800c276:	7b5a      	ldrb	r2, [r3, #13]
 800c278:	f042 0220 	orr.w	r2, r2, #32
 800c27c:	735a      	strb	r2, [r3, #13]
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
 800c27e:	2300      	movs	r3, #0
        /* Try to send something out. */
        tcp_output(pcb);
 800c280:	4638      	mov	r0, r7
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
 800c282:	602b      	str	r3, [r5, #0]
        /* Try to send something out. */
        tcp_output(pcb);
 800c284:	f000 ff14 	bl	800d0b0 <tcp_output>
 800c288:	e537      	b.n	800bcfa <tcp_input+0x22a>

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
      if (ackno == pcb->snd_nxt) {
 800c28a:	f8da 3000 	ldr.w	r3, [sl]
 800c28e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800c290:	429a      	cmp	r2, r3
 800c292:	f47f ade0 	bne.w	800be56 <tcp_input+0x386>
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
 800c296:	f898 2000 	ldrb.w	r2, [r8]
      pcb->flags &= ~TF_ACK_DELAY;
 800c29a:	7fbb      	ldrb	r3, [r7, #30]
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
 800c29c:	f042 0208 	orr.w	r2, r2, #8
      pcb->flags &= ~TF_ACK_DELAY;
 800c2a0:	f023 0301 	bic.w	r3, r3, #1
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
 800c2a4:	f888 2000 	strb.w	r2, [r8]
      pcb->flags &= ~TF_ACK_DELAY;
 800c2a8:	77bb      	strb	r3, [r7, #30]
 800c2aa:	e5d4      	b.n	800be56 <tcp_input+0x386>
            tcp_abort(pcb);
            goto aborted;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 800c2ac:	4620      	mov	r0, r4
 800c2ae:	4623      	mov	r3, r4
 800c2b0:	4639      	mov	r1, r7
 800c2b2:	f8d9 2000 	ldr.w	r2, [r9]
 800c2b6:	f7fe fb8b 	bl	800a9d0 <tcp_recv_null>
 800c2ba:	e7cd      	b.n	800c258 <tcp_input+0x788>
        if (recv_data != NULL) {
          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
          if (pcb->flags & TF_RXCLOSED) {
            /* received data although already closed -> abort (send RST) to
               notify the remote host that not all data has been processed */
            pbuf_free(recv_data);
 800c2bc:	f8d9 0000 	ldr.w	r0, [r9]
 800c2c0:	f7fd f89e 	bl	8009400 <pbuf_free>
            tcp_abort(pcb);
 800c2c4:	4638      	mov	r0, r7
 800c2c6:	f7fe fcd3 	bl	800ac70 <tcp_abort>
            goto aborted;
 800c2ca:	e516      	b.n	800bcfa <tcp_input+0x22a>
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
                tcphdr->dest, tcphdr->src);
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 800c2cc:	079b      	lsls	r3, r3, #30
 800c2ce:	f57f adc2 	bpl.w	800be56 <tcp_input+0x386>
 800c2d2:	4a1b      	ldr	r2, [pc, #108]	; (800c340 <tcp_input+0x870>)
 800c2d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c2d6:	6812      	ldr	r2, [r2, #0]
 800c2d8:	3b01      	subs	r3, #1
 800c2da:	4293      	cmp	r3, r2
 800c2dc:	f47f adbb 	bne.w	800be56 <tcp_input+0x386>
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
 800c2e0:	4638      	mov	r0, r7
 800c2e2:	f001 f90d 	bl	800d500 <tcp_rexmit>
 800c2e6:	e5b6      	b.n	800be56 <tcp_input+0x386>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
 800c2e8:	697b      	ldr	r3, [r7, #20]
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
 800c2ea:	2204      	movs	r2, #4
 800c2ec:	763a      	strb	r2, [r7, #24]
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
 800c2ee:	2b00      	cmp	r3, #0
 800c2f0:	f000 80f9 	beq.w	800c4e6 <tcp_input+0xa16>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
 800c2f4:	6938      	ldr	r0, [r7, #16]
 800c2f6:	4639      	mov	r1, r7
 800c2f8:	2200      	movs	r2, #0
 800c2fa:	4798      	blx	r3
        if (err != ERR_OK) {
 800c2fc:	2800      	cmp	r0, #0
 800c2fe:	f000 80da 	beq.w	800c4b6 <tcp_input+0x9e6>
          /* If the accept function returns with an error, we abort
           * the connection. */
          /* Already aborted? */
          if (err != ERR_ABRT) {
 800c302:	300a      	adds	r0, #10
 800c304:	d1de      	bne.n	800c2c4 <tcp_input+0x7f4>
 800c306:	e4f8      	b.n	800bcfa <tcp_input+0x22a>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND) {
 800c308:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
              pcb->rcv_wnd++;
            }
            TCP_EVENT_CLOSED(pcb, err);
 800c30a:	f8d7 4080 	ldr.w	r4, [r7, #128]	; 0x80
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND) {
 800c30e:	f241 62d0 	movw	r2, #5840	; 0x16d0
 800c312:	4293      	cmp	r3, r2
              pcb->rcv_wnd++;
 800c314:	bf1c      	itt	ne
 800c316:	3301      	addne	r3, #1
 800c318:	85bb      	strhne	r3, [r7, #44]	; 0x2c
            }
            TCP_EVENT_CLOSED(pcb, err);
 800c31a:	2c00      	cmp	r4, #0
 800c31c:	d0af      	beq.n	800c27e <tcp_input+0x7ae>
 800c31e:	2200      	movs	r2, #0
 800c320:	4613      	mov	r3, r2
 800c322:	6938      	ldr	r0, [r7, #16]
 800c324:	4639      	mov	r1, r7
 800c326:	47a0      	blx	r4
            if (err == ERR_ABRT) {
 800c328:	300a      	adds	r0, #10
 800c32a:	d1a8      	bne.n	800c27e <tcp_input+0x7ae>
 800c32c:	e4e5      	b.n	800bcfa <tcp_input+0x22a>
 800c32e:	bf00      	nop
 800c330:	2000cb60 	.word	0x2000cb60
 800c334:	2000cb68 	.word	0x2000cb68
 800c338:	2000cb80 	.word	0x2000cb80
 800c33c:	2000cb78 	.word	0x2000cb78
 800c340:	2000cb70 	.word	0x2000cb70
 800c344:	2000cbac 	.word	0x2000cbac
 800c348:	2000cbb0 	.word	0x2000cbb0
 800c34c:	08017d5c 	.word	0x08017d5c
 800c350:	200180c8 	.word	0x200180c8
 800c354:	08016fe0 	.word	0x08016fe0
 800c358:	08018024 	.word	0x08018024
 800c35c:	2000cb84 	.word	0x2000cb84
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
 800c360:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c362:	68db      	ldr	r3, [r3, #12]
 800c364:	6858      	ldr	r0, [r3, #4]
 800c366:	f002 fd33 	bl	800edd0 <lwip_ntohl>
 800c36a:	f8da 3000 	ldr.w	r3, [sl]
 800c36e:	3001      	adds	r0, #1
 800c370:	4298      	cmp	r0, r3
 800c372:	f47f af0d 	bne.w	800c190 <tcp_input+0x6c0>
      pcb->snd_buf++;
      pcb->rcv_nxt = seqno + 1;
 800c376:	4b90      	ldr	r3, [pc, #576]	; (800c5b8 <tcp_input+0xae8>)
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
 800c378:	f8b7 2066 	ldrh.w	r2, [r7, #102]	; 0x66
      pcb->rcv_nxt = seqno + 1;
 800c37c:	681b      	ldr	r3, [r3, #0]
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
      pcb->snd_wnd = tcphdr->wnd;
 800c37e:	6834      	ldr	r4, [r6, #0]
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
      pcb->rcv_nxt = seqno + 1;
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
 800c380:	64b8      	str	r0, [r7, #72]	; 0x48
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
      pcb->rcv_nxt = seqno + 1;
 800c382:	1c59      	adds	r1, r3, #1
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
 800c384:	3201      	adds	r2, #1
      pcb->rcv_nxt = seqno + 1;
 800c386:	62b9      	str	r1, [r7, #40]	; 0x28
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 800c388:	6339      	str	r1, [r7, #48]	; 0x30
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
 800c38a:	f8a7 2066 	strh.w	r2, [r7, #102]	; 0x66
      pcb->rcv_nxt = seqno + 1;
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
      pcb->snd_wnd = tcphdr->wnd;
 800c38e:	89e2      	ldrh	r2, [r4, #14]
 800c390:	f8a7 2060 	strh.w	r2, [r7, #96]	; 0x60
      pcb->snd_wnd_max = tcphdr->wnd;
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 800c394:	3b01      	subs	r3, #1
      pcb->state = ESTABLISHED;
 800c396:	2104      	movs	r1, #4
      pcb->rcv_nxt = seqno + 1;
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
      pcb->snd_wnd = tcphdr->wnd;
      pcb->snd_wnd_max = tcphdr->wnd;
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 800c398:	657b      	str	r3, [r7, #84]	; 0x54
      pcb->snd_buf++;
      pcb->rcv_nxt = seqno + 1;
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
      pcb->snd_wnd = tcphdr->wnd;
      pcb->snd_wnd_max = tcphdr->wnd;
 800c39a:	f8a7 2062 	strh.w	r2, [r7, #98]	; 0x62
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
      pcb->state = ESTABLISHED;
 800c39e:	7639      	strb	r1, [r7, #24]

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
 800c3a0:	8ef8      	ldrh	r0, [r7, #54]	; 0x36
 800c3a2:	1879      	adds	r1, r7, r1
 800c3a4:	f7fe fd1c 	bl	800ade0 <tcp_eff_send_mss>

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 800c3a8:	f8b7 204c 	ldrh.w	r2, [r7, #76]	; 0x4c
      pcb->snd_wnd_max = tcphdr->wnd;
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
      pcb->state = ESTABLISHED;

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
 800c3ac:	86f8      	strh	r0, [r7, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
 800c3ae:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 800c3b2:	005b      	lsls	r3, r3, #1

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 800c3b4:	2a01      	cmp	r2, #1
 800c3b6:	bf08      	it	eq
 800c3b8:	0040      	lsleq	r0, r0, #1
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
 800c3ba:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
 800c3be:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 800c3c2:	bf08      	it	eq
 800c3c4:	b280      	uxtheq	r0, r0
 800c3c6:	f8a7 004c 	strh.w	r0, [r7, #76]	; 0x4c
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
 800c3ca:	b95b      	cbnz	r3, 800c3e4 <tcp_input+0x914>
 800c3cc:	4b7b      	ldr	r3, [pc, #492]	; (800c5bc <tcp_input+0xaec>)
 800c3ce:	9300      	str	r3, [sp, #0]
 800c3d0:	487b      	ldr	r0, [pc, #492]	; (800c5c0 <tcp_input+0xaf0>)
 800c3d2:	497c      	ldr	r1, [pc, #496]	; (800c5c4 <tcp_input+0xaf4>)
 800c3d4:	4a7c      	ldr	r2, [pc, #496]	; (800c5c8 <tcp_input+0xaf8>)
 800c3d6:	f44f 7323 	mov.w	r3, #652	; 0x28c
 800c3da:	f7fe fdb9 	bl	800af50 <chprintf.constprop.1>
 800c3de:	487a      	ldr	r0, [pc, #488]	; (800c5c8 <tcp_input+0xaf8>)
 800c3e0:	f7f4 fdc6 	bl	8000f70 <chSysHalt>
      --pcb->snd_queuelen;
 800c3e4:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
 800c3e8:	6f38      	ldr	r0, [r7, #112]	; 0x70
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
      --pcb->snd_queuelen;
 800c3ea:	3b01      	subs	r3, #1
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
      pcb->unacked = rseg->next;
 800c3ec:	6802      	ldr	r2, [r0, #0]
 800c3ee:	673a      	str	r2, [r7, #112]	; 0x70
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
      --pcb->snd_queuelen;
 800c3f0:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
      pcb->unacked = rseg->next;
      tcp_seg_free(rseg);
 800c3f4:	f7fd fe14 	bl	800a020 <tcp_seg_free>

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
 800c3f8:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c3fa:	2b00      	cmp	r3, #0
 800c3fc:	f000 80d8 	beq.w	800c5b0 <tcp_input+0xae0>
        pcb->rtime = -1;
      else {
        pcb->rtime = 0;
 800c400:	2300      	movs	r3, #0
 800c402:	86bb      	strh	r3, [r7, #52]	; 0x34
        pcb->nrtx = 0;
 800c404:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
      }

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 800c408:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800c40c:	2b00      	cmp	r3, #0
 800c40e:	f43f ad3e 	beq.w	800be8e <tcp_input+0x3be>
 800c412:	6938      	ldr	r0, [r7, #16]
 800c414:	4639      	mov	r1, r7
 800c416:	2200      	movs	r2, #0
 800c418:	4798      	blx	r3
      if (err == ERR_ABRT) {
 800c41a:	300a      	adds	r0, #10
 800c41c:	f47f ad37 	bne.w	800be8e <tcp_input+0x3be>
 800c420:	e46b      	b.n	800bcfa <tcp_input+0x22a>
  case CLOSING:
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 800c422:	68fa      	ldr	r2, [r7, #12]
 800c424:	601a      	str	r2, [r3, #0]
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
 800c426:	4b69      	ldr	r3, [pc, #420]	; (800c5cc <tcp_input+0xafc>)
  case CLOSING:
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 800c428:	4a69      	ldr	r2, [pc, #420]	; (800c5d0 <tcp_input+0xb00>)
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
 800c42a:	6819      	ldr	r1, [r3, #0]
 800c42c:	60f9      	str	r1, [r7, #12]
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      pcb->state = TIME_WAIT;
 800c42e:	200a      	movs	r0, #10
  case CLOSING:
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 800c430:	2101      	movs	r1, #1
      pcb->state = TIME_WAIT;
 800c432:	7638      	strb	r0, [r7, #24]
      TCP_REG(&tcp_tw_pcbs, pcb);
 800c434:	601f      	str	r7, [r3, #0]
  case CLOSING:
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 800c436:	7011      	strb	r1, [r2, #0]
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
 800c438:	f002 fd3a 	bl	800eeb0 <tcp_timer_needed>
 800c43c:	e50b      	b.n	800be56 <tcp_input+0x386>
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 800c43e:	06d8      	lsls	r0, r3, #27
 800c440:	f57f ad09 	bpl.w	800be56 <tcp_input+0x386>
 800c444:	f8da 3000 	ldr.w	r3, [sl]
 800c448:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800c44a:	429a      	cmp	r2, r3
 800c44c:	f47f ad03 	bne.w	800be56 <tcp_input+0x386>
      pcb->state = FIN_WAIT_2;
 800c450:	2306      	movs	r3, #6
 800c452:	763b      	strb	r3, [r7, #24]
 800c454:	e4ff      	b.n	800be56 <tcp_input+0x386>
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) {
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
 800c456:	7fbb      	ldrb	r3, [r7, #30]
 800c458:	f043 0302 	orr.w	r3, r3, #2
 800c45c:	77bb      	strb	r3, [r7, #30]
        tcp_pcb_purge(pcb);
 800c45e:	4638      	mov	r0, r7
 800c460:	f7fd fec6 	bl	800a1f0 <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 800c464:	4b5b      	ldr	r3, [pc, #364]	; (800c5d4 <tcp_input+0xb04>)
 800c466:	681a      	ldr	r2, [r3, #0]
 800c468:	42ba      	cmp	r2, r7
 800c46a:	d0da      	beq.n	800c422 <tcp_input+0x952>
 800c46c:	4b5a      	ldr	r3, [pc, #360]	; (800c5d8 <tcp_input+0xb08>)
 800c46e:	601a      	str	r2, [r3, #0]
 800c470:	b142      	cbz	r2, 800c484 <tcp_input+0x9b4>
 800c472:	68d1      	ldr	r1, [r2, #12]
 800c474:	42b9      	cmp	r1, r7
 800c476:	d001      	beq.n	800c47c <tcp_input+0x9ac>
 800c478:	460a      	mov	r2, r1
 800c47a:	e7f9      	b.n	800c470 <tcp_input+0x9a0>
  case CLOSING:
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 800c47c:	68f9      	ldr	r1, [r7, #12]
 800c47e:	601a      	str	r2, [r3, #0]
 800c480:	60d1      	str	r1, [r2, #12]
 800c482:	e7d0      	b.n	800c426 <tcp_input+0x956>
 800c484:	601a      	str	r2, [r3, #0]
 800c486:	e7ce      	b.n	800c426 <tcp_input+0x956>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
      return ERR_OK;
    }
  } else if (flags & TCP_FIN) {
 800c488:	07cc      	lsls	r4, r1, #31
 800c48a:	f57f acc9 	bpl.w	800be20 <tcp_input+0x350>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
 800c48e:	4b53      	ldr	r3, [pc, #332]	; (800c5dc <tcp_input+0xb0c>)
 800c490:	681b      	ldr	r3, [r3, #0]
 800c492:	627b      	str	r3, [r7, #36]	; 0x24
 800c494:	e4c4      	b.n	800be20 <tcp_input+0x350>
      }
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
 800c496:	2a00      	cmp	r2, #0
 800c498:	f47f aefd 	bne.w	800c296 <tcp_input+0x7c6>
 800c49c:	4b47      	ldr	r3, [pc, #284]	; (800c5bc <tcp_input+0xaec>)
 800c49e:	9300      	str	r3, [sp, #0]
 800c4a0:	4948      	ldr	r1, [pc, #288]	; (800c5c4 <tcp_input+0xaf4>)
 800c4a2:	4a4f      	ldr	r2, [pc, #316]	; (800c5e0 <tcp_input+0xb10>)
 800c4a4:	4846      	ldr	r0, [pc, #280]	; (800c5c0 <tcp_input+0xaf0>)
 800c4a6:	f240 2357 	movw	r3, #599	; 0x257
 800c4aa:	f7fe fd51 	bl	800af50 <chprintf.constprop.1>
 800c4ae:	484c      	ldr	r0, [pc, #304]	; (800c5e0 <tcp_input+0xb10>)
 800c4b0:	f7f4 fd5e 	bl	8000f70 <chSysHalt>
 800c4b4:	e6ef      	b.n	800c296 <tcp_input+0x7c6>
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
 800c4b6:	4638      	mov	r0, r7
          if (err != ERR_ABRT) {
            tcp_abort(pcb);
          }
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
 800c4b8:	f8b7 404c 	ldrh.w	r4, [r7, #76]	; 0x4c
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
 800c4bc:	f7fe fd60 	bl	800af80 <tcp_receive>

        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
 800c4c0:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 800c4c4:	b113      	cbz	r3, 800c4cc <tcp_input+0x9fc>
          pcb->acked--;
 800c4c6:	3b01      	subs	r3, #1
 800c4c8:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 800c4cc:	8efb      	ldrh	r3, [r7, #54]	; 0x36

        if (recv_flags & TF_GOT_FIN) {
 800c4ce:	f898 2000 	ldrb.w	r2, [r8]
        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
          pcb->acked--;
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 800c4d2:	2c01      	cmp	r4, #1
 800c4d4:	bf04      	itt	eq
 800c4d6:	005b      	lsleq	r3, r3, #1
 800c4d8:	b29b      	uxtheq	r3, r3

        if (recv_flags & TF_GOT_FIN) {
 800c4da:	0692      	lsls	r2, r2, #26
        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
          pcb->acked--;
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 800c4dc:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c

        if (recv_flags & TF_GOT_FIN) {
 800c4e0:	f57f acb9 	bpl.w	800be56 <tcp_input+0x386>
 800c4e4:	e627      	b.n	800c136 <tcp_input+0x666>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
 800c4e6:	4b35      	ldr	r3, [pc, #212]	; (800c5bc <tcp_input+0xaec>)
 800c4e8:	9300      	str	r3, [sp, #0]
 800c4ea:	4936      	ldr	r1, [pc, #216]	; (800c5c4 <tcp_input+0xaf4>)
 800c4ec:	4a3d      	ldr	r2, [pc, #244]	; (800c5e4 <tcp_input+0xb14>)
 800c4ee:	4834      	ldr	r0, [pc, #208]	; (800c5c0 <tcp_input+0xaf0>)
 800c4f0:	f240 23b3 	movw	r3, #691	; 0x2b3
 800c4f4:	f7fe fd2c 	bl	800af50 <chprintf.constprop.1>
 800c4f8:	483a      	ldr	r0, [pc, #232]	; (800c5e4 <tcp_input+0xb14>)
 800c4fa:	f7f4 fd39 	bl	8000f70 <chSysHalt>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
 800c4fe:	697b      	ldr	r3, [r7, #20]
 800c500:	2b00      	cmp	r3, #0
 800c502:	f47f aef7 	bne.w	800c2f4 <tcp_input+0x824>
 800c506:	e6dd      	b.n	800c2c4 <tcp_input+0x7f4>
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 800c508:	4837      	ldr	r0, [pc, #220]	; (800c5e8 <tcp_input+0xb18>)
 800c50a:	8800      	ldrh	r0, [r0, #0]
 800c50c:	9201      	str	r2, [sp, #4]
 800c50e:	f8cd e000 	str.w	lr, [sp]
 800c512:	4401      	add	r1, r0
 800c514:	4a35      	ldr	r2, [pc, #212]	; (800c5ec <tcp_input+0xb1c>)
 800c516:	f8da 0000 	ldr.w	r0, [sl]
 800c51a:	f000 ff69 	bl	800d3f0 <tcp_rst>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
 800c51e:	4628      	mov	r0, r5
 800c520:	f7ff bb00 	b.w	800bb24 <tcp_input+0x54>
    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
    if (rc != ERR_OK) {
      tcp_abandon(npcb, 0);
 800c524:	4650      	mov	r0, sl
 800c526:	4639      	mov	r1, r7
 800c528:	f7fe fb22 	bl	800ab70 <tcp_abandon>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
 800c52c:	4628      	mov	r0, r5
 800c52e:	f7ff baf9 	b.w	800bb24 <tcp_input+0x54>
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
 800c532:	f8b4 309c 	ldrh.w	r3, [r4, #156]	; 0x9c
 800c536:	3301      	adds	r3, #1
 800c538:	f8a4 309c 	strh.w	r3, [r4, #156]	; 0x9c
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
 800c53c:	4628      	mov	r0, r5
 800c53e:	f7ff baf1 	b.w	800bb24 <tcp_input+0x54>
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 800c542:	4b29      	ldr	r3, [pc, #164]	; (800c5e8 <tcp_input+0xb18>)
 800c544:	9200      	str	r2, [sp, #0]
 800c546:	8819      	ldrh	r1, [r3, #0]
 800c548:	4b1b      	ldr	r3, [pc, #108]	; (800c5b8 <tcp_input+0xae8>)
 800c54a:	f8bc 2000 	ldrh.w	r2, [ip]
 800c54e:	681b      	ldr	r3, [r3, #0]
 800c550:	9201      	str	r2, [sp, #4]
 800c552:	4419      	add	r1, r3
 800c554:	f8da 0000 	ldr.w	r0, [sl]
 800c558:	4a24      	ldr	r2, [pc, #144]	; (800c5ec <tcp_input+0xb1c>)
 800c55a:	4b25      	ldr	r3, [pc, #148]	; (800c5f0 <tcp_input+0xb20>)
 800c55c:	f000 ff48 	bl	800d3f0 <tcp_rst>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
 800c560:	4628      	mov	r0, r5
 800c562:	f7ff badf 	b.w	800bb24 <tcp_input+0x54>
      if (prev != NULL) {
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
 800c566:	4b15      	ldr	r3, [pc, #84]	; (800c5bc <tcp_input+0xaec>)
 800c568:	9300      	str	r3, [sp, #0]
 800c56a:	4916      	ldr	r1, [pc, #88]	; (800c5c4 <tcp_input+0xaf4>)
 800c56c:	4a21      	ldr	r2, [pc, #132]	; (800c5f4 <tcp_input+0xb24>)
 800c56e:	4814      	ldr	r0, [pc, #80]	; (800c5c0 <tcp_input+0xaf0>)
 800c570:	23bc      	movs	r3, #188	; 0xbc
 800c572:	f7fe fced 	bl	800af50 <chprintf.constprop.1>
 800c576:	481f      	ldr	r0, [pc, #124]	; (800c5f4 <tcp_input+0xb24>)
 800c578:	f7f4 fcfa 	bl	8000f70 <chSysHalt>
 800c57c:	f7ff bb87 	b.w	800bc8e <tcp_input+0x1be>
    pcb->tmr = tcp_ticks;
  }

  if ((tcplen > 0))  {
    /* Acknowledge data, FIN or out-of-window SYN */
    pcb->flags |= TF_ACK_NOW;
 800c580:	7fbb      	ldrb	r3, [r7, #30]
 800c582:	f043 0302 	orr.w	r3, r3, #2
 800c586:	77bb      	strb	r3, [r7, #30]
    return tcp_output(pcb);
 800c588:	4638      	mov	r0, r7
 800c58a:	f000 fd91 	bl	800d0b0 <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
 800c58e:	4628      	mov	r0, r5
 800c590:	f7ff bac8 	b.w	800bb24 <tcp_input+0x54>
       ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 800c594:	4b09      	ldr	r3, [pc, #36]	; (800c5bc <tcp_input+0xaec>)
 800c596:	9300      	str	r3, [sp, #0]
 800c598:	490a      	ldr	r1, [pc, #40]	; (800c5c4 <tcp_input+0xaf4>)
 800c59a:	4a17      	ldr	r2, [pc, #92]	; (800c5f8 <tcp_input+0xb28>)
 800c59c:	4808      	ldr	r0, [pc, #32]	; (800c5c0 <tcp_input+0xaf0>)
 800c59e:	23b6      	movs	r3, #182	; 0xb6
 800c5a0:	f7fe fcd6 	bl	800af50 <chprintf.constprop.1>
 800c5a4:	4814      	ldr	r0, [pc, #80]	; (800c5f8 <tcp_input+0xb28>)
 800c5a6:	f7f4 fce3 	bl	8000f70 <chSysHalt>
 800c5aa:	68fb      	ldr	r3, [r7, #12]
 800c5ac:	f7ff bb61 	b.w	800bc72 <tcp_input+0x1a2>
      tcp_seg_free(rseg);

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
        pcb->rtime = -1;
 800c5b0:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800c5b4:	86bb      	strh	r3, [r7, #52]	; 0x34
 800c5b6:	e727      	b.n	800c408 <tcp_input+0x938>
 800c5b8:	2000cb70 	.word	0x2000cb70
 800c5bc:	08017d5c 	.word	0x08017d5c
 800c5c0:	200180c8 	.word	0x200180c8
 800c5c4:	08016fe0 	.word	0x08016fe0
 800c5c8:	08017ff8 	.word	0x08017ff8
 800c5cc:	2000cb50 	.word	0x2000cb50
 800c5d0:	2000cb4c 	.word	0x2000cb4c
 800c5d4:	2000cb60 	.word	0x2000cb60
 800c5d8:	2000cb68 	.word	0x2000cb68
 800c5dc:	2000cb54 	.word	0x2000cb54
 800c5e0:	08017fd8 	.word	0x08017fd8
 800c5e4:	08018010 	.word	0x08018010
 800c5e8:	2000cb78 	.word	0x2000cb78
 800c5ec:	2000cbb0 	.word	0x2000cbb0
 800c5f0:	2000cbac 	.word	0x2000cbac
 800c5f4:	08017f7c 	.word	0x08017f7c
 800c5f8:	08017f50 	.word	0x08017f50
 800c5fc:	f3af 8000 	nop.w

0800c600 <tcp_create_segment.isra.0>:
 * @return a new tcp_seg pointing to p, or NULL.
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
 800c600:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800c604:	f89d 7024 	ldrb.w	r7, [sp, #36]	; 0x24
 800c608:	4680      	mov	r8, r0
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 800c60a:	f017 0401 	ands.w	r4, r7, #1

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 800c60e:	f04f 0004 	mov.w	r0, #4
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 800c612:	bf18      	it	ne
 800c614:	2404      	movne	r4, #4
 * @return a new tcp_seg pointing to p, or NULL.
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
 800c616:	4689      	mov	r9, r1
 800c618:	4692      	mov	sl, r2
 800c61a:	461e      	mov	r6, r3
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 800c61c:	f7fc fc78 	bl	8008f10 <memp_malloc>
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 800c620:	f007 0502 	and.w	r5, r7, #2
 800c624:	2d00      	cmp	r5, #0
 800c626:	bf14      	ite	ne
 800c628:	250c      	movne	r5, #12
 800c62a:	2500      	moveq	r5, #0
 800c62c:	4425      	add	r5, r4

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 800c62e:	4604      	mov	r4, r0
 800c630:	2800      	cmp	r0, #0
 800c632:	d040      	beq.n	800c6b6 <tcp_create_segment.isra.0+0xb6>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
 800c634:	7287      	strb	r7, [r0, #10]
  seg->next = NULL;
  seg->p = p;
  seg->len = p->tot_len - optlen;
 800c636:	f8ba 3008 	ldrh.w	r3, [sl, #8]
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
  seg->next = NULL;
  seg->p = p;
 800c63a:	f8c0 a004 	str.w	sl, [r0, #4]
  seg->len = p->tot_len - optlen;
 800c63e:	1b5b      	subs	r3, r3, r5
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
  seg->next = NULL;
 800c640:	2700      	movs	r7, #0
  seg->p = p;
  seg->len = p->tot_len - optlen;
 800c642:	8103      	strh	r3, [r0, #8]
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
 800c644:	2114      	movs	r1, #20
 800c646:	4650      	mov	r0, sl
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
  seg->next = NULL;
 800c648:	6027      	str	r7, [r4, #0]
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
 800c64a:	f7fc fe69 	bl	8009320 <pbuf_header>
 800c64e:	4682      	mov	sl, r0
 800c650:	bb28      	cbnz	r0, 800c69e <tcp_create_segment.isra.0+0x9e>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 800c652:	6863      	ldr	r3, [r4, #4]
  seg->tcphdr->src = htons(pcb->local_port);
 800c654:	f8b8 0000 	ldrh.w	r0, [r8]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 800c658:	685f      	ldr	r7, [r3, #4]
 800c65a:	60e7      	str	r7, [r4, #12]
  seg->tcphdr->src = htons(pcb->local_port);
 800c65c:	f002 fba0 	bl	800eda0 <lwip_htons>
 800c660:	8038      	strh	r0, [r7, #0]
  seg->tcphdr->dest = htons(pcb->remote_port);
 800c662:	f8b9 0000 	ldrh.w	r0, [r9]
 800c666:	68e7      	ldr	r7, [r4, #12]
 800c668:	f002 fb9a 	bl	800eda0 <lwip_htons>
 800c66c:	8078      	strh	r0, [r7, #2]
  seg->tcphdr->seqno = htonl(seqno);
 800c66e:	9808      	ldr	r0, [sp, #32]
 800c670:	68e7      	ldr	r7, [r4, #12]
 800c672:	f002 fba5 	bl	800edc0 <lwip_htonl>
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 800c676:	f3c5 0387 	ubfx	r3, r5, #2, #8
 800c67a:	3305      	adds	r3, #5
 800c67c:	ea46 3303 	orr.w	r3, r6, r3, lsl #12
 800c680:	b29b      	uxth	r3, r3
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = htons(pcb->local_port);
  seg->tcphdr->dest = htons(pcb->remote_port);
  seg->tcphdr->seqno = htonl(seqno);
 800c682:	6078      	str	r0, [r7, #4]
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 800c684:	4618      	mov	r0, r3
 800c686:	68e5      	ldr	r5, [r4, #12]
 800c688:	f002 fb8a 	bl	800eda0 <lwip_htons>
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 800c68c:	68e3      	ldr	r3, [r4, #12]
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = htons(pcb->local_port);
  seg->tcphdr->dest = htons(pcb->remote_port);
  seg->tcphdr->seqno = htonl(seqno);
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 800c68e:	81a8      	strh	r0, [r5, #12]
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 800c690:	4620      	mov	r0, r4
 800c692:	f883 a012 	strb.w	sl, [r3, #18]
 800c696:	f883 a013 	strb.w	sl, [r3, #19]
  return seg;
} 
 800c69a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
 800c69e:	4a09      	ldr	r2, [pc, #36]	; (800c6c4 <tcp_create_segment.isra.0+0xc4>)
 800c6a0:	f8b2 30a4 	ldrh.w	r3, [r2, #164]	; 0xa4
    tcp_seg_free(seg);
 800c6a4:	4620      	mov	r0, r4
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
 800c6a6:	3301      	adds	r3, #1
 800c6a8:	f8a2 30a4 	strh.w	r3, [r2, #164]	; 0xa4
    tcp_seg_free(seg);
 800c6ac:	f7fd fcb8 	bl	800a020 <tcp_seg_free>
    return NULL;
 800c6b0:	4638      	mov	r0, r7
 800c6b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
 800c6b6:	4650      	mov	r0, sl
 800c6b8:	f7fc fea2 	bl	8009400 <pbuf_free>
    return NULL;
 800c6bc:	4620      	mov	r0, r4
 800c6be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800c6c2:	bf00      	nop
 800c6c4:	2000c9fc 	.word	0x2000c9fc
 800c6c8:	f3af 8000 	nop.w
 800c6cc:	f3af 8000 	nop.w

0800c6d0 <chprintf.constprop.2>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 800c6d0:	b40e      	push	{r1, r2, r3}
 800c6d2:	b500      	push	{lr}
 800c6d4:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800c6d6:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 800c6d8:	461a      	mov	r2, r3
 800c6da:	4905      	ldr	r1, [pc, #20]	; (800c6f0 <chprintf.constprop.2+0x20>)
 800c6dc:	4805      	ldr	r0, [pc, #20]	; (800c6f4 <chprintf.constprop.2+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800c6de:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800c6e0:	f004 fb0e 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 800c6e4:	b002      	add	sp, #8
 800c6e6:	f85d eb04 	ldr.w	lr, [sp], #4
 800c6ea:	b003      	add	sp, #12
 800c6ec:	4770      	bx	lr
 800c6ee:	bf00      	nop
 800c6f0:	08016fe0 	.word	0x08016fe0
 800c6f4:	200180c8 	.word	0x200180c8
 800c6f8:	f3af 8000 	nop.w
 800c6fc:	f3af 8000 	nop.w

0800c700 <tcp_output_alloc_header.constprop.1>:
 * @param datalen length of tcp data to reserve in pbuf
 * @param seqno_be seqno in network byte order (big-endian)
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
 800c700:	b5f0      	push	{r4, r5, r6, r7, lr}
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 800c702:	3114      	adds	r1, #20
 * @param datalen length of tcp data to reserve in pbuf
 * @param seqno_be seqno in network byte order (big-endian)
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
 800c704:	b083      	sub	sp, #12
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 800c706:	b289      	uxth	r1, r1
 * @param datalen length of tcp data to reserve in pbuf
 * @param seqno_be seqno in network byte order (big-endian)
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
 800c708:	4605      	mov	r5, r0
 800c70a:	4617      	mov	r7, r2
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 800c70c:	2001      	movs	r0, #1
 800c70e:	2200      	movs	r2, #0
 800c710:	f7fc fef6 	bl	8009500 <pbuf_alloc>
  if (p != NULL) {
 800c714:	4606      	mov	r6, r0
 800c716:	b310      	cbz	r0, 800c75e <tcp_output_alloc_header.constprop.1+0x5e>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 800c718:	8943      	ldrh	r3, [r0, #10]
 800c71a:	2b13      	cmp	r3, #19
 800c71c:	dd22      	ble.n	800c764 <tcp_output_alloc_header.constprop.1+0x64>
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
 800c71e:	8b68      	ldrh	r0, [r5, #26]
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
 800c720:	6874      	ldr	r4, [r6, #4]
    tcphdr->src = htons(pcb->local_port);
 800c722:	f002 fb3d 	bl	800eda0 <lwip_htons>
 800c726:	8020      	strh	r0, [r4, #0]
    tcphdr->dest = htons(pcb->remote_port);
 800c728:	8ba8      	ldrh	r0, [r5, #28]
 800c72a:	f002 fb39 	bl	800eda0 <lwip_htons>
    tcphdr->seqno = seqno_be;
 800c72e:	6067      	str	r7, [r4, #4]
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
    tcphdr->dest = htons(pcb->remote_port);
 800c730:	8060      	strh	r0, [r4, #2]
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
 800c732:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 800c734:	f002 fb44 	bl	800edc0 <lwip_htonl>
 800c738:	60a0      	str	r0, [r4, #8]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
 800c73a:	f245 0010 	movw	r0, #20496	; 0x5010
 800c73e:	f002 fb2f 	bl	800eda0 <lwip_htons>
 800c742:	81a0      	strh	r0, [r4, #12]
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 800c744:	8de8      	ldrh	r0, [r5, #46]	; 0x2e
 800c746:	f002 fb2b 	bl	800eda0 <lwip_htons>
    tcphdr->chksum = 0;
    tcphdr->urgp = 0;

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 800c74a:	8de9      	ldrh	r1, [r5, #46]	; 0x2e
 800c74c:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    tcphdr->src = htons(pcb->local_port);
    tcphdr->dest = htons(pcb->remote_port);
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 800c74e:	81e0      	strh	r0, [r4, #14]
    tcphdr->chksum = 0;
 800c750:	2300      	movs	r3, #0
    tcphdr->urgp = 0;

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 800c752:	440a      	add	r2, r1
    tcphdr->dest = htons(pcb->remote_port);
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    tcphdr->chksum = 0;
 800c754:	7423      	strb	r3, [r4, #16]
 800c756:	7463      	strb	r3, [r4, #17]
    tcphdr->urgp = 0;
 800c758:	74a3      	strb	r3, [r4, #18]
 800c75a:	74e3      	strb	r3, [r4, #19]

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 800c75c:	632a      	str	r2, [r5, #48]	; 0x30
  }
  return p;
}
 800c75e:	4630      	mov	r0, r6
 800c760:	b003      	add	sp, #12
 800c762:	bdf0      	pop	{r4, r5, r6, r7, pc}
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 800c764:	4b05      	ldr	r3, [pc, #20]	; (800c77c <tcp_output_alloc_header.constprop.1+0x7c>)
 800c766:	9300      	str	r3, [sp, #0]
 800c768:	4905      	ldr	r1, [pc, #20]	; (800c780 <tcp_output_alloc_header.constprop.1+0x80>)
 800c76a:	4a06      	ldr	r2, [pc, #24]	; (800c784 <tcp_output_alloc_header.constprop.1+0x84>)
 800c76c:	4806      	ldr	r0, [pc, #24]	; (800c788 <tcp_output_alloc_header.constprop.1+0x88>)
 800c76e:	2365      	movs	r3, #101	; 0x65
 800c770:	f7ff ffae 	bl	800c6d0 <chprintf.constprop.2>
 800c774:	4803      	ldr	r0, [pc, #12]	; (800c784 <tcp_output_alloc_header.constprop.1+0x84>)
 800c776:	f7f4 fbfb 	bl	8000f70 <chSysHalt>
 800c77a:	e7d0      	b.n	800c71e <tcp_output_alloc_header.constprop.1+0x1e>
 800c77c:	08018070 	.word	0x08018070
 800c780:	08016fe0 	.word	0x08016fe0
 800c784:	08018040 	.word	0x08018040
 800c788:	200180c8 	.word	0x200180c8
 800c78c:	f3af 8000 	nop.w

0800c790 <tcp_pbuf_prealloc>:
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
 800c790:	b570      	push	{r4, r5, r6, lr}
 800c792:	460d      	mov	r5, r1
 800c794:	b082      	sub	sp, #8
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  /* always create MSS-sized pbufs */
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
 800c796:	4295      	cmp	r5, r2
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
 800c798:	461e      	mov	r6, r3
 800c79a:	f89d 1020 	ldrb.w	r1, [sp, #32]
 800c79e:	f89d 301c 	ldrb.w	r3, [sp, #28]
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  /* always create MSS-sized pbufs */
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
 800c7a2:	d20e      	bcs.n	800c7c2 <tcp_pbuf_prealloc+0x32>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 800c7a4:	079c      	lsls	r4, r3, #30
 800c7a6:	d508      	bpl.n	800c7ba <tcp_pbuf_prealloc+0x2a>
        (!(pcb->flags & TF_NODELAY) &&
         (!first_seg ||
          pcb->unsent != NULL ||
          pcb->unacked != NULL))) {
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
 800c7a8:	f205 51b7 	addw	r1, r5, #1463	; 0x5b7
 800c7ac:	f021 0103 	bic.w	r1, r1, #3
 800c7b0:	428a      	cmp	r2, r1
 800c7b2:	bfa8      	it	ge
 800c7b4:	460a      	movge	r2, r1
 800c7b6:	b291      	uxth	r1, r2
 800c7b8:	e004      	b.n	800c7c4 <tcp_pbuf_prealloc+0x34>
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
        (!(pcb->flags & TF_NODELAY) &&
 800c7ba:	9b06      	ldr	r3, [sp, #24]
 800c7bc:	7f9b      	ldrb	r3, [r3, #30]
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 800c7be:	065b      	lsls	r3, r3, #25
 800c7c0:	d51b      	bpl.n	800c7fa <tcp_pbuf_prealloc+0x6a>
 800c7c2:	4629      	mov	r1, r5
          pcb->unacked != NULL))) {
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
 800c7c4:	2200      	movs	r2, #0
 800c7c6:	f7fc fe9b 	bl	8009500 <pbuf_alloc>
  if (p == NULL) {
 800c7ca:	4604      	mov	r4, r0
 800c7cc:	b190      	cbz	r0, 800c7f4 <tcp_pbuf_prealloc+0x64>
    return NULL;
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
 800c7ce:	6803      	ldr	r3, [r0, #0]
 800c7d0:	b15b      	cbz	r3, 800c7ea <tcp_pbuf_prealloc+0x5a>
 800c7d2:	4b0f      	ldr	r3, [pc, #60]	; (800c810 <tcp_pbuf_prealloc+0x80>)
 800c7d4:	9300      	str	r3, [sp, #0]
 800c7d6:	480f      	ldr	r0, [pc, #60]	; (800c814 <tcp_pbuf_prealloc+0x84>)
 800c7d8:	490f      	ldr	r1, [pc, #60]	; (800c818 <tcp_pbuf_prealloc+0x88>)
 800c7da:	4a10      	ldr	r2, [pc, #64]	; (800c81c <tcp_pbuf_prealloc+0x8c>)
 800c7dc:	f240 1303 	movw	r3, #259	; 0x103
 800c7e0:	f7ff ff76 	bl	800c6d0 <chprintf.constprop.2>
 800c7e4:	480d      	ldr	r0, [pc, #52]	; (800c81c <tcp_pbuf_prealloc+0x8c>)
 800c7e6:	f7f4 fbc3 	bl	8000f70 <chSysHalt>
  *oversize = p->len - length;
 800c7ea:	8963      	ldrh	r3, [r4, #10]
 800c7ec:	1b5b      	subs	r3, r3, r5
 800c7ee:	8033      	strh	r3, [r6, #0]
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
 800c7f0:	8125      	strh	r5, [r4, #8]
 800c7f2:	8165      	strh	r5, [r4, #10]
  return p;
}
 800c7f4:	4620      	mov	r0, r4
 800c7f6:	b002      	add	sp, #8
 800c7f8:	bd70      	pop	{r4, r5, r6, pc}
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
        (!(pcb->flags & TF_NODELAY) &&
 800c7fa:	2900      	cmp	r1, #0
 800c7fc:	d0d4      	beq.n	800c7a8 <tcp_pbuf_prealloc+0x18>
         (!first_seg ||
 800c7fe:	9b06      	ldr	r3, [sp, #24]
 800c800:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800c802:	2b00      	cmp	r3, #0
 800c804:	d1d0      	bne.n	800c7a8 <tcp_pbuf_prealloc+0x18>
          pcb->unsent != NULL ||
 800c806:	9b06      	ldr	r3, [sp, #24]
 800c808:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c80a:	2b00      	cmp	r3, #0
 800c80c:	d1cc      	bne.n	800c7a8 <tcp_pbuf_prealloc+0x18>
 800c80e:	e7d8      	b.n	800c7c2 <tcp_pbuf_prealloc+0x32>
 800c810:	08018070 	.word	0x08018070
 800c814:	200180c8 	.word	0x200180c8
 800c818:	08016fe0 	.word	0x08016fe0
 800c81c:	080180a0 	.word	0x080180a0

0800c820 <tcp_write>:
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
 800c820:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c824:	4607      	mov	r7, r0
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
 800c826:	f8b0 0062 	ldrh.w	r0, [r0, #98]	; 0x62
 800c82a:	8efc      	ldrh	r4, [r7, #54]	; 0x36
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
 800c82c:	b08f      	sub	sp, #60	; 0x3c
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
 800c82e:	0840      	lsrs	r0, r0, #1
 800c830:	42a0      	cmp	r0, r4
  u16_t pos = 0; /* position in 'arg' data */
  u16_t queuelen;
  u8_t optlen = 0;
  u8_t optflags = 0;
#if TCP_OVERSIZE
  u16_t oversize = 0;
 800c832:	f04f 0500 	mov.w	r5, #0
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
 800c836:	9308      	str	r3, [sp, #32]
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
 800c838:	4603      	mov	r3, r0
 800c83a:	bf28      	it	cs
 800c83c:	4623      	movcs	r3, r4
  u16_t pos = 0; /* position in 'arg' data */
  u16_t queuelen;
  u8_t optlen = 0;
  u8_t optflags = 0;
#if TCP_OVERSIZE
  u16_t oversize = 0;
 800c83e:	f8ad 5036 	strh.w	r5, [sp, #54]	; 0x36
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
 800c842:	9305      	str	r3, [sp, #20]
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
 800c844:	9106      	str	r1, [sp, #24]
 800c846:	2900      	cmp	r1, #0
 800c848:	f000 82c5 	beq.w	800cdd6 <tcp_write+0x5b6>
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
 800c84c:	7e3b      	ldrb	r3, [r7, #24]
 800c84e:	2b07      	cmp	r3, #7
 800c850:	4693      	mov	fp, r2
 800c852:	d007      	beq.n	800c864 <tcp_write+0x44>
      (pcb->state != CLOSE_WAIT) &&
 800c854:	3b02      	subs	r3, #2
 800c856:	2b02      	cmp	r3, #2
 800c858:	d904      	bls.n	800c864 <tcp_write+0x44>
      (pcb->state != SYN_SENT) &&
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
 800c85a:	20f3      	movs	r0, #243	; 0xf3
 800c85c:	b240      	sxtb	r0, r0
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
 800c85e:	b00f      	add	sp, #60	; 0x3c
 800c860:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  } else if (len == 0) {
 800c864:	f1bb 0f00 	cmp.w	fp, #0
 800c868:	f000 80f0 	beq.w	800ca4c <tcp_write+0x22c>
    return ERR_OK;
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
 800c86c:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 800c870:	455b      	cmp	r3, fp
 800c872:	f0c0 8276 	bcc.w	800cd62 <tcp_write+0x542>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 800c876:	f8b7 6068 	ldrh.w	r6, [r7, #104]	; 0x68
 800c87a:	2e07      	cmp	r6, #7
 800c87c:	f200 826b 	bhi.w	800cd56 <tcp_write+0x536>
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 800c880:	6f3b      	ldr	r3, [r7, #112]	; 0x70
      pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (pcb->snd_queuelen != 0) {
 800c882:	2e00      	cmp	r6, #0
 800c884:	f000 80ba 	beq.w	800c9fc <tcp_write+0x1dc>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 800c888:	2b00      	cmp	r3, #0
 800c88a:	f000 81f8 	beq.w	800cc7e <tcp_write+0x45e>
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
 800c88e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800c890:	9309      	str	r3, [sp, #36]	; 0x24
 800c892:	2b00      	cmp	r3, #0
 800c894:	f000 80c8 	beq.w	800ca28 <tcp_write+0x208>
 800c898:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800c89a:	e000      	b.n	800c89e <tcp_write+0x7e>
 800c89c:	461a      	mov	r2, r3
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 800c89e:	6813      	ldr	r3, [r2, #0]
 800c8a0:	2b00      	cmp	r3, #0
 800c8a2:	d1fb      	bne.n	800c89c <tcp_write+0x7c>
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 800c8a4:	7a91      	ldrb	r1, [r2, #10]
 800c8a6:	9805      	ldr	r0, [sp, #20]
 800c8a8:	9209      	str	r2, [sp, #36]	; 0x24
 800c8aa:	4698      	mov	r8, r3
 800c8ac:	8913      	ldrh	r3, [r2, #8]
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
 800c8ae:	f8b7 206a 	ldrh.w	r2, [r7, #106]	; 0x6a
    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 800c8b2:	f011 0f01 	tst.w	r1, #1
 800c8b6:	bf14      	ite	ne
 800c8b8:	2404      	movne	r4, #4
 800c8ba:	2400      	moveq	r4, #0
 800c8bc:	1ac3      	subs	r3, r0, r3
 800c8be:	f011 0f02 	tst.w	r1, #2
 800c8c2:	eba3 0304 	sub.w	r3, r3, r4
 800c8c6:	bf14      	ite	ne
 800c8c8:	240c      	movne	r4, #12
 800c8ca:	2400      	moveq	r4, #0
    space = mss_local - (last_unsent->len + unsent_optlen);
 800c8cc:	1b1c      	subs	r4, r3, r4
 800c8ce:	b2a4      	uxth	r4, r4
    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
    if (oversize > 0) {
 800c8d0:	2a00      	cmp	r2, #0
 800c8d2:	f040 80be 	bne.w	800ca52 <tcp_write+0x232>
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
 800c8d6:	f8ad 8036 	strh.w	r8, [sp, #54]	; 0x36
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 800c8da:	46c1      	mov	r9, r8
  u16_t pos = 0; /* position in 'arg' data */
 800c8dc:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 800c8e0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c8e2:	459b      	cmp	fp, r3
 800c8e4:	f240 80c7 	bls.w	800ca76 <tcp_write+0x256>
 800c8e8:	2c00      	cmp	r4, #0
 800c8ea:	f040 80e8 	bne.w	800cabe <tcp_write+0x29e>
 800c8ee:	9b08      	ldr	r3, [sp, #32]
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
  u16_t pos = 0; /* position in 'arg' data */
 800c8f0:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 800c8f2:	f003 0301 	and.w	r3, r3, #1
 800c8f6:	9307      	str	r3, [sp, #28]
 800c8f8:	2300      	movs	r3, #0
 800c8fa:	930b      	str	r3, [sp, #44]	; 0x2c
 800c8fc:	f04f 0800 	mov.w	r8, #0
 800c900:	46c2      	mov	sl, r8
 800c902:	f8cd 8010 	str.w	r8, [sp, #16]
 800c906:	e044      	b.n	800c992 <tcp_write+0x172>
       * sent out on the link (as it has to be ACKed by the remote
       * party) we can safely use PBUF_ROM instead of PBUF_REF here.
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
 800c908:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
 800c90c:	2b00      	cmp	r3, #0
 800c90e:	f040 811f 	bne.w	800cb50 <tcp_write+0x330>
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
 800c912:	2000      	movs	r0, #0
 800c914:	4629      	mov	r1, r5
 800c916:	2201      	movs	r2, #1
 800c918:	f7fc fdf2 	bl	8009500 <pbuf_alloc>
 800c91c:	4680      	mov	r8, r0
 800c91e:	2800      	cmp	r0, #0
 800c920:	f000 8181 	beq.w	800cc26 <tcp_write+0x406>
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      p2->payload = (u8_t*)arg + pos;
 800c924:	9b06      	ldr	r3, [sp, #24]

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 800c926:	2000      	movs	r0, #0
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      p2->payload = (u8_t*)arg + pos;
 800c928:	191a      	adds	r2, r3, r4
 800c92a:	f8c8 2004 	str.w	r2, [r8, #4]

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 800c92e:	4601      	mov	r1, r0
 800c930:	4602      	mov	r2, r0
 800c932:	f7fc fde5 	bl	8009500 <pbuf_alloc>
 800c936:	4681      	mov	r9, r0
 800c938:	2800      	cmp	r0, #0
 800c93a:	f000 8199 	beq.w	800cc70 <tcp_write+0x450>
        pbuf_free(p2);
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
 800c93e:	4641      	mov	r1, r8
 800c940:	f7fc ffa6 	bl	8009890 <pbuf_cat>
    }

    queuelen += pbuf_clen(p);
 800c944:	4648      	mov	r0, r9
 800c946:	f7fc ff8b 	bl	8009860 <pbuf_clen>
 800c94a:	4430      	add	r0, r6
 800c94c:	b286      	uxth	r6, r0

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 800c94e:	2e08      	cmp	r6, #8
 800c950:	d84e      	bhi.n	800c9f0 <tcp_write+0x1d0>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      pbuf_free(p);
      goto memerr;
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 800c952:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800c954:	2300      	movs	r3, #0
 800c956:	18a1      	adds	r1, r4, r2
 800c958:	e88d 000a 	stmia.w	sp, {r1, r3}
 800c95c:	464a      	mov	r2, r9
 800c95e:	f107 001a 	add.w	r0, r7, #26
 800c962:	f107 011c 	add.w	r1, r7, #28
 800c966:	f7ff fe4b 	bl	800c600 <tcp_create_segment.isra.0>
 800c96a:	4681      	mov	r9, r0
 800c96c:	2800      	cmp	r0, #0
 800c96e:	f000 815a 	beq.w	800cc26 <tcp_write+0x406>
    seg->chksum_swapped = chksum_swapped;
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
 800c972:	9b04      	ldr	r3, [sp, #16]
 800c974:	2b00      	cmp	r3, #0
 800c976:	f000 80f8 	beq.w	800cb6a <tcp_write+0x34a>
      queue = seg;
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
 800c97a:	f1ba 0f00 	cmp.w	sl, #0
 800c97e:	f000 8145 	beq.w	800cc0c <tcp_write+0x3ec>

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
 800c982:	442c      	add	r4, r5
 800c984:	b2a4      	uxth	r4, r4
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 800c986:	45a3      	cmp	fp, r4
    if (queue == NULL) {
      queue = seg;
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
      prev_seg->next = seg;
 800c988:	f8ca 9000 	str.w	r9, [sl]
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 800c98c:	f240 80f3 	bls.w	800cb76 <tcp_write+0x356>
 800c990:	46ca      	mov	sl, r9
    struct pbuf *p;
    u16_t left = len - pos;
    u16_t max_len = mss_local - optlen;
    u16_t seglen = left > max_len ? max_len : left;
 800c992:	9b05      	ldr	r3, [sp, #20]
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
    struct pbuf *p;
    u16_t left = len - pos;
 800c994:	ebc4 050b 	rsb	r5, r4, fp
    u16_t max_len = mss_local - optlen;
    u16_t seglen = left > max_len ? max_len : left;
 800c998:	b2ad      	uxth	r5, r5
 800c99a:	429d      	cmp	r5, r3
 800c99c:	bf28      	it	cs
 800c99e:	461d      	movcs	r5, r3
#if TCP_CHECKSUM_ON_COPY
    u16_t chksum = 0;
    u8_t chksum_swapped = 0;
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
 800c9a0:	9b07      	ldr	r3, [sp, #28]
 800c9a2:	2b00      	cmp	r3, #0
 800c9a4:	d0b0      	beq.n	800c908 <tcp_write+0xe8>
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
 800c9a6:	9a08      	ldr	r2, [sp, #32]
 800c9a8:	9b04      	ldr	r3, [sp, #16]
 800c9aa:	fab3 f383 	clz	r3, r3
 800c9ae:	095b      	lsrs	r3, r3, #5
 800c9b0:	9201      	str	r2, [sp, #4]
 800c9b2:	9302      	str	r3, [sp, #8]
 800c9b4:	9700      	str	r7, [sp, #0]
 800c9b6:	2000      	movs	r0, #0
 800c9b8:	4629      	mov	r1, r5
 800c9ba:	9a05      	ldr	r2, [sp, #20]
 800c9bc:	f10d 0336 	add.w	r3, sp, #54	; 0x36
 800c9c0:	f7ff fee6 	bl	800c790 <tcp_pbuf_prealloc>
 800c9c4:	4681      	mov	r9, r0
 800c9c6:	2800      	cmp	r0, #0
 800c9c8:	f000 812d 	beq.w	800cc26 <tcp_write+0x406>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
 800c9cc:	8943      	ldrh	r3, [r0, #10]
 800c9ce:	42ab      	cmp	r3, r5
 800c9d0:	f0c0 810f 	bcc.w	800cbf2 <tcp_write+0x3d2>
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
 800c9d4:	9b06      	ldr	r3, [sp, #24]
 800c9d6:	f8d9 0004 	ldr.w	r0, [r9, #4]
 800c9da:	1919      	adds	r1, r3, r4
 800c9dc:	462a      	mov	r2, r5
 800c9de:	f7f3 ff6f 	bl	80008c0 <memcpy>
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
    }

    queuelen += pbuf_clen(p);
 800c9e2:	4648      	mov	r0, r9
 800c9e4:	f7fc ff3c 	bl	8009860 <pbuf_clen>
 800c9e8:	4430      	add	r0, r6
 800c9ea:	b286      	uxth	r6, r0

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 800c9ec:	2e08      	cmp	r6, #8
 800c9ee:	d9b0      	bls.n	800c952 <tcp_write+0x132>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      pbuf_free(p);
 800c9f0:	4648      	mov	r0, r9
 800c9f2:	f8dd 8010 	ldr.w	r8, [sp, #16]
 800c9f6:	f7fc fd03 	bl	8009400 <pbuf_free>
      goto memerr;
 800c9fa:	e116      	b.n	800cc2a <tcp_write+0x40a>
  }
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
 800c9fc:	2b00      	cmp	r3, #0
 800c9fe:	f000 8092 	beq.w	800cb26 <tcp_write+0x306>
 800ca02:	4ba9      	ldr	r3, [pc, #676]	; (800cca8 <tcp_write+0x488>)
 800ca04:	9300      	str	r3, [sp, #0]
 800ca06:	49a9      	ldr	r1, [pc, #676]	; (800ccac <tcp_write+0x48c>)
 800ca08:	4aa9      	ldr	r2, [pc, #676]	; (800ccb0 <tcp_write+0x490>)
 800ca0a:	48aa      	ldr	r0, [pc, #680]	; (800ccb4 <tcp_write+0x494>)
 800ca0c:	f44f 73a6 	mov.w	r3, #332	; 0x14c
 800ca10:	f7ff fe5e 	bl	800c6d0 <chprintf.constprop.2>
 800ca14:	48a6      	ldr	r0, [pc, #664]	; (800ccb0 <tcp_write+0x490>)
 800ca16:	f7f4 faab 	bl	8000f70 <chSysHalt>
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
 800ca1a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ca1c:	f8b7 6068 	ldrh.w	r6, [r7, #104]	; 0x68
 800ca20:	9309      	str	r3, [sp, #36]	; 0x24
 800ca22:	2b00      	cmp	r3, #0
 800ca24:	f47f af38 	bne.w	800c898 <tcp_write+0x78>
      pos += seglen;
      queuelen += pbuf_clen(concat_p);
    }
  } else {
#if TCP_OVERSIZE
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
 800ca28:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
 800ca2c:	2b00      	cmp	r3, #0
 800ca2e:	f040 8082 	bne.w	800cb36 <tcp_write+0x316>
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 800ca32:	f1bb 0f00 	cmp.w	fp, #0
 800ca36:	f000 81df 	beq.w	800cdf8 <tcp_write+0x5d8>
 800ca3a:	9b08      	ldr	r3, [sp, #32]
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
  u16_t pos = 0; /* position in 'arg' data */
 800ca3c:	2400      	movs	r4, #0
 800ca3e:	f003 0301 	and.w	r3, r3, #1
 800ca42:	940a      	str	r4, [sp, #40]	; 0x28
 800ca44:	9409      	str	r4, [sp, #36]	; 0x24
 800ca46:	940b      	str	r4, [sp, #44]	; 0x2c
 800ca48:	9307      	str	r3, [sp, #28]
 800ca4a:	e757      	b.n	800c8fc <tcp_write+0xdc>
 800ca4c:	f8b7 6068 	ldrh.w	r6, [r7, #104]	; 0x68
 800ca50:	e71d      	b.n	800c88e <tcp_write+0x6e>
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
    if (oversize > 0) {
      LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
      seg = last_unsent;
      oversize_used = oversize < len ? oversize : len;
 800ca52:	4593      	cmp	fp, r2
 800ca54:	465b      	mov	r3, fp
 800ca56:	bf28      	it	cs
 800ca58:	4613      	movcs	r3, r2
      pos += oversize_used;
      oversize -= oversize_used;
 800ca5a:	1ad2      	subs	r2, r2, r3
 800ca5c:	b292      	uxth	r2, r2
      space -= oversize_used;
 800ca5e:	1ae4      	subs	r4, r4, r3
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
    if (oversize > 0) {
      LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
      seg = last_unsent;
      oversize_used = oversize < len ? oversize : len;
 800ca60:	930a      	str	r3, [sp, #40]	; 0x28
      pos += oversize_used;
      oversize -= oversize_used;
 800ca62:	f8ad 2036 	strh.w	r2, [sp, #54]	; 0x36
      space -= oversize_used;
 800ca66:	b2a4      	uxth	r4, r4
    }
    /* now we are either finished or oversize is zero */
    LWIP_ASSERT("inconsistend oversize vs. len", (oversize == 0) || (pos == len));
 800ca68:	2a00      	cmp	r2, #0
 800ca6a:	f000 81c2 	beq.w	800cdf2 <tcp_write+0x5d2>
 800ca6e:	459b      	cmp	fp, r3
 800ca70:	d116      	bne.n	800caa0 <tcp_write+0x280>
 800ca72:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
 800ca76:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800ca78:	2b00      	cmp	r3, #0
 800ca7a:	f000 813f 	beq.w	800ccfc <tcp_write+0x4dc>
 800ca7e:	2300      	movs	r3, #0
 800ca80:	930b      	str	r3, [sp, #44]	; 0x2c
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 800ca82:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800ca84:	685c      	ldr	r4, [r3, #4]
 800ca86:	2c00      	cmp	r4, #0
 800ca88:	f000 8132 	beq.w	800ccf0 <tcp_write+0x4d0>
 800ca8c:	9d0a      	ldr	r5, [sp, #40]	; 0x28
      p->tot_len += oversize_used;
 800ca8e:	8923      	ldrh	r3, [r4, #8]
      if (p->next == NULL) {
 800ca90:	6822      	ldr	r2, [r4, #0]
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
      p->tot_len += oversize_used;
 800ca92:	442b      	add	r3, r5
 800ca94:	8123      	strh	r3, [r4, #8]
      if (p->next == NULL) {
 800ca96:	2a00      	cmp	r2, #0
 800ca98:	f000 811c 	beq.w	800ccd4 <tcp_write+0x4b4>
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
 800ca9c:	4614      	mov	r4, r2
 800ca9e:	e7f6      	b.n	800ca8e <tcp_write+0x26e>
      pos += oversize_used;
      oversize -= oversize_used;
      space -= oversize_used;
    }
    /* now we are either finished or oversize is zero */
    LWIP_ASSERT("inconsistend oversize vs. len", (oversize == 0) || (pos == len));
 800caa0:	4b81      	ldr	r3, [pc, #516]	; (800cca8 <tcp_write+0x488>)
 800caa2:	9300      	str	r3, [sp, #0]
 800caa4:	4981      	ldr	r1, [pc, #516]	; (800ccac <tcp_write+0x48c>)
 800caa6:	4a84      	ldr	r2, [pc, #528]	; (800ccb8 <tcp_write+0x498>)
 800caa8:	4882      	ldr	r0, [pc, #520]	; (800ccb4 <tcp_write+0x494>)
 800caaa:	f240 13c9 	movw	r3, #457	; 0x1c9
 800caae:	f7ff fe0f 	bl	800c6d0 <chprintf.constprop.2>
 800cab2:	4881      	ldr	r0, [pc, #516]	; (800ccb8 <tcp_write+0x498>)
 800cab4:	f7f4 fa5c 	bl	8000f70 <chSysHalt>
 800cab8:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 800cabc:	e710      	b.n	800c8e0 <tcp_write+0xc0>
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 800cabe:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800cac0:	891b      	ldrh	r3, [r3, #8]
 800cac2:	2b00      	cmp	r3, #0
 800cac4:	f43f af13 	beq.w	800c8ee <tcp_write+0xce>
      u16_t seglen = space < len - pos ? space : len - pos;
 800cac8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800caca:	ebc3 050b 	rsb	r5, r3, fp
      seg = last_unsent;

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 800cace:	9b08      	ldr	r3, [sp, #32]
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
      u16_t seglen = space < len - pos ? space : len - pos;
 800cad0:	42a5      	cmp	r5, r4
 800cad2:	bfa8      	it	ge
 800cad4:	4625      	movge	r5, r4
      seg = last_unsent;

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 800cad6:	f013 0301 	ands.w	r3, r3, #1
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
      u16_t seglen = space < len - pos ? space : len - pos;
 800cada:	b2ad      	uxth	r5, r5
      seg = last_unsent;

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 800cadc:	9307      	str	r3, [sp, #28]
 800cade:	f040 8112 	bne.w	800cd06 <tcp_write+0x4e6>
#if TCP_CHECKSUM_ON_COPY
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
      } else {
        /* Data is not copied */
        if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
 800cae2:	2003      	movs	r0, #3
 800cae4:	4629      	mov	r1, r5
 800cae6:	2201      	movs	r2, #1
 800cae8:	f7fc fd0a 	bl	8009500 <pbuf_alloc>
 800caec:	900b      	str	r0, [sp, #44]	; 0x2c
 800caee:	2800      	cmp	r0, #0
 800caf0:	f000 8159 	beq.w	800cda6 <tcp_write+0x586>
        tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,
          &concat_chksum, &concat_chksum_swapped);
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
 800caf4:	9b06      	ldr	r3, [sp, #24]
 800caf6:	990a      	ldr	r1, [sp, #40]	; 0x28
 800caf8:	440b      	add	r3, r1
 800cafa:	6043      	str	r3, [r0, #4]
      }

      pos += seglen;
 800cafc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      queuelen += pbuf_clen(concat_p);
 800cafe:	980b      	ldr	r0, [sp, #44]	; 0x2c
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
      }

      pos += seglen;
 800cb00:	18ec      	adds	r4, r5, r3
      queuelen += pbuf_clen(concat_p);
 800cb02:	f7fc fead 	bl	8009860 <pbuf_clen>
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
      }

      pos += seglen;
 800cb06:	b2a4      	uxth	r4, r4
      queuelen += pbuf_clen(concat_p);
 800cb08:	4430      	add	r0, r6
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 800cb0a:	45a3      	cmp	fp, r4
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
      }

      pos += seglen;
      queuelen += pbuf_clen(concat_p);
 800cb0c:	b286      	uxth	r6, r0
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 800cb0e:	f63f aef5 	bhi.w	800c8fc <tcp_write+0xdc>
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
 800cb12:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 800cb14:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
 800cb18:	2b00      	cmp	r3, #0
 800cb1a:	d1b2      	bne.n	800ca82 <tcp_write+0x262>
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
 800cb1c:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
 800cb20:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
 800cb24:	e034      	b.n	800cb90 <tcp_write+0x370>
  }
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
 800cb26:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800cb28:	2b00      	cmp	r3, #0
 800cb2a:	f47f af6a 	bne.w	800ca02 <tcp_write+0x1e2>
      pos += seglen;
      queuelen += pbuf_clen(concat_p);
    }
  } else {
#if TCP_OVERSIZE
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
 800cb2e:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
 800cb32:	2b00      	cmp	r3, #0
 800cb34:	d081      	beq.n	800ca3a <tcp_write+0x21a>
 800cb36:	4b5c      	ldr	r3, [pc, #368]	; (800cca8 <tcp_write+0x488>)
 800cb38:	9300      	str	r3, [sp, #0]
 800cb3a:	495c      	ldr	r1, [pc, #368]	; (800ccac <tcp_write+0x48c>)
 800cb3c:	4a5f      	ldr	r2, [pc, #380]	; (800ccbc <tcp_write+0x49c>)
 800cb3e:	485d      	ldr	r0, [pc, #372]	; (800ccb4 <tcp_write+0x494>)
 800cb40:	f44f 7300 	mov.w	r3, #512	; 0x200
 800cb44:	f7ff fdc4 	bl	800c6d0 <chprintf.constprop.2>
 800cb48:	485c      	ldr	r0, [pc, #368]	; (800ccbc <tcp_write+0x49c>)
 800cb4a:	f7f4 fa11 	bl	8000f70 <chSysHalt>
 800cb4e:	e770      	b.n	800ca32 <tcp_write+0x212>
       * sent out on the link (as it has to be ACKed by the remote
       * party) we can safely use PBUF_ROM instead of PBUF_REF here.
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
 800cb50:	4b55      	ldr	r3, [pc, #340]	; (800cca8 <tcp_write+0x488>)
 800cb52:	9300      	str	r3, [sp, #0]
 800cb54:	4955      	ldr	r1, [pc, #340]	; (800ccac <tcp_write+0x48c>)
 800cb56:	4a5a      	ldr	r2, [pc, #360]	; (800ccc0 <tcp_write+0x4a0>)
 800cb58:	4856      	ldr	r0, [pc, #344]	; (800ccb4 <tcp_write+0x494>)
 800cb5a:	f240 2326 	movw	r3, #550	; 0x226
 800cb5e:	f7ff fdb7 	bl	800c6d0 <chprintf.constprop.2>
 800cb62:	4857      	ldr	r0, [pc, #348]	; (800ccc0 <tcp_write+0x4a0>)
 800cb64:	f7f4 fa04 	bl	8000f70 <chSysHalt>
 800cb68:	e6d3      	b.n	800c912 <tcp_write+0xf2>

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
 800cb6a:	442c      	add	r4, r5
 800cb6c:	b2a4      	uxth	r4, r4
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 800cb6e:	45a3      	cmp	fp, r4
 800cb70:	9004      	str	r0, [sp, #16]
 800cb72:	f63f af0d 	bhi.w	800c990 <tcp_write+0x170>
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
 800cb76:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800cb78:	f8dd 8010 	ldr.w	r8, [sp, #16]
 800cb7c:	2b00      	cmp	r3, #0
 800cb7e:	d180      	bne.n	800ca82 <tcp_write+0x262>
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
 800cb80:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
 800cb84:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
#endif /* TCP_OVERSIZE */

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p
   */
  if (concat_p != NULL) {
 800cb88:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800cb8a:	2b00      	cmp	r3, #0
 800cb8c:	f000 8104 	beq.w	800cd98 <tcp_write+0x578>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
 800cb90:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800cb92:	2b00      	cmp	r3, #0
 800cb94:	f000 8112 	beq.w	800cdbc <tcp_write+0x59c>
      (last_unsent != NULL));
    pbuf_cat(last_unsent->p, concat_p);
 800cb98:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800cb9a:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 800cb9c:	6860      	ldr	r0, [r4, #4]
 800cb9e:	4629      	mov	r1, r5
 800cba0:	f7fc fe76 	bl	8009890 <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
 800cba4:	892a      	ldrh	r2, [r5, #8]
 800cba6:	8923      	ldrh	r3, [r4, #8]
 800cba8:	4413      	add	r3, r2
 800cbaa:	8123      	strh	r3, [r4, #8]
   * is harmless
   */
  if (last_unsent == NULL) {
    pcb->unsent = queue;
  } else {
    last_unsent->next = queue;
 800cbac:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800cbae:	f8c3 8000 	str.w	r8, [r3]
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
 800cbb2:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
  pcb->snd_buf -= len;
 800cbb4:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
  pcb->snd_queuelen = queuelen;
 800cbb8:	f8a7 6068 	strh.w	r6, [r7, #104]	; 0x68
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
 800cbbc:	445a      	add	r2, fp
  pcb->snd_buf -= len;
 800cbbe:	ebcb 0b03 	rsb	fp, fp, r3
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
 800cbc2:	65fa      	str	r2, [r7, #92]	; 0x5c
  pcb->snd_buf -= len;
 800cbc4:	f8a7 b066 	strh.w	fp, [r7, #102]	; 0x66
  pcb->snd_queuelen = queuelen;

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
    pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
 800cbc8:	b11e      	cbz	r6, 800cbd2 <tcp_write+0x3b2>
    LWIP_ASSERT("tcp_write: valid queue length",
 800cbca:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800cbcc:	2b00      	cmp	r3, #0
 800cbce:	f000 80b1 	beq.w	800cd34 <tcp_write+0x514>
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
 800cbd2:	f1b9 0f00 	cmp.w	r9, #0
 800cbd6:	d00a      	beq.n	800cbee <tcp_write+0x3ce>
 800cbd8:	f8d9 400c 	ldr.w	r4, [r9, #12]
 800cbdc:	b13c      	cbz	r4, 800cbee <tcp_write+0x3ce>
 800cbde:	9b08      	ldr	r3, [sp, #32]
 800cbe0:	f003 0302 	and.w	r3, r3, #2
 800cbe4:	f003 09ff 	and.w	r9, r3, #255	; 0xff
 800cbe8:	2b00      	cmp	r3, #0
 800cbea:	f000 80bf 	beq.w	800cd6c <tcp_write+0x54c>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
 800cbee:	2000      	movs	r0, #0
 800cbf0:	e634      	b.n	800c85c <tcp_write+0x3c>
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
 800cbf2:	4b2d      	ldr	r3, [pc, #180]	; (800cca8 <tcp_write+0x488>)
 800cbf4:	9300      	str	r3, [sp, #0]
 800cbf6:	492d      	ldr	r1, [pc, #180]	; (800ccac <tcp_write+0x48c>)
 800cbf8:	4a32      	ldr	r2, [pc, #200]	; (800ccc4 <tcp_write+0x4a4>)
 800cbfa:	482e      	ldr	r0, [pc, #184]	; (800ccb4 <tcp_write+0x494>)
 800cbfc:	f44f 7307 	mov.w	r3, #540	; 0x21c
 800cc00:	f7ff fd66 	bl	800c6d0 <chprintf.constprop.2>
 800cc04:	482f      	ldr	r0, [pc, #188]	; (800ccc4 <tcp_write+0x4a4>)
 800cc06:	f7f4 f9b3 	bl	8000f70 <chSysHalt>
 800cc0a:	e6e3      	b.n	800c9d4 <tcp_write+0x1b4>
    /* first segment of to-be-queued data? */
    if (queue == NULL) {
      queue = seg;
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
 800cc0c:	4b26      	ldr	r3, [pc, #152]	; (800cca8 <tcp_write+0x488>)
 800cc0e:	9300      	str	r3, [sp, #0]
 800cc10:	4926      	ldr	r1, [pc, #152]	; (800ccac <tcp_write+0x48c>)
 800cc12:	4a2d      	ldr	r2, [pc, #180]	; (800ccc8 <tcp_write+0x4a8>)
 800cc14:	4827      	ldr	r0, [pc, #156]	; (800ccb4 <tcp_write+0x494>)
 800cc16:	f240 235b 	movw	r3, #603	; 0x25b
 800cc1a:	f7ff fd59 	bl	800c6d0 <chprintf.constprop.2>
 800cc1e:	482a      	ldr	r0, [pc, #168]	; (800ccc8 <tcp_write+0x4a8>)
 800cc20:	f7f4 f9a6 	bl	8000f70 <chSysHalt>
 800cc24:	e6ad      	b.n	800c982 <tcp_write+0x162>
 800cc26:	f8dd 8010 	ldr.w	r8, [sp, #16]
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
 800cc2a:	7fbb      	ldrb	r3, [r7, #30]
  TCP_STATS_INC(tcp.memerr);
 800cc2c:	4a27      	ldr	r2, [pc, #156]	; (800cccc <tcp_write+0x4ac>)
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
 800cc2e:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800cc32:	77bb      	strb	r3, [r7, #30]
  TCP_STATS_INC(tcp.memerr);
 800cc34:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 800cc38:	3301      	adds	r3, #1
 800cc3a:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c

  if (concat_p != NULL) {
 800cc3e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800cc40:	b113      	cbz	r3, 800cc48 <tcp_write+0x428>
    pbuf_free(concat_p);
 800cc42:	4618      	mov	r0, r3
 800cc44:	f7fc fbdc 	bl	8009400 <pbuf_free>
  }
  if (queue != NULL) {
 800cc48:	f1b8 0f00 	cmp.w	r8, #0
 800cc4c:	d002      	beq.n	800cc54 <tcp_write+0x434>
    tcp_segs_free(queue);
 800cc4e:	4640      	mov	r0, r8
 800cc50:	f7fd f9f6 	bl	800a040 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
 800cc54:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 800cc58:	b12b      	cbz	r3, 800cc66 <tcp_write+0x446>
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
 800cc5a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800cc5c:	b91b      	cbnz	r3, 800cc66 <tcp_write+0x446>
 800cc5e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800cc60:	2b00      	cmp	r3, #0
 800cc62:	f000 808b 	beq.w	800cd7c <tcp_write+0x55c>
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
      pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
 800cc66:	20ff      	movs	r0, #255	; 0xff
 800cc68:	b240      	sxtb	r0, r0
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
 800cc6a:	b00f      	add	sp, #60	; 0x3c
 800cc6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800cc70:	4643      	mov	r3, r8

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p2);
 800cc72:	4618      	mov	r0, r3
 800cc74:	f8dd 8010 	ldr.w	r8, [sp, #16]
 800cc78:	f7fc fbc2 	bl	8009400 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
 800cc7c:	e7d5      	b.n	800cc2a <tcp_write+0x40a>
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 800cc7e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800cc80:	9309      	str	r3, [sp, #36]	; 0x24
 800cc82:	2b00      	cmp	r3, #0
 800cc84:	f47f ae08 	bne.w	800c898 <tcp_write+0x78>
 800cc88:	4b07      	ldr	r3, [pc, #28]	; (800cca8 <tcp_write+0x488>)
 800cc8a:	9300      	str	r3, [sp, #0]
 800cc8c:	4907      	ldr	r1, [pc, #28]	; (800ccac <tcp_write+0x48c>)
 800cc8e:	4a10      	ldr	r2, [pc, #64]	; (800ccd0 <tcp_write+0x4b0>)
 800cc90:	4808      	ldr	r0, [pc, #32]	; (800ccb4 <tcp_write+0x494>)
 800cc92:	f240 1349 	movw	r3, #329	; 0x149
 800cc96:	f7ff fd1b 	bl	800c6d0 <chprintf.constprop.2>
 800cc9a:	480d      	ldr	r0, [pc, #52]	; (800ccd0 <tcp_write+0x4b0>)
 800cc9c:	f7f4 f968 	bl	8000f70 <chSysHalt>
 800cca0:	f8b7 6068 	ldrh.w	r6, [r7, #104]	; 0x68
 800cca4:	e5f3      	b.n	800c88e <tcp_write+0x6e>
 800cca6:	bf00      	nop
 800cca8:	08018070 	.word	0x08018070
 800ccac:	08016fe0 	.word	0x08016fe0
 800ccb0:	08018124 	.word	0x08018124
 800ccb4:	200180c8 	.word	0x200180c8
 800ccb8:	08018158 	.word	0x08018158
 800ccbc:	08018178 	.word	0x08018178
 800ccc0:	080181e8 	.word	0x080181e8
 800ccc4:	080181a8 	.word	0x080181a8
 800ccc8:	080181f8 	.word	0x080181f8
 800cccc:	2000c9fc 	.word	0x2000c9fc
 800ccd0:	080180e8 	.word	0x080180e8
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
      p->tot_len += oversize_used;
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
 800ccd4:	8963      	ldrh	r3, [r4, #10]
 800ccd6:	6860      	ldr	r0, [r4, #4]
 800ccd8:	9906      	ldr	r1, [sp, #24]
 800ccda:	4418      	add	r0, r3
 800ccdc:	462a      	mov	r2, r5
 800ccde:	f7f3 fdef 	bl	80008c0 <memcpy>
        p->len += oversize_used;
 800cce2:	8963      	ldrh	r3, [r4, #10]
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 800cce4:	6822      	ldr	r2, [r4, #0]
      p->tot_len += oversize_used;
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
        p->len += oversize_used;
 800cce6:	442b      	add	r3, r5
 800cce8:	8163      	strh	r3, [r4, #10]
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 800ccea:	2a00      	cmp	r2, #0
 800ccec:	f47f aed6 	bne.w	800ca9c <tcp_write+0x27c>
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
        p->len += oversize_used;
      }
    }
    last_unsent->len += oversize_used;
 800ccf0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800ccf2:	990a      	ldr	r1, [sp, #40]	; 0x28
 800ccf4:	8913      	ldrh	r3, [r2, #8]
 800ccf6:	4419      	add	r1, r3
 800ccf8:	8111      	strh	r1, [r2, #8]
 800ccfa:	e741      	b.n	800cb80 <tcp_write+0x360>
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
 800ccfc:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
 800cd00:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
 800cd04:	e752      	b.n	800cbac <tcp_write+0x38c>
      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
 800cd06:	9a08      	ldr	r2, [sp, #32]
 800cd08:	9201      	str	r2, [sp, #4]
 800cd0a:	2301      	movs	r3, #1
 800cd0c:	9302      	str	r3, [sp, #8]
 800cd0e:	9700      	str	r7, [sp, #0]
 800cd10:	4622      	mov	r2, r4
 800cd12:	2003      	movs	r0, #3
 800cd14:	4629      	mov	r1, r5
 800cd16:	f10d 0336 	add.w	r3, sp, #54	; 0x36
 800cd1a:	f7ff fd39 	bl	800c790 <tcp_pbuf_prealloc>
 800cd1e:	900b      	str	r0, [sp, #44]	; 0x2c
 800cd20:	2800      	cmp	r0, #0
 800cd22:	d040      	beq.n	800cda6 <tcp_write+0x586>
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        last_unsent->oversize_left += oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
 800cd24:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800cd26:	9b06      	ldr	r3, [sp, #24]
 800cd28:	6840      	ldr	r0, [r0, #4]
 800cd2a:	1899      	adds	r1, r3, r2
 800cd2c:	462a      	mov	r2, r5
 800cd2e:	f7f3 fdc7 	bl	80008c0 <memcpy>
 800cd32:	e6e3      	b.n	800cafc <tcp_write+0x2dc>
  pcb->snd_queuelen = queuelen;

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
    pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: valid queue length",
 800cd34:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800cd36:	2b00      	cmp	r3, #0
 800cd38:	f47f af4b 	bne.w	800cbd2 <tcp_write+0x3b2>
 800cd3c:	4b32      	ldr	r3, [pc, #200]	; (800ce08 <tcp_write+0x5e8>)
 800cd3e:	9300      	str	r3, [sp, #0]
 800cd40:	4932      	ldr	r1, [pc, #200]	; (800ce0c <tcp_write+0x5ec>)
 800cd42:	4a33      	ldr	r2, [pc, #204]	; (800ce10 <tcp_write+0x5f0>)
 800cd44:	4833      	ldr	r0, [pc, #204]	; (800ce14 <tcp_write+0x5f4>)
 800cd46:	f44f 732b 	mov.w	r3, #684	; 0x2ac
 800cd4a:	f7ff fcc1 	bl	800c6d0 <chprintf.constprop.2>
 800cd4e:	4830      	ldr	r0, [pc, #192]	; (800ce10 <tcp_write+0x5f0>)
 800cd50:	f7f4 f90e 	bl	8000f70 <chSysHalt>
 800cd54:	e73d      	b.n	800cbd2 <tcp_write+0x3b2>
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
      pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
 800cd56:	4a30      	ldr	r2, [pc, #192]	; (800ce18 <tcp_write+0x5f8>)
 800cd58:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 800cd5c:	3301      	adds	r3, #1
 800cd5e:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
    pcb->flags |= TF_NAGLEMEMERR;
 800cd62:	7fbb      	ldrb	r3, [r7, #30]
 800cd64:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800cd68:	77bb      	strb	r3, [r7, #30]
 800cd6a:	e77c      	b.n	800cc66 <tcp_write+0x446>
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 800cd6c:	2008      	movs	r0, #8
 800cd6e:	89a5      	ldrh	r5, [r4, #12]
 800cd70:	f002 f816 	bl	800eda0 <lwip_htons>
 800cd74:	4328      	orrs	r0, r5
 800cd76:	81a0      	strh	r0, [r4, #12]
  }

  return ERR_OK;
 800cd78:	4648      	mov	r0, r9
 800cd7a:	e56f      	b.n	800c85c <tcp_write+0x3c>
  }
  if (queue != NULL) {
    tcp_segs_free(queue);
  }
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
 800cd7c:	4b22      	ldr	r3, [pc, #136]	; (800ce08 <tcp_write+0x5e8>)
 800cd7e:	9300      	str	r3, [sp, #0]
 800cd80:	4922      	ldr	r1, [pc, #136]	; (800ce0c <tcp_write+0x5ec>)
 800cd82:	4a23      	ldr	r2, [pc, #140]	; (800ce10 <tcp_write+0x5f0>)
 800cd84:	4823      	ldr	r0, [pc, #140]	; (800ce14 <tcp_write+0x5f4>)
 800cd86:	f240 23c1 	movw	r3, #705	; 0x2c1
 800cd8a:	f7ff fca1 	bl	800c6d0 <chprintf.constprop.2>
 800cd8e:	4820      	ldr	r0, [pc, #128]	; (800ce10 <tcp_write+0x5f0>)
 800cd90:	f7f4 f8ee 	bl	8000f70 <chSysHalt>
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
 800cd94:	20ff      	movs	r0, #255	; 0xff
 800cd96:	e561      	b.n	800c85c <tcp_write+0x3c>

  /*
   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
   * is harmless
   */
  if (last_unsent == NULL) {
 800cd98:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800cd9a:	2b00      	cmp	r3, #0
 800cd9c:	f47f af06 	bne.w	800cbac <tcp_write+0x38c>
    pcb->unsent = queue;
 800cda0:	f8c7 806c 	str.w	r8, [r7, #108]	; 0x6c
 800cda4:	e705      	b.n	800cbb2 <tcp_write+0x392>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
 800cda6:	7fbb      	ldrb	r3, [r7, #30]
  TCP_STATS_INC(tcp.memerr);
 800cda8:	4a1b      	ldr	r2, [pc, #108]	; (800ce18 <tcp_write+0x5f8>)
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
 800cdaa:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800cdae:	77bb      	strb	r3, [r7, #30]
  TCP_STATS_INC(tcp.memerr);
 800cdb0:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 800cdb4:	3301      	adds	r3, #1
 800cdb6:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
 800cdba:	e74b      	b.n	800cc54 <tcp_write+0x434>

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p
   */
  if (concat_p != NULL) {
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
 800cdbc:	4b12      	ldr	r3, [pc, #72]	; (800ce08 <tcp_write+0x5e8>)
 800cdbe:	9300      	str	r3, [sp, #0]
 800cdc0:	4912      	ldr	r1, [pc, #72]	; (800ce0c <tcp_write+0x5ec>)
 800cdc2:	4a16      	ldr	r2, [pc, #88]	; (800ce1c <tcp_write+0x5fc>)
 800cdc4:	4813      	ldr	r0, [pc, #76]	; (800ce14 <tcp_write+0x5f4>)
 800cdc6:	f240 238b 	movw	r3, #651	; 0x28b
 800cdca:	f7ff fc81 	bl	800c6d0 <chprintf.constprop.2>
 800cdce:	4813      	ldr	r0, [pc, #76]	; (800ce1c <tcp_write+0x5fc>)
 800cdd0:	f7f4 f8ce 	bl	8000f70 <chSysHalt>
 800cdd4:	e6e0      	b.n	800cb98 <tcp_write+0x378>
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
 800cdd6:	4b0c      	ldr	r3, [pc, #48]	; (800ce08 <tcp_write+0x5e8>)
 800cdd8:	9300      	str	r3, [sp, #0]
 800cdda:	490c      	ldr	r1, [pc, #48]	; (800ce0c <tcp_write+0x5ec>)
 800cddc:	4a10      	ldr	r2, [pc, #64]	; (800ce20 <tcp_write+0x600>)
 800cdde:	480d      	ldr	r0, [pc, #52]	; (800ce14 <tcp_write+0x5f4>)
 800cde0:	f240 137f 	movw	r3, #383	; 0x17f
 800cde4:	f7ff fc74 	bl	800c6d0 <chprintf.constprop.2>
 800cde8:	480d      	ldr	r0, [pc, #52]	; (800ce20 <tcp_write+0x600>)
 800cdea:	f7f4 f8c1 	bl	8000f70 <chSysHalt>
 800cdee:	20f2      	movs	r0, #242	; 0xf2
 800cdf0:	e534      	b.n	800c85c <tcp_write+0x3c>
 800cdf2:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 800cdf6:	e573      	b.n	800c8e0 <tcp_write+0xc0>
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
 800cdf8:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
 800cdfc:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
 800ce00:	46d9      	mov	r9, fp
 800ce02:	46d8      	mov	r8, fp
 800ce04:	e7cc      	b.n	800cda0 <tcp_write+0x580>
 800ce06:	bf00      	nop
 800ce08:	08018070 	.word	0x08018070
 800ce0c:	08016fe0 	.word	0x08016fe0
 800ce10:	08018244 	.word	0x08018244
 800ce14:	200180c8 	.word	0x200180c8
 800ce18:	2000c9fc 	.word	0x2000c9fc
 800ce1c:	0801820c 	.word	0x0801820c
 800ce20:	080180b4 	.word	0x080180b4
 800ce24:	f3af 8000 	nop.w
 800ce28:	f3af 8000 	nop.w
 800ce2c:	f3af 8000 	nop.w

0800ce30 <tcp_enqueue_flags>:
 * @param optdata pointer to TCP options, or NULL.
 * @param optlen length of TCP options in bytes.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
 800ce30:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  u8_t optflags = 0;
  u8_t optlen = 0;

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
 800ce34:	f011 0703 	ands.w	r7, r1, #3
 * @param optdata pointer to TCP options, or NULL.
 * @param optlen length of TCP options in bytes.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
 800ce38:	b083      	sub	sp, #12
 800ce3a:	460e      	mov	r6, r1
 800ce3c:	4604      	mov	r4, r0
  u8_t optflags = 0;
  u8_t optlen = 0;

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
 800ce3e:	d063      	beq.n	800cf08 <tcp_enqueue_flags+0xd8>
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 800ce40:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 800ce44:	2b07      	cmp	r3, #7
 800ce46:	f200 80b0 	bhi.w	800cfaa <tcp_enqueue_flags+0x17a>
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }

  if (flags & TCP_SYN) {
 800ce4a:	f006 0302 	and.w	r3, r6, #2

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
 800ce4e:	f8b4 2066 	ldrh.w	r2, [r4, #102]	; 0x66
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
 800ce52:	2b00      	cmp	r3, #0
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }

  if (flags & TCP_SYN) {
 800ce54:	f003 01ff 	and.w	r1, r3, #255	; 0xff
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
 800ce58:	bf0e      	itee	eq
 800ce5a:	4689      	moveq	r9, r1
 800ce5c:	f04f 0901 	movne.w	r9, #1
 800ce60:	2104      	movne	r1, #4

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
 800ce62:	2a00      	cmp	r2, #0
 800ce64:	f000 8099 	beq.w	800cf9a <tcp_enqueue_flags+0x16a>
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 800ce68:	2000      	movs	r0, #0
 800ce6a:	b28d      	uxth	r5, r1
 800ce6c:	4629      	mov	r1, r5
 800ce6e:	4602      	mov	r2, r0
 800ce70:	f7fc fb46 	bl	8009500 <pbuf_alloc>
 800ce74:	4680      	mov	r8, r0
 800ce76:	2800      	cmp	r0, #0
 800ce78:	f000 80a3 	beq.w	800cfc2 <tcp_enqueue_flags+0x192>
    pcb->flags |= TF_NAGLEMEMERR;
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
 800ce7c:	8943      	ldrh	r3, [r0, #10]
 800ce7e:	42ab      	cmp	r3, r5
 800ce80:	d34f      	bcc.n	800cf22 <tcp_enqueue_flags+0xf2>
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 800ce82:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800ce84:	9300      	str	r3, [sp, #0]
 800ce86:	f8cd 9004 	str.w	r9, [sp, #4]
 800ce8a:	4642      	mov	r2, r8
 800ce8c:	f104 001a 	add.w	r0, r4, #26
 800ce90:	f104 011c 	add.w	r1, r4, #28
 800ce94:	4633      	mov	r3, r6
 800ce96:	f7ff fbb3 	bl	800c600 <tcp_create_segment.isra.0>
 800ce9a:	4605      	mov	r5, r0
 800ce9c:	2800      	cmp	r0, #0
 800ce9e:	f000 8090 	beq.w	800cfc2 <tcp_enqueue_flags+0x192>
    pcb->flags |= TF_NAGLEMEMERR;
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
 800cea2:	68c3      	ldr	r3, [r0, #12]
 800cea4:	079a      	lsls	r2, r3, #30
 800cea6:	d15a      	bne.n	800cf5e <tcp_enqueue_flags+0x12e>
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
 800cea8:	892b      	ldrh	r3, [r5, #8]
 800ceaa:	2b00      	cmp	r3, #0
 800ceac:	d146      	bne.n	800cf3c <tcp_enqueue_flags+0x10c>
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 800ceae:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800ceb0:	b90a      	cbnz	r2, 800ceb6 <tcp_enqueue_flags+0x86>
 800ceb2:	e052      	b.n	800cf5a <tcp_enqueue_flags+0x12a>
 800ceb4:	461a      	mov	r2, r3
    pcb->unsent = seg;
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 800ceb6:	6813      	ldr	r3, [r2, #0]
 800ceb8:	2b00      	cmp	r3, #0
 800ceba:	d1fb      	bne.n	800ceb4 <tcp_enqueue_flags+0x84>
    useg->next = seg;
 800cebc:	6015      	str	r5, [r2, #0]
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
 800cebe:	2300      	movs	r3, #0
 800cec0:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 800cec4:	b13f      	cbz	r7, 800ced6 <tcp_enqueue_flags+0xa6>
    pcb->snd_lbb++;
 800cec6:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
 800cec8:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
  pcb->unsent_oversize = 0;
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    pcb->snd_lbb++;
 800cecc:	3201      	adds	r2, #1
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
 800cece:	3b01      	subs	r3, #1
  pcb->unsent_oversize = 0;
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    pcb->snd_lbb++;
 800ced0:	65e2      	str	r2, [r4, #92]	; 0x5c
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
 800ced2:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
  }
  if (flags & TCP_FIN) {
 800ced6:	07f3      	lsls	r3, r6, #31
 800ced8:	d411      	bmi.n	800cefe <tcp_enqueue_flags+0xce>
    pcb->flags |= TF_FIN;
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 800ceda:	6868      	ldr	r0, [r5, #4]
 800cedc:	f7fc fcc0 	bl	8009860 <pbuf_clen>
 800cee0:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 800cee4:	4418      	add	r0, r3
 800cee6:	b280      	uxth	r0, r0
 800cee8:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
 800ceec:	b118      	cbz	r0, 800cef6 <tcp_enqueue_flags+0xc6>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 800ceee:	6f20      	ldr	r0, [r4, #112]	; 0x70
 800cef0:	2800      	cmp	r0, #0
 800cef2:	d041      	beq.n	800cf78 <tcp_enqueue_flags+0x148>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
 800cef4:	2000      	movs	r0, #0
}
 800cef6:	b240      	sxtb	r0, r0
 800cef8:	b003      	add	sp, #12
 800cefa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    pcb->snd_lbb++;
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
  }
  if (flags & TCP_FIN) {
    pcb->flags |= TF_FIN;
 800cefe:	7fa3      	ldrb	r3, [r4, #30]
 800cf00:	f043 0320 	orr.w	r3, r3, #32
 800cf04:	77a3      	strb	r3, [r4, #30]
 800cf06:	e7e8      	b.n	800ceda <tcp_enqueue_flags+0xaa>
  u8_t optflags = 0;
  u8_t optlen = 0;

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
 800cf08:	4b34      	ldr	r3, [pc, #208]	; (800cfdc <tcp_enqueue_flags+0x1ac>)
 800cf0a:	9300      	str	r3, [sp, #0]
 800cf0c:	4934      	ldr	r1, [pc, #208]	; (800cfe0 <tcp_enqueue_flags+0x1b0>)
 800cf0e:	4a35      	ldr	r2, [pc, #212]	; (800cfe4 <tcp_enqueue_flags+0x1b4>)
 800cf10:	4835      	ldr	r0, [pc, #212]	; (800cfe8 <tcp_enqueue_flags+0x1b8>)
 800cf12:	f44f 7337 	mov.w	r3, #732	; 0x2dc
 800cf16:	f7ff fbdb 	bl	800c6d0 <chprintf.constprop.2>
 800cf1a:	4832      	ldr	r0, [pc, #200]	; (800cfe4 <tcp_enqueue_flags+0x1b4>)
 800cf1c:	f7f4 f828 	bl	8000f70 <chSysHalt>
 800cf20:	e78e      	b.n	800ce40 <tcp_enqueue_flags+0x10>
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    pcb->flags |= TF_NAGLEMEMERR;
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
 800cf22:	4b2e      	ldr	r3, [pc, #184]	; (800cfdc <tcp_enqueue_flags+0x1ac>)
 800cf24:	9300      	str	r3, [sp, #0]
 800cf26:	492e      	ldr	r1, [pc, #184]	; (800cfe0 <tcp_enqueue_flags+0x1b0>)
 800cf28:	4a30      	ldr	r2, [pc, #192]	; (800cfec <tcp_enqueue_flags+0x1bc>)
 800cf2a:	482f      	ldr	r0, [pc, #188]	; (800cfe8 <tcp_enqueue_flags+0x1b8>)
 800cf2c:	f240 3302 	movw	r3, #770	; 0x302
 800cf30:	f7ff fbce 	bl	800c6d0 <chprintf.constprop.2>
 800cf34:	482d      	ldr	r0, [pc, #180]	; (800cfec <tcp_enqueue_flags+0x1bc>)
 800cf36:	f7f4 f81b 	bl	8000f70 <chSysHalt>
 800cf3a:	e7a2      	b.n	800ce82 <tcp_enqueue_flags+0x52>
    pcb->flags |= TF_NAGLEMEMERR;
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
 800cf3c:	4b27      	ldr	r3, [pc, #156]	; (800cfdc <tcp_enqueue_flags+0x1ac>)
 800cf3e:	4a2c      	ldr	r2, [pc, #176]	; (800cff0 <tcp_enqueue_flags+0x1c0>)
 800cf40:	9300      	str	r3, [sp, #0]
 800cf42:	4927      	ldr	r1, [pc, #156]	; (800cfe0 <tcp_enqueue_flags+0x1b0>)
 800cf44:	4828      	ldr	r0, [pc, #160]	; (800cfe8 <tcp_enqueue_flags+0x1b8>)
 800cf46:	f240 330b 	movw	r3, #779	; 0x30b
 800cf4a:	f7ff fbc1 	bl	800c6d0 <chprintf.constprop.2>
 800cf4e:	4828      	ldr	r0, [pc, #160]	; (800cff0 <tcp_enqueue_flags+0x1c0>)
 800cf50:	f7f4 f80e 	bl	8000f70 <chSysHalt>
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 800cf54:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800cf56:	2a00      	cmp	r2, #0
 800cf58:	d1ad      	bne.n	800ceb6 <tcp_enqueue_flags+0x86>
    pcb->unsent = seg;
 800cf5a:	66e5      	str	r5, [r4, #108]	; 0x6c
 800cf5c:	e7af      	b.n	800cebe <tcp_enqueue_flags+0x8e>
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    pcb->flags |= TF_NAGLEMEMERR;
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
 800cf5e:	4b1f      	ldr	r3, [pc, #124]	; (800cfdc <tcp_enqueue_flags+0x1ac>)
 800cf60:	9300      	str	r3, [sp, #0]
 800cf62:	491f      	ldr	r1, [pc, #124]	; (800cfe0 <tcp_enqueue_flags+0x1b0>)
 800cf64:	4a23      	ldr	r2, [pc, #140]	; (800cff4 <tcp_enqueue_flags+0x1c4>)
 800cf66:	4820      	ldr	r0, [pc, #128]	; (800cfe8 <tcp_enqueue_flags+0x1b8>)
 800cf68:	f240 330a 	movw	r3, #778	; 0x30a
 800cf6c:	f7ff fbb0 	bl	800c6d0 <chprintf.constprop.2>
 800cf70:	4820      	ldr	r0, [pc, #128]	; (800cff4 <tcp_enqueue_flags+0x1c4>)
 800cf72:	f7f3 fffd 	bl	8000f70 <chSysHalt>
 800cf76:	e797      	b.n	800cea8 <tcp_enqueue_flags+0x78>

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 800cf78:	6ee4      	ldr	r4, [r4, #108]	; 0x6c
 800cf7a:	2c00      	cmp	r4, #0
 800cf7c:	d1bb      	bne.n	800cef6 <tcp_enqueue_flags+0xc6>
 800cf7e:	4b17      	ldr	r3, [pc, #92]	; (800cfdc <tcp_enqueue_flags+0x1ac>)
 800cf80:	9300      	str	r3, [sp, #0]
 800cf82:	4917      	ldr	r1, [pc, #92]	; (800cfe0 <tcp_enqueue_flags+0x1b0>)
 800cf84:	4a1c      	ldr	r2, [pc, #112]	; (800cff8 <tcp_enqueue_flags+0x1c8>)
 800cf86:	4818      	ldr	r0, [pc, #96]	; (800cfe8 <tcp_enqueue_flags+0x1b8>)
 800cf88:	f240 332f 	movw	r3, #815	; 0x32f
 800cf8c:	f7ff fba0 	bl	800c6d0 <chprintf.constprop.2>
 800cf90:	4819      	ldr	r0, [pc, #100]	; (800cff8 <tcp_enqueue_flags+0x1c8>)
 800cf92:	f7f3 ffed 	bl	8000f70 <chSysHalt>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
 800cf96:	4620      	mov	r0, r4
 800cf98:	e7ad      	b.n	800cef6 <tcp_enqueue_flags+0xc6>
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
    TCP_STATS_INC(tcp.memerr);
 800cf9a:	4a18      	ldr	r2, [pc, #96]	; (800cffc <tcp_enqueue_flags+0x1cc>)
 800cf9c:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 800cfa0:	3301      	adds	r3, #1
 800cfa2:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
    return ERR_MEM;
 800cfa6:	20ff      	movs	r0, #255	; 0xff
 800cfa8:	e7a5      	b.n	800cef6 <tcp_enqueue_flags+0xc6>

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
                                       pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
 800cfaa:	4a14      	ldr	r2, [pc, #80]	; (800cffc <tcp_enqueue_flags+0x1cc>)
 800cfac:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 800cfb0:	3301      	adds	r3, #1
 800cfb2:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
    pcb->flags |= TF_NAGLEMEMERR;
 800cfb6:	7fa3      	ldrb	r3, [r4, #30]
 800cfb8:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800cfbc:	77a3      	strb	r3, [r4, #30]
    return ERR_MEM;
 800cfbe:	20ff      	movs	r0, #255	; 0xff
 800cfc0:	e799      	b.n	800cef6 <tcp_enqueue_flags+0xc6>
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    pcb->flags |= TF_NAGLEMEMERR;
 800cfc2:	7fa3      	ldrb	r3, [r4, #30]
    TCP_STATS_INC(tcp.memerr);
 800cfc4:	4a0d      	ldr	r2, [pc, #52]	; (800cffc <tcp_enqueue_flags+0x1cc>)
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    pcb->flags |= TF_NAGLEMEMERR;
 800cfc6:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800cfca:	77a3      	strb	r3, [r4, #30]
    TCP_STATS_INC(tcp.memerr);
 800cfcc:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 800cfd0:	3301      	adds	r3, #1
 800cfd2:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
    return ERR_MEM;
 800cfd6:	20ff      	movs	r0, #255	; 0xff
 800cfd8:	e78d      	b.n	800cef6 <tcp_enqueue_flags+0xc6>
 800cfda:	bf00      	nop
 800cfdc:	08018070 	.word	0x08018070
 800cfe0:	08016fe0 	.word	0x08016fe0
 800cfe4:	08018264 	.word	0x08018264
 800cfe8:	200180c8 	.word	0x200180c8
 800cfec:	080182bc 	.word	0x080182bc
 800cff0:	08018310 	.word	0x08018310
 800cff4:	080182f8 	.word	0x080182f8
 800cff8:	0801833c 	.word	0x0801833c
 800cffc:	2000c9fc 	.word	0x2000c9fc

0800d000 <tcp_send_fin>:
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
 800d000:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
 800d002:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
 800d004:	4605      	mov	r5, r0
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
 800d006:	b90c      	cbnz	r4, 800d00c <tcp_send_fin+0xc>
 800d008:	e00a      	b.n	800d020 <tcp_send_fin+0x20>
 800d00a:	461c      	mov	r4, r3
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 800d00c:	6823      	ldr	r3, [r4, #0]
 800d00e:	2b00      	cmp	r3, #0
 800d010:	d1fb      	bne.n	800d00a <tcp_send_fin+0xa>
         last_unsent = last_unsent->next);

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 800d012:	68e3      	ldr	r3, [r4, #12]
 800d014:	8998      	ldrh	r0, [r3, #12]
 800d016:	f001 fecb 	bl	800edb0 <lwip_ntohs>
 800d01a:	f010 0607 	ands.w	r6, r0, #7
 800d01e:	d005      	beq.n	800d02c <tcp_send_fin+0x2c>
      pcb->flags |= TF_FIN;
      return ERR_OK;
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
 800d020:	4628      	mov	r0, r5
 800d022:	2101      	movs	r1, #1
}
 800d024:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      pcb->flags |= TF_FIN;
      return ERR_OK;
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
 800d028:	f7ff bf02 	b.w	800ce30 <tcp_enqueue_flags>
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 800d02c:	68e7      	ldr	r7, [r4, #12]
 800d02e:	2001      	movs	r0, #1
 800d030:	89bc      	ldrh	r4, [r7, #12]
 800d032:	f001 feb5 	bl	800eda0 <lwip_htons>
 800d036:	4320      	orrs	r0, r4
 800d038:	81b8      	strh	r0, [r7, #12]
      pcb->flags |= TF_FIN;
 800d03a:	7fab      	ldrb	r3, [r5, #30]
 800d03c:	f043 0320 	orr.w	r3, r3, #32
 800d040:	77ab      	strb	r3, [r5, #30]
      return ERR_OK;
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
}
 800d042:	4630      	mov	r0, r6
 800d044:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800d046:	bf00      	nop
 800d048:	f3af 8000 	nop.w
 800d04c:	f3af 8000 	nop.w

0800d050 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
 800d050:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d052:	4604      	mov	r4, r0
 800d054:	b083      	sub	sp, #12
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
 800d056:	6d00      	ldr	r0, [r0, #80]	; 0x50
 800d058:	f001 feb2 	bl	800edc0 <lwip_htonl>
 800d05c:	2100      	movs	r1, #0
 800d05e:	4602      	mov	r2, r0
 800d060:	4620      	mov	r0, r4
 800d062:	f7ff fb4d 	bl	800c700 <tcp_output_alloc_header.constprop.1>
  if (p == NULL) {
 800d066:	b1f8      	cbz	r0, 800d0a8 <tcp_send_empty_ack+0x58>
  }
  tcphdr = (struct tcp_hdr *)p->payload;
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 800d068:	7fa3      	ldrb	r3, [r4, #30]
  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
  if (p == NULL) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 800d06a:	6847      	ldr	r7, [r0, #4]
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 800d06c:	f023 0303 	bic.w	r3, r3, #3
 800d070:	77a3      	strb	r3, [r4, #30]
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif 

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
 800d072:	8903      	ldrh	r3, [r0, #8]
 800d074:	9300      	str	r3, [sp, #0]
 800d076:	1d26      	adds	r6, r4, #4
 800d078:	4632      	mov	r2, r6
 800d07a:	4621      	mov	r1, r4
 800d07c:	2306      	movs	r3, #6
 800d07e:	4605      	mov	r5, r0
 800d080:	f000 ff2e 	bl	800dee0 <inet_chksum_pseudo>
 800d084:	8238      	strh	r0, [r7, #16]
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 800d086:	7a62      	ldrb	r2, [r4, #9]
 800d088:	7aa3      	ldrb	r3, [r4, #10]
 800d08a:	9200      	str	r2, [sp, #0]
 800d08c:	2006      	movs	r0, #6
 800d08e:	4632      	mov	r2, r6
 800d090:	4621      	mov	r1, r4
 800d092:	9001      	str	r0, [sp, #4]
 800d094:	4628      	mov	r0, r5
 800d096:	f001 f9a3 	bl	800e3e0 <ip_output>
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);
 800d09a:	4628      	mov	r0, r5
 800d09c:	f7fc f9b0 	bl	8009400 <pbuf_free>

  return ERR_OK;
 800d0a0:	2000      	movs	r0, #0
}
 800d0a2:	b240      	sxtb	r0, r0
 800d0a4:	b003      	add	sp, #12
 800d0a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
  if (p == NULL) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
 800d0a8:	20fe      	movs	r0, #254	; 0xfe
 800d0aa:	e7fa      	b.n	800d0a2 <tcp_send_empty_ack+0x52>
 800d0ac:	f3af 8000 	nop.w

0800d0b0 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
 800d0b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
#if TCP_CWND_DEBUG
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 800d0b4:	7e03      	ldrb	r3, [r0, #24]
 800d0b6:	2b01      	cmp	r3, #1
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
 800d0b8:	b082      	sub	sp, #8
 800d0ba:	4604      	mov	r4, r0
#if TCP_CWND_DEBUG
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 800d0bc:	f000 8180 	beq.w	800d3c0 <tcp_output+0x310>

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
 800d0c0:	4bb5      	ldr	r3, [pc, #724]	; (800d398 <tcp_output+0x2e8>)
 800d0c2:	681b      	ldr	r3, [r3, #0]
 800d0c4:	42a3      	cmp	r3, r4
 800d0c6:	f000 8123 	beq.w	800d310 <tcp_output+0x260>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 800d0ca:	f8b4 8060 	ldrh.w	r8, [r4, #96]	; 0x60
 800d0ce:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
 800d0d2:	7fa3      	ldrb	r3, [r4, #30]
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);

  seg = pcb->unsent;
 800d0d4:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
     with. */
  if (tcp_input_pcb == pcb) {
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 800d0d6:	4590      	cmp	r8, r2
 800d0d8:	bf28      	it	cs
 800d0da:	4690      	movcs	r8, r2
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
 800d0dc:	0799      	lsls	r1, r3, #30
 800d0de:	f140 80e7 	bpl.w	800d2b0 <tcp_output+0x200>
 800d0e2:	2d00      	cmp	r5, #0
 800d0e4:	f000 8166 	beq.w	800d3b4 <tcp_output+0x304>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
 800d0e8:	68eb      	ldr	r3, [r5, #12]
 800d0ea:	6858      	ldr	r0, [r3, #4]
 800d0ec:	f001 fe70 	bl	800edd0 <lwip_ntohl>
 800d0f0:	892b      	ldrh	r3, [r5, #8]
 800d0f2:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 800d0f4:	1a9b      	subs	r3, r3, r2
 800d0f6:	4418      	add	r0, r3
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
 800d0f8:	4580      	cmp	r8, r0
 800d0fa:	f0c0 815b 	bcc.w	800d3b4 <tcp_output+0x304>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
 800d0fe:	6f27      	ldr	r7, [r4, #112]	; 0x70
  if (useg != NULL) {
 800d100:	b137      	cbz	r7, 800d110 <tcp_output+0x60>
    for (; useg->next != NULL; useg = useg->next);
 800d102:	683b      	ldr	r3, [r7, #0]
 800d104:	2b00      	cmp	r3, #0
 800d106:	f040 80d6 	bne.w	800d2b6 <tcp_output+0x206>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 800d10a:	2d00      	cmp	r5, #0
 800d10c:	f000 8140 	beq.w	800d390 <tcp_output+0x2e0>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
 800d110:	f8df 929c 	ldr.w	r9, [pc, #668]	; 800d3b0 <tcp_output+0x300>
 800d114:	e0ad      	b.n	800d272 <tcp_output+0x1c2>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
 800d116:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800d118:	b15b      	cbz	r3, 800d132 <tcp_output+0x82>
 800d11a:	7fa3      	ldrb	r3, [r4, #30]
 800d11c:	f013 0f44 	tst.w	r3, #68	; 0x44
 800d120:	d107      	bne.n	800d132 <tcp_output+0x82>
 800d122:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800d124:	2a00      	cmp	r2, #0
 800d126:	f000 811c 	beq.w	800d362 <tcp_output+0x2b2>
 800d12a:	6811      	ldr	r1, [r2, #0]
 800d12c:	2900      	cmp	r1, #0
 800d12e:	f000 8113 	beq.w	800d358 <tcp_output+0x2a8>
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;

    if (pcb->state != SYN_SENT) {
 800d132:	7e23      	ldrb	r3, [r4, #24]
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
 800d134:	682a      	ldr	r2, [r5, #0]
 800d136:	66e2      	str	r2, [r4, #108]	; 0x6c

    if (pcb->state != SYN_SENT) {
 800d138:	2b02      	cmp	r3, #2
 800d13a:	d00d      	beq.n	800d158 <tcp_output+0xa8>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 800d13c:	f8d5 a00c 	ldr.w	sl, [r5, #12]
 800d140:	2010      	movs	r0, #16
 800d142:	f8ba 600c 	ldrh.w	r6, [sl, #12]
 800d146:	f001 fe2b 	bl	800eda0 <lwip_htons>
 800d14a:	4330      	orrs	r0, r6
 800d14c:	f8aa 000c 	strh.w	r0, [sl, #12]
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 800d150:	7fa3      	ldrb	r3, [r4, #30]
 800d152:	f023 0303 	bic.w	r3, r3, #3
 800d156:	77a3      	strb	r3, [r4, #30]
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
 800d158:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800d15a:	68ee      	ldr	r6, [r5, #12]
 800d15c:	f001 fe30 	bl	800edc0 <lwip_htonl>
 800d160:	60b0      	str	r0, [r6, #8]

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 800d162:	8de0      	ldrh	r0, [r4, #46]	; 0x2e
 800d164:	68ee      	ldr	r6, [r5, #12]
 800d166:	f001 fe1b 	bl	800eda0 <lwip_htons>

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 800d16a:	8de2      	ldrh	r2, [r4, #46]	; 0x2e
 800d16c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 800d16e:	81f0      	strh	r0, [r6, #14]

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 800d170:	4413      	add	r3, r2
 800d172:	6323      	str	r3, [r4, #48]	; 0x30

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
  if (seg->flags & TF_SEG_OPTS_MSS) {
 800d174:	7aab      	ldrb	r3, [r5, #10]

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 800d176:	f8d5 a00c 	ldr.w	sl, [r5, #12]
  if (seg->flags & TF_SEG_OPTS_MSS) {
 800d17a:	07db      	lsls	r3, r3, #31
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
 800d17c:	f104 0604 	add.w	r6, r4, #4
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
  if (seg->flags & TF_SEG_OPTS_MSS) {
 800d180:	f100 809e 	bmi.w	800d2c0 <tcp_output+0x210>
  }
#endif

  /* Set retransmission timer running if it is not currently enabled 
     This must be set before checking the route. */
  if (pcb->rtime == -1) {
 800d184:	f9b4 3034 	ldrsh.w	r3, [r4, #52]	; 0x34
 800d188:	3301      	adds	r3, #1
 800d18a:	f000 80a9 	beq.w	800d2e0 <tcp_output+0x230>
    pcb->rtime = 0;
  }

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
 800d18e:	6823      	ldr	r3, [r4, #0]
 800d190:	b933      	cbnz	r3, 800d1a0 <tcp_output+0xf0>
    netif = ip_route(&(pcb->remote_ip));
 800d192:	4630      	mov	r0, r6
 800d194:	f000 ff34 	bl	800e000 <ip_route>
    if (netif == NULL) {
 800d198:	2800      	cmp	r0, #0
 800d19a:	d032      	beq.n	800d202 <tcp_output+0x152>
      return;
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
 800d19c:	6843      	ldr	r3, [r0, #4]
 800d19e:	6023      	str	r3, [r4, #0]
  }

  if (pcb->rttest == 0) {
 800d1a0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800d1a2:	2b00      	cmp	r3, #0
 800d1a4:	f000 809f 	beq.w	800d2e6 <tcp_output+0x236>
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 800d1a8:	6868      	ldr	r0, [r5, #4]
 800d1aa:	f8d5 a00c 	ldr.w	sl, [r5, #12]
 800d1ae:	6842      	ldr	r2, [r0, #4]

  seg->p->len -= len;
  seg->p->tot_len -= len;
 800d1b0:	8903      	ldrh	r3, [r0, #8]
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);

  seg->p->len -= len;
 800d1b2:	8941      	ldrh	r1, [r0, #10]
  seg->p->tot_len -= len;

  seg->p->payload = seg->tcphdr;
 800d1b4:	f8c0 a004 	str.w	sl, [r0, #4]
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 800d1b8:	ebc2 020a 	rsb	r2, r2, sl
 800d1bc:	b292      	uxth	r2, r2

  seg->p->len -= len;
  seg->p->tot_len -= len;
 800d1be:	1a9b      	subs	r3, r3, r2
 800d1c0:	b29b      	uxth	r3, r3
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);

  seg->p->len -= len;
 800d1c2:	1a8a      	subs	r2, r1, r2
  seg->p->tot_len -= len;

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
 800d1c4:	2100      	movs	r1, #0
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);

  seg->p->len -= len;
 800d1c6:	8142      	strh	r2, [r0, #10]
  seg->p->tot_len -= len;
 800d1c8:	8103      	strh	r3, [r0, #8]
      seg->tcphdr->chksum = chksum_slow;
    }
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
  }
#else /* TCP_CHECKSUM_ON_COPY */
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
 800d1ca:	4632      	mov	r2, r6
  seg->p->len -= len;
  seg->p->tot_len -= len;

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
 800d1cc:	f88a 1010 	strb.w	r1, [sl, #16]
 800d1d0:	f88a 1011 	strb.w	r1, [sl, #17]
      seg->tcphdr->chksum = chksum_slow;
    }
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
  }
#else /* TCP_CHECKSUM_ON_COPY */
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
 800d1d4:	4621      	mov	r1, r4
 800d1d6:	9300      	str	r3, [sp, #0]
 800d1d8:	2306      	movs	r3, #6
 800d1da:	f000 fe81 	bl	800dee0 <inet_chksum_pseudo>
         &(pcb->remote_ip),
         IP_PROTO_TCP, seg->p->tot_len);
#endif /* TCP_CHECKSUM_ON_COPY */
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);
 800d1de:	4a6f      	ldr	r2, [pc, #444]	; (800d39c <tcp_output+0x2ec>)
      seg->tcphdr->chksum = chksum_slow;
    }
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
  }
#else /* TCP_CHECKSUM_ON_COPY */
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
 800d1e0:	f8aa 0010 	strh.w	r0, [sl, #16]
         &(pcb->remote_ip),
         IP_PROTO_TCP, seg->p->tot_len);
#endif /* TCP_CHECKSUM_ON_COPY */
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);
 800d1e4:	f8b2 3090 	ldrh.w	r3, [r2, #144]	; 0x90

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 800d1e8:	6868      	ldr	r0, [r5, #4]
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
         &(pcb->remote_ip),
         IP_PROTO_TCP, seg->p->tot_len);
#endif /* TCP_CHECKSUM_ON_COPY */
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);
 800d1ea:	3301      	adds	r3, #1
 800d1ec:	f8a2 3090 	strh.w	r3, [r2, #144]	; 0x90

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 800d1f0:	7a62      	ldrb	r2, [r4, #9]
 800d1f2:	7aa3      	ldrb	r3, [r4, #10]
 800d1f4:	9200      	str	r2, [sp, #0]
 800d1f6:	2106      	movs	r1, #6
 800d1f8:	9101      	str	r1, [sp, #4]
 800d1fa:	4632      	mov	r2, r6
 800d1fc:	4621      	mov	r1, r4
 800d1fe:	f001 f8ef 	bl	800e3e0 <ip_output>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 800d202:	68eb      	ldr	r3, [r5, #12]
 800d204:	6858      	ldr	r0, [r3, #4]
 800d206:	f001 fde3 	bl	800edd0 <lwip_ntohl>
 800d20a:	68eb      	ldr	r3, [r5, #12]
 800d20c:	f8b5 a008 	ldrh.w	sl, [r5, #8]
 800d210:	4606      	mov	r6, r0
 800d212:	8998      	ldrh	r0, [r3, #12]
 800d214:	f001 fdcc 	bl	800edb0 <lwip_ntohs>
 800d218:	f010 0003 	ands.w	r0, r0, #3
 800d21c:	bf18      	it	ne
 800d21e:	2001      	movne	r0, #1
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 800d220:	6d23      	ldr	r3, [r4, #80]	; 0x50
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 800d222:	4450      	add	r0, sl
 800d224:	4430      	add	r0, r6
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 800d226:	1a1b      	subs	r3, r3, r0
 800d228:	2b00      	cmp	r3, #0
      pcb->snd_nxt = snd_nxt;
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
 800d22a:	68eb      	ldr	r3, [r5, #12]
    }

    tcp_output_segment(seg, pcb);
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
      pcb->snd_nxt = snd_nxt;
 800d22c:	bfb8      	it	lt
 800d22e:	6520      	strlt	r0, [r4, #80]	; 0x50
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
 800d230:	8998      	ldrh	r0, [r3, #12]
 800d232:	892e      	ldrh	r6, [r5, #8]
 800d234:	f001 fdbc 	bl	800edb0 <lwip_ntohs>
 800d238:	f010 0003 	ands.w	r0, r0, #3
 800d23c:	bf18      	it	ne
 800d23e:	2001      	movne	r0, #1
 800d240:	42c6      	cmn	r6, r0
 800d242:	f000 8085 	beq.w	800d350 <tcp_output+0x2a0>
      seg->next = NULL;
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
 800d246:	6f23      	ldr	r3, [r4, #112]	; 0x70
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
      pcb->snd_nxt = snd_nxt;
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
      seg->next = NULL;
 800d248:	2200      	movs	r2, #0
 800d24a:	602a      	str	r2, [r5, #0]
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
 800d24c:	2b00      	cmp	r3, #0
 800d24e:	d053      	beq.n	800d2f8 <tcp_output+0x248>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
 800d250:	68eb      	ldr	r3, [r5, #12]
 800d252:	6858      	ldr	r0, [r3, #4]
 800d254:	f001 fdbc 	bl	800edd0 <lwip_ntohl>
 800d258:	68fb      	ldr	r3, [r7, #12]
 800d25a:	4606      	mov	r6, r0
 800d25c:	6858      	ldr	r0, [r3, #4]
 800d25e:	f001 fdb7 	bl	800edd0 <lwip_ntohl>
 800d262:	1a30      	subs	r0, r6, r0
 800d264:	2800      	cmp	r0, #0
 800d266:	db57      	blt.n	800d318 <tcp_output+0x268>
          }
          seg->next = (*cur_seg);
          (*cur_seg) = seg;
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
 800d268:	603d      	str	r5, [r7, #0]
 800d26a:	462f      	mov	r7, r5
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
 800d26c:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 800d26e:	2d00      	cmp	r5, #0
 800d270:	d047      	beq.n	800d302 <tcp_output+0x252>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 800d272:	68eb      	ldr	r3, [r5, #12]
 800d274:	6858      	ldr	r0, [r3, #4]
 800d276:	f001 fdab 	bl	800edd0 <lwip_ntohl>
 800d27a:	892b      	ldrh	r3, [r5, #8]
 800d27c:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 800d27e:	1a9b      	subs	r3, r3, r2
 800d280:	4418      	add	r0, r3
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 800d282:	4580      	cmp	r8, r0
 800d284:	f0c0 8084 	bcc.w	800d390 <tcp_output+0x2e0>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
 800d288:	68eb      	ldr	r3, [r5, #12]
 800d28a:	8998      	ldrh	r0, [r3, #12]
 800d28c:	f001 fd90 	bl	800edb0 <lwip_ntohs>
 800d290:	0742      	lsls	r2, r0, #29
 800d292:	f57f af40 	bpl.w	800d116 <tcp_output+0x66>
 800d296:	f8cd 9000 	str.w	r9, [sp]
 800d29a:	4941      	ldr	r1, [pc, #260]	; (800d3a0 <tcp_output+0x2f0>)
 800d29c:	4a41      	ldr	r2, [pc, #260]	; (800d3a4 <tcp_output+0x2f4>)
 800d29e:	4842      	ldr	r0, [pc, #264]	; (800d3a8 <tcp_output+0x2f8>)
 800d2a0:	f240 33c5 	movw	r3, #965	; 0x3c5
 800d2a4:	f7ff fa14 	bl	800c6d0 <chprintf.constprop.2>
 800d2a8:	483e      	ldr	r0, [pc, #248]	; (800d3a4 <tcp_output+0x2f4>)
 800d2aa:	f7f3 fe61 	bl	8000f70 <chSysHalt>
 800d2ae:	e732      	b.n	800d116 <tcp_output+0x66>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
 800d2b0:	6f27      	ldr	r7, [r4, #112]	; 0x70
  if (useg != NULL) {
 800d2b2:	b90f      	cbnz	r7, 800d2b8 <tcp_output+0x208>
 800d2b4:	e729      	b.n	800d10a <tcp_output+0x5a>
 800d2b6:	461f      	mov	r7, r3
    for (; useg->next != NULL; useg = useg->next);
 800d2b8:	683b      	ldr	r3, [r7, #0]
 800d2ba:	2b00      	cmp	r3, #0
 800d2bc:	d1fb      	bne.n	800d2b6 <tcp_output+0x206>
 800d2be:	e724      	b.n	800d10a <tcp_output+0x5a>
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
  if (seg->flags & TF_SEG_OPTS_MSS) {
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
 800d2c0:	4631      	mov	r1, r6
 800d2c2:	f240 50b4 	movw	r0, #1460	; 0x5b4
 800d2c6:	f7fd fd8b 	bl	800ade0 <tcp_eff_send_mss>
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
 800d2ca:	f040 7001 	orr.w	r0, r0, #33816576	; 0x2040000
 800d2ce:	f001 fd77 	bl	800edc0 <lwip_htonl>
  }
#endif

  /* Set retransmission timer running if it is not currently enabled 
     This must be set before checking the route. */
  if (pcb->rtime == -1) {
 800d2d2:	f9b4 3034 	ldrsh.w	r3, [r4, #52]	; 0x34
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
 800d2d6:	f8ca 0014 	str.w	r0, [sl, #20]
  }
#endif

  /* Set retransmission timer running if it is not currently enabled 
     This must be set before checking the route. */
  if (pcb->rtime == -1) {
 800d2da:	3301      	adds	r3, #1
 800d2dc:	f47f af57 	bne.w	800d18e <tcp_output+0xde>
    pcb->rtime = 0;
 800d2e0:	2300      	movs	r3, #0
 800d2e2:	86a3      	strh	r3, [r4, #52]	; 0x34
 800d2e4:	e753      	b.n	800d18e <tcp_output+0xde>
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
  }

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
 800d2e6:	4a31      	ldr	r2, [pc, #196]	; (800d3ac <tcp_output+0x2fc>)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
 800d2e8:	68eb      	ldr	r3, [r5, #12]
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
  }

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
 800d2ea:	6812      	ldr	r2, [r2, #0]
 800d2ec:	63a2      	str	r2, [r4, #56]	; 0x38
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
 800d2ee:	6858      	ldr	r0, [r3, #4]
 800d2f0:	f001 fd6e 	bl	800edd0 <lwip_ntohl>
 800d2f4:	63e0      	str	r0, [r4, #60]	; 0x3c
 800d2f6:	e757      	b.n	800d1a8 <tcp_output+0xf8>
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
      seg->next = NULL;
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
        pcb->unacked = seg;
 800d2f8:	6725      	str	r5, [r4, #112]	; 0x70
 800d2fa:	462f      	mov	r7, r5
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
 800d2fc:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 800d2fe:	2d00      	cmp	r5, #0
 800d300:	d1b7      	bne.n	800d272 <tcp_output+0x1c2>
 800d302:	7fa3      	ldrb	r3, [r4, #30]
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
 800d304:	2200      	movs	r2, #0
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
 800d306:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
 800d30a:	f8a4 206a 	strh.w	r2, [r4, #106]	; 0x6a
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
 800d30e:	77a3      	strb	r3, [r4, #30]
  return ERR_OK;
}
 800d310:	2000      	movs	r0, #0
 800d312:	b002      	add	sp, #8
 800d314:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
 800d318:	6f23      	ldr	r3, [r4, #112]	; 0x70
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
 800d31a:	f104 0a70 	add.w	sl, r4, #112	; 0x70
          while (*cur_seg &&
 800d31e:	b92b      	cbnz	r3, 800d32c <tcp_output+0x27c>
 800d320:	e012      	b.n	800d348 <tcp_output+0x298>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
 800d322:	f8da a000 	ldr.w	sl, [sl]
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
 800d326:	f8da 3000 	ldr.w	r3, [sl]
 800d32a:	b16b      	cbz	r3, 800d348 <tcp_output+0x298>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 800d32c:	68db      	ldr	r3, [r3, #12]
 800d32e:	6858      	ldr	r0, [r3, #4]
 800d330:	f001 fd4e 	bl	800edd0 <lwip_ntohl>
 800d334:	68eb      	ldr	r3, [r5, #12]
 800d336:	4606      	mov	r6, r0
 800d338:	6858      	ldr	r0, [r3, #4]
 800d33a:	f001 fd49 	bl	800edd0 <lwip_ntohl>
 800d33e:	1a30      	subs	r0, r6, r0
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
 800d340:	2800      	cmp	r0, #0
 800d342:	dbee      	blt.n	800d322 <tcp_output+0x272>
 800d344:	f8da 3000 	ldr.w	r3, [sl]
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
          }
          seg->next = (*cur_seg);
 800d348:	602b      	str	r3, [r5, #0]
          (*cur_seg) = seg;
 800d34a:	f8ca 5000 	str.w	r5, [sl]
 800d34e:	e78d      	b.n	800d26c <tcp_output+0x1bc>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
 800d350:	4628      	mov	r0, r5
 800d352:	f7fc fe65 	bl	800a020 <tcp_seg_free>
 800d356:	e789      	b.n	800d26c <tcp_output+0x1bc>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
 800d358:	8910      	ldrh	r0, [r2, #8]
 800d35a:	8ee1      	ldrh	r1, [r4, #54]	; 0x36
 800d35c:	4288      	cmp	r0, r1
 800d35e:	f4bf aee8 	bcs.w	800d132 <tcp_output+0x82>
 800d362:	f8b4 1066 	ldrh.w	r1, [r4, #102]	; 0x66
 800d366:	2900      	cmp	r1, #0
 800d368:	f43f aee3 	beq.w	800d132 <tcp_output+0x82>
 800d36c:	f8b4 1068 	ldrh.w	r1, [r4, #104]	; 0x68
 800d370:	2907      	cmp	r1, #7
 800d372:	f63f aede 	bhi.w	800d132 <tcp_output+0x82>
 800d376:	f013 0fa0 	tst.w	r3, #160	; 0xa0
 800d37a:	f47f aeda 	bne.w	800d132 <tcp_output+0x82>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
 800d37e:	2a00      	cmp	r2, #0
 800d380:	d0c0      	beq.n	800d304 <tcp_output+0x254>
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
 800d382:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  return ERR_OK;
}
 800d386:	2000      	movs	r0, #0
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
 800d388:	77a3      	strb	r3, [r4, #30]
  return ERR_OK;
}
 800d38a:	b002      	add	sp, #8
 800d38c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800d390:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800d392:	7fa3      	ldrb	r3, [r4, #30]
 800d394:	e7f3      	b.n	800d37e <tcp_output+0x2ce>
 800d396:	bf00      	nop
 800d398:	2000cb9c 	.word	0x2000cb9c
 800d39c:	2000c9fc 	.word	0x2000c9fc
 800d3a0:	08016fe0 	.word	0x08016fe0
 800d3a4:	0801838c 	.word	0x0801838c
 800d3a8:	200180c8 	.word	0x200180c8
 800d3ac:	2000cb54 	.word	0x2000cb54
 800d3b0:	08018070 	.word	0x08018070
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
 800d3b4:	4620      	mov	r0, r4
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
 800d3b6:	b002      	add	sp, #8
 800d3b8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
 800d3bc:	f7ff be48 	b.w	800d050 <tcp_send_empty_ack>
#if TCP_CWND_DEBUG
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 800d3c0:	4b06      	ldr	r3, [pc, #24]	; (800d3dc <tcp_output+0x32c>)
 800d3c2:	9300      	str	r3, [sp, #0]
 800d3c4:	4906      	ldr	r1, [pc, #24]	; (800d3e0 <tcp_output+0x330>)
 800d3c6:	4a07      	ldr	r2, [pc, #28]	; (800d3e4 <tcp_output+0x334>)
 800d3c8:	4807      	ldr	r0, [pc, #28]	; (800d3e8 <tcp_output+0x338>)
 800d3ca:	f44f 7363 	mov.w	r3, #908	; 0x38c
 800d3ce:	f7ff f97f 	bl	800c6d0 <chprintf.constprop.2>
 800d3d2:	4804      	ldr	r0, [pc, #16]	; (800d3e4 <tcp_output+0x334>)
 800d3d4:	f7f3 fdcc 	bl	8000f70 <chSysHalt>
 800d3d8:	e672      	b.n	800d0c0 <tcp_output+0x10>
 800d3da:	bf00      	nop
 800d3dc:	08018070 	.word	0x08018070
 800d3e0:	08016fe0 	.word	0x08016fe0
 800d3e4:	08018364 	.word	0x08018364
 800d3e8:	200180c8 	.word	0x200180c8
 800d3ec:	f3af 8000 	nop.w

0800d3f0 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
 800d3f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800d3f4:	b082      	sub	sp, #8
 800d3f6:	4681      	mov	r9, r0
 800d3f8:	460e      	mov	r6, r1
 800d3fa:	4690      	mov	r8, r2
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 800d3fc:	2001      	movs	r0, #1
 800d3fe:	2114      	movs	r1, #20
 800d400:	2200      	movs	r2, #0
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
 800d402:	461f      	mov	r7, r3
 800d404:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
 800d408:	f8bd a02c 	ldrh.w	sl, [sp, #44]	; 0x2c
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 800d40c:	f7fc f878 	bl	8009500 <pbuf_alloc>
  if (p == NULL) {
 800d410:	4605      	mov	r5, r0
 800d412:	2800      	cmp	r0, #0
 800d414:	d04e      	beq.n	800d4b4 <tcp_rst+0xc4>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 800d416:	8943      	ldrh	r3, [r0, #10]
 800d418:	2b13      	cmp	r3, #19
 800d41a:	d93e      	bls.n	800d49a <tcp_rst+0xaa>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
 800d41c:	4620      	mov	r0, r4
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
 800d41e:	686c      	ldr	r4, [r5, #4]
  tcphdr->src = htons(local_port);
 800d420:	f001 fcbe 	bl	800eda0 <lwip_htons>
 800d424:	8020      	strh	r0, [r4, #0]
  tcphdr->dest = htons(remote_port);
 800d426:	4650      	mov	r0, sl
 800d428:	f001 fcba 	bl	800eda0 <lwip_htons>
 800d42c:	8060      	strh	r0, [r4, #2]
  tcphdr->seqno = htonl(seqno);
 800d42e:	4648      	mov	r0, r9
 800d430:	f001 fcc6 	bl	800edc0 <lwip_htonl>
 800d434:	6060      	str	r0, [r4, #4]
  tcphdr->ackno = htonl(ackno);
 800d436:	4630      	mov	r0, r6
 800d438:	f001 fcc2 	bl	800edc0 <lwip_htonl>
 800d43c:	60a0      	str	r0, [r4, #8]
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
 800d43e:	f245 0014 	movw	r0, #20500	; 0x5014
 800d442:	f001 fcad 	bl	800eda0 <lwip_htons>
  tcphdr->wnd = PP_HTONS(TCP_WND);
 800d446:	2600      	movs	r6, #0
  tcphdr->chksum = 0;
  tcphdr->urgp = 0;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
 800d448:	892b      	ldrh	r3, [r5, #8]
  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
  tcphdr->ackno = htonl(ackno);
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
 800d44a:	81a0      	strh	r0, [r4, #12]
  tcphdr->wnd = PP_HTONS(TCP_WND);
 800d44c:	2116      	movs	r1, #22
 800d44e:	f06f 022f 	mvn.w	r2, #47	; 0x2f
 800d452:	73a1      	strb	r1, [r4, #14]
 800d454:	73e2      	strb	r2, [r4, #15]
  tcphdr->chksum = 0;
 800d456:	7426      	strb	r6, [r4, #16]
 800d458:	7466      	strb	r6, [r4, #17]
  tcphdr->urgp = 0;
 800d45a:	74a6      	strb	r6, [r4, #18]
 800d45c:	74e6      	strb	r6, [r4, #19]

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
 800d45e:	4641      	mov	r1, r8
 800d460:	9300      	str	r3, [sp, #0]
 800d462:	463a      	mov	r2, r7
 800d464:	4628      	mov	r0, r5
 800d466:	2306      	movs	r3, #6
 800d468:	f000 fd3a 	bl	800dee0 <inet_chksum_pseudo>
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 800d46c:	f8df e05c 	ldr.w	lr, [pc, #92]	; 800d4cc <tcp_rst+0xdc>
  tcphdr->wnd = PP_HTONS(TCP_WND);
  tcphdr->chksum = 0;
  tcphdr->urgp = 0;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
 800d470:	8220      	strh	r0, [r4, #16]
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 800d472:	f8be 4090 	ldrh.w	r4, [lr, #144]	; 0x90
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
 800d476:	9600      	str	r6, [sp, #0]
 800d478:	2306      	movs	r3, #6

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 800d47a:	3401      	adds	r4, #1
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
 800d47c:	9301      	str	r3, [sp, #4]
 800d47e:	4641      	mov	r1, r8
 800d480:	463a      	mov	r2, r7
 800d482:	4628      	mov	r0, r5
 800d484:	23ff      	movs	r3, #255	; 0xff

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 800d486:	f8ae 4090 	strh.w	r4, [lr, #144]	; 0x90
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
 800d48a:	f000 ffa9 	bl	800e3e0 <ip_output>
  pbuf_free(p);
 800d48e:	4628      	mov	r0, r5
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 800d490:	b002      	add	sp, #8
 800d492:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
 800d496:	f7fb bfb3 	b.w	8009400 <pbuf_free>
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  if (p == NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 800d49a:	4b08      	ldr	r3, [pc, #32]	; (800d4bc <tcp_rst+0xcc>)
 800d49c:	9300      	str	r3, [sp, #0]
 800d49e:	4908      	ldr	r1, [pc, #32]	; (800d4c0 <tcp_rst+0xd0>)
 800d4a0:	4a08      	ldr	r2, [pc, #32]	; (800d4c4 <tcp_rst+0xd4>)
 800d4a2:	4809      	ldr	r0, [pc, #36]	; (800d4c8 <tcp_rst+0xd8>)
 800d4a4:	f240 43b7 	movw	r3, #1207	; 0x4b7
 800d4a8:	f7ff f912 	bl	800c6d0 <chprintf.constprop.2>
 800d4ac:	4805      	ldr	r0, [pc, #20]	; (800d4c4 <tcp_rst+0xd4>)
 800d4ae:	f7f3 fd5f 	bl	8000f70 <chSysHalt>
 800d4b2:	e7b3      	b.n	800d41c <tcp_rst+0x2c>
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 800d4b4:	b002      	add	sp, #8
 800d4b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800d4ba:	bf00      	nop
 800d4bc:	08018070 	.word	0x08018070
 800d4c0:	08016fe0 	.word	0x08016fe0
 800d4c4:	08018040 	.word	0x08018040
 800d4c8:	200180c8 	.word	0x200180c8
 800d4cc:	2000c9fc 	.word	0x2000c9fc

0800d4d0 <tcp_rexmit_rto>:
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
 800d4d0:	6f01      	ldr	r1, [r0, #112]	; 0x70
 800d4d2:	b1a1      	cbz	r1, 800d4fe <tcp_rexmit_rto+0x2e>
 800d4d4:	460a      	mov	r2, r1
 800d4d6:	e000      	b.n	800d4da <tcp_rexmit_rto+0xa>
 800d4d8:	461a      	mov	r2, r3
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
 800d4da:	6813      	ldr	r3, [r2, #0]
 800d4dc:	2b00      	cmp	r3, #0
 800d4de:	d1fb      	bne.n	800d4d8 <tcp_rexmit_rto+0x8>
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
 800d4e0:	b410      	push	{r4}
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 800d4e2:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
 800d4e4:	6014      	str	r4, [r2, #0]
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  /* last unsent hasn't changed, no need to reset unsent_oversize */

  /* increment number of retransmissions */
  ++pcb->nrtx;
 800d4e6:	f890 2046 	ldrb.w	r2, [r0, #70]	; 0x46
  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
 800d4ea:	66c1      	str	r1, [r0, #108]	; 0x6c
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  /* last unsent hasn't changed, no need to reset unsent_oversize */

  /* increment number of retransmissions */
  ++pcb->nrtx;
 800d4ec:	3201      	adds	r2, #1
 800d4ee:	f880 2046 	strb.w	r2, [r0, #70]	; 0x46
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  /* unacked queue is now empty */
  pcb->unacked = NULL;
 800d4f2:	6703      	str	r3, [r0, #112]	; 0x70

  /* increment number of retransmissions */
  ++pcb->nrtx;

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 800d4f4:	6383      	str	r3, [r0, #56]	; 0x38

  /* Do the actual retransmission */
  tcp_output(pcb);
}
 800d4f6:	f85d 4b04 	ldr.w	r4, [sp], #4

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
 800d4fa:	f7ff bdd9 	b.w	800d0b0 <tcp_output>
 800d4fe:	4770      	bx	lr

0800d500 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
 800d500:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
 800d502:	6f06      	ldr	r6, [r0, #112]	; 0x70
 800d504:	b316      	cbz	r6, 800d54c <tcp_rexmit+0x4c>
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 800d506:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;
 800d508:	6832      	ldr	r2, [r6, #0]
 800d50a:	6702      	str	r2, [r0, #112]	; 0x70
 800d50c:	4607      	mov	r7, r0

  cur_seg = &(pcb->unsent);
 800d50e:	f100 056c 	add.w	r5, r0, #108	; 0x6c
  while (*cur_seg &&
 800d512:	b91b      	cbnz	r3, 800d51c <tcp_rexmit+0x1c>
 800d514:	e00f      	b.n	800d536 <tcp_rexmit+0x36>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
 800d516:	682d      	ldr	r5, [r5, #0]
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 800d518:	682b      	ldr	r3, [r5, #0]
 800d51a:	b163      	cbz	r3, 800d536 <tcp_rexmit+0x36>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 800d51c:	68db      	ldr	r3, [r3, #12]
 800d51e:	6858      	ldr	r0, [r3, #4]
 800d520:	f001 fc56 	bl	800edd0 <lwip_ntohl>
 800d524:	68f3      	ldr	r3, [r6, #12]
 800d526:	4604      	mov	r4, r0
 800d528:	6858      	ldr	r0, [r3, #4]
 800d52a:	f001 fc51 	bl	800edd0 <lwip_ntohl>
 800d52e:	1a20      	subs	r0, r4, r0
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 800d530:	2800      	cmp	r0, #0
 800d532:	dbf0      	blt.n	800d516 <tcp_rexmit+0x16>
 800d534:	682b      	ldr	r3, [r5, #0]
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
 800d536:	6033      	str	r3, [r6, #0]
  *cur_seg = seg;
 800d538:	602e      	str	r6, [r5, #0]
#if TCP_OVERSIZE
  if (seg->next == NULL) {
 800d53a:	6833      	ldr	r3, [r6, #0]
 800d53c:	b13b      	cbz	r3, 800d54e <tcp_rexmit+0x4e>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
 800d53e:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 800d542:	2200      	movs	r2, #0
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
 800d544:	3301      	adds	r3, #1
 800d546:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 800d54a:	63ba      	str	r2, [r7, #56]	; 0x38
 800d54c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  seg->next = *cur_seg;
  *cur_seg = seg;
#if TCP_OVERSIZE
  if (seg->next == NULL) {
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
 800d54e:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
 800d552:	e7f4      	b.n	800d53e <tcp_rexmit+0x3e>
 800d554:	f3af 8000 	nop.w
 800d558:	f3af 8000 	nop.w
 800d55c:	f3af 8000 	nop.w

0800d560 <tcp_rexmit_fast>:
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 800d560:	6f02      	ldr	r2, [r0, #112]	; 0x70
 800d562:	b112      	cbz	r2, 800d56a <tcp_rexmit_fast+0xa>
 800d564:	7f82      	ldrb	r2, [r0, #30]
 800d566:	0752      	lsls	r2, r2, #29
 800d568:	d500      	bpl.n	800d56c <tcp_rexmit_fast+0xc>
 800d56a:	4770      	bx	lr
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
 800d56c:	b510      	push	{r4, lr}
 800d56e:	4604      	mov	r4, r0
    LWIP_DEBUGF(TCP_FR_DEBUG, 
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
 800d570:	f7ff ffc6 	bl	800d500 <tcp_rexmit>

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
 800d574:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
 800d578:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
    }
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
 800d57c:	8ee0      	ldrh	r0, [r4, #54]	; 0x36
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
    pcb->flags |= TF_INFR;
 800d57e:	7fa1      	ldrb	r1, [r4, #30]
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
 800d580:	4293      	cmp	r3, r2
      pcb->ssthresh = pcb->snd_wnd / 2;
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
 800d582:	bf94      	ite	ls
 800d584:	085a      	lsrls	r2, r3, #1
    tcp_rexmit(pcb);

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
      pcb->ssthresh = pcb->snd_wnd / 2;
 800d586:	0852      	lsrhi	r2, r2, #1
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
    }
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
 800d588:	0043      	lsls	r3, r0, #1
 800d58a:	429a      	cmp	r2, r3
    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
      pcb->ssthresh = pcb->snd_wnd / 2;
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
 800d58c:	f8a4 204e 	strh.w	r2, [r4, #78]	; 0x4e
    if (pcb->ssthresh < 2*pcb->mss) {
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
 800d590:	bfb8      	it	lt
 800d592:	b29a      	uxthlt	r2, r3
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 800d594:	4403      	add	r3, r0
 800d596:	4413      	add	r3, r2
    if (pcb->ssthresh < 2*pcb->mss) {
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
 800d598:	bfb8      	it	lt
 800d59a:	f8a4 204e 	strhlt.w	r2, [r4, #78]	; 0x4e
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
    pcb->flags |= TF_INFR;
 800d59e:	f041 0204 	orr.w	r2, r1, #4
 800d5a2:	77a2      	strb	r2, [r4, #30]
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 800d5a4:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
 800d5a8:	bd10      	pop	{r4, pc}
 800d5aa:	bf00      	nop
 800d5ac:	f3af 8000 	nop.w

0800d5b0 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
 800d5b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d5b2:	4604      	mov	r4, r0
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
 800d5b4:	6d00      	ldr	r0, [r0, #80]	; 0x50
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
 800d5b6:	b083      	sub	sp, #12
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
 800d5b8:	3801      	subs	r0, #1
 800d5ba:	f001 fc01 	bl	800edc0 <lwip_htonl>
 800d5be:	2100      	movs	r1, #0
 800d5c0:	4602      	mov	r2, r0
 800d5c2:	4620      	mov	r0, r4
 800d5c4:	f7ff f89c 	bl	800c700 <tcp_output_alloc_header.constprop.1>
  if(p == NULL) {
 800d5c8:	b300      	cbz	r0, 800d60c <tcp_keepalive+0x5c>
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 800d5ca:	1d26      	adds	r6, r4, #4
 800d5cc:	8903      	ldrh	r3, [r0, #8]
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 800d5ce:	6847      	ldr	r7, [r0, #4]

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 800d5d0:	9300      	str	r3, [sp, #0]
 800d5d2:	4632      	mov	r2, r6
 800d5d4:	4621      	mov	r1, r4
 800d5d6:	2306      	movs	r3, #6
 800d5d8:	4605      	mov	r5, r0
 800d5da:	f000 fc81 	bl	800dee0 <inet_chksum_pseudo>
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 800d5de:	4a0c      	ldr	r2, [pc, #48]	; (800d610 <tcp_keepalive+0x60>)
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 800d5e0:	8238      	strh	r0, [r7, #16]
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 800d5e2:	f8b2 3090 	ldrh.w	r3, [r2, #144]	; 0x90
 800d5e6:	3301      	adds	r3, #1
 800d5e8:	f8a2 3090 	strh.w	r3, [r2, #144]	; 0x90
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 800d5ec:	2700      	movs	r7, #0
 800d5ee:	2006      	movs	r0, #6
 800d5f0:	7aa3      	ldrb	r3, [r4, #10]
 800d5f2:	9001      	str	r0, [sp, #4]
 800d5f4:	4632      	mov	r2, r6
 800d5f6:	4621      	mov	r1, r4
 800d5f8:	9700      	str	r7, [sp, #0]
 800d5fa:	4628      	mov	r0, r5
 800d5fc:	f000 fef0 	bl	800e3e0 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 800d600:	4628      	mov	r0, r5

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 800d602:	b003      	add	sp, #12
 800d604:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 800d608:	f7fb befa 	b.w	8009400 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 800d60c:	b003      	add	sp, #12
 800d60e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d610:	2000c9fc 	.word	0x2000c9fc
 800d614:	f3af 8000 	nop.w
 800d618:	f3af 8000 	nop.w
 800d61c:	f3af 8000 	nop.w

0800d620 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 800d620:	b5f0      	push	{r4, r5, r6, r7, lr}
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
 800d622:	6f06      	ldr	r6, [r0, #112]	; 0x70
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 800d624:	b083      	sub	sp, #12
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;

  if(seg == NULL) {
 800d626:	2e00      	cmp	r6, #0
 800d628:	d04f      	beq.n	800d6ca <tcp_zero_window_probe+0xaa>
  }
  if(seg == NULL) {
    return;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 800d62a:	68f3      	ldr	r3, [r6, #12]
 800d62c:	4604      	mov	r4, r0
 800d62e:	8998      	ldrh	r0, [r3, #12]
 800d630:	f001 fbbe 	bl	800edb0 <lwip_ntohs>
 800d634:	07c3      	lsls	r3, r0, #31
 800d636:	d433      	bmi.n	800d6a0 <tcp_zero_window_probe+0x80>
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 800d638:	68f3      	ldr	r3, [r6, #12]
 800d63a:	4620      	mov	r0, r4
 800d63c:	685a      	ldr	r2, [r3, #4]
 800d63e:	2101      	movs	r1, #1
 800d640:	f7ff f85e 	bl	800c700 <tcp_output_alloc_header.constprop.1>
  if(p == NULL) {
 800d644:	4605      	mov	r5, r0
 800d646:	2800      	cmp	r0, #0
 800d648:	d042      	beq.n	800d6d0 <tcp_zero_window_probe+0xb0>
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 800d64a:	6870      	ldr	r0, [r6, #4]
 800d64c:	8932      	ldrh	r2, [r6, #8]
 800d64e:	8903      	ldrh	r3, [r0, #8]
  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 800d650:	686f      	ldr	r7, [r5, #4]
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 800d652:	1a9b      	subs	r3, r3, r2
 800d654:	b29b      	uxth	r3, r3
 800d656:	f107 0114 	add.w	r1, r7, #20
 800d65a:	2201      	movs	r2, #1
 800d65c:	f7fc fa40 	bl	8009ae0 <pbuf_copy_partial>
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 800d660:	892b      	ldrh	r3, [r5, #8]
 800d662:	9300      	str	r3, [sp, #0]
 800d664:	1d26      	adds	r6, r4, #4
 800d666:	4632      	mov	r2, r6
 800d668:	4621      	mov	r1, r4
 800d66a:	4628      	mov	r0, r5
 800d66c:	2306      	movs	r3, #6
 800d66e:	f000 fc37 	bl	800dee0 <inet_chksum_pseudo>
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 800d672:	4a18      	ldr	r2, [pc, #96]	; (800d6d4 <tcp_zero_window_probe+0xb4>)
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 800d674:	8238      	strh	r0, [r7, #16]
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 800d676:	f8b2 3090 	ldrh.w	r3, [r2, #144]	; 0x90
 800d67a:	3301      	adds	r3, #1
 800d67c:	f8a2 3090 	strh.w	r3, [r2, #144]	; 0x90
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 800d680:	2700      	movs	r7, #0
 800d682:	2006      	movs	r0, #6
 800d684:	7aa3      	ldrb	r3, [r4, #10]
 800d686:	9001      	str	r0, [sp, #4]
 800d688:	4632      	mov	r2, r6
 800d68a:	4621      	mov	r1, r4
 800d68c:	9700      	str	r7, [sp, #0]
 800d68e:	4628      	mov	r0, r5
 800d690:	f000 fea6 	bl	800e3e0 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 800d694:	4628      	mov	r0, r5

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 800d696:	b003      	add	sp, #12
 800d698:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 800d69c:	f7fb beb0 	b.w	8009400 <pbuf_free>
  }
  if(seg == NULL) {
    return;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 800d6a0:	8931      	ldrh	r1, [r6, #8]
 800d6a2:	2900      	cmp	r1, #0
 800d6a4:	d1c8      	bne.n	800d638 <tcp_zero_window_probe+0x18>
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 800d6a6:	68f3      	ldr	r3, [r6, #12]
 800d6a8:	4620      	mov	r0, r4
 800d6aa:	685a      	ldr	r2, [r3, #4]
 800d6ac:	f7ff f828 	bl	800c700 <tcp_output_alloc_header.constprop.1>
  if(p == NULL) {
 800d6b0:	4605      	mov	r5, r0
 800d6b2:	b168      	cbz	r0, 800d6d0 <tcp_zero_window_probe+0xb0>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 800d6b4:	686f      	ldr	r7, [r5, #4]

  if (is_fin) {
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 800d6b6:	2011      	movs	r0, #17
 800d6b8:	89be      	ldrh	r6, [r7, #12]
 800d6ba:	f001 fb71 	bl	800eda0 <lwip_htons>
 800d6be:	f426 567c 	bic.w	r6, r6, #16128	; 0x3f00
 800d6c2:	b2b6      	uxth	r6, r6
 800d6c4:	4330      	orrs	r0, r6
 800d6c6:	81b8      	strh	r0, [r7, #12]
 800d6c8:	e7ca      	b.n	800d660 <tcp_zero_window_probe+0x40>
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;

  if(seg == NULL) {
    seg = pcb->unsent;
 800d6ca:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
  }
  if(seg == NULL) {
 800d6cc:	2e00      	cmp	r6, #0
 800d6ce:	d1ac      	bne.n	800d62a <tcp_zero_window_probe+0xa>
  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 800d6d0:	b003      	add	sp, #12
 800d6d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d6d4:	2000c9fc 	.word	0x2000c9fc
 800d6d8:	f3af 8000 	nop.w
 800d6dc:	f3af 8000 	nop.w

0800d6e0 <chprintf.constprop.1>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 800d6e0:	b40e      	push	{r1, r2, r3}
 800d6e2:	b500      	push	{lr}
 800d6e4:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800d6e6:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 800d6e8:	461a      	mov	r2, r3
 800d6ea:	4905      	ldr	r1, [pc, #20]	; (800d700 <chprintf.constprop.1+0x20>)
 800d6ec:	4805      	ldr	r0, [pc, #20]	; (800d704 <chprintf.constprop.1+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800d6ee:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800d6f0:	f003 fb06 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 800d6f4:	b002      	add	sp, #8
 800d6f6:	f85d eb04 	ldr.w	lr, [sp], #4
 800d6fa:	b003      	add	sp, #12
 800d6fc:	4770      	bx	lr
 800d6fe:	bf00      	nop
 800d700:	08016fe0 	.word	0x08016fe0
 800d704:	200180c8 	.word	0x200180c8
 800d708:	f3af 8000 	nop.w
 800d70c:	f3af 8000 	nop.w

0800d710 <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
 800d710:	4770      	bx	lr
 800d712:	bf00      	nop
 800d714:	f3af 8000 	nop.w
 800d718:	f3af 8000 	nop.w
 800d71c:	f3af 8000 	nop.w

0800d720 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 800d720:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  u8_t local_match;
  u8_t broadcast;

  PERF_START;

  UDP_STATS_INC(udp.recv);
 800d724:	4d7d      	ldr	r5, [pc, #500]	; (800d91c <udp_input+0x1fc>)

  iphdr = (struct ip_hdr *)p->payload;
 800d726:	f8d0 8004 	ldr.w	r8, [r0, #4]
  u8_t local_match;
  u8_t broadcast;

  PERF_START;

  UDP_STATS_INC(udp.recv);
 800d72a:	f8b5 307a 	ldrh.w	r3, [r5, #122]	; 0x7a

  iphdr = (struct ip_hdr *)p->payload;

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
 800d72e:	8902      	ldrh	r2, [r0, #8]
  u8_t local_match;
  u8_t broadcast;

  PERF_START;

  UDP_STATS_INC(udp.recv);
 800d730:	3301      	adds	r3, #1
 800d732:	f8a5 307a 	strh.w	r3, [r5, #122]	; 0x7a

  iphdr = (struct ip_hdr *)p->payload;

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
 800d736:	f898 3000 	ldrb.w	r3, [r8]
 800d73a:	f003 030f 	and.w	r3, r3, #15
 800d73e:	1c9c      	adds	r4, r3, #2
 800d740:	ebb2 0f84 	cmp.w	r2, r4, lsl #2
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 800d744:	b085      	sub	sp, #20
 800d746:	4606      	mov	r6, r0

  iphdr = (struct ip_hdr *)p->payload;

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
 800d748:	db06      	blt.n	800d758 <udp_input+0x38>
 800d74a:	468a      	mov	sl, r1
 800d74c:	0099      	lsls	r1, r3, #2
 800d74e:	4249      	negs	r1, r1
 800d750:	f7fb fde6 	bl	8009320 <pbuf_header>
 800d754:	4604      	mov	r4, r0
 800d756:	b178      	cbz	r0, 800d778 <udp_input+0x58>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
 800d758:	f8b5 2082 	ldrh.w	r2, [r5, #130]	; 0x82
    UDP_STATS_INC(udp.drop);
 800d75c:	f8b5 307e 	ldrh.w	r3, [r5, #126]	; 0x7e
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
 800d760:	3201      	adds	r2, #1
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
 800d762:	4630      	mov	r0, r6
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
 800d764:	3301      	adds	r3, #1
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
 800d766:	f8a5 2082 	strh.w	r2, [r5, #130]	; 0x82
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
        icmp_dest_unreach(p, ICMP_DUR_PORT);
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
 800d76a:	f8a5 307e 	strh.w	r3, [r5, #126]	; 0x7e
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
 800d76e:	b005      	add	sp, #20
 800d770:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
 800d774:	f7fb be44 	b.w	8009400 <pbuf_free>
  }

  udphdr = (struct udp_hdr *)p->payload;

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
 800d778:	4969      	ldr	r1, [pc, #420]	; (800d920 <udp_input+0x200>)
    snmp_inc_udpinerrors();
    pbuf_free(p);
    goto end;
  }

  udphdr = (struct udp_hdr *)p->payload;
 800d77a:	6873      	ldr	r3, [r6, #4]

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
 800d77c:	6808      	ldr	r0, [r1, #0]
    snmp_inc_udpinerrors();
    pbuf_free(p);
    goto end;
  }

  udphdr = (struct udp_hdr *)p->payload;
 800d77e:	9302      	str	r3, [sp, #8]

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
 800d780:	4651      	mov	r1, sl
 800d782:	f000 fe6d 	bl	800e460 <ip4_addr_isbroadcast>

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
 800d786:	9a02      	ldr	r2, [sp, #8]
  }

  udphdr = (struct udp_hdr *)p->payload;

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
 800d788:	4607      	mov	r7, r0

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
 800d78a:	8810      	ldrh	r0, [r2, #0]
 800d78c:	f001 fb10 	bl	800edb0 <lwip_ntohs>
  dest = ntohs(udphdr->dest);
 800d790:	9a02      	ldr	r2, [sp, #8]
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
 800d792:	4681      	mov	r9, r0
  dest = ntohs(udphdr->dest);
 800d794:	8850      	ldrh	r0, [r2, #2]
 800d796:	f001 fb0b 	bl	800edb0 <lwip_ntohs>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 800d79a:	4b62      	ldr	r3, [pc, #392]	; (800d924 <udp_input+0x204>)
 800d79c:	681b      	ldr	r3, [r3, #0]
 800d79e:	9303      	str	r3, [sp, #12]
 800d7a0:	4619      	mov	r1, r3
 800d7a2:	2b00      	cmp	r3, #0
 800d7a4:	d05f      	beq.n	800d866 <udp_input+0x146>
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
 800d7a6:	4b60      	ldr	r3, [pc, #384]	; (800d928 <udp_input+0x208>)

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
        if (
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
 800d7a8:	4a5d      	ldr	r2, [pc, #372]	; (800d920 <udp_input+0x200>)
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
 800d7aa:	f8d3 b000 	ldr.w	fp, [r3]

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
        if (
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
 800d7ae:	f8d2 c000 	ldr.w	ip, [r2]
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
 800d7b2:	4623      	mov	r3, r4
 800d7b4:	4622      	mov	r2, r4
 800d7b6:	460c      	mov	r4, r1
 800d7b8:	e004      	b.n	800d7c4 <udp_input+0xa4>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 800d7ba:	68e1      	ldr	r1, [r4, #12]
 800d7bc:	4623      	mov	r3, r4
 800d7be:	2900      	cmp	r1, #0
 800d7c0:	d04f      	beq.n	800d862 <udp_input+0x142>
 800d7c2:	460c      	mov	r4, r1
                   ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip), pcb->local_port,
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
 800d7c4:	8a61      	ldrh	r1, [r4, #18]
 800d7c6:	4281      	cmp	r1, r0
 800d7c8:	d1f7      	bne.n	800d7ba <udp_input+0x9a>
        if (
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 800d7ca:	6821      	ldr	r1, [r4, #0]
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
        if (
 800d7cc:	2f00      	cmp	r7, #0
 800d7ce:	d135      	bne.n	800d83c <udp_input+0x11c>
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 800d7d0:	b109      	cbz	r1, 800d7d6 <udp_input+0xb6>
 800d7d2:	458c      	cmp	ip, r1
 800d7d4:	d1f1      	bne.n	800d7ba <udp_input+0x9a>
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
          if ((uncon_pcb == NULL) && 
 800d7d6:	2a00      	cmp	r2, #0
 800d7d8:	d03d      	beq.n	800d856 <udp_input+0x136>
            uncon_pcb = pcb;
          }
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
 800d7da:	8aa1      	ldrh	r1, [r4, #20]
 800d7dc:	4549      	cmp	r1, r9
 800d7de:	d1ec      	bne.n	800d7ba <udp_input+0x9a>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
 800d7e0:	6861      	ldr	r1, [r4, #4]
 800d7e2:	b109      	cbz	r1, 800d7e8 <udp_input+0xc8>
 800d7e4:	4559      	cmp	r1, fp
 800d7e6:	d1e8      	bne.n	800d7ba <udp_input+0x9a>
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
 800d7e8:	2b00      	cmp	r3, #0
 800d7ea:	f000 808e 	beq.w	800d90a <udp_input+0x1ea>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
 800d7ee:	68e2      	ldr	r2, [r4, #12]
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
 800d7f0:	494c      	ldr	r1, [pc, #304]	; (800d924 <udp_input+0x204>)
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
 800d7f2:	60da      	str	r2, [r3, #12]
          pcb->next = udp_pcbs;
 800d7f4:	9b03      	ldr	r3, [sp, #12]
          udp_pcbs = pcb;
 800d7f6:	600c      	str	r4, [r1, #0]
        /* the first fully matching PCB */
        if (prev != NULL) {
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
          pcb->next = udp_pcbs;
 800d7f8:	60e3      	str	r3, [r4, #12]
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
 800d7fa:	9b02      	ldr	r3, [sp, #8]
 800d7fc:	88db      	ldrh	r3, [r3, #6]
 800d7fe:	b14b      	cbz	r3, 800d814 <udp_input+0xf4>
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
 800d800:	8933      	ldrh	r3, [r6, #8]
 800d802:	9300      	str	r3, [sp, #0]
 800d804:	4630      	mov	r0, r6
 800d806:	4948      	ldr	r1, [pc, #288]	; (800d928 <udp_input+0x208>)
 800d808:	4a45      	ldr	r2, [pc, #276]	; (800d920 <udp_input+0x200>)
 800d80a:	2311      	movs	r3, #17
 800d80c:	f000 fb68 	bl	800dee0 <inet_chksum_pseudo>
 800d810:	2800      	cmp	r0, #0
 800d812:	d170      	bne.n	800d8f6 <udp_input+0x1d6>
          goto end;
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
 800d814:	4630      	mov	r0, r6
 800d816:	f06f 0107 	mvn.w	r1, #7
 800d81a:	f7fb fd81 	bl	8009320 <pbuf_header>
 800d81e:	bb60      	cbnz	r0, 800d87a <udp_input+0x15a>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
 800d820:	2c00      	cmp	r4, #0
 800d822:	d03b      	beq.n	800d89c <udp_input+0x17c>
          pbuf_header(p, -(s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
        }
      }
#endif /* SO_REUSE && SO_REUSE_RXTOALL */
      /* callback */
      if (pcb->recv != NULL) {
 800d824:	69a5      	ldr	r5, [r4, #24]
 800d826:	b325      	cbz	r5, 800d872 <udp_input+0x152>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 800d828:	69e0      	ldr	r0, [r4, #28]
 800d82a:	4b3f      	ldr	r3, [pc, #252]	; (800d928 <udp_input+0x208>)
 800d82c:	f8cd 9000 	str.w	r9, [sp]
 800d830:	4632      	mov	r2, r6
 800d832:	4621      	mov	r1, r4
 800d834:	47a8      	blx	r5
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
 800d836:	b005      	add	sp, #20
 800d838:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
        if (
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 800d83c:	4561      	cmp	r1, ip
 800d83e:	d0ca      	beq.n	800d7d6 <udp_input+0xb6>
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
 800d840:	2900      	cmp	r1, #0
 800d842:	d0c8      	beq.n	800d7d6 <udp_input+0xb6>
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
 800d844:	ea81 0e0c 	eor.w	lr, r1, ip
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
 800d848:	f8da 1008 	ldr.w	r1, [sl, #8]
 800d84c:	ea1e 0f01 	tst.w	lr, r1
 800d850:	d1b3      	bne.n	800d7ba <udp_input+0x9a>
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
          if ((uncon_pcb == NULL) && 
 800d852:	2a00      	cmp	r2, #0
 800d854:	d1c1      	bne.n	800d7da <udp_input+0xba>
              ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
 800d856:	7c21      	ldrb	r1, [r4, #16]
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
          if ((uncon_pcb == NULL) && 
 800d858:	f011 0f04 	tst.w	r1, #4
 800d85c:	bf08      	it	eq
 800d85e:	4622      	moveq	r2, r4
 800d860:	e7bb      	b.n	800d7da <udp_input+0xba>
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
 800d862:	2a00      	cmp	r2, #0
 800d864:	d157      	bne.n	800d916 <udp_input+0x1f6>
 800d866:	4b2e      	ldr	r3, [pc, #184]	; (800d920 <udp_input+0x200>)
 800d868:	f8da 2004 	ldr.w	r2, [sl, #4]
 800d86c:	681b      	ldr	r3, [r3, #0]
 800d86e:	429a      	cmp	r2, r3
 800d870:	d001      	beq.n	800d876 <udp_input+0x156>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
 800d872:	4630      	mov	r0, r6
 800d874:	e77b      	b.n	800d76e <udp_input+0x4e>
 800d876:	2400      	movs	r4, #0
 800d878:	e7bf      	b.n	800d7fa <udp_input+0xda>
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
 800d87a:	4b2c      	ldr	r3, [pc, #176]	; (800d92c <udp_input+0x20c>)
 800d87c:	9300      	str	r3, [sp, #0]
 800d87e:	492c      	ldr	r1, [pc, #176]	; (800d930 <udp_input+0x210>)
 800d880:	4a2c      	ldr	r2, [pc, #176]	; (800d934 <udp_input+0x214>)
 800d882:	482d      	ldr	r0, [pc, #180]	; (800d938 <udp_input+0x218>)
 800d884:	f44f 73ac 	mov.w	r3, #344	; 0x158
 800d888:	f7ff ff2a 	bl	800d6e0 <chprintf.constprop.1>
 800d88c:	4829      	ldr	r0, [pc, #164]	; (800d934 <udp_input+0x214>)
 800d88e:	f7f3 fb6f 	bl	8000f70 <chSysHalt>
      UDP_STATS_INC(udp.drop);
 800d892:	f8b5 307e 	ldrh.w	r3, [r5, #126]	; 0x7e
      snmp_inc_udpinerrors();
      pbuf_free(p);
 800d896:	4630      	mov	r0, r6
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      UDP_STATS_INC(udp.drop);
 800d898:	3301      	adds	r3, #1
 800d89a:	e766      	b.n	800d76a <udp_input+0x4a>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
 800d89c:	bb0f      	cbnz	r7, 800d8e2 <udp_input+0x1c2>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
 800d89e:	4b20      	ldr	r3, [pc, #128]	; (800d920 <udp_input+0x200>)
 800d8a0:	681b      	ldr	r3, [r3, #0]
 800d8a2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
 800d8a6:	2be0      	cmp	r3, #224	; 0xe0
 800d8a8:	d01b      	beq.n	800d8e2 <udp_input+0x1c2>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
 800d8aa:	f898 1000 	ldrb.w	r1, [r8]
 800d8ae:	f001 010f 	and.w	r1, r1, #15
 800d8b2:	3102      	adds	r1, #2
 800d8b4:	0089      	lsls	r1, r1, #2
 800d8b6:	4630      	mov	r0, r6
 800d8b8:	f7fb fd32 	bl	8009320 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
 800d8bc:	6873      	ldr	r3, [r6, #4]
 800d8be:	4543      	cmp	r3, r8
 800d8c0:	d00b      	beq.n	800d8da <udp_input+0x1ba>
 800d8c2:	4b1a      	ldr	r3, [pc, #104]	; (800d92c <udp_input+0x20c>)
 800d8c4:	9300      	str	r3, [sp, #0]
 800d8c6:	481c      	ldr	r0, [pc, #112]	; (800d938 <udp_input+0x218>)
 800d8c8:	4919      	ldr	r1, [pc, #100]	; (800d930 <udp_input+0x210>)
 800d8ca:	4a1c      	ldr	r2, [pc, #112]	; (800d93c <udp_input+0x21c>)
 800d8cc:	f240 13a3 	movw	r3, #419	; 0x1a3
 800d8d0:	f7ff ff06 	bl	800d6e0 <chprintf.constprop.1>
 800d8d4:	4819      	ldr	r0, [pc, #100]	; (800d93c <udp_input+0x21c>)
 800d8d6:	f7f3 fb4b 	bl	8000f70 <chSysHalt>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
 800d8da:	4630      	mov	r0, r6
 800d8dc:	2103      	movs	r1, #3
 800d8de:	f000 faaf 	bl	800de40 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
 800d8e2:	f8b5 2088 	ldrh.w	r2, [r5, #136]	; 0x88
      UDP_STATS_INC(udp.drop);
 800d8e6:	f8b5 307e 	ldrh.w	r3, [r5, #126]	; 0x7e
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
        icmp_dest_unreach(p, ICMP_DUR_PORT);
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
 800d8ea:	3201      	adds	r2, #1
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
 800d8ec:	4630      	mov	r0, r6
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
        icmp_dest_unreach(p, ICMP_DUR_PORT);
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
 800d8ee:	3301      	adds	r3, #1
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
        icmp_dest_unreach(p, ICMP_DUR_PORT);
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
 800d8f0:	f8a5 2088 	strh.w	r2, [r5, #136]	; 0x88
 800d8f4:	e739      	b.n	800d76a <udp_input+0x4a>
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
                               IP_PROTO_UDP, p->tot_len) != 0) {
          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
 800d8f6:	f8b5 2080 	ldrh.w	r2, [r5, #128]	; 0x80
          UDP_STATS_INC(udp.drop);
 800d8fa:	f8b5 307e 	ldrh.w	r3, [r5, #126]	; 0x7e
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
                               IP_PROTO_UDP, p->tot_len) != 0) {
          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
 800d8fe:	3201      	adds	r2, #1
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
 800d900:	4630      	mov	r0, r6
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
                               IP_PROTO_UDP, p->tot_len) != 0) {
          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
 800d902:	3301      	adds	r3, #1
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
                               IP_PROTO_UDP, p->tot_len) != 0) {
          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
 800d904:	f8a5 2080 	strh.w	r2, [r5, #128]	; 0x80
 800d908:	e72f      	b.n	800d76a <udp_input+0x4a>
             found faster next time */
          prev->next = pcb->next;
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
        } else {
          UDP_STATS_INC(udp.cachehit);
 800d90a:	f8b5 308e 	ldrh.w	r3, [r5, #142]	; 0x8e
 800d90e:	3301      	adds	r3, #1
 800d910:	f8a5 308e 	strh.w	r3, [r5, #142]	; 0x8e
 800d914:	e771      	b.n	800d7fa <udp_input+0xda>
 800d916:	4614      	mov	r4, r2
 800d918:	e76f      	b.n	800d7fa <udp_input+0xda>
 800d91a:	bf00      	nop
 800d91c:	2000c9fc 	.word	0x2000c9fc
 800d920:	2000cbb0 	.word	0x2000cbb0
 800d924:	2000cba0 	.word	0x2000cba0
 800d928:	2000cbac 	.word	0x2000cbac
 800d92c:	080183c4 	.word	0x080183c4
 800d930:	08016fe0 	.word	0x08016fe0
 800d934:	080183b0 	.word	0x080183b0
 800d938:	200180c8 	.word	0x200180c8
 800d93c:	080183f0 	.word	0x080183f0

0800d940 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 800d940:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 800d944:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 800da2c <udp_bind+0xec>
 800d948:	f8d9 4000 	ldr.w	r4, [r9]
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 800d94c:	b083      	sub	sp, #12
 800d94e:	4606      	mov	r6, r0
 800d950:	460f      	mov	r7, r1
 800d952:	4615      	mov	r5, r2
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 800d954:	2c00      	cmp	r4, #0
 800d956:	d05f      	beq.n	800da18 <udp_bind+0xd8>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
 800d958:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 800da30 <udp_bind+0xf0>
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 800d95c:	2000      	movs	r0, #0
 800d95e:	e001      	b.n	800d964 <udp_bind+0x24>
 800d960:	68e4      	ldr	r4, [r4, #12]
 800d962:	b1ac      	cbz	r4, 800d990 <udp_bind+0x50>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
 800d964:	42a6      	cmp	r6, r4
 800d966:	d00e      	beq.n	800d986 <udp_bind+0x46>
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
 800d968:	8a63      	ldrh	r3, [r4, #18]
 800d96a:	42ab      	cmp	r3, r5
 800d96c:	d1f8      	bne.n	800d960 <udp_bind+0x20>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
 800d96e:	6823      	ldr	r3, [r4, #0]
 800d970:	b123      	cbz	r3, 800d97c <udp_bind+0x3c>
 800d972:	b11f      	cbz	r7, 800d97c <udp_bind+0x3c>
           ip_addr_isany(ipaddr) ||
 800d974:	683a      	ldr	r2, [r7, #0]
 800d976:	b10a      	cbz	r2, 800d97c <udp_bind+0x3c>
 800d978:	4293      	cmp	r3, r2
 800d97a:	d1f1      	bne.n	800d960 <udp_bind+0x20>
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
        /* other PCB already binds to this local IP and port */
        LWIP_DEBUGF(UDP_DEBUG,
                    ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
        return ERR_USE;
 800d97c:	20f8      	movs	r0, #248	; 0xf8
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
}
 800d97e:	b240      	sxtb	r0, r0
 800d980:	b003      	add	sp, #12
 800d982:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
 800d986:	b990      	cbnz	r0, 800d9ae <udp_bind+0x6e>
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 800d988:	68e4      	ldr	r4, [r4, #12]
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
 800d98a:	2001      	movs	r0, #1
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 800d98c:	2c00      	cmp	r4, #0
 800d98e:	d1e9      	bne.n	800d964 <udp_bind+0x24>
        return ERR_USE;
      }
    }
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
 800d990:	b107      	cbz	r7, 800d994 <udp_bind+0x54>
 800d992:	683f      	ldr	r7, [r7, #0]
 800d994:	6037      	str	r7, [r6, #0]

  /* no port specified? */
  if (port == 0) {
 800d996:	b1ed      	cbz	r5, 800d9d4 <udp_bind+0x94>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
 800d998:	8275      	strh	r5, [r6, #18]
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 800d99a:	b9b0      	cbnz	r0, 800d9ca <udp_bind+0x8a>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 800d99c:	f8d9 3000 	ldr.w	r3, [r9]
 800d9a0:	60f3      	str	r3, [r6, #12]
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
}
 800d9a2:	b240      	sxtb	r0, r0
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
    udp_pcbs = pcb;
 800d9a4:	f8c9 6000 	str.w	r6, [r9]
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
}
 800d9a8:	b003      	add	sp, #12
 800d9aa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
 800d9ae:	491b      	ldr	r1, [pc, #108]	; (800da1c <udp_bind+0xdc>)
 800d9b0:	4a1b      	ldr	r2, [pc, #108]	; (800da20 <udp_bind+0xe0>)
 800d9b2:	f8cd 8000 	str.w	r8, [sp]
 800d9b6:	f240 330d 	movw	r3, #781	; 0x30d
 800d9ba:	481a      	ldr	r0, [pc, #104]	; (800da24 <udp_bind+0xe4>)
 800d9bc:	f7ff fe90 	bl	800d6e0 <chprintf.constprop.1>
 800d9c0:	4817      	ldr	r0, [pc, #92]	; (800da20 <udp_bind+0xe0>)
 800d9c2:	f7f3 fad5 	bl	8000f70 <chSysHalt>
      /* pcb already in list, just rebind */
      rebind = 1;
 800d9c6:	2001      	movs	r0, #1
 800d9c8:	e7ca      	b.n	800d960 <udp_bind+0x20>
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
 800d9ca:	2000      	movs	r0, #0
}
 800d9cc:	b240      	sxtb	r0, r0
 800d9ce:	b003      	add	sp, #12
 800d9d0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800d9d4:	4f14      	ldr	r7, [pc, #80]	; (800da28 <udp_bind+0xe8>)
 800d9d6:	f8d9 1000 	ldr.w	r1, [r9]
 800d9da:	883d      	ldrh	r5, [r7, #0]
  }

  ip_addr_set(&pcb->local_ip, ipaddr);

  /* no port specified? */
  if (port == 0) {
 800d9dc:	f44f 4480 	mov.w	r4, #16384	; 0x4000
{
  u16_t n = 0;
  struct udp_pcb *pcb;
  
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 800d9e0:	f64f 7eff 	movw	lr, #65535	; 0xffff
 800d9e4:	4575      	cmp	r5, lr
 800d9e6:	bf1a      	itte	ne
 800d9e8:	3501      	addne	r5, #1
 800d9ea:	b2ad      	uxthne	r5, r5
 800d9ec:	f44f 4540 	moveq.w	r5, #49152	; 0xc000
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 800d9f0:	b151      	cbz	r1, 800da08 <udp_bind+0xc8>
    if (pcb->local_port == udp_port) {
 800d9f2:	8a4b      	ldrh	r3, [r1, #18]
 800d9f4:	42ab      	cmp	r3, r5
 800d9f6:	d009      	beq.n	800da0c <udp_bind+0xcc>
 800d9f8:	460b      	mov	r3, r1
 800d9fa:	e002      	b.n	800da02 <udp_bind+0xc2>
 800d9fc:	8a5a      	ldrh	r2, [r3, #18]
 800d9fe:	42aa      	cmp	r2, r5
 800da00:	d004      	beq.n	800da0c <udp_bind+0xcc>
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 800da02:	68db      	ldr	r3, [r3, #12]
 800da04:	2b00      	cmp	r3, #0
 800da06:	d1f9      	bne.n	800d9fc <udp_bind+0xbc>
 800da08:	803d      	strh	r5, [r7, #0]
 800da0a:	e7c5      	b.n	800d998 <udp_bind+0x58>
 800da0c:	3c01      	subs	r4, #1
 800da0e:	b2a4      	uxth	r4, r4
    if (pcb->local_port == udp_port) {
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 800da10:	2c00      	cmp	r4, #0
 800da12:	d1e7      	bne.n	800d9e4 <udp_bind+0xa4>
 800da14:	803d      	strh	r5, [r7, #0]
 800da16:	e7b1      	b.n	800d97c <udp_bind+0x3c>

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
 800da18:	4620      	mov	r0, r4
 800da1a:	e7b9      	b.n	800d990 <udp_bind+0x50>
 800da1c:	08016fe0 	.word	0x08016fe0
 800da20:	08018404 	.word	0x08018404
 800da24:	200180c8 	.word	0x200180c8
 800da28:	200008c0 	.word	0x200008c0
 800da2c:	2000cba0 	.word	0x2000cba0
 800da30:	080183c4 	.word	0x080183c4
 800da34:	f3af 8000 	nop.w
 800da38:	f3af 8000 	nop.w
 800da3c:	f3af 8000 	nop.w

0800da40 <udp_recv>:
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
  /* remember recv() callback and user data */
  pcb->recv = recv;
 800da40:	6181      	str	r1, [r0, #24]
  pcb->recv_arg = recv_arg;
 800da42:	61c2      	str	r2, [r0, #28]
 800da44:	4770      	bx	lr
 800da46:	bf00      	nop
 800da48:	f3af 8000 	nop.w
 800da4c:	f3af 8000 	nop.w

0800da50 <udp_remove>:
{
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 800da50:	4b0d      	ldr	r3, [pc, #52]	; (800da88 <udp_remove+0x38>)
 800da52:	681a      	ldr	r2, [r3, #0]
 800da54:	4282      	cmp	r2, r0
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 800da56:	4601      	mov	r1, r0
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 800da58:	d011      	beq.n	800da7e <udp_remove+0x2e>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 800da5a:	b13a      	cbz	r2, 800da6c <udp_remove+0x1c>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 800da5c:	68d3      	ldr	r3, [r2, #12]
 800da5e:	b12b      	cbz	r3, 800da6c <udp_remove+0x1c>
 800da60:	4299      	cmp	r1, r3
 800da62:	d006      	beq.n	800da72 <udp_remove+0x22>
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 800da64:	461a      	mov	r2, r3
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 800da66:	68d3      	ldr	r3, [r2, #12]
 800da68:	2b00      	cmp	r3, #0
 800da6a:	d1f9      	bne.n	800da60 <udp_remove+0x10>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 800da6c:	2001      	movs	r0, #1
 800da6e:	f7fb baa7 	b.w	8008fc0 <memp_free>
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
 800da72:	68cb      	ldr	r3, [r1, #12]
 800da74:	60d3      	str	r3, [r2, #12]
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 800da76:	2b00      	cmp	r3, #0
 800da78:	d0f8      	beq.n	800da6c <udp_remove+0x1c>
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 800da7a:	461a      	mov	r2, r3
 800da7c:	e7f3      	b.n	800da66 <udp_remove+0x16>

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
 800da7e:	68c2      	ldr	r2, [r0, #12]
 800da80:	601a      	str	r2, [r3, #0]
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 800da82:	2001      	movs	r0, #1
 800da84:	f7fb ba9c 	b.w	8008fc0 <memp_free>
 800da88:	2000cba0 	.word	0x2000cba0
 800da8c:	f3af 8000 	nop.w

0800da90 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 800da90:	b510      	push	{r4, lr}
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 800da92:	2001      	movs	r0, #1
 800da94:	f7fb fa3c 	bl	8008f10 <memp_malloc>
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 800da98:	4604      	mov	r4, r0
 800da9a:	b128      	cbz	r0, 800daa8 <udp_new+0x18>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 800da9c:	2100      	movs	r1, #0
 800da9e:	2220      	movs	r2, #32
 800daa0:	f006 f996 	bl	8013dd0 <memset>
    pcb->ttl = UDP_TTL;
 800daa4:	23ff      	movs	r3, #255	; 0xff
 800daa6:	72a3      	strb	r3, [r4, #10]
  }
  return pcb;
}
 800daa8:	4620      	mov	r0, r4
 800daaa:	bd10      	pop	{r4, pc}
 800daac:	f3af 8000 	nop.w

0800dab0 <chprintf.constprop.1>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 800dab0:	b40e      	push	{r1, r2, r3}
 800dab2:	b500      	push	{lr}
 800dab4:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800dab6:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 800dab8:	461a      	mov	r2, r3
 800daba:	4905      	ldr	r1, [pc, #20]	; (800dad0 <chprintf.constprop.1+0x20>)
 800dabc:	4805      	ldr	r0, [pc, #20]	; (800dad4 <chprintf.constprop.1+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800dabe:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800dac0:	f003 f91e 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 800dac4:	b002      	add	sp, #8
 800dac6:	f85d eb04 	ldr.w	lr, [sp], #4
 800daca:	b003      	add	sp, #12
 800dacc:	4770      	bx	lr
 800dace:	bf00      	nop
 800dad0:	08016fe0 	.word	0x08016fe0
 800dad4:	200180c8 	.word	0x200180c8
 800dad8:	f3af 8000 	nop.w
 800dadc:	f3af 8000 	nop.w

0800dae0 <icmp_send_response.isra.0>:
 *          p->payload pointing to the IP header
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
 800dae0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800dae4:	4605      	mov	r5, r0
 800dae6:	b085      	sub	sp, #20
 800dae8:	4689      	mov	r9, r1
 800daea:	4690      	mov	r8, r2
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;
  ip_addr_t iphdr_src;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 800daec:	2001      	movs	r0, #1
 800daee:	2124      	movs	r1, #36	; 0x24
 800daf0:	2200      	movs	r2, #0
 800daf2:	f7fb fd05 	bl	8009500 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
 800daf6:	4606      	mov	r6, r0
 800daf8:	2800      	cmp	r0, #0
 800dafa:	d050      	beq.n	800db9e <icmp_send_response.isra.0+0xbe>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
 800dafc:	8943      	ldrh	r3, [r0, #10]
 800dafe:	2b23      	cmp	r3, #35	; 0x23
 800db00:	d80b      	bhi.n	800db1a <icmp_send_response.isra.0+0x3a>
 800db02:	4b28      	ldr	r3, [pc, #160]	; (800dba4 <icmp_send_response.isra.0+0xc4>)
 800db04:	9300      	str	r3, [sp, #0]
 800db06:	4828      	ldr	r0, [pc, #160]	; (800dba8 <icmp_send_response.isra.0+0xc8>)
 800db08:	4928      	ldr	r1, [pc, #160]	; (800dbac <icmp_send_response.isra.0+0xcc>)
 800db0a:	4a29      	ldr	r2, [pc, #164]	; (800dbb0 <icmp_send_response.isra.0+0xd0>)
 800db0c:	f240 1333 	movw	r3, #307	; 0x133
 800db10:	f7ff ffce 	bl	800dab0 <chprintf.constprop.1>
 800db14:	4826      	ldr	r0, [pc, #152]	; (800dbb0 <icmp_send_response.isra.0+0xd0>)
 800db16:	f7f3 fa2b 	bl	8000f70 <chSysHalt>
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 800db1a:	6874      	ldr	r4, [r6, #4]
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
 800db1c:	682f      	ldr	r7, [r5, #0]
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
  icmphdr->type = type;
 800db1e:	f884 9000 	strb.w	r9, [r4]
  icmphdr->code = code;
 800db22:	f884 8001 	strb.w	r8, [r4, #1]
  icmphdr->id = 0;
  icmphdr->seqno = 0;

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 800db26:	682b      	ldr	r3, [r5, #0]
 800db28:	f8d6 c004 	ldr.w	ip, [r6, #4]
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
  icmphdr->type = type;
  icmphdr->code = code;
  icmphdr->id = 0;
 800db2c:	2500      	movs	r5, #0
 800db2e:	7125      	strb	r5, [r4, #4]
 800db30:	7165      	strb	r5, [r4, #5]
  icmphdr->seqno = 0;
 800db32:	71a5      	strb	r5, [r4, #6]
 800db34:	71e5      	strb	r5, [r4, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 800db36:	6818      	ldr	r0, [r3, #0]
 800db38:	6859      	ldr	r1, [r3, #4]
 800db3a:	f8d3 e008 	ldr.w	lr, [r3, #8]
 800db3e:	f8d3 800c 	ldr.w	r8, [r3, #12]
 800db42:	f8cc 8014 	str.w	r8, [ip, #20]
 800db46:	f8cc 0008 	str.w	r0, [ip, #8]
 800db4a:	f8cc 100c 	str.w	r1, [ip, #12]
 800db4e:	f8cc e010 	str.w	lr, [ip, #16]
 800db52:	6918      	ldr	r0, [r3, #16]
 800db54:	6959      	ldr	r1, [r3, #20]
 800db56:	f8d3 e018 	ldr.w	lr, [r3, #24]
 800db5a:	f8cc e020 	str.w	lr, [ip, #32]
 800db5e:	f8cc 0018 	str.w	r0, [ip, #24]
 800db62:	f8cc 101c 	str.w	r1, [ip, #28]
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
 800db66:	8971      	ldrh	r1, [r6, #10]
  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
 800db68:	70a5      	strb	r5, [r4, #2]
 800db6a:	70e5      	strb	r5, [r4, #3]
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
 800db6c:	4620      	mov	r0, r4
 800db6e:	f000 f9ff 	bl	800df70 <inet_chksum>
  ICMP_STATS_INC(icmp.xmit);
 800db72:	4a10      	ldr	r2, [pc, #64]	; (800dbb4 <icmp_send_response.isra.0+0xd4>)
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
 800db74:	8060      	strh	r0, [r4, #2]
  ICMP_STATS_INC(icmp.xmit);
 800db76:	f8b2 3060 	ldrh.w	r3, [r2, #96]	; 0x60
 800db7a:	3301      	adds	r3, #1
 800db7c:	f8a2 3060 	strh.w	r3, [r2, #96]	; 0x60
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
 800db80:	aa04      	add	r2, sp, #16
 800db82:	68fb      	ldr	r3, [r7, #12]
 800db84:	f842 3d04 	str.w	r3, [r2, #-4]!
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
 800db88:	2301      	movs	r3, #1
 800db8a:	9301      	str	r3, [sp, #4]
 800db8c:	9500      	str	r5, [sp, #0]
 800db8e:	4629      	mov	r1, r5
 800db90:	4630      	mov	r0, r6
 800db92:	23ff      	movs	r3, #255	; 0xff
 800db94:	f000 fc24 	bl	800e3e0 <ip_output>
  pbuf_free(q);
 800db98:	4630      	mov	r0, r6
 800db9a:	f7fb fc31 	bl	8009400 <pbuf_free>
}
 800db9e:	b005      	add	sp, #20
 800dba0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800dba4:	0801846c 	.word	0x0801846c
 800dba8:	200180c8 	.word	0x200180c8
 800dbac:	08016fe0 	.word	0x08016fe0
 800dbb0:	08018440 	.word	0x08018440
 800dbb4:	2000c9fc 	.word	0x2000c9fc
 800dbb8:	f3af 8000 	nop.w
 800dbbc:	f3af 8000 	nop.w

0800dbc0 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 800dbc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#endif /* LWIP_DEBUG */
  struct icmp_echo_hdr *iecho;
  struct ip_hdr *iphdr;
  s16_t hlen;

  ICMP_STATS_INC(icmp.recv);
 800dbc4:	4d93      	ldr	r5, [pc, #588]	; (800de14 <icmp_input+0x254>)
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
 800dbc6:	6847      	ldr	r7, [r0, #4]
#endif /* LWIP_DEBUG */
  struct icmp_echo_hdr *iecho;
  struct ip_hdr *iphdr;
  s16_t hlen;

  ICMP_STATS_INC(icmp.recv);
 800dbc8:	f8b5 3062 	ldrh.w	r3, [r5, #98]	; 0x62
 800dbcc:	3301      	adds	r3, #1
 800dbce:	f8a5 3062 	strh.w	r3, [r5, #98]	; 0x62
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
  hlen = IPH_HL(iphdr) * 4;
 800dbd2:	783c      	ldrb	r4, [r7, #0]
 800dbd4:	f004 040f 	and.w	r4, r4, #15
 800dbd8:	00a4      	lsls	r4, r4, #2
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
 800dbda:	f1c4 0800 	rsb	r8, r4, #0
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 800dbde:	b087      	sub	sp, #28
 800dbe0:	4689      	mov	r9, r1
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
  hlen = IPH_HL(iphdr) * 4;
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
 800dbe2:	4641      	mov	r1, r8
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 800dbe4:	4606      	mov	r6, r0
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
  hlen = IPH_HL(iphdr) * 4;
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
 800dbe6:	f7fb fb9b 	bl	8009320 <pbuf_header>
 800dbea:	b9d0      	cbnz	r0, 800dc22 <icmp_input+0x62>
 800dbec:	8933      	ldrh	r3, [r6, #8]
 800dbee:	2b03      	cmp	r3, #3
 800dbf0:	d917      	bls.n	800dc22 <icmp_input+0x62>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
 800dbf2:	6873      	ldr	r3, [r6, #4]
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
 800dbf4:	781b      	ldrb	r3, [r3, #0]
 800dbf6:	2b00      	cmp	r3, #0
 800dbf8:	d059      	beq.n	800dcae <icmp_input+0xee>
 800dbfa:	2b08      	cmp	r3, #8
 800dbfc:	d15d      	bne.n	800dcba <icmp_input+0xfa>
#if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
    {
      int accepted = 1;
#if !LWIP_MULTICAST_PING
      /* multicast destination address? */
      if (ip_addr_ismulticast(&current_iphdr_dest)) {
 800dbfe:	f8df a234 	ldr.w	sl, [pc, #564]	; 800de34 <icmp_input+0x274>
 800dc02:	f8da 0000 	ldr.w	r0, [sl]
 800dc06:	f000 03f0 	and.w	r3, r0, #240	; 0xf0
 800dc0a:	2be0      	cmp	r3, #224	; 0xe0
 800dc0c:	f000 8087 	beq.w	800dd1e <icmp_input+0x15e>
        accepted = 0;
      }
#endif /* LWIP_MULTICAST_PING */
#if !LWIP_BROADCAST_PING
      /* broadcast destination address? */
      if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
 800dc10:	4649      	mov	r1, r9
 800dc12:	f000 fc25 	bl	800e460 <ip4_addr_isbroadcast>
 800dc16:	2800      	cmp	r0, #0
 800dc18:	f040 8084 	bne.w	800dd24 <icmp_input+0x164>
        return;
      }
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 800dc1c:	8933      	ldrh	r3, [r6, #8]
 800dc1e:	2b07      	cmp	r3, #7
 800dc20:	d856      	bhi.n	800dcd0 <icmp_input+0x110>
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  return;
lenerr:
  pbuf_free(p);
 800dc22:	4630      	mov	r0, r6
 800dc24:	f7fb fbec 	bl	8009400 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
 800dc28:	f8b5 306a 	ldrh.w	r3, [r5, #106]	; 0x6a
 800dc2c:	3301      	adds	r3, #1
 800dc2e:	f8a5 306a 	strh.w	r3, [r5, #106]	; 0x6a
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
}
 800dc32:	b007      	add	sp, #28
 800dc34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      pbuf_free(p);
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 800dc38:	4630      	mov	r0, r6
 800dc3a:	f06f 0121 	mvn.w	r1, #33	; 0x21
 800dc3e:	f7fb fb6f 	bl	8009320 <pbuf_header>
 800dc42:	2800      	cmp	r0, #0
 800dc44:	f040 80ab 	bne.w	800dd9e <icmp_input+0x1de>
 800dc48:	fa0f fb8b 	sxth.w	fp, fp
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
 800dc4c:	4b72      	ldr	r3, [pc, #456]	; (800de18 <icmp_input+0x258>)
    }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
 800dc4e:	6872      	ldr	r2, [r6, #4]
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
 800dc50:	f8da 1000 	ldr.w	r1, [sl]
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
 800dc54:	681b      	ldr	r3, [r3, #0]
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
 800dc56:	60f9      	str	r1, [r7, #12]
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
 800dc58:	613b      	str	r3, [r7, #16]
    ICMPH_TYPE_SET(iecho, ICMP_ER);
#if CHECKSUM_GEN_ICMP
    /* adjust the checksum */
    if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
 800dc5a:	8853      	ldrh	r3, [r2, #2]
 800dc5c:	f64f 71f6 	movw	r1, #65526	; 0xfff6
 800dc60:	428b      	cmp	r3, r1
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
 800dc62:	bf8c      	ite	hi
 800dc64:	3309      	addhi	r3, #9
    } else {
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
 800dc66:	3308      	addls	r3, #8
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
    ICMPH_TYPE_SET(iecho, ICMP_ER);
 800dc68:	2000      	movs	r0, #0
 800dc6a:	7010      	strb	r0, [r2, #0]
#if CHECKSUM_GEN_ICMP
    /* adjust the checksum */
    if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
    } else {
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
 800dc6c:	8053      	strh	r3, [r2, #2]
#else /* CHECKSUM_GEN_ICMP */
    iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
 800dc6e:	24ff      	movs	r4, #255	; 0xff
    IPH_CHKSUM_SET(iphdr, 0);
 800dc70:	2200      	movs	r2, #0
 800dc72:	72ba      	strb	r2, [r7, #10]
 800dc74:	72fa      	strb	r2, [r7, #11]
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 800dc76:	2114      	movs	r1, #20
#else /* CHECKSUM_GEN_ICMP */
    iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
 800dc78:	723c      	strb	r4, [r7, #8]
    IPH_CHKSUM_SET(iphdr, 0);
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 800dc7a:	4638      	mov	r0, r7
 800dc7c:	f000 f978 	bl	800df70 <inet_chksum>
#endif /* CHECKSUM_GEN_IP */

    ICMP_STATS_INC(icmp.xmit);
 800dc80:	f8b5 2060 	ldrh.w	r2, [r5, #96]	; 0x60

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
    IPH_CHKSUM_SET(iphdr, 0);
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 800dc84:	8178      	strh	r0, [r7, #10]
#endif /* CHECKSUM_GEN_IP */

    ICMP_STATS_INC(icmp.xmit);
 800dc86:	3201      	adds	r2, #1
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
 800dc88:	4659      	mov	r1, fp
 800dc8a:	4630      	mov	r0, r6
    IPH_CHKSUM_SET(iphdr, 0);
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
#endif /* CHECKSUM_GEN_IP */

    ICMP_STATS_INC(icmp.xmit);
 800dc8c:	f8a5 2060 	strh.w	r2, [r5, #96]	; 0x60
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
 800dc90:	f7fb fb46 	bl	8009320 <pbuf_header>
 800dc94:	2800      	cmp	r0, #0
 800dc96:	d076      	beq.n	800dd86 <icmp_input+0x1c6>
      LWIP_ASSERT("Can't move over header in packet", 0);
 800dc98:	4b60      	ldr	r3, [pc, #384]	; (800de1c <icmp_input+0x25c>)
 800dc9a:	9300      	str	r3, [sp, #0]
 800dc9c:	4860      	ldr	r0, [pc, #384]	; (800de20 <icmp_input+0x260>)
 800dc9e:	4961      	ldr	r1, [pc, #388]	; (800de24 <icmp_input+0x264>)
 800dca0:	4a61      	ldr	r2, [pc, #388]	; (800de28 <icmp_input+0x268>)
 800dca2:	23da      	movs	r3, #218	; 0xda
 800dca4:	f7ff ff04 	bl	800dab0 <chprintf.constprop.1>
 800dca8:	485f      	ldr	r0, [pc, #380]	; (800de28 <icmp_input+0x268>)
 800dcaa:	f7f3 f961 	bl	8000f70 <chSysHalt>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
 800dcae:	4630      	mov	r0, r6
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
}
 800dcb0:	b007      	add	sp, #28
 800dcb2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
 800dcb6:	f7fb bba3 	b.w	8009400 <pbuf_free>
    }
    break;
  default:
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
 800dcba:	f8b5 2070 	ldrh.w	r2, [r5, #112]	; 0x70
    ICMP_STATS_INC(icmp.drop);
 800dcbe:	f8b5 3066 	ldrh.w	r3, [r5, #102]	; 0x66
    }
    break;
  default:
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
 800dcc2:	3201      	adds	r2, #1
    ICMP_STATS_INC(icmp.drop);
 800dcc4:	3301      	adds	r3, #1
    }
    break;
  default:
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
 800dcc6:	f8a5 2070 	strh.w	r2, [r5, #112]	; 0x70
    ICMP_STATS_INC(icmp.drop);
 800dcca:	f8a5 3066 	strh.w	r3, [r5, #102]	; 0x66
 800dcce:	e7ee      	b.n	800dcae <icmp_input+0xee>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
 800dcd0:	4630      	mov	r0, r6
 800dcd2:	f000 f955 	bl	800df80 <inet_chksum_pbuf>
 800dcd6:	bb60      	cbnz	r0, 800dd32 <icmp_input+0x172>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
    }
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 800dcd8:	4630      	mov	r0, r6
 800dcda:	2122      	movs	r1, #34	; 0x22
  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
  hlen = IPH_HL(iphdr) * 4;
 800dcdc:	fa1f fb84 	uxth.w	fp, r4
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
    }
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 800dce0:	f7fb fb1e 	bl	8009320 <pbuf_header>
 800dce4:	2800      	cmp	r0, #0
 800dce6:	d0a7      	beq.n	800dc38 <icmp_input+0x78>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
 800dce8:	fa0f fb8b 	sxth.w	fp, fp
 800dcec:	4659      	mov	r1, fp
 800dcee:	4630      	mov	r0, r6
 800dcf0:	f7fb fb16 	bl	8009320 <pbuf_header>
 800dcf4:	b330      	cbz	r0, 800dd44 <icmp_input+0x184>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
 800dcf6:	4b49      	ldr	r3, [pc, #292]	; (800de1c <icmp_input+0x25c>)
 800dcf8:	9300      	str	r3, [sp, #0]
 800dcfa:	4849      	ldr	r0, [pc, #292]	; (800de20 <icmp_input+0x260>)
 800dcfc:	4949      	ldr	r1, [pc, #292]	; (800de24 <icmp_input+0x264>)
 800dcfe:	4a4b      	ldr	r2, [pc, #300]	; (800de2c <icmp_input+0x26c>)
 800dd00:	2398      	movs	r3, #152	; 0x98
 800dd02:	f7ff fed5 	bl	800dab0 <chprintf.constprop.1>
 800dd06:	4849      	ldr	r0, [pc, #292]	; (800de2c <icmp_input+0x26c>)
 800dd08:	f7f3 f932 	bl	8000f70 <chSysHalt>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
memerr:
  pbuf_free(p);
 800dd0c:	4630      	mov	r0, r6
 800dd0e:	f7fb fb77 	bl	8009400 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
 800dd12:	f8b5 3074 	ldrh.w	r3, [r5, #116]	; 0x74
 800dd16:	3301      	adds	r3, #1
 800dd18:	f8a5 3074 	strh.w	r3, [r5, #116]	; 0x74
  snmp_inc_icmpinerrors();
  return;
 800dd1c:	e789      	b.n	800dc32 <icmp_input+0x72>
        accepted = 0;
      }
#endif /* LWIP_MULTICAST_PING */
#if !LWIP_BROADCAST_PING
      /* broadcast destination address? */
      if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
 800dd1e:	4649      	mov	r1, r9
 800dd20:	f000 fb9e 	bl	800e460 <ip4_addr_isbroadcast>
      }
#endif /* LWIP_BROADCAST_PING */
      /* broadcast or multicast destination address not acceptd? */
      if (!accepted) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
        ICMP_STATS_INC(icmp.err);
 800dd24:	f8b5 3074 	ldrh.w	r3, [r5, #116]	; 0x74
 800dd28:	3301      	adds	r3, #1
        pbuf_free(p);
 800dd2a:	4630      	mov	r0, r6
      }
#endif /* LWIP_BROADCAST_PING */
      /* broadcast or multicast destination address not acceptd? */
      if (!accepted) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
        ICMP_STATS_INC(icmp.err);
 800dd2c:	f8a5 3074 	strh.w	r3, [r5, #116]	; 0x74
 800dd30:	e7be      	b.n	800dcb0 <icmp_input+0xf0>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
 800dd32:	4630      	mov	r0, r6
 800dd34:	f7fb fb64 	bl	8009400 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
 800dd38:	f8b5 3068 	ldrh.w	r3, [r5, #104]	; 0x68
 800dd3c:	3301      	adds	r3, #1
 800dd3e:	f8a5 3068 	strh.w	r3, [r5, #104]	; 0x68
      snmp_inc_icmpinerrors();
      return;
 800dd42:	e776      	b.n	800dc32 <icmp_input+0x72>
      if (pbuf_header(p, hlen)) {
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
 800dd44:	2002      	movs	r0, #2
 800dd46:	8931      	ldrh	r1, [r6, #8]
 800dd48:	2200      	movs	r2, #0
 800dd4a:	f7fb fbd9 	bl	8009500 <pbuf_alloc>
      if (r == NULL) {
 800dd4e:	4684      	mov	ip, r0
 800dd50:	2800      	cmp	r0, #0
 800dd52:	d0db      	beq.n	800dd0c <icmp_input+0x14c>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
 800dd54:	8943      	ldrh	r3, [r0, #10]
 800dd56:	3408      	adds	r4, #8
 800dd58:	42a3      	cmp	r3, r4
 800dd5a:	d343      	bcc.n	800dde4 <icmp_input+0x224>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
 800dd5c:	4660      	mov	r0, ip
 800dd5e:	4631      	mov	r1, r6
 800dd60:	f8cd c014 	str.w	ip, [sp, #20]
 800dd64:	f7fb fdec 	bl	8009940 <pbuf_copy>
 800dd68:	f8dd c014 	ldr.w	ip, [sp, #20]
 800dd6c:	b318      	cbz	r0, 800ddb6 <icmp_input+0x1f6>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
 800dd6e:	4b2b      	ldr	r3, [pc, #172]	; (800de1c <icmp_input+0x25c>)
 800dd70:	9300      	str	r3, [sp, #0]
 800dd72:	492c      	ldr	r1, [pc, #176]	; (800de24 <icmp_input+0x264>)
 800dd74:	4a2e      	ldr	r2, [pc, #184]	; (800de30 <icmp_input+0x270>)
 800dd76:	482a      	ldr	r0, [pc, #168]	; (800de20 <icmp_input+0x260>)
 800dd78:	23a5      	movs	r3, #165	; 0xa5
 800dd7a:	f7ff fe99 	bl	800dab0 <chprintf.constprop.1>
 800dd7e:	482c      	ldr	r0, [pc, #176]	; (800de30 <icmp_input+0x270>)
 800dd80:	f7f3 f8f6 	bl	8000f70 <chSysHalt>
 800dd84:	e7c2      	b.n	800dd0c <icmp_input+0x14c>
    if(pbuf_header(p, hlen)) {
      LWIP_ASSERT("Can't move over header in packet", 0);
    } else {
      err_t ret;
      /* send an ICMP packet, src addr is the dest addr of the curren packet */
      ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
 800dd86:	2101      	movs	r1, #1
 800dd88:	9000      	str	r0, [sp, #0]
 800dd8a:	4602      	mov	r2, r0
 800dd8c:	9101      	str	r1, [sp, #4]
 800dd8e:	f8cd 9008 	str.w	r9, [sp, #8]
 800dd92:	4623      	mov	r3, r4
 800dd94:	4630      	mov	r0, r6
 800dd96:	4927      	ldr	r1, [pc, #156]	; (800de34 <icmp_input+0x274>)
 800dd98:	f000 fa6a 	bl	800e270 <ip_output_if>
 800dd9c:	e787      	b.n	800dcae <icmp_input+0xee>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
 800dd9e:	4b1f      	ldr	r3, [pc, #124]	; (800de1c <icmp_input+0x25c>)
 800dda0:	9300      	str	r3, [sp, #0]
 800dda2:	4920      	ldr	r1, [pc, #128]	; (800de24 <icmp_input+0x264>)
 800dda4:	4a24      	ldr	r2, [pc, #144]	; (800de38 <icmp_input+0x278>)
 800dda6:	481e      	ldr	r0, [pc, #120]	; (800de20 <icmp_input+0x260>)
 800dda8:	23b5      	movs	r3, #181	; 0xb5
 800ddaa:	f7ff fe81 	bl	800dab0 <chprintf.constprop.1>
 800ddae:	4822      	ldr	r0, [pc, #136]	; (800de38 <icmp_input+0x278>)
 800ddb0:	f7f3 f8de 	bl	8000f70 <chSysHalt>
 800ddb4:	e7aa      	b.n	800dd0c <icmp_input+0x14c>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
      }
      iphdr = (struct ip_hdr *)r->payload;
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
 800ddb6:	4660      	mov	r0, ip
 800ddb8:	4641      	mov	r1, r8
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
      }
      iphdr = (struct ip_hdr *)r->payload;
 800ddba:	f8dc 7004 	ldr.w	r7, [ip, #4]
 800ddbe:	f8cd c014 	str.w	ip, [sp, #20]
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
 800ddc2:	f7fb faad 	bl	8009320 <pbuf_header>
 800ddc6:	f8dd c014 	ldr.w	ip, [sp, #20]
 800ddca:	b1d0      	cbz	r0, 800de02 <icmp_input+0x242>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
 800ddcc:	4b13      	ldr	r3, [pc, #76]	; (800de1c <icmp_input+0x25c>)
 800ddce:	9300      	str	r3, [sp, #0]
 800ddd0:	4914      	ldr	r1, [pc, #80]	; (800de24 <icmp_input+0x264>)
 800ddd2:	4a19      	ldr	r2, [pc, #100]	; (800de38 <icmp_input+0x278>)
 800ddd4:	4812      	ldr	r0, [pc, #72]	; (800de20 <icmp_input+0x260>)
 800ddd6:	23ab      	movs	r3, #171	; 0xab
 800ddd8:	f7ff fe6a 	bl	800dab0 <chprintf.constprop.1>
 800dddc:	4816      	ldr	r0, [pc, #88]	; (800de38 <icmp_input+0x278>)
 800ddde:	f7f3 f8c7 	bl	8000f70 <chSysHalt>
 800dde2:	e793      	b.n	800dd0c <icmp_input+0x14c>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
 800dde4:	4b0d      	ldr	r3, [pc, #52]	; (800de1c <icmp_input+0x25c>)
 800dde6:	9005      	str	r0, [sp, #20]
 800dde8:	9300      	str	r3, [sp, #0]
 800ddea:	490e      	ldr	r1, [pc, #56]	; (800de24 <icmp_input+0x264>)
 800ddec:	4a13      	ldr	r2, [pc, #76]	; (800de3c <icmp_input+0x27c>)
 800ddee:	480c      	ldr	r0, [pc, #48]	; (800de20 <icmp_input+0x260>)
 800ddf0:	23a2      	movs	r3, #162	; 0xa2
 800ddf2:	f7ff fe5d 	bl	800dab0 <chprintf.constprop.1>
 800ddf6:	4811      	ldr	r0, [pc, #68]	; (800de3c <icmp_input+0x27c>)
 800ddf8:	f7f3 f8ba 	bl	8000f70 <chSysHalt>
 800ddfc:	f8dd c014 	ldr.w	ip, [sp, #20]
 800de00:	e7ac      	b.n	800dd5c <icmp_input+0x19c>
      if (pbuf_header(r, -hlen)) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
 800de02:	4630      	mov	r0, r6
 800de04:	f8cd c014 	str.w	ip, [sp, #20]
 800de08:	f7fb fafa 	bl	8009400 <pbuf_free>
 800de0c:	f8dd c014 	ldr.w	ip, [sp, #20]
 800de10:	4666      	mov	r6, ip
 800de12:	e71b      	b.n	800dc4c <icmp_input+0x8c>
 800de14:	2000c9fc 	.word	0x2000c9fc
 800de18:	2000cbac 	.word	0x2000cbac
 800de1c:	0801846c 	.word	0x0801846c
 800de20:	200180c8 	.word	0x200180c8
 800de24:	08016fe0 	.word	0x08016fe0
 800de28:	080171a4 	.word	0x080171a4
 800de2c:	0801849c 	.word	0x0801849c
 800de30:	08018508 	.word	0x08018508
 800de34:	2000cbb0 	.word	0x2000cbb0
 800de38:	08018530 	.word	0x08018530
 800de3c:	080184d0 	.word	0x080184d0

0800de40 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
 800de40:	460a      	mov	r2, r1
  icmp_send_response(p, ICMP_DUR, t);
 800de42:	3004      	adds	r0, #4
 800de44:	2103      	movs	r1, #3
 800de46:	f7ff be4b 	b.w	800dae0 <icmp_send_response.isra.0>
 800de4a:	bf00      	nop
 800de4c:	f3af 8000 	nop.w

0800de50 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
 800de50:	460a      	mov	r2, r1
  icmp_send_response(p, ICMP_TE, t);
 800de52:	3004      	adds	r0, #4
 800de54:	210b      	movs	r1, #11
 800de56:	f7ff be43 	b.w	800dae0 <icmp_send_response.isra.0>
 800de5a:	bf00      	nop
 800de5c:	f3af 8000 	nop.w

0800de60 <lwip_standard_chksum>:
 * @return host order (!) lwip checksum (non-inverted Internet sum) 
 */

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
 800de60:	b470      	push	{r4, r5, r6}
 800de62:	b083      	sub	sp, #12
  u8_t *pb = (u8_t *)dataptr;
  u16_t *ps, t = 0;
 800de64:	2200      	movs	r2, #0
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 800de66:	f010 0601 	ands.w	r6, r0, #1

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
  u8_t *pb = (u8_t *)dataptr;
  u16_t *ps, t = 0;
 800de6a:	f8ad 2006 	strh.w	r2, [sp, #6]
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 800de6e:	d006      	beq.n	800de7e <lwip_standard_chksum+0x1e>
 800de70:	4291      	cmp	r1, r2
 800de72:	dd16      	ble.n	800dea2 <lwip_standard_chksum+0x42>
    ((u8_t *)&t)[1] = *pb++;
 800de74:	7803      	ldrb	r3, [r0, #0]
 800de76:	f88d 3007 	strb.w	r3, [sp, #7]
    len--;
 800de7a:	3901      	subs	r1, #1
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);

  /* Get aligned to u16_t */
  if (odd && len > 0) {
    ((u8_t *)&t)[1] = *pb++;
 800de7c:	3001      	adds	r0, #1
    len--;
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
 800de7e:	2901      	cmp	r1, #1
 800de80:	dd27      	ble.n	800ded2 <lwip_standard_chksum+0x72>
 800de82:	4604      	mov	r4, r0
 800de84:	460b      	mov	r3, r1
 800de86:	2200      	movs	r2, #0
    sum += *ps++;
 800de88:	f834 5b02 	ldrh.w	r5, [r4], #2
    len -= 2;
 800de8c:	3b02      	subs	r3, #2
    len--;
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
 800de8e:	2b01      	cmp	r3, #1
    sum += *ps++;
 800de90:	442a      	add	r2, r5
    len--;
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
 800de92:	dcf9      	bgt.n	800de88 <lwip_standard_chksum+0x28>
 800de94:	3902      	subs	r1, #2
 800de96:	084b      	lsrs	r3, r1, #1
 800de98:	1c5c      	adds	r4, r3, #1
 800de9a:	eba1 0143 	sub.w	r1, r1, r3, lsl #1
 800de9e:	eb00 0044 	add.w	r0, r0, r4, lsl #1
    sum += *ps++;
    len -= 2;
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
 800dea2:	2901      	cmp	r1, #1
    ((u8_t *)&t)[0] = *(u8_t *)ps;
 800dea4:	bf04      	itt	eq
 800dea6:	7803      	ldrbeq	r3, [r0, #0]
 800dea8:	f88d 3006 	strbeq.w	r3, [sp, #6]
  }

  /* Add end bytes */
  sum += t;
 800deac:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 800deb0:	4410      	add	r0, r2

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  sum = FOLD_U32T(sum);
 800deb2:	b283      	uxth	r3, r0
 800deb4:	eb03 4010 	add.w	r0, r3, r0, lsr #16
  sum = FOLD_U32T(sum);
 800deb8:	b283      	uxth	r3, r0
 800deba:	eb03 4010 	add.w	r0, r3, r0, lsr #16

  /* Swap if alignment was odd */
  if (odd) {
 800debe:	b126      	cbz	r6, 800deca <lwip_standard_chksum+0x6a>
    sum = SWAP_BYTES_IN_WORD(sum);
 800dec0:	0203      	lsls	r3, r0, #8
 800dec2:	b29b      	uxth	r3, r3
 800dec4:	f3c0 2007 	ubfx	r0, r0, #8, #8
 800dec8:	4318      	orrs	r0, r3
  }

  return (u16_t)sum;
 800deca:	b280      	uxth	r0, r0
}
 800decc:	b003      	add	sp, #12
 800dece:	bc70      	pop	{r4, r5, r6}
 800ded0:	4770      	bx	lr
static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
  u8_t *pb = (u8_t *)dataptr;
  u16_t *ps, t = 0;
  u32_t sum = 0;
 800ded2:	2200      	movs	r2, #0
 800ded4:	e7e5      	b.n	800dea2 <lwip_standard_chksum+0x42>
 800ded6:	bf00      	nop
 800ded8:	f3af 8000 	nop.w
 800dedc:	f3af 8000 	nop.w

0800dee0 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       ip_addr_t *src, ip_addr_t *dest,
       u8_t proto, u16_t proto_len)
{
 800dee0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800dee4:	468a      	mov	sl, r1
 800dee6:	4691      	mov	r9, r2
 800dee8:	4698      	mov	r8, r3
 800deea:	f8bd 7020 	ldrh.w	r7, [sp, #32]
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
 800deee:	4605      	mov	r5, r0
 800def0:	2800      	cmp	r0, #0
 800def2:	d03b      	beq.n	800df6c <inet_chksum_pseudo+0x8c>
 800def4:	2600      	movs	r6, #0
 800def6:	4634      	mov	r4, r6
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
 800def8:	6868      	ldr	r0, [r5, #4]
 800defa:	8969      	ldrh	r1, [r5, #10]
 800defc:	f7ff ffb0 	bl	800de60 <lwip_standard_chksum>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
 800df00:	896b      	ldrh	r3, [r5, #10]
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
 800df02:	4420      	add	r0, r4
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
 800df04:	b284      	uxth	r4, r0
    if (q->len % 2 != 0) {
 800df06:	07db      	lsls	r3, r3, #31
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
 800df08:	eb04 4410 	add.w	r4, r4, r0, lsr #16
    if (q->len % 2 != 0) {
 800df0c:	d507      	bpl.n	800df1e <inet_chksum_pseudo+0x3e>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
 800df0e:	0223      	lsls	r3, r4, #8
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
 800df10:	f1c6 0601 	rsb	r6, r6, #1
      acc = SWAP_BYTES_IN_WORD(acc);
 800df14:	b29b      	uxth	r3, r3
 800df16:	f3c4 2407 	ubfx	r4, r4, #8, #8
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
 800df1a:	b2f6      	uxtb	r6, r6
      acc = SWAP_BYTES_IN_WORD(acc);
 800df1c:	431c      	orrs	r4, r3
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
 800df1e:	682d      	ldr	r5, [r5, #0]
 800df20:	2d00      	cmp	r5, #0
 800df22:	d1e9      	bne.n	800def8 <inet_chksum_pseudo+0x18>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 800df24:	b126      	cbz	r6, 800df30 <inet_chksum_pseudo+0x50>
    acc = SWAP_BYTES_IN_WORD(acc);
 800df26:	0223      	lsls	r3, r4, #8
 800df28:	b29b      	uxth	r3, r3
 800df2a:	f3c4 2407 	ubfx	r4, r4, #8, #8
 800df2e:	431c      	orrs	r4, r3
  }
  addr = ip4_addr_get_u32(src);
 800df30:	f8da 3000 	ldr.w	r3, [sl]
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
 800df34:	f8d9 1000 	ldr.w	r1, [r9]

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  addr = ip4_addr_get_u32(src);
  acc += (addr & 0xffffUL);
 800df38:	b29a      	uxth	r2, r3
 800df3a:	eb02 4313 	add.w	r3, r2, r3, lsr #16
 800df3e:	fa13 f381 	uxtah	r3, r3, r1
 800df42:	eb03 4311 	add.w	r3, r3, r1, lsr #16
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
 800df46:	4640      	mov	r0, r8
  addr = ip4_addr_get_u32(src);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
 800df48:	441c      	add	r4, r3
  acc += (u32_t)htons((u16_t)proto);
 800df4a:	f000 ff29 	bl	800eda0 <lwip_htons>
 800df4e:	4404      	add	r4, r0
  acc += (u32_t)htons(proto_len);
 800df50:	4638      	mov	r0, r7
 800df52:	f000 ff25 	bl	800eda0 <lwip_htons>
 800df56:	4420      	add	r0, r4

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
 800df58:	b283      	uxth	r3, r0
 800df5a:	eb03 4010 	add.w	r0, r3, r0, lsr #16
  acc = FOLD_U32T(acc);
 800df5e:	b283      	uxth	r3, r0
 800df60:	eb03 4010 	add.w	r0, r3, r0, lsr #16
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 800df64:	43c0      	mvns	r0, r0
}
 800df66:	b280      	uxth	r0, r0
 800df68:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  u32_t acc;
  u32_t addr;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
 800df6c:	4604      	mov	r4, r0
 800df6e:	e7df      	b.n	800df30 <inet_chksum_pseudo+0x50>

0800df70 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
 800df70:	b508      	push	{r3, lr}
  return ~LWIP_CHKSUM(dataptr, len);
 800df72:	f7ff ff75 	bl	800de60 <lwip_standard_chksum>
 800df76:	43c0      	mvns	r0, r0
}
 800df78:	b280      	uxth	r0, r0
 800df7a:	bd08      	pop	{r3, pc}
 800df7c:	f3af 8000 	nop.w

0800df80 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
 800df80:	b570      	push	{r4, r5, r6, lr}
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
 800df82:	4605      	mov	r5, r0
 800df84:	b300      	cbz	r0, 800dfc8 <inet_chksum_pbuf+0x48>
 800df86:	2600      	movs	r6, #0
 800df88:	4634      	mov	r4, r6
    acc += LWIP_CHKSUM(q->payload, q->len);
 800df8a:	6868      	ldr	r0, [r5, #4]
 800df8c:	8969      	ldrh	r1, [r5, #10]
 800df8e:	f7ff ff67 	bl	800de60 <lwip_standard_chksum>
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
 800df92:	896b      	ldrh	r3, [r5, #10]
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
 800df94:	4420      	add	r0, r4
    acc = FOLD_U32T(acc);
 800df96:	b284      	uxth	r4, r0
    if (q->len % 2 != 0) {
 800df98:	07db      	lsls	r3, r3, #31

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
    acc = FOLD_U32T(acc);
 800df9a:	eb04 4410 	add.w	r4, r4, r0, lsr #16
    if (q->len % 2 != 0) {
 800df9e:	d507      	bpl.n	800dfb0 <inet_chksum_pbuf+0x30>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
 800dfa0:	0223      	lsls	r3, r4, #8
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
 800dfa2:	f1c6 0601 	rsb	r6, r6, #1
      acc = SWAP_BYTES_IN_WORD(acc);
 800dfa6:	b29b      	uxth	r3, r3
 800dfa8:	f3c4 2407 	ubfx	r4, r4, #8, #8
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
 800dfac:	b2f6      	uxtb	r6, r6
      acc = SWAP_BYTES_IN_WORD(acc);
 800dfae:	431c      	orrs	r4, r3
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
 800dfb0:	682d      	ldr	r5, [r5, #0]
 800dfb2:	2d00      	cmp	r5, #0
 800dfb4:	d1e9      	bne.n	800df8a <inet_chksum_pbuf+0xa>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
 800dfb6:	b126      	cbz	r6, 800dfc2 <inet_chksum_pbuf+0x42>
    acc = SWAP_BYTES_IN_WORD(acc);
 800dfb8:	0220      	lsls	r0, r4, #8
 800dfba:	b280      	uxth	r0, r0
 800dfbc:	f3c4 2407 	ubfx	r4, r4, #8, #8
 800dfc0:	4304      	orrs	r4, r0
 800dfc2:	43e4      	mvns	r4, r4
 800dfc4:	b2a0      	uxth	r0, r4
 800dfc6:	bd70      	pop	{r4, r5, r6, pc}
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
 800dfc8:	f64f 70ff 	movw	r0, #65535	; 0xffff

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  return (u16_t)~(acc & 0xffffUL);
}
 800dfcc:	bd70      	pop	{r4, r5, r6, pc}
 800dfce:	bf00      	nop

0800dfd0 <chprintf.constprop.1>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 800dfd0:	b40e      	push	{r1, r2, r3}
 800dfd2:	b500      	push	{lr}
 800dfd4:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800dfd6:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 800dfd8:	461a      	mov	r2, r3
 800dfda:	4905      	ldr	r1, [pc, #20]	; (800dff0 <chprintf.constprop.1+0x20>)
 800dfdc:	4805      	ldr	r0, [pc, #20]	; (800dff4 <chprintf.constprop.1+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800dfde:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800dfe0:	f002 fe8e 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 800dfe4:	b002      	add	sp, #8
 800dfe6:	f85d eb04 	ldr.w	lr, [sp], #4
 800dfea:	b003      	add	sp, #12
 800dfec:	4770      	bx	lr
 800dfee:	bf00      	nop
 800dff0:	08016fe0 	.word	0x08016fe0
 800dff4:	200180c8 	.word	0x200180c8
 800dff8:	f3af 8000 	nop.w
 800dffc:	f3af 8000 	nop.w

0800e000 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(ip_addr_t *dest)
{
 800e000:	b410      	push	{r4}
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 800e002:	4b11      	ldr	r3, [pc, #68]	; (800e048 <ip_route+0x48>)
 800e004:	681b      	ldr	r3, [r3, #0]
 800e006:	b16b      	cbz	r3, 800e024 <ip_route+0x24>
    /* network mask matches? */
    if (netif_is_up(netif)) {
 800e008:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 800e00c:	07d2      	lsls	r2, r2, #31
 800e00e:	d5f9      	bpl.n	800e004 <ip_route+0x4>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
 800e010:	685c      	ldr	r4, [r3, #4]
 800e012:	6802      	ldr	r2, [r0, #0]
 800e014:	6899      	ldr	r1, [r3, #8]
 800e016:	4062      	eors	r2, r4
 800e018:	420a      	tst	r2, r1
 800e01a:	d1f3      	bne.n	800e004 <ip_route+0x4>
 800e01c:	4618      	mov	r0, r3
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
}
 800e01e:	f85d 4b04 	ldr.w	r4, [sp], #4
 800e022:	4770      	bx	lr
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
 800e024:	4b09      	ldr	r3, [pc, #36]	; (800e04c <ip_route+0x4c>)
 800e026:	6818      	ldr	r0, [r3, #0]
 800e028:	b130      	cbz	r0, 800e038 <ip_route+0x38>
 800e02a:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
 800e02e:	07db      	lsls	r3, r3, #31
 800e030:	d502      	bpl.n	800e038 <ip_route+0x38>
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
}
 800e032:	f85d 4b04 	ldr.w	r4, [sp], #4
 800e036:	4770      	bx	lr
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
 800e038:	4a05      	ldr	r2, [pc, #20]	; (800e050 <ip_route+0x50>)
 800e03a:	f8b2 3056 	ldrh.w	r3, [r2, #86]	; 0x56
 800e03e:	3301      	adds	r3, #1
 800e040:	f8a2 3056 	strh.w	r3, [r2, #86]	; 0x56
 800e044:	2000      	movs	r0, #0
 800e046:	e7f4      	b.n	800e032 <ip_route+0x32>
 800e048:	2000c9ec 	.word	0x2000c9ec
 800e04c:	2000c9f0 	.word	0x2000c9f0
 800e050:	2000c9fc 	.word	0x2000c9fc
 800e054:	f3af 8000 	nop.w
 800e058:	f3af 8000 	nop.w
 800e05c:	f3af 8000 	nop.w

0800e060 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
 800e060:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  u16_t iphdr_len;
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  int check_ip_src=1;
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  IP_STATS_INC(ip.recv);
 800e064:	4d7a      	ldr	r5, [pc, #488]	; (800e250 <ip_input+0x1f0>)
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 800e066:	f8d0 8004 	ldr.w	r8, [r0, #4]
  u16_t iphdr_len;
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  int check_ip_src=1;
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  IP_STATS_INC(ip.recv);
 800e06a:	f8b5 304a 	ldrh.w	r3, [r5, #74]	; 0x4a
 800e06e:	3301      	adds	r3, #1
 800e070:	f8a5 304a 	strh.w	r3, [r5, #74]	; 0x4a
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
  if (IPH_V(iphdr) != 4) {
 800e074:	f898 3000 	ldrb.w	r3, [r8]
 800e078:	091a      	lsrs	r2, r3, #4
 800e07a:	2a04      	cmp	r2, #4
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
 800e07c:	4606      	mov	r6, r0
  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
  if (IPH_V(iphdr) != 4) {
 800e07e:	d00e      	beq.n	800e09e <ip_input+0x3e>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
 800e080:	f7fb f9be 	bl	8009400 <pbuf_free>
    IP_STATS_INC(ip.err);
 800e084:	f8b5 205c 	ldrh.w	r2, [r5, #92]	; 0x5c
    IP_STATS_INC(ip.drop);
 800e088:	f8b5 304e 	ldrh.w	r3, [r5, #78]	; 0x4e
  iphdr = (struct ip_hdr *)p->payload;
  if (IPH_V(iphdr) != 4) {
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
    IP_STATS_INC(ip.err);
 800e08c:	3201      	adds	r2, #1
    IP_STATS_INC(ip.drop);
 800e08e:	3301      	adds	r3, #1
  iphdr = (struct ip_hdr *)p->payload;
  if (IPH_V(iphdr) != 4) {
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
    IP_STATS_INC(ip.err);
 800e090:	f8a5 205c 	strh.w	r2, [r5, #92]	; 0x5c
    IP_STATS_INC(ip.drop);
 800e094:	f8a5 304e 	strh.w	r3, [r5, #78]	; 0x4e
  current_header = NULL;
  ip_addr_set_any(&current_iphdr_src);
  ip_addr_set_any(&current_iphdr_dest);

  return ERR_OK;
}
 800e098:	2000      	movs	r0, #0
 800e09a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return ERR_OK;
  }
#endif

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
 800e09e:	f003 030f 	and.w	r3, r3, #15
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
 800e0a2:	f8b8 0002 	ldrh.w	r0, [r8, #2]
#endif

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
 800e0a6:	009c      	lsls	r4, r3, #2
 800e0a8:	460f      	mov	r7, r1
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
 800e0aa:	f000 fe81 	bl	800edb0 <lwip_ntohs>

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
 800e0ae:	8973      	ldrh	r3, [r6, #10]
 800e0b0:	42a3      	cmp	r3, r4
  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
 800e0b2:	4681      	mov	r9, r0

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
 800e0b4:	d302      	bcc.n	800e0bc <ip_input+0x5c>
 800e0b6:	8933      	ldrh	r3, [r6, #8]
 800e0b8:	4283      	cmp	r3, r0
 800e0ba:	d20f      	bcs.n	800e0dc <ip_input+0x7c>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
        iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
 800e0bc:	4630      	mov	r0, r6
 800e0be:	f7fb f99f 	bl	8009400 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
 800e0c2:	f8b5 2052 	ldrh.w	r2, [r5, #82]	; 0x52
    IP_STATS_INC(ip.drop);
 800e0c6:	f8b5 304e 	ldrh.w	r3, [r5, #78]	; 0x4e
        ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
        iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
    IP_STATS_INC(ip.lenerr);
 800e0ca:	3201      	adds	r2, #1
    IP_STATS_INC(ip.drop);
 800e0cc:	3301      	adds	r3, #1
        ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
        iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
    IP_STATS_INC(ip.lenerr);
 800e0ce:	f8a5 2052 	strh.w	r2, [r5, #82]	; 0x52
    IP_STATS_INC(ip.drop);
 800e0d2:	f8a5 304e 	strh.w	r3, [r5, #78]	; 0x4e
  current_header = NULL;
  ip_addr_set_any(&current_iphdr_src);
  ip_addr_set_any(&current_iphdr_dest);

  return ERR_OK;
}
 800e0d6:	2000      	movs	r0, #0
 800e0d8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return ERR_OK;
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
 800e0dc:	4621      	mov	r1, r4
 800e0de:	4640      	mov	r0, r8
 800e0e0:	f7ff ff46 	bl	800df70 <inet_chksum>
 800e0e4:	2800      	cmp	r0, #0
 800e0e6:	f040 8091 	bne.w	800e20c <ip_input+0x1ac>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
 800e0ea:	4649      	mov	r1, r9
 800e0ec:	4630      	mov	r0, r6

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
 800e0ee:	f8df 916c 	ldr.w	r9, [pc, #364]	; 800e25c <ip_input+0x1fc>
        }
#endif /* LWIP_AUTOIP */
      }
      if (first) {
        first = 0;
        netif = netif_list;
 800e0f2:	f8df a16c 	ldr.w	sl, [pc, #364]	; 800e260 <ip_input+0x200>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
 800e0f6:	f7fb fb23 	bl	8009740 <pbuf_realloc>

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
 800e0fa:	f8d8 3010 	ldr.w	r3, [r8, #16]
 800e0fe:	f8c9 3000 	str.w	r3, [r9]
  ip_addr_copy(current_iphdr_src, iphdr->src);
 800e102:	4a54      	ldr	r2, [pc, #336]	; (800e254 <ip_input+0x1f4>)
 800e104:	f8d8 300c 	ldr.w	r3, [r8, #12]
 800e108:	6013      	str	r3, [r2, #0]
 800e10a:	463c      	mov	r4, r7
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
 800e10c:	f04f 0b01 	mov.w	fp, #1
          ip4_addr_get_u32(&iphdr->dest) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&netif->ip_addr) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
 800e110:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
 800e114:	07db      	lsls	r3, r3, #31
 800e116:	d509      	bpl.n	800e12c <ip_input+0xcc>
 800e118:	6863      	ldr	r3, [r4, #4]
 800e11a:	b13b      	cbz	r3, 800e12c <ip_input+0xcc>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 800e11c:	f8d9 0000 	ldr.w	r0, [r9]
 800e120:	4283      	cmp	r3, r0
 800e122:	d00f      	beq.n	800e144 <ip_input+0xe4>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
 800e124:	4621      	mov	r1, r4
 800e126:	f000 f99b 	bl	800e460 <ip4_addr_isbroadcast>
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 800e12a:	b958      	cbnz	r0, 800e144 <ip_input+0xe4>
          /* break out of for loop */
          break;
        }
#endif /* LWIP_AUTOIP */
      }
      if (first) {
 800e12c:	f1bb 0f00 	cmp.w	fp, #0
 800e130:	d061      	beq.n	800e1f6 <ip_input+0x196>
        first = 0;
        netif = netif_list;
 800e132:	f8da 4000 	ldr.w	r4, [sl]
      } else {
        netif = netif->next;
      }
      if (netif == inp) {
 800e136:	42bc      	cmp	r4, r7
        netif = netif->next;
 800e138:	bf08      	it	eq
 800e13a:	6824      	ldreq	r4, [r4, #0]
 800e13c:	f04f 0b00 	mov.w	fp, #0
      }
    } while(netif != NULL);
 800e140:	2c00      	cmp	r4, #0
 800e142:	d1e5      	bne.n	800e110 <ip_input+0xb0>
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
 800e144:	4b43      	ldr	r3, [pc, #268]	; (800e254 <ip_input+0x1f4>)
 800e146:	4639      	mov	r1, r7
 800e148:	6818      	ldr	r0, [r3, #0]
 800e14a:	469b      	mov	fp, r3
 800e14c:	f000 f988 	bl	800e460 <ip4_addr_isbroadcast>
 800e150:	2800      	cmp	r0, #0
 800e152:	d152      	bne.n	800e1fa <ip_input+0x19a>
         (ip_addr_ismulticast(&current_iphdr_src))) {
 800e154:	f8db 3000 	ldr.w	r3, [fp]
 800e158:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
 800e15c:	2be0      	cmp	r3, #224	; 0xe0
 800e15e:	d04c      	beq.n	800e1fa <ip_input+0x19a>
      return ERR_OK;
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
 800e160:	2c00      	cmp	r4, #0
 800e162:	d070      	beq.n	800e246 <ip_input+0x1e6>
    }
    pbuf_free(p);
    return ERR_OK;
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 800e164:	f8b8 3006 	ldrh.w	r3, [r8, #6]
 800e168:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800e16c:	b13b      	cbz	r3, 800e17e <ip_input+0x11e>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
 800e16e:	4630      	mov	r0, r6
 800e170:	f000 fb16 	bl	800e7a0 <ip_reass>
    /* packet not fully reassembled yet? */
    if (p == NULL) {
 800e174:	4606      	mov	r6, r0
 800e176:	2800      	cmp	r0, #0
 800e178:	d08e      	beq.n	800e098 <ip_input+0x38>
      return ERR_OK;
    }
    iphdr = (struct ip_hdr *)p->payload;
 800e17a:	f8d0 8004 	ldr.w	r8, [r0, #4]
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
 800e17e:	f8df b0e4 	ldr.w	fp, [pc, #228]	; 800e264 <ip_input+0x204>
  current_header = iphdr;
 800e182:	4c35      	ldr	r4, [pc, #212]	; (800e258 <ip_input+0x1f8>)
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
 800e184:	f8cb 7000 	str.w	r7, [fp]
  current_header = iphdr;

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
 800e188:	4630      	mov	r0, r6
 800e18a:	4639      	mov	r1, r7
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
  current_header = iphdr;
 800e18c:	f8c4 8000 	str.w	r8, [r4]

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
 800e190:	f7fb fd06 	bl	8009ba0 <raw_input>
 800e194:	bb30      	cbnz	r0, 800e1e4 <ip_input+0x184>
#endif /* LWIP_RAW */
  {
    switch (IPH_PROTO(iphdr)) {
 800e196:	f898 3009 	ldrb.w	r3, [r8, #9]
 800e19a:	2b06      	cmp	r3, #6
 800e19c:	d049      	beq.n	800e232 <ip_input+0x1d2>
 800e19e:	2b11      	cmp	r3, #17
 800e1a0:	d042      	beq.n	800e228 <ip_input+0x1c8>
 800e1a2:	2b01      	cmp	r3, #1
 800e1a4:	d04a      	beq.n	800e23c <ip_input+0x1dc>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
 800e1a6:	4639      	mov	r1, r7
 800e1a8:	f8d9 0000 	ldr.w	r0, [r9]
 800e1ac:	4f2b      	ldr	r7, [pc, #172]	; (800e25c <ip_input+0x1fc>)
 800e1ae:	f000 f957 	bl	800e460 <ip4_addr_isbroadcast>
 800e1b2:	b950      	cbnz	r0, 800e1ca <ip_input+0x16a>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
 800e1b4:	683b      	ldr	r3, [r7, #0]
 800e1b6:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
 800e1ba:	2be0      	cmp	r3, #224	; 0xe0
 800e1bc:	d005      	beq.n	800e1ca <ip_input+0x16a>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        p->payload = iphdr;
 800e1be:	f8c6 8004 	str.w	r8, [r6, #4]
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
 800e1c2:	4630      	mov	r0, r6
 800e1c4:	2102      	movs	r1, #2
 800e1c6:	f7ff fe3b 	bl	800de40 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
 800e1ca:	4630      	mov	r0, r6
 800e1cc:	f7fb f918 	bl	8009400 <pbuf_free>

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));

      IP_STATS_INC(ip.proterr);
 800e1d0:	f8b5 2058 	ldrh.w	r2, [r5, #88]	; 0x58
      IP_STATS_INC(ip.drop);
 800e1d4:	f8b5 304e 	ldrh.w	r3, [r5, #78]	; 0x4e
#endif /* LWIP_ICMP */
      pbuf_free(p);

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));

      IP_STATS_INC(ip.proterr);
 800e1d8:	3201      	adds	r2, #1
      IP_STATS_INC(ip.drop);
 800e1da:	3301      	adds	r3, #1
#endif /* LWIP_ICMP */
      pbuf_free(p);

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));

      IP_STATS_INC(ip.proterr);
 800e1dc:	f8a5 2058 	strh.w	r2, [r5, #88]	; 0x58
      IP_STATS_INC(ip.drop);
 800e1e0:	f8a5 304e 	strh.w	r3, [r5, #78]	; 0x4e
    }
  }

  current_netif = NULL;
  current_header = NULL;
  ip_addr_set_any(&current_iphdr_src);
 800e1e4:	4a1b      	ldr	r2, [pc, #108]	; (800e254 <ip_input+0x1f4>)
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinunknownprotos();
    }
  }

  current_netif = NULL;
 800e1e6:	2300      	movs	r3, #0
 800e1e8:	f8cb 3000 	str.w	r3, [fp]
  current_header = NULL;
 800e1ec:	6023      	str	r3, [r4, #0]
  ip_addr_set_any(&current_iphdr_src);
 800e1ee:	6013      	str	r3, [r2, #0]
  ip_addr_set_any(&current_iphdr_dest);
 800e1f0:	f8c9 3000 	str.w	r3, [r9]

  return ERR_OK;
 800e1f4:	e750      	b.n	800e098 <ip_input+0x38>
      }
      if (first) {
        first = 0;
        netif = netif_list;
      } else {
        netif = netif->next;
 800e1f6:	6824      	ldr	r4, [r4, #0]
 800e1f8:	e79d      	b.n	800e136 <ip_input+0xd6>
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
         (ip_addr_ismulticast(&current_iphdr_src))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
 800e1fa:	4630      	mov	r0, r6
 800e1fc:	f7fb f900 	bl	8009400 <pbuf_free>
      IP_STATS_INC(ip.drop);
 800e200:	f8b5 304e 	ldrh.w	r3, [r5, #78]	; 0x4e
 800e204:	3301      	adds	r3, #1
 800e206:	f8a5 304e 	strh.w	r3, [r5, #78]	; 0x4e
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
 800e20a:	e745      	b.n	800e098 <ip_input+0x38>
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {

    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
 800e20c:	4630      	mov	r0, r6
 800e20e:	f7fb f8f7 	bl	8009400 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
 800e212:	f8b5 2050 	ldrh.w	r2, [r5, #80]	; 0x50
    IP_STATS_INC(ip.drop);
 800e216:	f8b5 304e 	ldrh.w	r3, [r5, #78]	; 0x4e

    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
    IP_STATS_INC(ip.chkerr);
 800e21a:	3201      	adds	r2, #1
    IP_STATS_INC(ip.drop);
 800e21c:	3301      	adds	r3, #1

    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
    IP_STATS_INC(ip.chkerr);
 800e21e:	f8a5 2050 	strh.w	r2, [r5, #80]	; 0x50
    IP_STATS_INC(ip.drop);
 800e222:	f8a5 304e 	strh.w	r3, [r5, #78]	; 0x4e
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
 800e226:	e737      	b.n	800e098 <ip_input+0x38>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
 800e228:	4630      	mov	r0, r6
 800e22a:	4639      	mov	r1, r7
 800e22c:	f7ff fa78 	bl	800d720 <udp_input>
      break;
 800e230:	e7d8      	b.n	800e1e4 <ip_input+0x184>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
 800e232:	4630      	mov	r0, r6
 800e234:	4639      	mov	r1, r7
 800e236:	f7fd fc4b 	bl	800bad0 <tcp_input>
      break;
 800e23a:	e7d3      	b.n	800e1e4 <ip_input+0x184>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
 800e23c:	4630      	mov	r0, r6
 800e23e:	4639      	mov	r1, r7
 800e240:	f7ff fcbe 	bl	800dbc0 <icmp_input>
      break;
 800e244:	e7ce      	b.n	800e1e4 <ip_input+0x184>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
 800e246:	4630      	mov	r0, r6
 800e248:	f7fb f8da 	bl	8009400 <pbuf_free>
    return ERR_OK;
 800e24c:	e724      	b.n	800e098 <ip_input+0x38>
 800e24e:	bf00      	nop
 800e250:	2000c9fc 	.word	0x2000c9fc
 800e254:	2000cbac 	.word	0x2000cbac
 800e258:	2000cba4 	.word	0x2000cba4
 800e25c:	2000cbb0 	.word	0x2000cbb0
 800e260:	2000c9ec 	.word	0x2000c9ec
 800e264:	2000cbb4 	.word	0x2000cbb4
 800e268:	f3af 8000 	nop.w
 800e26c:	f3af 8000 	nop.w

0800e270 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
 800e270:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e274:	468a      	mov	sl, r1
  u32_t chk_sum = 0;
#endif /* CHECKSUM_GEN_IP_INLINE */

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
 800e276:	89c1      	ldrh	r1, [r0, #14]
 */
err_t
ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
 800e278:	b087      	sub	sp, #28
  u32_t chk_sum = 0;
#endif /* CHECKSUM_GEN_IP_INLINE */

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
 800e27a:	2901      	cmp	r1, #1
 */
err_t
ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
 800e27c:	4605      	mov	r5, r0
 800e27e:	f89d b040 	ldrb.w	fp, [sp, #64]	; 0x40
 800e282:	f89d 9044 	ldrb.w	r9, [sp, #68]	; 0x44
 800e286:	4690      	mov	r8, r2
 800e288:	461e      	mov	r6, r3
  u32_t chk_sum = 0;
#endif /* CHECKSUM_GEN_IP_INLINE */

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
 800e28a:	d00b      	beq.n	800e2a4 <ip_output_if+0x34>
 800e28c:	4b4d      	ldr	r3, [pc, #308]	; (800e3c4 <ip_output_if+0x154>)
 800e28e:	9300      	str	r3, [sp, #0]
 800e290:	484d      	ldr	r0, [pc, #308]	; (800e3c8 <ip_output_if+0x158>)
 800e292:	494e      	ldr	r1, [pc, #312]	; (800e3cc <ip_output_if+0x15c>)
 800e294:	4a4e      	ldr	r2, [pc, #312]	; (800e3d0 <ip_output_if+0x160>)
 800e296:	f44f 7327 	mov.w	r3, #668	; 0x29c
 800e29a:	f7ff fe99 	bl	800dfd0 <chprintf.constprop.1>
 800e29e:	484c      	ldr	r0, [pc, #304]	; (800e3d0 <ip_output_if+0x160>)
 800e2a0:	f7f2 fe66 	bl	8000f70 <chSysHalt>

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
 800e2a4:	f1b8 0f00 	cmp.w	r8, #0
 800e2a8:	d066      	beq.n	800e378 <ip_output_if+0x108>
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
 800e2aa:	4628      	mov	r0, r5
 800e2ac:	2114      	movs	r1, #20
 800e2ae:	f7fb f837 	bl	8009320 <pbuf_header>
 800e2b2:	2800      	cmp	r0, #0
 800e2b4:	d17d      	bne.n	800e3b2 <ip_output_if+0x142>
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *)p->payload;
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 800e2b6:	896b      	ldrh	r3, [r5, #10]
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *)p->payload;
 800e2b8:	686c      	ldr	r4, [r5, #4]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 800e2ba:	2b13      	cmp	r3, #19
 800e2bc:	d963      	bls.n	800e386 <ip_output_if+0x116>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
    IPH_PROTO_SET(iphdr, proto);
 800e2be:	f884 9009 	strb.w	r9, [r4, #9]

    iphdr = (struct ip_hdr *)p->payload;
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 800e2c2:	7226      	strb	r6, [r4, #8]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
 800e2c4:	f8d8 3000 	ldr.w	r3, [r8]
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
 800e2c8:	f884 b001 	strb.w	fp, [r4, #1]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 800e2cc:	2245      	movs	r2, #69	; 0x45
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
 800e2ce:	b299      	uxth	r1, r3
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 800e2d0:	7022      	strb	r2, [r4, #0]
 800e2d2:	eb01 4113 	add.w	r1, r1, r3, lsr #16
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
 800e2d6:	6123      	str	r3, [r4, #16]
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
 800e2d8:	ea4f 2b0b 	mov.w	fp, fp, lsl #8
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 800e2dc:	8928      	ldrh	r0, [r5, #8]
 800e2de:	9103      	str	r1, [sp, #12]
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
 800e2e0:	ea4b 0b02 	orr.w	fp, fp, r2
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 800e2e4:	f000 fd5c 	bl	800eda0 <lwip_htons>
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
 800e2e8:	4f3a      	ldr	r7, [pc, #232]	; (800e3d4 <ip_output_if+0x164>)
    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 800e2ea:	8060      	strh	r0, [r4, #2]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 800e2ec:	f04f 0e00 	mov.w	lr, #0
    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 800e2f0:	9002      	str	r0, [sp, #8]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 800e2f2:	f884 e006 	strb.w	lr, [r4, #6]
 800e2f6:	f884 e007 	strb.w	lr, [r4, #7]
    IPH_ID_SET(iphdr, htons(ip_id));
 800e2fa:	8838      	ldrh	r0, [r7, #0]
 800e2fc:	f000 fd50 	bl	800eda0 <lwip_htons>
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 800e300:	f8b7 e000 	ldrh.w	lr, [r7]
    IPH_LEN_SET(iphdr, htons(p->tot_len));
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
 800e304:	80a0      	strh	r0, [r4, #4]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 800e306:	f10e 0e01 	add.w	lr, lr, #1
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
    IPH_PROTO_SET(iphdr, proto);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
 800e30a:	ea46 2909 	orr.w	r9, r6, r9, lsl #8
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 800e30e:	f8a7 e000 	strh.w	lr, [r7]

    if (ip_addr_isany(src)) {
 800e312:	9b02      	ldr	r3, [sp, #8]
 800e314:	9903      	ldr	r1, [sp, #12]
 800e316:	f1ba 0f00 	cmp.w	sl, #0
 800e31a:	d002      	beq.n	800e322 <ip_output_if+0xb2>
 800e31c:	f8da 2000 	ldr.w	r2, [sl]
 800e320:	bb42      	cbnz	r2, 800e374 <ip_output_if+0x104>
      ip_addr_copy(iphdr->src, netif->ip_addr);
 800e322:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800e324:	6852      	ldr	r2, [r2, #4]
 800e326:	60e2      	str	r2, [r4, #12]
 800e328:	eb01 060b 	add.w	r6, r1, fp
 800e32c:	444e      	add	r6, r9
 800e32e:	441e      	add	r6, r3
 800e330:	4430      	add	r0, r6
 800e332:	fa10 f082 	uxtah	r0, r0, r2
      ip_addr_copy(iphdr->src, *src);
    }

#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
 800e336:	eb00 4012 	add.w	r0, r0, r2, lsr #16
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
 800e33a:	b283      	uxth	r3, r0
 800e33c:	eb03 4010 	add.w	r0, r3, r0, lsr #16
    chk_sum = (chk_sum >> 16) + chk_sum;
 800e340:	eb00 4010 	add.w	r0, r0, r0, lsr #16
    chk_sum = ~chk_sum;
    iphdr->_chksum = chk_sum; /* network order */
 800e344:	43c0      	mvns	r0, r0
 800e346:	8160      	strh	r0, [r4, #10]
    iphdr = (struct ip_hdr *)p->payload;
    ip_addr_copy(dest_addr, iphdr->dest);
    dest = &dest_addr;
  }

  IP_STATS_INC(ip.xmit);
 800e348:	4a23      	ldr	r2, [pc, #140]	; (800e3d8 <ip_output_if+0x168>)
  }
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 800e34a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800e34c:	8c19      	ldrh	r1, [r3, #32]
    iphdr = (struct ip_hdr *)p->payload;
    ip_addr_copy(dest_addr, iphdr->dest);
    dest = &dest_addr;
  }

  IP_STATS_INC(ip.xmit);
 800e34e:	f8b2 3048 	ldrh.w	r3, [r2, #72]	; 0x48
 800e352:	3301      	adds	r3, #1
 800e354:	f8a2 3048 	strh.w	r3, [r2, #72]	; 0x48
  }
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 800e358:	b111      	cbz	r1, 800e360 <ip_output_if+0xf0>
 800e35a:	892b      	ldrh	r3, [r5, #8]
 800e35c:	428b      	cmp	r3, r1
 800e35e:	d81f      	bhi.n	800e3a0 <ip_output_if+0x130>
    return ip_frag(p, netif, dest);
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
 800e360:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800e362:	9812      	ldr	r0, [sp, #72]	; 0x48
 800e364:	695b      	ldr	r3, [r3, #20]
 800e366:	4629      	mov	r1, r5
 800e368:	4642      	mov	r2, r8
 800e36a:	4798      	blx	r3
}
 800e36c:	b240      	sxtb	r0, r0
 800e36e:	b007      	add	sp, #28
 800e370:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

    if (ip_addr_isany(src)) {
      ip_addr_copy(iphdr->src, netif->ip_addr);
    } else {
      /* src cannot be NULL here */
      ip_addr_copy(iphdr->src, *src);
 800e374:	60e2      	str	r2, [r4, #12]
 800e376:	e7d7      	b.n	800e328 <ip_output_if+0xb8>
#endif
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    iphdr = (struct ip_hdr *)p->payload;
    ip_addr_copy(dest_addr, iphdr->dest);
 800e378:	686b      	ldr	r3, [r5, #4]
 800e37a:	f10d 0818 	add.w	r8, sp, #24
 800e37e:	691b      	ldr	r3, [r3, #16]
 800e380:	f848 3d04 	str.w	r3, [r8, #-4]!
 800e384:	e7e0      	b.n	800e348 <ip_output_if+0xd8>
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *)p->payload;
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 800e386:	4b0f      	ldr	r3, [pc, #60]	; (800e3c4 <ip_output_if+0x154>)
 800e388:	9300      	str	r3, [sp, #0]
 800e38a:	4910      	ldr	r1, [pc, #64]	; (800e3cc <ip_output_if+0x15c>)
 800e38c:	4a13      	ldr	r2, [pc, #76]	; (800e3dc <ip_output_if+0x16c>)
 800e38e:	480e      	ldr	r0, [pc, #56]	; (800e3c8 <ip_output_if+0x158>)
 800e390:	f240 23ca 	movw	r3, #714	; 0x2ca
 800e394:	f7ff fe1c 	bl	800dfd0 <chprintf.constprop.1>
 800e398:	4810      	ldr	r0, [pc, #64]	; (800e3dc <ip_output_if+0x16c>)
 800e39a:	f7f2 fde9 	bl	8000f70 <chSysHalt>
 800e39e:	e78e      	b.n	800e2be <ip_output_if+0x4e>
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
    return ip_frag(p, netif, dest);
 800e3a0:	4628      	mov	r0, r5
 800e3a2:	9912      	ldr	r1, [sp, #72]	; 0x48
 800e3a4:	4642      	mov	r2, r8
 800e3a6:	f000 fc03 	bl	800ebb0 <ip_frag>
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
}
 800e3aa:	b240      	sxtb	r0, r0
 800e3ac:	b007      	add	sp, #28
 800e3ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
 800e3b2:	4a09      	ldr	r2, [pc, #36]	; (800e3d8 <ip_output_if+0x168>)
 800e3b4:	f8b2 305c 	ldrh.w	r3, [r2, #92]	; 0x5c
 800e3b8:	3301      	adds	r3, #1
 800e3ba:	f8a2 305c 	strh.w	r3, [r2, #92]	; 0x5c
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
 800e3be:	20fe      	movs	r0, #254	; 0xfe
 800e3c0:	e7d4      	b.n	800e36c <ip_output_if+0xfc>
 800e3c2:	bf00      	nop
 800e3c4:	0801857c 	.word	0x0801857c
 800e3c8:	200180c8 	.word	0x200180c8
 800e3cc:	08016fe0 	.word	0x08016fe0
 800e3d0:	08018570 	.word	0x08018570
 800e3d4:	2000cba8 	.word	0x2000cba8
 800e3d8:	2000c9fc 	.word	0x2000c9fc
 800e3dc:	080185ac 	.word	0x080185ac

0800e3e0 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
 800e3e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800e3e4:	460f      	mov	r7, r1
  struct netif *netif;

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
 800e3e6:	89c1      	ldrh	r1, [r0, #14]
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
 800e3e8:	b085      	sub	sp, #20
  struct netif *netif;

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
 800e3ea:	2901      	cmp	r1, #1
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
 800e3ec:	4605      	mov	r5, r0
 800e3ee:	f89d 9030 	ldrb.w	r9, [sp, #48]	; 0x30
 800e3f2:	f89d 8034 	ldrb.w	r8, [sp, #52]	; 0x34
 800e3f6:	4614      	mov	r4, r2
 800e3f8:	461e      	mov	r6, r3
  struct netif *netif;

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
 800e3fa:	d00b      	beq.n	800e414 <ip_output+0x34>
 800e3fc:	4b13      	ldr	r3, [pc, #76]	; (800e44c <ip_output+0x6c>)
 800e3fe:	9300      	str	r3, [sp, #0]
 800e400:	4813      	ldr	r0, [pc, #76]	; (800e450 <ip_output+0x70>)
 800e402:	4914      	ldr	r1, [pc, #80]	; (800e454 <ip_output+0x74>)
 800e404:	4a14      	ldr	r2, [pc, #80]	; (800e458 <ip_output+0x78>)
 800e406:	f240 3339 	movw	r3, #825	; 0x339
 800e40a:	f7ff fde1 	bl	800dfd0 <chprintf.constprop.1>
 800e40e:	4812      	ldr	r0, [pc, #72]	; (800e458 <ip_output+0x78>)
 800e410:	f7f2 fdae 	bl	8000f70 <chSysHalt>

  if ((netif = ip_route(dest)) == NULL) {
 800e414:	4620      	mov	r0, r4
 800e416:	f7ff fdf3 	bl	800e000 <ip_route>
 800e41a:	b170      	cbz	r0, 800e43a <ip_output+0x5a>
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
 800e41c:	9002      	str	r0, [sp, #8]
 800e41e:	f8cd 9000 	str.w	r9, [sp]
 800e422:	f8cd 8004 	str.w	r8, [sp, #4]
 800e426:	4628      	mov	r0, r5
 800e428:	4639      	mov	r1, r7
 800e42a:	4622      	mov	r2, r4
 800e42c:	4633      	mov	r3, r6
 800e42e:	f7ff ff1f 	bl	800e270 <ip_output_if>
}
 800e432:	b240      	sxtb	r0, r0
 800e434:	b005      	add	sp, #20
 800e436:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  if ((netif = ip_route(dest)) == NULL) {
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
 800e43a:	4a08      	ldr	r2, [pc, #32]	; (800e45c <ip_output+0x7c>)
 800e43c:	f8b2 3056 	ldrh.w	r3, [r2, #86]	; 0x56
 800e440:	3301      	adds	r3, #1
 800e442:	f8a2 3056 	strh.w	r3, [r2, #86]	; 0x56
    return ERR_RTE;
 800e446:	20fc      	movs	r0, #252	; 0xfc
 800e448:	e7f3      	b.n	800e432 <ip_output+0x52>
 800e44a:	bf00      	nop
 800e44c:	0801857c 	.word	0x0801857c
 800e450:	200180c8 	.word	0x200180c8
 800e454:	08016fe0 	.word	0x08016fe0
 800e458:	08018570 	.word	0x08018570
 800e45c:	2000c9fc 	.word	0x2000c9fc

0800e460 <ip4_addr_isbroadcast>:
{
  ip_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 800e460:	1e43      	subs	r3, r0, #1
 800e462:	3303      	adds	r3, #3
 800e464:	d818      	bhi.n	800e498 <ip4_addr_isbroadcast+0x38>
      (addr == IPADDR_ANY)) {
    return 1;
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 800e466:	f891 2029 	ldrb.w	r2, [r1, #41]	; 0x29
 800e46a:	f002 0202 	and.w	r2, r2, #2
 800e46e:	f002 03ff 	and.w	r3, r2, #255	; 0xff
 800e472:	b162      	cbz	r2, 800e48e <ip4_addr_isbroadcast+0x2e>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
 800e474:	684a      	ldr	r2, [r1, #4]
 800e476:	4282      	cmp	r2, r0
 800e478:	d00b      	beq.n	800e492 <ip4_addr_isbroadcast+0x32>
    return 0;
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
 800e47a:	688b      	ldr	r3, [r1, #8]
 800e47c:	4042      	eors	r2, r0
 800e47e:	421a      	tst	r2, r3
 800e480:	d107      	bne.n	800e492 <ip4_addr_isbroadcast+0x32>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
 800e482:	43db      	mvns	r3, r3
 800e484:	4018      	ands	r0, r3
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
      (addr == IPADDR_ANY)) {
    return 1;
 800e486:	1a1b      	subs	r3, r3, r0
 800e488:	fab3 f383 	clz	r3, r3
 800e48c:	095b      	lsrs	r3, r3, #5
    /* => network broadcast address */
    return 1;
  } else {
    return 0;
  }
}
 800e48e:	4618      	mov	r0, r3
 800e490:	4770      	bx	lr
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
    /* => network broadcast address */
    return 1;
  } else {
    return 0;
 800e492:	2300      	movs	r3, #0
  }
}
 800e494:	4618      	mov	r0, r3
 800e496:	4770      	bx	lr
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
      (addr == IPADDR_ANY)) {
    return 1;
 800e498:	2301      	movs	r3, #1
    /* => network broadcast address */
    return 1;
  } else {
    return 0;
  }
}
 800e49a:	4618      	mov	r0, r3
 800e49c:	4770      	bx	lr
 800e49e:	bf00      	nop

0800e4a0 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 800e4a0:	b40e      	push	{r1, r2, r3}
 800e4a2:	b500      	push	{lr}
 800e4a4:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800e4a6:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 800e4a8:	461a      	mov	r2, r3
 800e4aa:	4905      	ldr	r1, [pc, #20]	; (800e4c0 <chprintf.constprop.0+0x20>)
 800e4ac:	4805      	ldr	r0, [pc, #20]	; (800e4c4 <chprintf.constprop.0+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800e4ae:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800e4b0:	f002 fc26 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 800e4b4:	b002      	add	sp, #8
 800e4b6:	f85d eb04 	ldr.w	lr, [sp], #4
 800e4ba:	b003      	add	sp, #12
 800e4bc:	4770      	bx	lr
 800e4be:	bf00      	nop
 800e4c0:	08016fe0 	.word	0x08016fe0
 800e4c4:	200180c8 	.word	0x200180c8
 800e4c8:	f3af 8000 	nop.w
 800e4cc:	f3af 8000 	nop.w

0800e4d0 <ip_frag_free_pbuf_custom_ref>:
}

/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
{
 800e4d0:	b510      	push	{r4, lr}
  LWIP_ASSERT("p != NULL", p != NULL);
 800e4d2:	4604      	mov	r4, r0
}

/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
{
 800e4d4:	b082      	sub	sp, #8
  LWIP_ASSERT("p != NULL", p != NULL);
 800e4d6:	b130      	cbz	r0, 800e4e6 <ip_frag_free_pbuf_custom_ref+0x16>
  memp_free(MEMP_FRAG_PBUF, p);
 800e4d8:	4621      	mov	r1, r4
 800e4da:	2006      	movs	r0, #6
}
 800e4dc:	b002      	add	sp, #8
 800e4de:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
{
  LWIP_ASSERT("p != NULL", p != NULL);
  memp_free(MEMP_FRAG_PBUF, p);
 800e4e2:	f7fa bd6d 	b.w	8008fc0 <memp_free>

/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
{
  LWIP_ASSERT("p != NULL", p != NULL);
 800e4e6:	4b06      	ldr	r3, [pc, #24]	; (800e500 <ip_frag_free_pbuf_custom_ref+0x30>)
 800e4e8:	9300      	str	r3, [sp, #0]
 800e4ea:	4906      	ldr	r1, [pc, #24]	; (800e504 <ip_frag_free_pbuf_custom_ref+0x34>)
 800e4ec:	4a06      	ldr	r2, [pc, #24]	; (800e508 <ip_frag_free_pbuf_custom_ref+0x38>)
 800e4ee:	4807      	ldr	r0, [pc, #28]	; (800e50c <ip_frag_free_pbuf_custom_ref+0x3c>)
 800e4f0:	f240 2379 	movw	r3, #633	; 0x279
 800e4f4:	f7ff ffd4 	bl	800e4a0 <chprintf.constprop.0>
 800e4f8:	4803      	ldr	r0, [pc, #12]	; (800e508 <ip_frag_free_pbuf_custom_ref+0x38>)
 800e4fa:	f7f2 fd39 	bl	8000f70 <chSysHalt>
 800e4fe:	e7eb      	b.n	800e4d8 <ip_frag_free_pbuf_custom_ref+0x8>
 800e500:	080185e0 	.word	0x080185e0
 800e504:	08016fe0 	.word	0x08016fe0
 800e508:	08018be8 	.word	0x08018be8
 800e50c:	200180c8 	.word	0x200180c8

0800e510 <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
 800e510:	b510      	push	{r4, lr}
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
 800e512:	4604      	mov	r4, r0

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
 800e514:	b082      	sub	sp, #8
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
 800e516:	b148      	cbz	r0, 800e52c <ipfrag_free_pbuf_custom+0x1c>
  LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
  if (pcr->original != NULL) {
 800e518:	6960      	ldr	r0, [r4, #20]
 800e51a:	b108      	cbz	r0, 800e520 <ipfrag_free_pbuf_custom+0x10>
    pbuf_free(pcr->original);
 800e51c:	f7fa ff70 	bl	8009400 <pbuf_free>
  }
  ip_frag_free_pbuf_custom_ref(pcr);
 800e520:	4620      	mov	r0, r4
}
 800e522:	b002      	add	sp, #8
 800e524:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
  LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
  if (pcr->original != NULL) {
    pbuf_free(pcr->original);
  }
  ip_frag_free_pbuf_custom_ref(pcr);
 800e528:	f7ff bfd2 	b.w	800e4d0 <ip_frag_free_pbuf_custom_ref>
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
 800e52c:	4b06      	ldr	r3, [pc, #24]	; (800e548 <ipfrag_free_pbuf_custom+0x38>)
 800e52e:	9300      	str	r3, [sp, #0]
 800e530:	4906      	ldr	r1, [pc, #24]	; (800e54c <ipfrag_free_pbuf_custom+0x3c>)
 800e532:	4a07      	ldr	r2, [pc, #28]	; (800e550 <ipfrag_free_pbuf_custom+0x40>)
 800e534:	4807      	ldr	r0, [pc, #28]	; (800e554 <ipfrag_free_pbuf_custom+0x44>)
 800e536:	f240 2383 	movw	r3, #643	; 0x283
 800e53a:	f7ff ffb1 	bl	800e4a0 <chprintf.constprop.0>
 800e53e:	4804      	ldr	r0, [pc, #16]	; (800e550 <ipfrag_free_pbuf_custom+0x40>)
 800e540:	f7f2 fd16 	bl	8000f70 <chSysHalt>
 800e544:	e7e8      	b.n	800e518 <ipfrag_free_pbuf_custom+0x8>
 800e546:	bf00      	nop
 800e548:	080185e0 	.word	0x080185e0
 800e54c:	08016fe0 	.word	0x08016fe0
 800e550:	08018614 	.word	0x08018614
 800e554:	200180c8 	.word	0x200180c8
 800e558:	f3af 8000 	nop.w
 800e55c:	f3af 8000 	nop.w

0800e560 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 800e560:	b530      	push	{r4, r5, lr}
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 800e562:	4b10      	ldr	r3, [pc, #64]	; (800e5a4 <ip_reass_dequeue_datagram+0x44>)
 800e564:	681a      	ldr	r2, [r3, #0]
 800e566:	4282      	cmp	r2, r0
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 800e568:	b083      	sub	sp, #12
 800e56a:	4604      	mov	r4, r0
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 800e56c:	d00a      	beq.n	800e584 <ip_reass_dequeue_datagram+0x24>
 800e56e:	460d      	mov	r5, r1
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
 800e570:	b159      	cbz	r1, 800e58a <ip_reass_dequeue_datagram+0x2a>
    prev->next = ipr->next;
 800e572:	6823      	ldr	r3, [r4, #0]
 800e574:	602b      	str	r3, [r5, #0]
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 800e576:	4621      	mov	r1, r4
 800e578:	2005      	movs	r0, #5
}
 800e57a:	b003      	add	sp, #12
 800e57c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 800e580:	f7fa bd1e 	b.w	8008fc0 <memp_free>
{
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
    /* it was the first in the list */
    reassdatagrams = ipr->next;
 800e584:	6802      	ldr	r2, [r0, #0]
 800e586:	601a      	str	r2, [r3, #0]
 800e588:	e7f5      	b.n	800e576 <ip_reass_dequeue_datagram+0x16>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
 800e58a:	4b07      	ldr	r3, [pc, #28]	; (800e5a8 <ip_reass_dequeue_datagram+0x48>)
 800e58c:	9300      	str	r3, [sp, #0]
 800e58e:	4907      	ldr	r1, [pc, #28]	; (800e5ac <ip_reass_dequeue_datagram+0x4c>)
 800e590:	4a07      	ldr	r2, [pc, #28]	; (800e5b0 <ip_reass_dequeue_datagram+0x50>)
 800e592:	4808      	ldr	r0, [pc, #32]	; (800e5b4 <ip_reass_dequeue_datagram+0x54>)
 800e594:	f240 1339 	movw	r3, #313	; 0x139
 800e598:	f7ff ff82 	bl	800e4a0 <chprintf.constprop.0>
 800e59c:	4804      	ldr	r0, [pc, #16]	; (800e5b0 <ip_reass_dequeue_datagram+0x50>)
 800e59e:	f7f2 fce7 	bl	8000f70 <chSysHalt>
 800e5a2:	e7e6      	b.n	800e572 <ip_reass_dequeue_datagram+0x12>
 800e5a4:	2000cbb8 	.word	0x2000cbb8
 800e5a8:	080185e0 	.word	0x080185e0
 800e5ac:	08016fe0 	.word	0x08016fe0
 800e5b0:	08018620 	.word	0x08018620
 800e5b4:	200180c8 	.word	0x200180c8
 800e5b8:	f3af 8000 	nop.w
 800e5bc:	f3af 8000 	nop.w

0800e5c0 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 800e5c0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  u16_t pbufs_freed = 0;
  u8_t clen;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
 800e5c4:	4281      	cmp	r1, r0
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 800e5c6:	b083      	sub	sp, #12
 800e5c8:	4607      	mov	r7, r0
 800e5ca:	4688      	mov	r8, r1
  u16_t pbufs_freed = 0;
  u8_t clen;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
 800e5cc:	d074      	beq.n	800e6b8 <ip_reass_free_complete_datagram+0xf8>
  if (prev != NULL) {
 800e5ce:	f1b8 0f00 	cmp.w	r8, #0
 800e5d2:	d00e      	beq.n	800e5f2 <ip_reass_free_complete_datagram+0x32>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
 800e5d4:	f8d8 3000 	ldr.w	r3, [r8]
 800e5d8:	42bb      	cmp	r3, r7
 800e5da:	d00a      	beq.n	800e5f2 <ip_reass_free_complete_datagram+0x32>
 800e5dc:	4b3c      	ldr	r3, [pc, #240]	; (800e6d0 <ip_reass_free_complete_datagram+0x110>)
 800e5de:	9300      	str	r3, [sp, #0]
 800e5e0:	483c      	ldr	r0, [pc, #240]	; (800e6d4 <ip_reass_free_complete_datagram+0x114>)
 800e5e2:	493d      	ldr	r1, [pc, #244]	; (800e6d8 <ip_reass_free_complete_datagram+0x118>)
 800e5e4:	4a3d      	ldr	r2, [pc, #244]	; (800e6dc <ip_reass_free_complete_datagram+0x11c>)
 800e5e6:	23a7      	movs	r3, #167	; 0xa7
 800e5e8:	f7ff ff5a 	bl	800e4a0 <chprintf.constprop.0>
 800e5ec:	483b      	ldr	r0, [pc, #236]	; (800e6dc <ip_reass_free_complete_datagram+0x11c>)
 800e5ee:	f7f2 fcbf 	bl	8000f70 <chSysHalt>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
 800e5f2:	687d      	ldr	r5, [r7, #4]
 800e5f4:	686b      	ldr	r3, [r5, #4]
  if (iprh->start == 0) {
 800e5f6:	889a      	ldrh	r2, [r3, #4]
 800e5f8:	2a00      	cmp	r2, #0
 800e5fa:	d03d      	beq.n	800e678 <ip_reass_free_complete_datagram+0xb8>
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  u16_t pbufs_freed = 0;
 800e5fc:	2600      	movs	r6, #0
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    clen = pbuf_clen(pcur);
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 800e5fe:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 800e6d0 <ip_reass_free_complete_datagram+0x110>
 800e602:	e006      	b.n	800e612 <ip_reass_free_complete_datagram+0x52>
    pbufs_freed += clen;
    pbuf_free(pcur);
 800e604:	4628      	mov	r0, r5
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    clen = pbuf_clen(pcur);
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
 800e606:	b2b6      	uxth	r6, r6
    pbuf_free(pcur);
 800e608:	f7fa fefa 	bl	8009400 <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
 800e60c:	b1d4      	cbz	r4, 800e644 <ip_reass_free_complete_datagram+0x84>
 800e60e:	6863      	ldr	r3, [r4, #4]
 800e610:	4625      	mov	r5, r4
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    clen = pbuf_clen(pcur);
 800e612:	4628      	mov	r0, r5
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
 800e614:	681c      	ldr	r4, [r3, #0]
    clen = pbuf_clen(pcur);
 800e616:	f7fb f923 	bl	8009860 <pbuf_clen>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 800e61a:	4406      	add	r6, r0
 800e61c:	f5b6 3f80 	cmp.w	r6, #65536	; 0x10000
 800e620:	dbf0      	blt.n	800e604 <ip_reass_free_complete_datagram+0x44>
 800e622:	492d      	ldr	r1, [pc, #180]	; (800e6d8 <ip_reass_free_complete_datagram+0x118>)
 800e624:	4a2e      	ldr	r2, [pc, #184]	; (800e6e0 <ip_reass_free_complete_datagram+0x120>)
 800e626:	f8cd 9000 	str.w	r9, [sp]
 800e62a:	23c6      	movs	r3, #198	; 0xc6
 800e62c:	4829      	ldr	r0, [pc, #164]	; (800e6d4 <ip_reass_free_complete_datagram+0x114>)
 800e62e:	f7ff ff37 	bl	800e4a0 <chprintf.constprop.0>
 800e632:	482b      	ldr	r0, [pc, #172]	; (800e6e0 <ip_reass_free_complete_datagram+0x120>)
 800e634:	f7f2 fc9c 	bl	8000f70 <chSysHalt>
    pbufs_freed += clen;
    pbuf_free(pcur);
 800e638:	4628      	mov	r0, r5
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    clen = pbuf_clen(pcur);
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
 800e63a:	b2b6      	uxth	r6, r6
    pbuf_free(pcur);
 800e63c:	f7fa fee0 	bl	8009400 <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
 800e640:	2c00      	cmp	r4, #0
 800e642:	d1e4      	bne.n	800e60e <ip_reass_free_complete_datagram+0x4e>
    pbufs_freed += clen;
    pbuf_free(pcur);
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
 800e644:	4c27      	ldr	r4, [pc, #156]	; (800e6e4 <ip_reass_free_complete_datagram+0x124>)
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
    pbuf_free(pcur);
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
 800e646:	4638      	mov	r0, r7
 800e648:	4641      	mov	r1, r8
 800e64a:	f7ff ff89 	bl	800e560 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
 800e64e:	8823      	ldrh	r3, [r4, #0]
 800e650:	429e      	cmp	r6, r3
 800e652:	d90b      	bls.n	800e66c <ip_reass_free_complete_datagram+0xac>
 800e654:	4b1e      	ldr	r3, [pc, #120]	; (800e6d0 <ip_reass_free_complete_datagram+0x110>)
 800e656:	9300      	str	r3, [sp, #0]
 800e658:	491f      	ldr	r1, [pc, #124]	; (800e6d8 <ip_reass_free_complete_datagram+0x118>)
 800e65a:	4a23      	ldr	r2, [pc, #140]	; (800e6e8 <ip_reass_free_complete_datagram+0x128>)
 800e65c:	481d      	ldr	r0, [pc, #116]	; (800e6d4 <ip_reass_free_complete_datagram+0x114>)
 800e65e:	23cc      	movs	r3, #204	; 0xcc
 800e660:	f7ff ff1e 	bl	800e4a0 <chprintf.constprop.0>
 800e664:	4820      	ldr	r0, [pc, #128]	; (800e6e8 <ip_reass_free_complete_datagram+0x128>)
 800e666:	f7f2 fc83 	bl	8000f70 <chSysHalt>
 800e66a:	8823      	ldrh	r3, [r4, #0]
  ip_reass_pbufcount -= pbufs_freed;
 800e66c:	1b9b      	subs	r3, r3, r6

  return pbufs_freed;
}
 800e66e:	4630      	mov	r0, r6
    pbuf_free(pcur);
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  ip_reass_pbufcount -= pbufs_freed;
 800e670:	8023      	strh	r3, [r4, #0]

  return pbufs_freed;
}
 800e672:	b003      	add	sp, #12
 800e674:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  if (iprh->start == 0) {
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
 800e678:	681a      	ldr	r2, [r3, #0]
 800e67a:	607a      	str	r2, [r7, #4]
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 800e67c:	463a      	mov	r2, r7
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 800e67e:	4628      	mov	r0, r5
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 800e680:	f852 1f08 	ldr.w	r1, [r2, #8]!
 800e684:	6856      	ldr	r6, [r2, #4]
 800e686:	6894      	ldr	r4, [r2, #8]
 800e688:	f8d2 e00c 	ldr.w	lr, [r2, #12]
 800e68c:	f8c3 e00c 	str.w	lr, [r3, #12]
 800e690:	605e      	str	r6, [r3, #4]
 800e692:	6019      	str	r1, [r3, #0]
 800e694:	609c      	str	r4, [r3, #8]
 800e696:	6911      	ldr	r1, [r2, #16]
 800e698:	6119      	str	r1, [r3, #16]
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 800e69a:	2101      	movs	r1, #1
 800e69c:	f7ff fbd8 	bl	800de50 <icmp_time_exceeded>
    clen = pbuf_clen(p);
 800e6a0:	4628      	mov	r0, r5
 800e6a2:	f7fb f8dd 	bl	8009860 <pbuf_clen>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
 800e6a6:	b286      	uxth	r6, r0
    pbuf_free(p);
 800e6a8:	4628      	mov	r0, r5
 800e6aa:	f7fa fea9 	bl	8009400 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
 800e6ae:	687d      	ldr	r5, [r7, #4]
  while (p != NULL) {
 800e6b0:	2d00      	cmp	r5, #0
 800e6b2:	d0c7      	beq.n	800e644 <ip_reass_free_complete_datagram+0x84>
 800e6b4:	686b      	ldr	r3, [r5, #4]
 800e6b6:	e7a2      	b.n	800e5fe <ip_reass_free_complete_datagram+0x3e>
  u16_t pbufs_freed = 0;
  u8_t clen;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
 800e6b8:	4b05      	ldr	r3, [pc, #20]	; (800e6d0 <ip_reass_free_complete_datagram+0x110>)
 800e6ba:	9300      	str	r3, [sp, #0]
 800e6bc:	4906      	ldr	r1, [pc, #24]	; (800e6d8 <ip_reass_free_complete_datagram+0x118>)
 800e6be:	4a0b      	ldr	r2, [pc, #44]	; (800e6ec <ip_reass_free_complete_datagram+0x12c>)
 800e6c0:	4804      	ldr	r0, [pc, #16]	; (800e6d4 <ip_reass_free_complete_datagram+0x114>)
 800e6c2:	23a5      	movs	r3, #165	; 0xa5
 800e6c4:	f7ff feec 	bl	800e4a0 <chprintf.constprop.0>
 800e6c8:	4808      	ldr	r0, [pc, #32]	; (800e6ec <ip_reass_free_complete_datagram+0x12c>)
 800e6ca:	f7f2 fc51 	bl	8000f70 <chSysHalt>
 800e6ce:	e77e      	b.n	800e5ce <ip_reass_free_complete_datagram+0xe>
 800e6d0:	080185e0 	.word	0x080185e0
 800e6d4:	200180c8 	.word	0x200180c8
 800e6d8:	08016fe0 	.word	0x08016fe0
 800e6dc:	08018648 	.word	0x08018648
 800e6e0:	0801865c 	.word	0x0801865c
 800e6e4:	2000cbbc 	.word	0x2000cbbc
 800e6e8:	0801867c 	.word	0x0801867c
 800e6ec:	0801863c 	.word	0x0801863c

0800e6f0 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
 800e6f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800e6f4:	4e1b      	ldr	r6, [pc, #108]	; (800e764 <ip_reass_remove_oldest_datagram+0x74>)
 800e6f6:	4680      	mov	r8, r0
 800e6f8:	460d      	mov	r5, r1
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
 800e6fa:	f04f 0900 	mov.w	r9, #0
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
 800e6fe:	6833      	ldr	r3, [r6, #0]
    while (r != NULL) {
 800e700:	b363      	cbz	r3, 800e75c <ip_reass_remove_oldest_datagram+0x6c>
 800e702:	2400      	movs	r4, #0
 800e704:	4621      	mov	r1, r4
 800e706:	4620      	mov	r0, r4
 800e708:	f8d8 e00c 	ldr.w	lr, [r8, #12]
 800e70c:	e00a      	b.n	800e724 <ip_reass_remove_oldest_datagram+0x34>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
        /* Not the same datagram as fraghdr */
        other_datagrams++;
 800e70e:	3401      	adds	r4, #1
        if (oldest == NULL) {
 800e710:	b1c0      	cbz	r0, 800e744 <ip_reass_remove_oldest_datagram+0x54>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
 800e712:	7fdf      	ldrb	r7, [r3, #31]
 800e714:	7fc2      	ldrb	r2, [r0, #31]
 800e716:	4297      	cmp	r7, r2
 800e718:	bf98      	it	ls
 800e71a:	4618      	movls	r0, r3
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
 800e71c:	681a      	ldr	r2, [r3, #0]
 800e71e:	b1aa      	cbz	r2, 800e74c <ip_reass_remove_oldest_datagram+0x5c>
 800e720:	4619      	mov	r1, r3
 800e722:	4613      	mov	r3, r2
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 800e724:	695a      	ldr	r2, [r3, #20]
 800e726:	4572      	cmp	r2, lr
 800e728:	d1f1      	bne.n	800e70e <ip_reass_remove_oldest_datagram+0x1e>
 800e72a:	f8d8 7010 	ldr.w	r7, [r8, #16]
 800e72e:	699a      	ldr	r2, [r3, #24]
 800e730:	42ba      	cmp	r2, r7
 800e732:	d1ec      	bne.n	800e70e <ip_reass_remove_oldest_datagram+0x1e>
 800e734:	899f      	ldrh	r7, [r3, #12]
 800e736:	f8b8 2004 	ldrh.w	r2, [r8, #4]
 800e73a:	4297      	cmp	r7, r2
 800e73c:	d0ee      	beq.n	800e71c <ip_reass_remove_oldest_datagram+0x2c>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
 800e73e:	3401      	adds	r4, #1
        if (oldest == NULL) {
 800e740:	2800      	cmp	r0, #0
 800e742:	d1e6      	bne.n	800e712 <ip_reass_remove_oldest_datagram+0x22>
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
 800e744:	681a      	ldr	r2, [r3, #0]
 800e746:	4618      	mov	r0, r3
 800e748:	2a00      	cmp	r2, #0
 800e74a:	d1e9      	bne.n	800e720 <ip_reass_remove_oldest_datagram+0x30>
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
 800e74c:	b110      	cbz	r0, 800e754 <ip_reass_remove_oldest_datagram+0x64>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
 800e74e:	f7ff ff37 	bl	800e5c0 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
 800e752:	4481      	add	r9, r0
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 800e754:	45a9      	cmp	r9, r5
 800e756:	da01      	bge.n	800e75c <ip_reass_remove_oldest_datagram+0x6c>
 800e758:	2c01      	cmp	r4, #1
 800e75a:	dcd0      	bgt.n	800e6fe <ip_reass_remove_oldest_datagram+0xe>
  return pbufs_freed;
}
 800e75c:	4648      	mov	r0, r9
 800e75e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800e762:	bf00      	nop
 800e764:	2000cbb8 	.word	0x2000cbb8
 800e768:	f3af 8000 	nop.w
 800e76c:	f3af 8000 	nop.w

0800e770 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
 800e770:	b538      	push	{r3, r4, r5, lr}
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
 800e772:	4b0a      	ldr	r3, [pc, #40]	; (800e79c <ip_reass_tmr+0x2c>)
 800e774:	6818      	ldr	r0, [r3, #0]
  while (r != NULL) {
 800e776:	b140      	cbz	r0, 800e78a <ip_reass_tmr+0x1a>
 800e778:	2400      	movs	r4, #0
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
 800e77a:	7fc3      	ldrb	r3, [r0, #31]
      r->timer--;
 800e77c:	1e5a      	subs	r2, r3, #1

  r = reassdatagrams;
  while (r != NULL) {
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
 800e77e:	b12b      	cbz	r3, 800e78c <ip_reass_tmr+0x1c>
      r->timer--;
 800e780:	77c2      	strb	r2, [r0, #31]
 800e782:	4604      	mov	r4, r0
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
      r = r->next;
 800e784:	6800      	ldr	r0, [r0, #0]
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
 800e786:	2800      	cmp	r0, #0
 800e788:	d1f7      	bne.n	800e77a <ip_reass_tmr+0xa>
 800e78a:	bd38      	pop	{r3, r4, r5, pc}
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
 800e78c:	6805      	ldr	r5, [r0, #0]
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
 800e78e:	4621      	mov	r1, r4
 800e790:	f7ff ff16 	bl	800e5c0 <ip_reass_free_complete_datagram>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
 800e794:	4628      	mov	r0, r5
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
 800e796:	2800      	cmp	r0, #0
 800e798:	d1ef      	bne.n	800e77a <ip_reass_tmr+0xa>
 800e79a:	e7f6      	b.n	800e78a <ip_reass_tmr+0x1a>
 800e79c:	2000cbb8 	.word	0x2000cbb8

0800e7a0 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
 800e7a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
 800e7a4:	f8df b3f0 	ldr.w	fp, [pc, #1008]	; 800eb98 <ip_reass+0x3f8>
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
 800e7a8:	6845      	ldr	r5, [r0, #4]
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
 800e7aa:	f8bb 3032 	ldrh.w	r3, [fp, #50]	; 0x32
 800e7ae:	3301      	adds	r3, #1
 800e7b0:	f8ab 3032 	strh.w	r3, [fp, #50]	; 0x32
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 800e7b4:	782b      	ldrb	r3, [r5, #0]
 800e7b6:	f003 030f 	and.w	r3, r3, #15
 800e7ba:	2b05      	cmp	r3, #5
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
 800e7bc:	b087      	sub	sp, #28
 800e7be:	4606      	mov	r6, r0
  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 800e7c0:	f040 80e3 	bne.w	800e98a <ip_reass+0x1ea>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 800e7c4:	88e8      	ldrh	r0, [r5, #6]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 800e7c6:	f8df 83d4 	ldr.w	r8, [pc, #980]	; 800eb9c <ip_reass+0x3fc>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 800e7ca:	f000 faf1 	bl	800edb0 <lwip_ntohs>
 800e7ce:	9003      	str	r0, [sp, #12]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 800e7d0:	8868      	ldrh	r0, [r5, #2]
 800e7d2:	f000 faed 	bl	800edb0 <lwip_ntohs>
 800e7d6:	782b      	ldrb	r3, [r5, #0]
 800e7d8:	9004      	str	r0, [sp, #16]

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
 800e7da:	4630      	mov	r0, r6
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 800e7dc:	9305      	str	r3, [sp, #20]

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
 800e7de:	f7fb f83f 	bl	8009860 <pbuf_clen>
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 800e7e2:	f8b8 3000 	ldrh.w	r3, [r8]
 800e7e6:	4403      	add	r3, r0
 800e7e8:	2b0a      	cmp	r3, #10

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
 800e7ea:	4681      	mov	r9, r0
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 800e7ec:	f300 80de 	bgt.w	800e9ac <ip_reass+0x20c>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 800e7f0:	f8df a3ac 	ldr.w	sl, [pc, #940]	; 800eba0 <ip_reass+0x400>
 800e7f4:	f8da 4000 	ldr.w	r4, [sl]
 800e7f8:	b394      	cbz	r4, 800e860 <ip_reass+0xc0>
 800e7fa:	68e8      	ldr	r0, [r5, #12]
 800e7fc:	f04f 0e00 	mov.w	lr, #0
 800e800:	e003      	b.n	800e80a <ip_reass+0x6a>
 800e802:	6823      	ldr	r3, [r4, #0]
 800e804:	46a6      	mov	lr, r4
 800e806:	b35b      	cbz	r3, 800e860 <ip_reass+0xc0>
 800e808:	461c      	mov	r4, r3
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 800e80a:	6963      	ldr	r3, [r4, #20]
 800e80c:	4283      	cmp	r3, r0
 800e80e:	d1f8      	bne.n	800e802 <ip_reass+0x62>
 800e810:	692b      	ldr	r3, [r5, #16]
 800e812:	69a2      	ldr	r2, [r4, #24]
 800e814:	429a      	cmp	r2, r3
 800e816:	d1f4      	bne.n	800e802 <ip_reass+0x62>
 800e818:	89a2      	ldrh	r2, [r4, #12]
 800e81a:	88ab      	ldrh	r3, [r5, #4]
 800e81c:	429a      	cmp	r2, r3
 800e81e:	d1f0      	bne.n	800e802 <ip_reass+0x62>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
 800e820:	f8bb 3046 	ldrh.w	r3, [fp, #70]	; 0x46
 800e824:	3301      	adds	r3, #1
 800e826:	f8ab 3046 	strh.w	r3, [fp, #70]	; 0x46
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 800e82a:	88e8      	ldrh	r0, [r5, #6]
 800e82c:	4627      	mov	r7, r4
 800e82e:	4674      	mov	r4, lr
 800e830:	f000 fabe 	bl	800edb0 <lwip_ntohs>
 800e834:	f3c0 000c 	ubfx	r0, r0, #0, #13
 800e838:	bb88      	cbnz	r0, 800e89e <ip_reass+0xfe>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 800e83a:	89f8      	ldrh	r0, [r7, #14]
 800e83c:	f000 fab8 	bl	800edb0 <lwip_ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 800e840:	f3c0 000c 	ubfx	r0, r0, #0, #13
 800e844:	b358      	cbz	r0, 800e89e <ip_reass+0xfe>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 800e846:	682a      	ldr	r2, [r5, #0]
 800e848:	f8d5 e004 	ldr.w	lr, [r5, #4]
 800e84c:	68a8      	ldr	r0, [r5, #8]
 800e84e:	68e9      	ldr	r1, [r5, #12]
 800e850:	6179      	str	r1, [r7, #20]
 800e852:	60ba      	str	r2, [r7, #8]
 800e854:	f8c7 e00c 	str.w	lr, [r7, #12]
 800e858:	6138      	str	r0, [r7, #16]
 800e85a:	692a      	ldr	r2, [r5, #16]
 800e85c:	61ba      	str	r2, [r7, #24]
 800e85e:	e01e      	b.n	800e89e <ip_reass+0xfe>
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 800e860:	2005      	movs	r0, #5
 800e862:	f7fa fb55 	bl	8008f10 <memp_malloc>
  if (ipr == NULL) {
 800e866:	4607      	mov	r7, r0
 800e868:	2800      	cmp	r0, #0
 800e86a:	f000 8138 	beq.w	800eade <ip_reass+0x33e>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
 800e86e:	2100      	movs	r1, #0
 800e870:	2220      	movs	r2, #32
 800e872:	4638      	mov	r0, r7
 800e874:	f005 faac 	bl	8013dd0 <memset>
  ipr->timer = IP_REASS_MAXAGE;
 800e878:	2103      	movs	r1, #3

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
 800e87a:	f8da 2000 	ldr.w	r2, [sl]
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  ipr->timer = IP_REASS_MAXAGE;
 800e87e:	77f9      	strb	r1, [r7, #31]

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
 800e880:	603a      	str	r2, [r7, #0]
  reassdatagrams = ipr;
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 800e882:	6829      	ldr	r1, [r5, #0]
 800e884:	f8d5 e004 	ldr.w	lr, [r5, #4]
 800e888:	68a8      	ldr	r0, [r5, #8]
 800e88a:	68eb      	ldr	r3, [r5, #12]
 800e88c:	617b      	str	r3, [r7, #20]
 800e88e:	60b9      	str	r1, [r7, #8]
 800e890:	f8c7 e00c 	str.w	lr, [r7, #12]
 800e894:	6138      	str	r0, [r7, #16]
 800e896:	6929      	ldr	r1, [r5, #16]
  memset(ipr, 0, sizeof(struct ip_reassdata));
  ipr->timer = IP_REASS_MAXAGE;

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  reassdatagrams = ipr;
 800e898:	f8ca 7000 	str.w	r7, [sl]
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 800e89c:	61b9      	str	r1, [r7, #24]
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
 800e89e:	f8b8 3000 	ldrh.w	r3, [r8]
 800e8a2:	eb09 0c03 	add.w	ip, r9, r3
 800e8a6:	f8a8 c000 	strh.w	ip, [r8]

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
 800e8aa:	88eb      	ldrh	r3, [r5, #6]
 800e8ac:	0699      	lsls	r1, r3, #26
 800e8ae:	d410      	bmi.n	800e8d2 <ip_reass+0x132>
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 800e8b0:	9b05      	ldr	r3, [sp, #20]
 800e8b2:	9a04      	ldr	r2, [sp, #16]
 800e8b4:	f003 090f 	and.w	r9, r3, #15
 800e8b8:	ebc9 3989 	rsb	r9, r9, r9, lsl #14
  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 800e8bc:	7fbb      	ldrb	r3, [r7, #30]
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 800e8be:	eb02 0b89 	add.w	fp, r2, r9, lsl #2
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    ipr->datagram_len = offset + len;
 800e8c2:	9a03      	ldr	r2, [sp, #12]
  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 800e8c4:	f043 0301 	orr.w	r3, r3, #1
    ipr->datagram_len = offset + len;
 800e8c8:	eb0b 0ac2 	add.w	sl, fp, r2, lsl #3
 800e8cc:	f8a7 a01c 	strh.w	sl, [r7, #28]
  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 800e8d0:	77bb      	strb	r3, [r7, #30]
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
 800e8d2:	f8d6 9004 	ldr.w	r9, [r6, #4]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 800e8d6:	f8b9 0002 	ldrh.w	r0, [r9, #2]
 800e8da:	f000 fa69 	bl	800edb0 <lwip_ntohs>
 800e8de:	f899 3000 	ldrb.w	r3, [r9]
 800e8e2:	f003 030f 	and.w	r3, r3, #15
 800e8e6:	ebc3 3383 	rsb	r3, r3, r3, lsl #14
 800e8ea:	eb00 0583 	add.w	r5, r0, r3, lsl #2
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 800e8ee:	f8b9 0006 	ldrh.w	r0, [r9, #6]
 800e8f2:	f000 fa5d 	bl	800edb0 <lwip_ntohs>
 800e8f6:	f3c0 000c 	ubfx	r0, r0, #0, #13
 800e8fa:	00c0      	lsls	r0, r0, #3
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 800e8fc:	b2ad      	uxth	r5, r5
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
 800e8fe:	f8d6 a004 	ldr.w	sl, [r6, #4]
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 800e902:	687a      	ldr	r2, [r7, #4]
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
  iprh->start = offset;
 800e904:	f8aa 0004 	strh.w	r0, [sl, #4]
  iprh->end = offset + len;
 800e908:	eb05 0e00 	add.w	lr, r5, r0
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
 800e90c:	2300      	movs	r3, #0
  iprh->start = offset;
  iprh->end = offset + len;
 800e90e:	fa1f fe8e 	uxth.w	lr, lr
 800e912:	f8aa e006 	strh.w	lr, [sl, #6]
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
 800e916:	f88a 3000 	strb.w	r3, [sl]
 800e91a:	f88a 3001 	strb.w	r3, [sl, #1]
 800e91e:	f88a 3002 	strb.w	r3, [sl, #2]
 800e922:	f88a 3003 	strb.w	r3, [sl, #3]
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 800e926:	2a00      	cmp	r2, #0
 800e928:	f000 80fb 	beq.w	800eb22 <ip_reass+0x382>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 800e92c:	6855      	ldr	r5, [r2, #4]
    if (iprh->start < iprh_tmp->start) {
 800e92e:	88ab      	ldrh	r3, [r5, #4]
 800e930:	4298      	cmp	r0, r3
 800e932:	f0c0 80e0 	bcc.w	800eaf6 <ip_reass+0x356>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
 800e936:	f000 80c3 	beq.w	800eac0 <ip_reass+0x320>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
 800e93a:	88eb      	ldrh	r3, [r5, #6]
 800e93c:	4283      	cmp	r3, r0
 800e93e:	f200 80bf 	bhi.w	800eac0 <ip_reass+0x320>
 800e942:	f04f 0901 	mov.w	r9, #1
 800e946:	e00f      	b.n	800e968 <ip_reass+0x1c8>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 800e948:	6853      	ldr	r3, [r2, #4]
    if (iprh->start < iprh_tmp->start) {
 800e94a:	8899      	ldrh	r1, [r3, #4]
 800e94c:	4288      	cmp	r0, r1
 800e94e:	d33b      	bcc.n	800e9c8 <ip_reass+0x228>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
 800e950:	f000 80b6 	beq.w	800eac0 <ip_reass+0x320>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
 800e954:	88da      	ldrh	r2, [r3, #6]
 800e956:	4282      	cmp	r2, r0
 800e958:	f200 80b2 	bhi.w	800eac0 <ip_reass+0x320>
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
        if (iprh_prev->end != iprh_tmp->start) {
 800e95c:	88ea      	ldrh	r2, [r5, #6]
      break;
    } else if(iprh->start == iprh_tmp->start) {
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
 800e95e:	461d      	mov	r5, r3
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
        if (iprh_prev->end != iprh_tmp->start) {
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
 800e960:	428a      	cmp	r2, r1
 800e962:	bf18      	it	ne
 800e964:	f04f 0900 	movne.w	r9, #0
        }
      }
    }
    q = iprh_tmp->next_pbuf;
 800e968:	682a      	ldr	r2, [r5, #0]
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 800e96a:	2a00      	cmp	r2, #0
 800e96c:	d1ec      	bne.n	800e948 <ip_reass+0x1a8>
  if (q == NULL) {
    if (iprh_prev != NULL) {
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 800e96e:	88eb      	ldrh	r3, [r5, #6]
 800e970:	4298      	cmp	r0, r3
 800e972:	f0c0 80c6 	bcc.w	800eb02 <ip_reass+0x362>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
      if (iprh_prev->end != iprh->start) {
 800e976:	4298      	cmp	r0, r3
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
 800e978:	602e      	str	r6, [r5, #0]
      if (iprh_prev->end != iprh->start) {
 800e97a:	d02d      	beq.n	800e9d8 <ip_reass+0x238>
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 800e97c:	7fbb      	ldrb	r3, [r7, #30]
 800e97e:	f013 0301 	ands.w	r3, r3, #1
 800e982:	f040 80a8 	bne.w	800ead6 <ip_reass+0x336>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
 800e986:	4618      	mov	r0, r3
 800e988:	e00d      	b.n	800e9a6 <ip_reass+0x206>

  fraghdr = (struct ip_hdr*)p->payload;

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
 800e98a:	f8bb 3044 	ldrh.w	r3, [fp, #68]	; 0x44
 800e98e:	3301      	adds	r3, #1
 800e990:	f8ab 3044 	strh.w	r3, [fp, #68]	; 0x44
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
 800e994:	f8bb 3036 	ldrh.w	r3, [fp, #54]	; 0x36
  pbuf_free(p);
 800e998:	4630      	mov	r0, r6
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
 800e99a:	3301      	adds	r3, #1
 800e99c:	f8ab 3036 	strh.w	r3, [fp, #54]	; 0x36
  pbuf_free(p);
 800e9a0:	f7fa fd2e 	bl	8009400 <pbuf_free>
  return NULL;
 800e9a4:	2000      	movs	r0, #0
}
 800e9a6:	b007      	add	sp, #28
 800e9a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 800e9ac:	4628      	mov	r0, r5
 800e9ae:	4649      	mov	r1, r9
 800e9b0:	f7ff fe9e 	bl	800e6f0 <ip_reass_remove_oldest_datagram>
 800e9b4:	2800      	cmp	r0, #0
 800e9b6:	f000 8098 	beq.w	800eaea <ip_reass+0x34a>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 800e9ba:	f8b8 3000 	ldrh.w	r3, [r8]
 800e9be:	444b      	add	r3, r9

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 800e9c0:	2b0a      	cmp	r3, #10
 800e9c2:	f77f af15 	ble.w	800e7f0 <ip_reass+0x50>
 800e9c6:	e090      	b.n	800eaea <ip_reass+0x34a>
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    if (iprh->start < iprh_tmp->start) {
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
 800e9c8:	f8ca 2000 	str.w	r2, [sl]
      if (iprh_prev != NULL) {
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 800e9cc:	88eb      	ldrh	r3, [r5, #6]
 800e9ce:	4283      	cmp	r3, r0
 800e9d0:	d876      	bhi.n	800eac0 <ip_reass+0x320>
 800e9d2:	458e      	cmp	lr, r1
 800e9d4:	d874      	bhi.n	800eac0 <ip_reass+0x320>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
 800e9d6:	602e      	str	r6, [r5, #0]
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 800e9d8:	7fbb      	ldrb	r3, [r7, #30]
 800e9da:	07db      	lsls	r3, r3, #31
 800e9dc:	d57b      	bpl.n	800ead6 <ip_reass+0x336>
    /* and had no wholes so far */
    if (valid) {
 800e9de:	f1b9 0f00 	cmp.w	r9, #0
 800e9e2:	d078      	beq.n	800ead6 <ip_reass+0x336>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
 800e9e4:	687b      	ldr	r3, [r7, #4]
 800e9e6:	6858      	ldr	r0, [r3, #4]
 800e9e8:	8883      	ldrh	r3, [r0, #4]
 800e9ea:	2b00      	cmp	r3, #0
 800e9ec:	d173      	bne.n	800ead6 <ip_reass+0x336>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
 800e9ee:	f8da 3000 	ldr.w	r3, [sl]
        while (q != NULL) {
 800e9f2:	2b00      	cmp	r3, #0
 800e9f4:	f000 80a3 	beq.w	800eb3e <ip_reass+0x39e>
          iprh = (struct ip_reass_helper*)q->payload;
 800e9f8:	685d      	ldr	r5, [r3, #4]
          if (iprh_prev->end != iprh->start) {
 800e9fa:	f8ba 2006 	ldrh.w	r2, [sl, #6]
 800e9fe:	88ab      	ldrh	r3, [r5, #4]
 800ea00:	429a      	cmp	r2, r3
 800ea02:	d006      	beq.n	800ea12 <ip_reass+0x272>
 800ea04:	e067      	b.n	800ead6 <ip_reass+0x336>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
 800ea06:	685b      	ldr	r3, [r3, #4]
          if (iprh_prev->end != iprh->start) {
 800ea08:	88e9      	ldrh	r1, [r5, #6]
 800ea0a:	889a      	ldrh	r2, [r3, #4]
 800ea0c:	4291      	cmp	r1, r2
 800ea0e:	d162      	bne.n	800ead6 <ip_reass+0x336>
 800ea10:	461d      	mov	r5, r3
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
 800ea12:	682b      	ldr	r3, [r5, #0]
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
 800ea14:	2b00      	cmp	r3, #0
 800ea16:	d1f6      	bne.n	800ea06 <ip_reass+0x266>
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
          LWIP_ASSERT("sanity check",
 800ea18:	42a8      	cmp	r0, r5
 800ea1a:	f000 8092 	beq.w	800eb42 <ip_reass+0x3a2>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
 800ea1e:	88ea      	ldrh	r2, [r5, #6]
 800ea20:	8bbb      	ldrh	r3, [r7, #28]
 800ea22:	429a      	cmp	r2, r3
 800ea24:	d00c      	beq.n	800ea40 <ip_reass+0x2a0>
 800ea26:	4b55      	ldr	r3, [pc, #340]	; (800eb7c <ip_reass+0x3dc>)
 800ea28:	9300      	str	r3, [sp, #0]
 800ea2a:	4955      	ldr	r1, [pc, #340]	; (800eb80 <ip_reass+0x3e0>)
 800ea2c:	4a55      	ldr	r2, [pc, #340]	; (800eb84 <ip_reass+0x3e4>)
 800ea2e:	4856      	ldr	r0, [pc, #344]	; (800eb88 <ip_reass+0x3e8>)
 800ea30:	f44f 73e1 	mov.w	r3, #450	; 0x1c2
 800ea34:	f7ff fd34 	bl	800e4a0 <chprintf.constprop.0>
 800ea38:	4852      	ldr	r0, [pc, #328]	; (800eb84 <ip_reass+0x3e4>)
 800ea3a:	f7f2 fa99 	bl	8000f70 <chSysHalt>
 800ea3e:	8bbb      	ldrh	r3, [r7, #28]
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 800ea40:	6879      	ldr	r1, [r7, #4]
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
 800ea42:	f103 0214 	add.w	r2, r3, #20
    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 800ea46:	463b      	mov	r3, r7
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
 800ea48:	83ba      	strh	r2, [r7, #28]
    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 800ea4a:	f853 2f08 	ldr.w	r2, [r3, #8]!
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 800ea4e:	684e      	ldr	r6, [r1, #4]

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 800ea50:	6858      	ldr	r0, [r3, #4]
 800ea52:	6899      	ldr	r1, [r3, #8]
 800ea54:	68dd      	ldr	r5, [r3, #12]
 800ea56:	60f5      	str	r5, [r6, #12]
 800ea58:	60b1      	str	r1, [r6, #8]
 800ea5a:	6070      	str	r0, [r6, #4]
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 800ea5c:	6835      	ldr	r5, [r6, #0]

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 800ea5e:	6032      	str	r2, [r6, #0]
 800ea60:	691a      	ldr	r2, [r3, #16]
 800ea62:	6132      	str	r2, [r6, #16]
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
 800ea64:	8bb8      	ldrh	r0, [r7, #28]
 800ea66:	f000 f99b 	bl	800eda0 <lwip_htons>
    IPH_OFFSET_SET(fraghdr, 0);
 800ea6a:	2300      	movs	r3, #0
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
 800ea6c:	8070      	strh	r0, [r6, #2]
    IPH_OFFSET_SET(fraghdr, 0);
 800ea6e:	71b3      	strb	r3, [r6, #6]
 800ea70:	71f3      	strb	r3, [r6, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
 800ea72:	72b3      	strb	r3, [r6, #10]
 800ea74:	72f3      	strb	r3, [r6, #11]
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
 800ea76:	4630      	mov	r0, r6
 800ea78:	2114      	movs	r1, #20
 800ea7a:	f7ff fa79 	bl	800df70 <inet_chksum>

    p = ipr->p;
 800ea7e:	f8d7 9004 	ldr.w	r9, [r7, #4]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    IPH_OFFSET_SET(fraghdr, 0);
    IPH_CHKSUM_SET(fraghdr, 0);
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
 800ea82:	8170      	strh	r0, [r6, #10]

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
 800ea84:	b165      	cbz	r5, 800eaa0 <ip_reass+0x300>
      iprh = (struct ip_reass_helper*)r->payload;
 800ea86:	686e      	ldr	r6, [r5, #4]

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
 800ea88:	4628      	mov	r0, r5
 800ea8a:	f06f 0113 	mvn.w	r1, #19
 800ea8e:	f7fa fc47 	bl	8009320 <pbuf_header>
      pbuf_cat(p, r);
 800ea92:	4629      	mov	r1, r5
 800ea94:	4648      	mov	r0, r9
 800ea96:	f7fa fefb 	bl	8009890 <pbuf_cat>
      r = iprh->next_pbuf;
 800ea9a:	6835      	ldr	r5, [r6, #0]
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
 800ea9c:	2d00      	cmp	r5, #0
 800ea9e:	d1f2      	bne.n	800ea86 <ip_reass+0x2e6>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
 800eaa0:	4638      	mov	r0, r7
 800eaa2:	4621      	mov	r1, r4
 800eaa4:	f7ff fd5c 	bl	800e560 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
 800eaa8:	4648      	mov	r0, r9
 800eaaa:	f7fa fed9 	bl	8009860 <pbuf_clen>
 800eaae:	f8b8 3000 	ldrh.w	r3, [r8]
 800eab2:	1a1b      	subs	r3, r3, r0

    /* Return the pbuf chain */
    return p;
 800eab4:	4648      	mov	r0, r9
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
 800eab6:	f8a8 3000 	strh.w	r3, [r8]
nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
}
 800eaba:	b007      	add	sp, #28
 800eabc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
 800eac0:	4630      	mov	r0, r6
 800eac2:	f7fa fecd 	bl	8009860 <pbuf_clen>
 800eac6:	f8b8 3000 	ldrh.w	r3, [r8]
 800eaca:	1a1b      	subs	r3, r3, r0
  pbuf_free(new_p);
 800eacc:	4630      	mov	r0, r6
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
 800eace:	f8a8 3000 	strh.w	r3, [r8]
  pbuf_free(new_p);
 800ead2:	f7fa fc95 	bl	8009400 <pbuf_free>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
 800ead6:	2000      	movs	r0, #0
nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
}
 800ead8:	b007      	add	sp, #28
 800eada:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
  if (ipr == NULL) {
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 800eade:	4628      	mov	r0, r5
 800eae0:	4649      	mov	r1, r9
 800eae2:	f7ff fe05 	bl	800e6f0 <ip_reass_remove_oldest_datagram>
 800eae6:	4581      	cmp	r9, r0
 800eae8:	dd21      	ble.n	800eb2e <ip_reass+0x38e>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    }
    if (ipr == NULL)
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
 800eaea:	f8bb 303c 	ldrh.w	r3, [fp, #60]	; 0x3c
 800eaee:	3301      	adds	r3, #1
 800eaf0:	f8ab 303c 	strh.w	r3, [fp, #60]	; 0x3c
 800eaf4:	e74e      	b.n	800e994 <ip_reass+0x1f4>
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    if (iprh->start < iprh_tmp->start) {
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
 800eaf6:	f8ca 2000 	str.w	r2, [sl]
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
 800eafa:	f04f 0901 	mov.w	r9, #1
 800eafe:	607e      	str	r6, [r7, #4]
 800eb00:	e76a      	b.n	800e9d8 <ip_reass+0x238>
  if (q == NULL) {
    if (iprh_prev != NULL) {
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 800eb02:	4b1e      	ldr	r3, [pc, #120]	; (800eb7c <ip_reass+0x3dc>)
 800eb04:	9300      	str	r3, [sp, #0]
 800eb06:	491e      	ldr	r1, [pc, #120]	; (800eb80 <ip_reass+0x3e0>)
 800eb08:	4a20      	ldr	r2, [pc, #128]	; (800eb8c <ip_reass+0x3ec>)
 800eb0a:	481f      	ldr	r0, [pc, #124]	; (800eb88 <ip_reass+0x3e8>)
 800eb0c:	f240 1393 	movw	r3, #403	; 0x193
 800eb10:	f7ff fcc6 	bl	800e4a0 <chprintf.constprop.0>
 800eb14:	481d      	ldr	r0, [pc, #116]	; (800eb8c <ip_reass+0x3ec>)
 800eb16:	f7f2 fa2b 	bl	8000f70 <chSysHalt>
 800eb1a:	88eb      	ldrh	r3, [r5, #6]
 800eb1c:	f8ba 0004 	ldrh.w	r0, [sl, #4]
 800eb20:	e729      	b.n	800e976 <ip_reass+0x1d6>
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 800eb22:	7fbb      	ldrb	r3, [r7, #30]
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
 800eb24:	607e      	str	r6, [r7, #4]
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 800eb26:	07da      	lsls	r2, r3, #31
 800eb28:	f53f af5c 	bmi.w	800e9e4 <ip_reass+0x244>
 800eb2c:	e7d3      	b.n	800ead6 <ip_reass+0x336>
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
  if (ipr == NULL) {
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 800eb2e:	2005      	movs	r0, #5
 800eb30:	f7fa f9ee 	bl	8008f10 <memp_malloc>
    }
    if (ipr == NULL)
 800eb34:	4607      	mov	r7, r0
 800eb36:	2800      	cmp	r0, #0
 800eb38:	f47f ae99 	bne.w	800e86e <ip_reass+0xce>
 800eb3c:	e7d5      	b.n	800eaea <ip_reass+0x34a>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
 800eb3e:	4655      	mov	r5, sl
 800eb40:	e76a      	b.n	800ea18 <ip_reass+0x278>
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
          LWIP_ASSERT("sanity check",
 800eb42:	4e0e      	ldr	r6, [pc, #56]	; (800eb7c <ip_reass+0x3dc>)
 800eb44:	490e      	ldr	r1, [pc, #56]	; (800eb80 <ip_reass+0x3e0>)
 800eb46:	4a12      	ldr	r2, [pc, #72]	; (800eb90 <ip_reass+0x3f0>)
 800eb48:	9600      	str	r6, [sp, #0]
 800eb4a:	f44f 73df 	mov.w	r3, #446	; 0x1be
 800eb4e:	480e      	ldr	r0, [pc, #56]	; (800eb88 <ip_reass+0x3e8>)
 800eb50:	f7ff fca6 	bl	800e4a0 <chprintf.constprop.0>
 800eb54:	480e      	ldr	r0, [pc, #56]	; (800eb90 <ip_reass+0x3f0>)
 800eb56:	f7f2 fa0b 	bl	8000f70 <chSysHalt>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
 800eb5a:	682b      	ldr	r3, [r5, #0]
 800eb5c:	2b00      	cmp	r3, #0
 800eb5e:	f43f af5e 	beq.w	800ea1e <ip_reass+0x27e>
 800eb62:	9600      	str	r6, [sp, #0]
 800eb64:	4906      	ldr	r1, [pc, #24]	; (800eb80 <ip_reass+0x3e0>)
 800eb66:	4a0b      	ldr	r2, [pc, #44]	; (800eb94 <ip_reass+0x3f4>)
 800eb68:	4807      	ldr	r0, [pc, #28]	; (800eb88 <ip_reass+0x3e8>)
 800eb6a:	f44f 73e0 	mov.w	r3, #448	; 0x1c0
 800eb6e:	f7ff fc97 	bl	800e4a0 <chprintf.constprop.0>
 800eb72:	4808      	ldr	r0, [pc, #32]	; (800eb94 <ip_reass+0x3f4>)
 800eb74:	f7f2 f9fc 	bl	8000f70 <chSysHalt>
 800eb78:	e751      	b.n	800ea1e <ip_reass+0x27e>
 800eb7a:	bf00      	nop
 800eb7c:	080185e0 	.word	0x080185e0
 800eb80:	08016fe0 	.word	0x08016fe0
 800eb84:	080186ec 	.word	0x080186ec
 800eb88:	200180c8 	.word	0x200180c8
 800eb8c:	08018698 	.word	0x08018698
 800eb90:	080186b8 	.word	0x080186b8
 800eb94:	080186c8 	.word	0x080186c8
 800eb98:	2000c9fc 	.word	0x2000c9fc
 800eb9c:	2000cbbc 	.word	0x2000cbbc
 800eba0:	2000cbb8 	.word	0x2000cbb8
 800eba4:	f3af 8000 	nop.w
 800eba8:	f3af 8000 	nop.w
 800ebac:	f3af 8000 	nop.w

0800ebb0 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
 800ebb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ebb4:	b08f      	sub	sp, #60	; 0x3c

  /* Copy the IP header in it */
  iphdr = (struct ip_hdr *)rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
#else /* IP_FRAG_USES_STATIC_BUF */
  original_iphdr = (struct ip_hdr *)p->payload;
 800ebb6:	f8d0 a004 	ldr.w	sl, [r0, #4]
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
 800ebba:	910b      	str	r1, [sp, #44]	; 0x2c
 800ebbc:	4605      	mov	r5, r0
  original_iphdr = (struct ip_hdr *)p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
 800ebbe:	f8ba 0006 	ldrh.w	r0, [sl, #6]
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
 800ebc2:	8c0c      	ldrh	r4, [r1, #32]
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
 800ebc4:	920c      	str	r2, [sp, #48]	; 0x30
  original_iphdr = (struct ip_hdr *)p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
 800ebc6:	f000 f8f3 	bl	800edb0 <lwip_ntohs>
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;
 800ebca:	f400 5300 	and.w	r3, r0, #8192	; 0x2000
 800ebce:	b29b      	uxth	r3, r3

  left = p->tot_len - IP_HLEN;
 800ebd0:	f8b5 9008 	ldrh.w	r9, [r5, #8]
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;
 800ebd4:	9309      	str	r3, [sp, #36]	; 0x24
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
 800ebd6:	f3c0 030c 	ubfx	r3, r0, #0, #13
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;
 800ebda:	f1a9 0914 	sub.w	r9, r9, #20
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
 800ebde:	9305      	str	r3, [sp, #20]
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;
 800ebe0:	f1b4 0314 	subs.w	r3, r4, #20
  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;
 800ebe4:	fa1f f289 	uxth.w	r2, r9

  nfb = (mtu - IP_HLEN) / 8;
 800ebe8:	bf48      	it	mi
 800ebea:	f1a4 030d 	submi.w	r3, r4, #13
 800ebee:	f3c3 03cf 	ubfx	r3, r3, #3, #16
  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;
 800ebf2:	9203      	str	r2, [sp, #12]

  nfb = (mtu - IP_HLEN) / 8;
 800ebf4:	9308      	str	r3, [sp, #32]

  while (left) {
 800ebf6:	9b03      	ldr	r3, [sp, #12]
 800ebf8:	2b00      	cmp	r3, #0
 800ebfa:	f000 80c3 	beq.w	800ed84 <ip_frag+0x1d4>
    if (!last) {
      tmp = tmp | IP_MF;
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
 800ebfe:	9b08      	ldr	r3, [sp, #32]
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      pbuf_ref(p);
      pcr->original = p;
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 800ec00:	f8df 8198 	ldr.w	r8, [pc, #408]	; 800ed9c <ip_frag+0x1ec>
    if (!last) {
      tmp = tmp | IP_MF;
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
 800ec04:	00db      	lsls	r3, r3, #3
 800ec06:	f1a4 0213 	sub.w	r2, r4, #19
 800ec0a:	b29b      	uxth	r3, r3
 800ec0c:	920a      	str	r2, [sp, #40]	; 0x28
 800ec0e:	930d      	str	r3, [sp, #52]	; 0x34
 800ec10:	2400      	movs	r4, #0
 800ec12:	2614      	movs	r6, #20

  while (left) {
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
 800ec14:	9b05      	ldr	r3, [sp, #20]
 800ec16:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800ec18:	f3c3 030c 	ubfx	r3, r3, #0, #13
 800ec1c:	4313      	orrs	r3, r2
 800ec1e:	9306      	str	r3, [sp, #24]
    if (!last) {
 800ec20:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800ec22:	9b03      	ldr	r3, [sp, #12]
 800ec24:	4293      	cmp	r3, r2
 800ec26:	f2c0 8090 	blt.w	800ed4a <ip_frag+0x19a>
      tmp = tmp | IP_MF;
 800ec2a:	9b06      	ldr	r3, [sp, #24]
 800ec2c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800ec30:	9306      	str	r3, [sp, #24]
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
 800ec32:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ec34:	9304      	str	r3, [sp, #16]
    /* When not using a static buffer, create a chain of pbufs.
     * The first will be a PBUF_RAM holding the link and IP header.
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 800ec36:	2002      	movs	r0, #2
 800ec38:	2114      	movs	r1, #20
 800ec3a:	2200      	movs	r2, #0
 800ec3c:	f7fa fc60 	bl	8009500 <pbuf_alloc>
    if (rambuf == NULL) {
 800ec40:	4607      	mov	r7, r0
 800ec42:	2800      	cmp	r0, #0
 800ec44:	f000 809c 	beq.w	800ed80 <ip_frag+0x1d0>
      return ERR_MEM;
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
 800ec48:	896b      	ldrh	r3, [r5, #10]
 800ec4a:	2b13      	cmp	r3, #19
 800ec4c:	f240 808b 	bls.w	800ed66 <ip_frag+0x1b6>
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
 800ec50:	687b      	ldr	r3, [r7, #4]
 800ec52:	f8da 2000 	ldr.w	r2, [sl]
 800ec56:	f8da 1008 	ldr.w	r1, [sl, #8]
 800ec5a:	f8da 0004 	ldr.w	r0, [sl, #4]
 800ec5e:	f8da e00c 	ldr.w	lr, [sl, #12]
 800ec62:	f8c3 e00c 	str.w	lr, [r3, #12]
 800ec66:	601a      	str	r2, [r3, #0]
 800ec68:	6058      	str	r0, [r3, #4]
 800ec6a:	6099      	str	r1, [r3, #8]
 800ec6c:	f8da 2010 	ldr.w	r2, [sl, #16]
 800ec70:	611a      	str	r2, [r3, #16]
    iphdr = (struct ip_hdr *)rambuf->payload;

    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
 800ec72:	686a      	ldr	r2, [r5, #4]
    p->len -= poff;
 800ec74:	896b      	ldrh	r3, [r5, #10]
      return ERR_MEM;
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
    iphdr = (struct ip_hdr *)rambuf->payload;
 800ec76:	6879      	ldr	r1, [r7, #4]
 800ec78:	9107      	str	r1, [sp, #28]

    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
    p->len -= poff;
 800ec7a:	1b9b      	subs	r3, r3, r6
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
    iphdr = (struct ip_hdr *)rambuf->payload;

    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
 800ec7c:	4416      	add	r6, r2
    p->len -= poff;

    left_to_copy = cop;
    while (left_to_copy) {
 800ec7e:	9a04      	ldr	r2, [sp, #16]
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
    iphdr = (struct ip_hdr *)rambuf->payload;

    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
 800ec80:	606e      	str	r6, [r5, #4]
    p->len -= poff;
 800ec82:	b29b      	uxth	r3, r3
 800ec84:	816b      	strh	r3, [r5, #10]

    left_to_copy = cop;
    while (left_to_copy) {
 800ec86:	b362      	cbz	r2, 800ece2 <ip_frag+0x132>
 800ec88:	4616      	mov	r6, r2
 800ec8a:	461c      	mov	r4, r3
 800ec8c:	e002      	b.n	800ec94 <ip_frag+0xe4>
      struct pbuf_custom_ref *pcr;
      newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
      /* Is this pbuf already empty? */
      if (!newpbuflen) {
        p = p->next;
 800ec8e:	682d      	ldr	r5, [r5, #0]
    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
    p->len -= poff;

    left_to_copy = cop;
    while (left_to_copy) {
 800ec90:	b33e      	cbz	r6, 800ece2 <ip_frag+0x132>
 800ec92:	896c      	ldrh	r4, [r5, #10]
      struct pbuf_custom_ref *pcr;
      newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
 800ec94:	42b4      	cmp	r4, r6
 800ec96:	bf28      	it	cs
 800ec98:	4634      	movcs	r4, r6
 800ec9a:	b2a4      	uxth	r4, r4
      /* Is this pbuf already empty? */
      if (!newpbuflen) {
 800ec9c:	2c00      	cmp	r4, #0
 800ec9e:	d0f6      	beq.n	800ec8e <ip_frag+0xde>
#if !LWIP_NETIF_TX_SINGLE_PBUF
/** Allocate a new struct pbuf_custom_ref */
static struct pbuf_custom_ref*
ip_frag_alloc_pbuf_custom_ref(void)
{
  return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
 800eca0:	2006      	movs	r0, #6
 800eca2:	f7fa f935 	bl	8008f10 <memp_malloc>
      if (pcr == NULL) {
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
 800eca6:	4621      	mov	r1, r4
      if (!newpbuflen) {
        p = p->next;
        continue;
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
      if (pcr == NULL) {
 800eca8:	4681      	mov	r9, r0
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
 800ecaa:	2202      	movs	r2, #2
 800ecac:	4603      	mov	r3, r0
      if (!newpbuflen) {
        p = p->next;
        continue;
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
      if (pcr == NULL) {
 800ecae:	2800      	cmp	r0, #0
 800ecb0:	d051      	beq.n	800ed56 <ip_frag+0x1a6>
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
 800ecb2:	6868      	ldr	r0, [r5, #4]
 800ecb4:	e88d 0011 	stmia.w	sp, {r0, r4}
 800ecb8:	2003      	movs	r0, #3
 800ecba:	f7fa fae9 	bl	8009290 <pbuf_alloced_custom>
      if (newpbuf == NULL) {
 800ecbe:	4683      	mov	fp, r0
 800ecc0:	2800      	cmp	r0, #0
 800ecc2:	d045      	beq.n	800ed50 <ip_frag+0x1a0>
        ip_frag_free_pbuf_custom_ref(pcr);
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      pbuf_ref(p);
 800ecc4:	4628      	mov	r0, r5

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
      left_to_copy -= newpbuflen;
 800ecc6:	1b36      	subs	r6, r6, r4
      if (newpbuf == NULL) {
        ip_frag_free_pbuf_custom_ref(pcr);
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      pbuf_ref(p);
 800ecc8:	f7fa fdda 	bl	8009880 <pbuf_ref>

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
      left_to_copy -= newpbuflen;
 800eccc:	b2b6      	uxth	r6, r6
        ip_frag_free_pbuf_custom_ref(pcr);
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      pbuf_ref(p);
      pcr->original = p;
 800ecce:	f8c9 5014 	str.w	r5, [r9, #20]
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 800ecd2:	f8c9 8010 	str.w	r8, [r9, #16]

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
 800ecd6:	4659      	mov	r1, fp
 800ecd8:	4638      	mov	r0, r7
 800ecda:	f7fa fdd9 	bl	8009890 <pbuf_cat>
      left_to_copy -= newpbuflen;
      if (left_to_copy) {
 800ecde:	2e00      	cmp	r6, #0
 800ece0:	d131      	bne.n	800ed46 <ip_frag+0x196>
    poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
 800ece2:	9806      	ldr	r0, [sp, #24]
 800ece4:	f000 f85c 	bl	800eda0 <lwip_htons>
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 800ece8:	9b04      	ldr	r3, [sp, #16]
    poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
 800ecea:	9e07      	ldr	r6, [sp, #28]
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 800ecec:	3314      	adds	r3, #20
    poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
 800ecee:	80f0      	strh	r0, [r6, #6]
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 800ecf0:	b298      	uxth	r0, r3
 800ecf2:	f000 f855 	bl	800eda0 <lwip_htons>
    IPH_CHKSUM_SET(iphdr, 0);
 800ecf6:	2300      	movs	r3, #0
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 800ecf8:	8070      	strh	r0, [r6, #2]
    IPH_CHKSUM_SET(iphdr, 0);
 800ecfa:	72b3      	strb	r3, [r6, #10]
 800ecfc:	72f3      	strb	r3, [r6, #11]
 800ecfe:	4630      	mov	r0, r6
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 800ed00:	2114      	movs	r1, #20
 800ed02:	f7ff f935 	bl	800df70 <inet_chksum>
 800ed06:	46b1      	mov	r9, r6
    }
#else /* IP_FRAG_USES_STATIC_BUF */
    /* No need for separate header pbuf - we allowed room for it in rambuf
     * when allocated.
     */
    netif->output(netif, rambuf, dest);
 800ed08:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800ed0a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800ed0c:	6973      	ldr	r3, [r6, #20]

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    IPH_CHKSUM_SET(iphdr, 0);
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 800ed0e:	f8a9 000a 	strh.w	r0, [r9, #10]
    }
#else /* IP_FRAG_USES_STATIC_BUF */
    /* No need for separate header pbuf - we allowed room for it in rambuf
     * when allocated.
     */
    netif->output(netif, rambuf, dest);
 800ed12:	4639      	mov	r1, r7
 800ed14:	4630      	mov	r0, r6
 800ed16:	4798      	blx	r3
    IPFRAG_STATS_INC(ip_frag.xmit);
 800ed18:	4a1b      	ldr	r2, [pc, #108]	; (800ed88 <ip_frag+0x1d8>)
 800ed1a:	8e13      	ldrh	r3, [r2, #48]	; 0x30
     * recreate it next time round the loop. If we're lucky the hardware
     * will have already sent the packet, the free will really free, and
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
 800ed1c:	4638      	mov	r0, r7
#else /* IP_FRAG_USES_STATIC_BUF */
    /* No need for separate header pbuf - we allowed room for it in rambuf
     * when allocated.
     */
    netif->output(netif, rambuf, dest);
    IPFRAG_STATS_INC(ip_frag.xmit);
 800ed1e:	3301      	adds	r3, #1
 800ed20:	8613      	strh	r3, [r2, #48]	; 0x30
     * recreate it next time round the loop. If we're lucky the hardware
     * will have already sent the packet, the free will really free, and
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
 800ed22:	f7fa fb6d 	bl	8009400 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
 800ed26:	9a03      	ldr	r2, [sp, #12]
 800ed28:	9b04      	ldr	r3, [sp, #16]
    ofo += nfb;
 800ed2a:	9908      	ldr	r1, [sp, #32]
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
 800ed2c:	ebc3 0902 	rsb	r9, r3, r2
 800ed30:	fa1f f389 	uxth.w	r3, r9
 800ed34:	461a      	mov	r2, r3
 800ed36:	9303      	str	r3, [sp, #12]
    ofo += nfb;
 800ed38:	9b05      	ldr	r3, [sp, #20]
 800ed3a:	440b      	add	r3, r1
 800ed3c:	b29b      	uxth	r3, r3
 800ed3e:	9305      	str	r3, [sp, #20]

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
 800ed40:	b302      	cbz	r2, 800ed84 <ip_frag+0x1d4>
      left_to_copy -= newpbuflen;
      if (left_to_copy) {
        p = p->next;
      }
    }
    poff = newpbuflen;
 800ed42:	4626      	mov	r6, r4
 800ed44:	e766      	b.n	800ec14 <ip_frag+0x64>
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
      left_to_copy -= newpbuflen;
      if (left_to_copy) {
        p = p->next;
 800ed46:	682d      	ldr	r5, [r5, #0]
 800ed48:	e7a3      	b.n	800ec92 <ip_frag+0xe2>
 800ed4a:	9b03      	ldr	r3, [sp, #12]
 800ed4c:	9304      	str	r3, [sp, #16]
 800ed4e:	e772      	b.n	800ec36 <ip_frag+0x86>
        return ERR_MEM;
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
      if (newpbuf == NULL) {
        ip_frag_free_pbuf_custom_ref(pcr);
 800ed50:	4648      	mov	r0, r9
 800ed52:	f7ff fbbd 	bl	800e4d0 <ip_frag_free_pbuf_custom_ref>
        pbuf_free(rambuf);
 800ed56:	4638      	mov	r0, r7
 800ed58:	f7fa fb52 	bl	8009400 <pbuf_free>
        return ERR_MEM;
 800ed5c:	20ff      	movs	r0, #255	; 0xff
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
 800ed5e:	b240      	sxtb	r0, r0
 800ed60:	b00f      	add	sp, #60	; 0x3c
 800ed62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    if (rambuf == NULL) {
      return ERR_MEM;
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
 800ed66:	4b09      	ldr	r3, [pc, #36]	; (800ed8c <ip_frag+0x1dc>)
 800ed68:	9300      	str	r3, [sp, #0]
 800ed6a:	4909      	ldr	r1, [pc, #36]	; (800ed90 <ip_frag+0x1e0>)
 800ed6c:	4a09      	ldr	r2, [pc, #36]	; (800ed94 <ip_frag+0x1e4>)
 800ed6e:	480a      	ldr	r0, [pc, #40]	; (800ed98 <ip_frag+0x1e8>)
 800ed70:	f44f 733f 	mov.w	r3, #764	; 0x2fc
 800ed74:	f7ff fb94 	bl	800e4a0 <chprintf.constprop.0>
 800ed78:	4806      	ldr	r0, [pc, #24]	; (800ed94 <ip_frag+0x1e4>)
 800ed7a:	f7f2 f8f9 	bl	8000f70 <chSysHalt>
 800ed7e:	e767      	b.n	800ec50 <ip_frag+0xa0>
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    if (rambuf == NULL) {
      return ERR_MEM;
 800ed80:	20ff      	movs	r0, #255	; 0xff
 800ed82:	e7ec      	b.n	800ed5e <ip_frag+0x1ae>
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
 800ed84:	2000      	movs	r0, #0
 800ed86:	e7ea      	b.n	800ed5e <ip_frag+0x1ae>
 800ed88:	2000c9fc 	.word	0x2000c9fc
 800ed8c:	080185e0 	.word	0x080185e0
 800ed90:	08016fe0 	.word	0x08016fe0
 800ed94:	0801871c 	.word	0x0801871c
 800ed98:	200180c8 	.word	0x200180c8
 800ed9c:	0800e511 	.word	0x0800e511

0800eda0 <lwip_htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
 800eda0:	ba40      	rev16	r0, r0
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
}
 800eda2:	b280      	uxth	r0, r0
 800eda4:	4770      	bx	lr
 800eda6:	bf00      	nop
 800eda8:	f3af 8000 	nop.w
 800edac:	f3af 8000 	nop.w

0800edb0 <lwip_ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
lwip_ntohs(u16_t n)
{
 800edb0:	ba40      	rev16	r0, r0
  return lwip_htons(n);
}
 800edb2:	b280      	uxth	r0, r0
 800edb4:	4770      	bx	lr
 800edb6:	bf00      	nop
 800edb8:	f3af 8000 	nop.w
 800edbc:	f3af 8000 	nop.w

0800edc0 <lwip_htonl>:
{
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
 800edc0:	ba00      	rev	r0, r0
 800edc2:	4770      	bx	lr
 800edc4:	f3af 8000 	nop.w
 800edc8:	f3af 8000 	nop.w
 800edcc:	f3af 8000 	nop.w

0800edd0 <lwip_ntohl>:
 */
u32_t
lwip_ntohl(u32_t n)
{
  return lwip_htonl(n);
}
 800edd0:	ba00      	rev	r0, r0
 800edd2:	4770      	bx	lr
 800edd4:	f3af 8000 	nop.w
 800edd8:	f3af 8000 	nop.w
 800eddc:	f3af 8000 	nop.w

0800ede0 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 800ede0:	b40e      	push	{r1, r2, r3}
 800ede2:	b500      	push	{lr}
 800ede4:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800ede6:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 800ede8:	461a      	mov	r2, r3
 800edea:	4905      	ldr	r1, [pc, #20]	; (800ee00 <chprintf.constprop.0+0x20>)
 800edec:	4805      	ldr	r0, [pc, #20]	; (800ee04 <chprintf.constprop.0+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800edee:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800edf0:	f001 ff86 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 800edf4:	b002      	add	sp, #8
 800edf6:	f85d eb04 	ldr.w	lr, [sp], #4
 800edfa:	b003      	add	sp, #12
 800edfc:	4770      	bx	lr
 800edfe:	bf00      	nop
 800ee00:	08016fe0 	.word	0x08016fe0
 800ee04:	200180c8 	.word	0x200180c8
 800ee08:	f3af 8000 	nop.w
 800ee0c:	f3af 8000 	nop.w

0800ee10 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 800ee10:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ee12:	4604      	mov	r4, r0
 800ee14:	b083      	sub	sp, #12
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 800ee16:	200b      	movs	r0, #11
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 800ee18:	460d      	mov	r5, r1
 800ee1a:	4617      	mov	r7, r2
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 800ee1c:	f7fa f878 	bl	8008f10 <memp_malloc>
  if (timeout == NULL) {
 800ee20:	b330      	cbz	r0, 800ee70 <sys_timeout+0x60>
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 800ee22:	4e1b      	ldr	r6, [pc, #108]	; (800ee90 <sys_timeout+0x80>)
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
  }
  timeout->next = NULL;
  timeout->h = handler;
 800ee24:	6085      	str	r5, [r0, #8]
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 800ee26:	6835      	ldr	r5, [r6, #0]
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
  }
  timeout->next = NULL;
  timeout->h = handler;
  timeout->arg = arg;
 800ee28:	60c7      	str	r7, [r0, #12]
  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
  }
  timeout->next = NULL;
 800ee2a:	2300      	movs	r3, #0
 800ee2c:	e880 0018 	stmia.w	r0, {r3, r4}
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 800ee30:	b1e5      	cbz	r5, 800ee6c <sys_timeout+0x5c>
    next_timeout = timeout;
    return;
  }

  if (next_timeout->time > msecs) {
 800ee32:	6869      	ldr	r1, [r5, #4]
 800ee34:	428c      	cmp	r4, r1
 800ee36:	d30e      	bcc.n	800ee56 <sys_timeout+0x46>
 800ee38:	4623      	mov	r3, r4
 800ee3a:	e003      	b.n	800ee44 <sys_timeout+0x34>
    timeout->next = next_timeout;
    next_timeout = timeout;
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
      timeout->time -= t->time;
      if (t->next == NULL || t->next->time > timeout->time) {
 800ee3c:	6851      	ldr	r1, [r2, #4]
 800ee3e:	428b      	cmp	r3, r1
 800ee40:	d30f      	bcc.n	800ee62 <sys_timeout+0x52>
 800ee42:	4615      	mov	r5, r2
 800ee44:	682a      	ldr	r2, [r5, #0]
    next_timeout->time -= msecs;
    timeout->next = next_timeout;
    next_timeout = timeout;
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
      timeout->time -= t->time;
 800ee46:	1a5b      	subs	r3, r3, r1
 800ee48:	6043      	str	r3, [r0, #4]
      if (t->next == NULL || t->next->time > timeout->time) {
 800ee4a:	2a00      	cmp	r2, #0
 800ee4c:	d1f6      	bne.n	800ee3c <sys_timeout+0x2c>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
        }
        timeout->next = t->next;
 800ee4e:	6002      	str	r2, [r0, #0]
        t->next = timeout;
 800ee50:	6028      	str	r0, [r5, #0]
        break;
      }
    }
  }
}
 800ee52:	b003      	add	sp, #12
 800ee54:	bdf0      	pop	{r4, r5, r6, r7, pc}
    next_timeout = timeout;
    return;
  }

  if (next_timeout->time > msecs) {
    next_timeout->time -= msecs;
 800ee56:	1b0b      	subs	r3, r1, r4
 800ee58:	606b      	str	r3, [r5, #4]
    timeout->next = next_timeout;
    next_timeout = timeout;
 800ee5a:	6030      	str	r0, [r6, #0]
    return;
  }

  if (next_timeout->time > msecs) {
    next_timeout->time -= msecs;
    timeout->next = next_timeout;
 800ee5c:	6005      	str	r5, [r0, #0]
        t->next = timeout;
        break;
      }
    }
  }
}
 800ee5e:	b003      	add	sp, #12
 800ee60:	bdf0      	pop	{r4, r5, r6, r7, pc}
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
      timeout->time -= t->time;
      if (t->next == NULL || t->next->time > timeout->time) {
        if (t->next != NULL) {
          t->next->time -= timeout->time;
 800ee62:	1acb      	subs	r3, r1, r3
 800ee64:	6053      	str	r3, [r2, #4]
        }
        timeout->next = t->next;
 800ee66:	6002      	str	r2, [r0, #0]
        t->next = timeout;
 800ee68:	6028      	str	r0, [r5, #0]
 800ee6a:	e7f2      	b.n	800ee52 <sys_timeout+0x42>
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
    next_timeout = timeout;
 800ee6c:	6030      	str	r0, [r6, #0]
    return;
 800ee6e:	e7f6      	b.n	800ee5e <sys_timeout+0x4e>
{
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
 800ee70:	4b08      	ldr	r3, [pc, #32]	; (800ee94 <sys_timeout+0x84>)
 800ee72:	9300      	str	r3, [sp, #0]
 800ee74:	4908      	ldr	r1, [pc, #32]	; (800ee98 <sys_timeout+0x88>)
 800ee76:	4a09      	ldr	r2, [pc, #36]	; (800ee9c <sys_timeout+0x8c>)
 800ee78:	4809      	ldr	r0, [pc, #36]	; (800eea0 <sys_timeout+0x90>)
 800ee7a:	f240 1311 	movw	r3, #273	; 0x111
 800ee7e:	f7ff ffaf 	bl	800ede0 <chprintf.constprop.0>
 800ee82:	4806      	ldr	r0, [pc, #24]	; (800ee9c <sys_timeout+0x8c>)
        t->next = timeout;
        break;
      }
    }
  }
}
 800ee84:	b003      	add	sp, #12
 800ee86:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 800ee8a:	f7f2 b871 	b.w	8000f70 <chSysHalt>
 800ee8e:	bf00      	nop
 800ee90:	2000cbc4 	.word	0x2000cbc4
 800ee94:	08018780 	.word	0x08018780
 800ee98:	08016fe0 	.word	0x08016fe0
 800ee9c:	08018740 	.word	0x08018740
 800eea0:	200180c8 	.word	0x200180c8
 800eea4:	f3af 8000 	nop.w
 800eea8:	f3af 8000 	nop.w
 800eeac:	f3af 8000 	nop.w

0800eeb0 <tcp_timer_needed>:
 */
void
tcp_timer_needed(void)
{
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 800eeb0:	4b08      	ldr	r3, [pc, #32]	; (800eed4 <tcp_timer_needed+0x24>)
 800eeb2:	681a      	ldr	r2, [r3, #0]
 800eeb4:	b96a      	cbnz	r2, 800eed2 <tcp_timer_needed+0x22>
 800eeb6:	4a08      	ldr	r2, [pc, #32]	; (800eed8 <tcp_timer_needed+0x28>)
 800eeb8:	6812      	ldr	r2, [r2, #0]
 800eeba:	b132      	cbz	r2, 800eeca <tcp_timer_needed+0x1a>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
 800eebc:	2201      	movs	r2, #1
 800eebe:	601a      	str	r2, [r3, #0]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 800eec0:	20fa      	movs	r0, #250	; 0xfa
 800eec2:	4906      	ldr	r1, [pc, #24]	; (800eedc <tcp_timer_needed+0x2c>)
 800eec4:	2200      	movs	r2, #0
 800eec6:	f7ff bfa3 	b.w	800ee10 <sys_timeout>
 */
void
tcp_timer_needed(void)
{
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 800eeca:	4a05      	ldr	r2, [pc, #20]	; (800eee0 <tcp_timer_needed+0x30>)
 800eecc:	6812      	ldr	r2, [r2, #0]
 800eece:	2a00      	cmp	r2, #0
 800eed0:	d1f4      	bne.n	800eebc <tcp_timer_needed+0xc>
 800eed2:	4770      	bx	lr
 800eed4:	2000cbc0 	.word	0x2000cbc0
 800eed8:	2000cb60 	.word	0x2000cb60
 800eedc:	0800eef1 	.word	0x0800eef1
 800eee0:	2000cb50 	.word	0x2000cb50
 800eee4:	f3af 8000 	nop.w
 800eee8:	f3af 8000 	nop.w
 800eeec:	f3af 8000 	nop.w

0800eef0 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
 800eef0:	b508      	push	{r3, lr}
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
 800eef2:	f7fb fdf5 	bl	800aae0 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 800eef6:	4b08      	ldr	r3, [pc, #32]	; (800ef18 <tcpip_tcp_timer+0x28>)
 800eef8:	681b      	ldr	r3, [r3, #0]
 800eefa:	b133      	cbz	r3, 800ef0a <tcpip_tcp_timer+0x1a>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 800eefc:	20fa      	movs	r0, #250	; 0xfa
 800eefe:	4907      	ldr	r1, [pc, #28]	; (800ef1c <tcpip_tcp_timer+0x2c>)
 800ef00:	2200      	movs	r2, #0
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  }
}
 800ef02:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  /* call TCP timer handler */
  tcp_tmr();
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 800ef06:	f7ff bf83 	b.w	800ee10 <sys_timeout>
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 800ef0a:	4b05      	ldr	r3, [pc, #20]	; (800ef20 <tcpip_tcp_timer+0x30>)
 800ef0c:	681b      	ldr	r3, [r3, #0]
 800ef0e:	2b00      	cmp	r3, #0
 800ef10:	d1f4      	bne.n	800eefc <tcpip_tcp_timer+0xc>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
 800ef12:	4a04      	ldr	r2, [pc, #16]	; (800ef24 <tcpip_tcp_timer+0x34>)
 800ef14:	6013      	str	r3, [r2, #0]
 800ef16:	bd08      	pop	{r3, pc}
 800ef18:	2000cb60 	.word	0x2000cb60
 800ef1c:	0800eef1 	.word	0x0800eef1
 800ef20:	2000cb50 	.word	0x2000cb50
 800ef24:	2000cbc0 	.word	0x2000cbc0
 800ef28:	f3af 8000 	nop.w
 800ef2c:	f3af 8000 	nop.w

0800ef30 <sys_timeouts_init>:
}
#endif /* LWIP_DNS */

/** Initialize this module */
void sys_timeouts_init(void)
{
 800ef30:	b508      	push	{r3, lr}
#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
 800ef32:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800ef36:	4906      	ldr	r1, [pc, #24]	; (800ef50 <sys_timeouts_init+0x20>)
 800ef38:	2200      	movs	r2, #0
 800ef3a:	f7ff ff69 	bl	800ee10 <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 800ef3e:	f241 3088 	movw	r0, #5000	; 0x1388
 800ef42:	4904      	ldr	r1, [pc, #16]	; (800ef54 <sys_timeouts_init+0x24>)
 800ef44:	2200      	movs	r2, #0

#if NO_SYS
  /* Initialise timestamp for sys_check_timeouts */
  timeouts_last_time = sys_now();
#endif
}
 800ef46:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 800ef4a:	f7ff bf61 	b.w	800ee10 <sys_timeout>
 800ef4e:	bf00      	nop
 800ef50:	0800ef81 	.word	0x0800ef81
 800ef54:	0800ef61 	.word	0x0800ef61
 800ef58:	f3af 8000 	nop.w
 800ef5c:	f3af 8000 	nop.w

0800ef60 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
 800ef60:	b508      	push	{r3, lr}
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
 800ef62:	f7f9 f84d 	bl	8008000 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 800ef66:	f241 3088 	movw	r0, #5000	; 0x1388
 800ef6a:	4903      	ldr	r1, [pc, #12]	; (800ef78 <arp_timer+0x18>)
 800ef6c:	2200      	movs	r2, #0
}
 800ef6e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
arp_timer(void *arg)
{
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 800ef72:	f7ff bf4d 	b.w	800ee10 <sys_timeout>
 800ef76:	bf00      	nop
 800ef78:	0800ef61 	.word	0x0800ef61
 800ef7c:	f3af 8000 	nop.w

0800ef80 <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
 800ef80:	b508      	push	{r3, lr}
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
 800ef82:	f7ff fbf5 	bl	800e770 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
 800ef86:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800ef8a:	4903      	ldr	r1, [pc, #12]	; (800ef98 <ip_reass_timer+0x18>)
 800ef8c:	2200      	movs	r2, #0
}
 800ef8e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
ip_reass_timer(void *arg)
{
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
 800ef92:	f7ff bf3d 	b.w	800ee10 <sys_timeout>
 800ef96:	bf00      	nop
 800ef98:	0800ef81 	.word	0x0800ef81
 800ef9c:	f3af 8000 	nop.w

0800efa0 <sys_untimeout>:
 * @param handler callback function that would be called by the timeout
 * @param arg callback argument that would be passed to handler
*/
void
sys_untimeout(sys_timeout_handler handler, void *arg)
{
 800efa0:	b430      	push	{r4, r5}
  struct sys_timeo *prev_t, *t;

  if (next_timeout == NULL) {
 800efa2:	4d10      	ldr	r5, [pc, #64]	; (800efe4 <sys_untimeout+0x44>)
 800efa4:	682b      	ldr	r3, [r5, #0]
 800efa6:	b1cb      	cbz	r3, 800efdc <sys_untimeout+0x3c>
 800efa8:	2400      	movs	r4, #0
 800efaa:	e003      	b.n	800efb4 <sys_untimeout+0x14>
    return;
  }

  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
 800efac:	681a      	ldr	r2, [r3, #0]
 800efae:	461c      	mov	r4, r3
 800efb0:	b1a2      	cbz	r2, 800efdc <sys_untimeout+0x3c>
 800efb2:	4613      	mov	r3, r2
    if ((t->h == handler) && (t->arg == arg)) {
 800efb4:	689a      	ldr	r2, [r3, #8]
 800efb6:	4282      	cmp	r2, r0
 800efb8:	d1f8      	bne.n	800efac <sys_untimeout+0xc>
 800efba:	68da      	ldr	r2, [r3, #12]
 800efbc:	428a      	cmp	r2, r1
 800efbe:	d1f5      	bne.n	800efac <sys_untimeout+0xc>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL) {
        next_timeout = t->next;
 800efc0:	681a      	ldr	r2, [r3, #0]

  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    if ((t->h == handler) && (t->arg == arg)) {
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL) {
 800efc2:	b16c      	cbz	r4, 800efe0 <sys_untimeout+0x40>
        next_timeout = t->next;
      } else {
        prev_t->next = t->next;
 800efc4:	6022      	str	r2, [r4, #0]
 800efc6:	681a      	ldr	r2, [r3, #0]
      }
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL) {
 800efc8:	b11a      	cbz	r2, 800efd2 <sys_untimeout+0x32>
        t->next->time += t->time;
 800efca:	6850      	ldr	r0, [r2, #4]
 800efcc:	6859      	ldr	r1, [r3, #4]
 800efce:	4401      	add	r1, r0
 800efd0:	6051      	str	r1, [r2, #4]
      }
      memp_free(MEMP_SYS_TIMEOUT, t);
 800efd2:	4619      	mov	r1, r3
 800efd4:	200b      	movs	r0, #11
      return;
    }
  }
  return;
}
 800efd6:	bc30      	pop	{r4, r5}
      }
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL) {
        t->next->time += t->time;
      }
      memp_free(MEMP_SYS_TIMEOUT, t);
 800efd8:	f7f9 bff2 	b.w	8008fc0 <memp_free>
      return;
    }
  }
  return;
}
 800efdc:	bc30      	pop	{r4, r5}
 800efde:	4770      	bx	lr
  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    if ((t->h == handler) && (t->arg == arg)) {
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL) {
        next_timeout = t->next;
 800efe0:	602a      	str	r2, [r5, #0]
 800efe2:	e7f1      	b.n	800efc8 <sys_untimeout+0x28>
 800efe4:	2000cbc4 	.word	0x2000cbc4
 800efe8:	f3af 8000 	nop.w
 800efec:	f3af 8000 	nop.w

0800eff0 <sys_timeouts_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
{
 800eff0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800eff4:	4c18      	ldr	r4, [pc, #96]	; (800f058 <sys_timeouts_mbox_fetch+0x68>)
 800eff6:	4607      	mov	r7, r0
 800eff8:	460e      	mov	r6, r1
  struct sys_timeo *tmptimeout;
  sys_timeout_handler handler;
  void *arg;

 again:
  if (!next_timeout) {
 800effa:	46a0      	mov	r8, r4
 800effc:	e009      	b.n	800f012 <sys_timeouts_mbox_fetch+0x22>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = next_timeout;
      next_timeout = tmptimeout->next;
      handler = tmptimeout->h;
 800effe:	689d      	ldr	r5, [r3, #8]
    if (time_needed == SYS_ARCH_TIMEOUT) {
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = next_timeout;
      next_timeout = tmptimeout->next;
 800f000:	681a      	ldr	r2, [r3, #0]
 800f002:	6022      	str	r2, [r4, #0]
      if (handler != NULL) {
        LWIP_DEBUGF(TIMERS_DEBUG, ("stmf calling h=%s arg=%p\n",
          tmptimeout->handler_name, arg));
      }
#endif /* LWIP_DEBUG_TIMERNAMES */
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 800f004:	200b      	movs	r0, #11
 800f006:	4619      	mov	r1, r3
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = next_timeout;
      next_timeout = tmptimeout->next;
      handler = tmptimeout->h;
      arg = tmptimeout->arg;
 800f008:	f8d3 900c 	ldr.w	r9, [r3, #12]
      if (handler != NULL) {
        LWIP_DEBUGF(TIMERS_DEBUG, ("stmf calling h=%s arg=%p\n",
          tmptimeout->handler_name, arg));
      }
#endif /* LWIP_DEBUG_TIMERNAMES */
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 800f00c:	f7f9 ffd8 	bl	8008fc0 <memp_free>
      if (handler != NULL) {
 800f010:	b9f5      	cbnz	r5, 800f050 <sys_timeouts_mbox_fetch+0x60>
  struct sys_timeo *tmptimeout;
  sys_timeout_handler handler;
  void *arg;

 again:
  if (!next_timeout) {
 800f012:	6823      	ldr	r3, [r4, #0]
 800f014:	4d10      	ldr	r5, [pc, #64]	; (800f058 <sys_timeouts_mbox_fetch+0x68>)
 800f016:	b15b      	cbz	r3, 800f030 <sys_timeouts_mbox_fetch+0x40>
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  } else {
    if (next_timeout->time > 0) {
 800f018:	685a      	ldr	r2, [r3, #4]
 800f01a:	2a00      	cmp	r2, #0
 800f01c:	d0ef      	beq.n	800effe <sys_timeouts_mbox_fetch+0xe>
      time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
 800f01e:	4638      	mov	r0, r7
 800f020:	4631      	mov	r1, r6
 800f022:	f7f8 fe45 	bl	8007cb0 <sys_arch_mbox_fetch>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
 800f026:	1c43      	adds	r3, r0, #1
 800f028:	d109      	bne.n	800f03e <sys_timeouts_mbox_fetch+0x4e>
 800f02a:	f8d8 3000 	ldr.w	r3, [r8]
 800f02e:	e7e6      	b.n	800effe <sys_timeouts_mbox_fetch+0xe>
  sys_timeout_handler handler;
  void *arg;

 again:
  if (!next_timeout) {
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
 800f030:	4638      	mov	r0, r7
 800f032:	4631      	mov	r1, r6
 800f034:	461a      	mov	r2, r3
      } else {
        next_timeout->time = 0;
      }
    }
  }
}
 800f036:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  sys_timeout_handler handler;
  void *arg;

 again:
  if (!next_timeout) {
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
 800f03a:	f7f8 be39 	b.w	8007cb0 <sys_arch_mbox_fetch>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < next_timeout->time) {
 800f03e:	682a      	ldr	r2, [r5, #0]
 800f040:	6853      	ldr	r3, [r2, #4]
 800f042:	4283      	cmp	r3, r0
        next_timeout->time -= time_needed;
 800f044:	bf8c      	ite	hi
 800f046:	1a1b      	subhi	r3, r3, r0
      } else {
        next_timeout->time = 0;
 800f048:	2300      	movls	r3, #0
 800f04a:	6053      	str	r3, [r2, #4]
 800f04c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
      if (handler != NULL) {
        /* For LWIP_TCPIP_CORE_LOCKING, lock the core before calling the
           timeout handler function. */
        LOCK_TCPIP_CORE();
        handler(arg);
 800f050:	4648      	mov	r0, r9
 800f052:	47a8      	blx	r5
 800f054:	e7dd      	b.n	800f012 <sys_timeouts_mbox_fetch+0x22>
 800f056:	bf00      	nop
 800f058:	2000cbc4 	.word	0x2000cbc4
 800f05c:	f3af 8000 	nop.w

0800f060 <chprintf.constprop.2>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 800f060:	b40e      	push	{r1, r2, r3}
 800f062:	b500      	push	{lr}
 800f064:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800f066:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 800f068:	461a      	mov	r2, r3
 800f06a:	4905      	ldr	r1, [pc, #20]	; (800f080 <chprintf.constprop.2+0x20>)
 800f06c:	4805      	ldr	r0, [pc, #20]	; (800f084 <chprintf.constprop.2+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800f06e:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800f070:	f001 fe46 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 800f074:	b002      	add	sp, #8
 800f076:	f85d eb04 	ldr.w	lr, [sp], #4
 800f07a:	b003      	add	sp, #12
 800f07c:	4770      	bx	lr
 800f07e:	bf00      	nop
 800f080:	08016fe0 	.word	0x08016fe0
 800f084:	200180c8 	.word	0x200180c8
 800f088:	f3af 8000 	nop.w
 800f08c:	f3af 8000 	nop.w

0800f090 <netconn_recv_data>:
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
static err_t
netconn_recv_data(struct netconn *conn, void **new_buf)
{
 800f090:	b5f0      	push	{r4, r5, r6, r7, lr}
 800f092:	b08b      	sub	sp, #44	; 0x2c
  void *buf = NULL;
 800f094:	2500      	movs	r5, #0
 800f096:	9503      	str	r5, [sp, #12]
  err_t err;
#if LWIP_TCP
  struct api_msg msg;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 800f098:	460e      	mov	r6, r1
 800f09a:	2900      	cmp	r1, #0
 800f09c:	d07b      	beq.n	800f196 <netconn_recv_data+0x106>
 800f09e:	4604      	mov	r4, r0
  *new_buf = NULL;
 800f0a0:	600d      	str	r5, [r1, #0]
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 800f0a2:	2800      	cmp	r0, #0
 800f0a4:	d069      	beq.n	800f17a <netconn_recv_data+0xea>
  LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
 800f0a6:	f100 0710 	add.w	r7, r0, #16
 800f0aa:	4638      	mov	r0, r7
 800f0ac:	f7f8 fe30 	bl	8007d10 <sys_mbox_valid>
 800f0b0:	2800      	cmp	r0, #0
 800f0b2:	d054      	beq.n	800f15e <netconn_recv_data+0xce>

  err = conn->last_err;
 800f0b4:	7a20      	ldrb	r0, [r4, #8]
  if (ERR_IS_FATAL(err)) {
 800f0b6:	b243      	sxtb	r3, r0
 800f0b8:	3309      	adds	r3, #9
 800f0ba:	da02      	bge.n	800f0c2 <netconn_recv_data+0x32>
 800f0bc:	b240      	sxtb	r0, r0
  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv_data: received %p, len=%"U16_F"\n", buf, len));

  *new_buf = buf;
  /* don't set conn->last_err: it's only ERR_OK, anyway */
  return ERR_OK;
}
 800f0be:	b00b      	add	sp, #44	; 0x2c
 800f0c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (sys_arch_mbox_fetch(&conn->recvmbox, &buf, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);
    return ERR_TIMEOUT;
  }
#else
  sys_arch_mbox_fetch(&conn->recvmbox, &buf, 0);
 800f0c2:	4638      	mov	r0, r7
 800f0c4:	462a      	mov	r2, r5
 800f0c6:	a903      	add	r1, sp, #12
 800f0c8:	f7f8 fdf2 	bl	8007cb0 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (conn->type == NETCONN_TCP)
 800f0cc:	7823      	ldrb	r3, [r4, #0]
 800f0ce:	2b10      	cmp	r3, #16
 800f0d0:	d00f      	beq.n	800f0f2 <netconn_recv_data+0x62>
#if LWIP_TCP && (LWIP_UDP || LWIP_RAW)
  else
#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
#if (LWIP_UDP || LWIP_RAW)
  {
    LWIP_ASSERT("buf != NULL", buf != NULL);
 800f0d2:	9b03      	ldr	r3, [sp, #12]
 800f0d4:	2b00      	cmp	r3, #0
 800f0d6:	d034      	beq.n	800f142 <netconn_recv_data+0xb2>
    len = netbuf_len((struct netbuf *)buf);
 800f0d8:	681a      	ldr	r2, [r3, #0]
 800f0da:	8912      	ldrh	r2, [r2, #8]

#if LWIP_SO_RCVBUF
  SYS_ARCH_DEC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
 800f0dc:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 800f0de:	b11d      	cbz	r5, 800f0e8 <netconn_recv_data+0x58>
 800f0e0:	4620      	mov	r0, r4
 800f0e2:	2101      	movs	r1, #1
 800f0e4:	47a8      	blx	r5
 800f0e6:	9b03      	ldr	r3, [sp, #12]

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv_data: received %p, len=%"U16_F"\n", buf, len));

  *new_buf = buf;
 800f0e8:	6033      	str	r3, [r6, #0]
  /* don't set conn->last_err: it's only ERR_OK, anyway */
  return ERR_OK;
 800f0ea:	2000      	movs	r0, #0
 800f0ec:	b240      	sxtb	r0, r0
}
 800f0ee:	b00b      	add	sp, #44	; 0x2c
 800f0f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (conn->type == NETCONN_TCP)
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
 800f0f2:	7f23      	ldrb	r3, [r4, #28]
 800f0f4:	f013 0f08 	tst.w	r3, #8
 800f0f8:	9b03      	ldr	r3, [sp, #12]
 800f0fa:	d10c      	bne.n	800f116 <netconn_recv_data+0x86>
      /* Let the stack know that we have taken the data. */
      /* TODO: Speedup: Don't block and wait for the answer here
         (to prevent multiple thread-switches). */
      msg.function = do_recv;
 800f0fc:	4a2d      	ldr	r2, [pc, #180]	; (800f1b4 <netconn_recv_data+0x124>)
      msg.msg.conn = conn;
 800f0fe:	9405      	str	r4, [sp, #20]
  {
    if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
      /* Let the stack know that we have taken the data. */
      /* TODO: Speedup: Don't block and wait for the answer here
         (to prevent multiple thread-switches). */
      msg.function = do_recv;
 800f100:	9204      	str	r2, [sp, #16]
      msg.msg.conn = conn;
      if (buf != NULL) {
 800f102:	b16b      	cbz	r3, 800f120 <netconn_recv_data+0x90>
        msg.msg.msg.r.len = ((struct pbuf *)buf)->tot_len;
 800f104:	891b      	ldrh	r3, [r3, #8]
 800f106:	9307      	str	r3, [sp, #28]
      } else {
        msg.msg.msg.r.len = 1;
      }
      /* don't care for the return value of do_recv */
      TCPIP_APIMSG(&msg);
 800f108:	a804      	add	r0, sp, #16
 800f10a:	f001 fca9 	bl	8010a60 <tcpip_apimsg>
    }

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (buf == NULL) {
 800f10e:	9b03      	ldr	r3, [sp, #12]
 800f110:	b14b      	cbz	r3, 800f126 <netconn_recv_data+0x96>
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
      /* Avoid to lose any previous error code */
      NETCONN_SET_SAFE_ERR(conn, ERR_CLSD);
      return ERR_CLSD;
    }
    len = ((struct pbuf *)buf)->tot_len;
 800f112:	891a      	ldrh	r2, [r3, #8]
 800f114:	e7e2      	b.n	800f0dc <netconn_recv_data+0x4c>
#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (conn->type == NETCONN_TCP)
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
 800f116:	2b00      	cmp	r3, #0
 800f118:	d1fb      	bne.n	800f112 <netconn_recv_data+0x82>
      /* Let the stack know that we have taken the data. */
      /* TODO: Speedup: Don't block and wait for the answer here
         (to prevent multiple thread-switches). */
      msg.function = do_recv;
 800f11a:	4b26      	ldr	r3, [pc, #152]	; (800f1b4 <netconn_recv_data+0x124>)
      msg.msg.conn = conn;
 800f11c:	9405      	str	r4, [sp, #20]
  {
    if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
      /* Let the stack know that we have taken the data. */
      /* TODO: Speedup: Don't block and wait for the answer here
         (to prevent multiple thread-switches). */
      msg.function = do_recv;
 800f11e:	9304      	str	r3, [sp, #16]
      msg.msg.conn = conn;
      if (buf != NULL) {
        msg.msg.msg.r.len = ((struct pbuf *)buf)->tot_len;
      } else {
        msg.msg.msg.r.len = 1;
 800f120:	2301      	movs	r3, #1
 800f122:	9307      	str	r3, [sp, #28]
 800f124:	e7f0      	b.n	800f108 <netconn_recv_data+0x78>
      TCPIP_APIMSG(&msg);
    }

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (buf == NULL) {
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
 800f126:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 800f128:	b11d      	cbz	r5, 800f132 <netconn_recv_data+0xa2>
 800f12a:	461a      	mov	r2, r3
 800f12c:	4620      	mov	r0, r4
 800f12e:	2101      	movs	r1, #1
 800f130:	47a8      	blx	r5
      /* Avoid to lose any previous error code */
      NETCONN_SET_SAFE_ERR(conn, ERR_CLSD);
 800f132:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800f136:	3309      	adds	r3, #9
 800f138:	f04f 00f4 	mov.w	r0, #244	; 0xf4
 800f13c:	dbbe      	blt.n	800f0bc <netconn_recv_data+0x2c>
 800f13e:	7220      	strb	r0, [r4, #8]
 800f140:	e7bc      	b.n	800f0bc <netconn_recv_data+0x2c>
#if LWIP_TCP && (LWIP_UDP || LWIP_RAW)
  else
#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
#if (LWIP_UDP || LWIP_RAW)
  {
    LWIP_ASSERT("buf != NULL", buf != NULL);
 800f142:	4b1d      	ldr	r3, [pc, #116]	; (800f1b8 <netconn_recv_data+0x128>)
 800f144:	9300      	str	r3, [sp, #0]
 800f146:	491d      	ldr	r1, [pc, #116]	; (800f1bc <netconn_recv_data+0x12c>)
 800f148:	4a1d      	ldr	r2, [pc, #116]	; (800f1c0 <netconn_recv_data+0x130>)
 800f14a:	481e      	ldr	r0, [pc, #120]	; (800f1c4 <netconn_recv_data+0x134>)
 800f14c:	f240 1399 	movw	r3, #409	; 0x199
 800f150:	f7ff ff86 	bl	800f060 <chprintf.constprop.2>
 800f154:	481a      	ldr	r0, [pc, #104]	; (800f1c0 <netconn_recv_data+0x130>)
 800f156:	f7f1 ff0b 	bl	8000f70 <chSysHalt>
 800f15a:	9b03      	ldr	r3, [sp, #12]
 800f15c:	e7bc      	b.n	800f0d8 <netconn_recv_data+0x48>
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
  *new_buf = NULL;
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
  LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
 800f15e:	4b16      	ldr	r3, [pc, #88]	; (800f1b8 <netconn_recv_data+0x128>)
 800f160:	9300      	str	r3, [sp, #0]
 800f162:	4916      	ldr	r1, [pc, #88]	; (800f1bc <netconn_recv_data+0x12c>)
 800f164:	4a18      	ldr	r2, [pc, #96]	; (800f1c8 <netconn_recv_data+0x138>)
 800f166:	4817      	ldr	r0, [pc, #92]	; (800f1c4 <netconn_recv_data+0x134>)
 800f168:	f44f 73b1 	mov.w	r3, #354	; 0x162
 800f16c:	f7ff ff78 	bl	800f060 <chprintf.constprop.2>
 800f170:	4815      	ldr	r0, [pc, #84]	; (800f1c8 <netconn_recv_data+0x138>)
 800f172:	f7f1 fefd 	bl	8000f70 <chSysHalt>
 800f176:	20f3      	movs	r0, #243	; 0xf3
 800f178:	e7a0      	b.n	800f0bc <netconn_recv_data+0x2c>
  struct api_msg msg;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
  *new_buf = NULL;
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 800f17a:	4b0f      	ldr	r3, [pc, #60]	; (800f1b8 <netconn_recv_data+0x128>)
 800f17c:	9300      	str	r3, [sp, #0]
 800f17e:	490f      	ldr	r1, [pc, #60]	; (800f1bc <netconn_recv_data+0x12c>)
 800f180:	4a12      	ldr	r2, [pc, #72]	; (800f1cc <netconn_recv_data+0x13c>)
 800f182:	4810      	ldr	r0, [pc, #64]	; (800f1c4 <netconn_recv_data+0x134>)
 800f184:	f240 1361 	movw	r3, #353	; 0x161
 800f188:	f7ff ff6a 	bl	800f060 <chprintf.constprop.2>
 800f18c:	480f      	ldr	r0, [pc, #60]	; (800f1cc <netconn_recv_data+0x13c>)
 800f18e:	f7f1 feef 	bl	8000f70 <chSysHalt>
 800f192:	20f2      	movs	r0, #242	; 0xf2
 800f194:	e792      	b.n	800f0bc <netconn_recv_data+0x2c>
  err_t err;
#if LWIP_TCP
  struct api_msg msg;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 800f196:	4b08      	ldr	r3, [pc, #32]	; (800f1b8 <netconn_recv_data+0x128>)
 800f198:	9300      	str	r3, [sp, #0]
 800f19a:	4908      	ldr	r1, [pc, #32]	; (800f1bc <netconn_recv_data+0x12c>)
 800f19c:	4a0c      	ldr	r2, [pc, #48]	; (800f1d0 <netconn_recv_data+0x140>)
 800f19e:	4809      	ldr	r0, [pc, #36]	; (800f1c4 <netconn_recv_data+0x134>)
 800f1a0:	f240 135f 	movw	r3, #351	; 0x15f
 800f1a4:	f7ff ff5c 	bl	800f060 <chprintf.constprop.2>
 800f1a8:	4809      	ldr	r0, [pc, #36]	; (800f1d0 <netconn_recv_data+0x140>)
 800f1aa:	f7f1 fee1 	bl	8000f70 <chSysHalt>
 800f1ae:	20f2      	movs	r0, #242	; 0xf2
 800f1b0:	e784      	b.n	800f0bc <netconn_recv_data+0x2c>
 800f1b2:	bf00      	nop
 800f1b4:	080105f1 	.word	0x080105f1
 800f1b8:	080187d0 	.word	0x080187d0
 800f1bc:	08016fe0 	.word	0x08016fe0
 800f1c0:	08018840 	.word	0x08018840
 800f1c4:	200180c8 	.word	0x200180c8
 800f1c8:	0801881c 	.word	0x0801881c
 800f1cc:	08018800 	.word	0x08018800
 800f1d0:	080187b0 	.word	0x080187b0
 800f1d4:	f3af 8000 	nop.w
 800f1d8:	f3af 8000 	nop.w
 800f1dc:	f3af 8000 	nop.w

0800f1e0 <netconn_close_shutdown>:
 * @param how fully close or only shutdown one side?
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
static err_t
netconn_close_shutdown(struct netconn *conn, u8_t how)
{
 800f1e0:	b510      	push	{r4, lr}
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
 800f1e2:	4604      	mov	r4, r0
 * @param how fully close or only shutdown one side?
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
static err_t
netconn_close_shutdown(struct netconn *conn, u8_t how)
{
 800f1e4:	b088      	sub	sp, #32
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
 800f1e6:	b178      	cbz	r0, 800f208 <netconn_close_shutdown+0x28>

  msg.function = do_close;
 800f1e8:	4b0e      	ldr	r3, [pc, #56]	; (800f224 <netconn_close_shutdown+0x44>)
  msg.msg.conn = conn;
 800f1ea:	9003      	str	r0, [sp, #12]
  /* shutting down both ends is the same as closing */
  msg.msg.msg.sd.shut = how;
  /* because of the LWIP_TCPIP_CORE_LOCKING implementation of do_close,
     don't use TCPIP_APIMSG here */
  err = tcpip_apimsg(&msg);
 800f1ec:	a802      	add	r0, sp, #8
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);

  msg.function = do_close;
 800f1ee:	9302      	str	r3, [sp, #8]
  msg.msg.conn = conn;
  /* shutting down both ends is the same as closing */
  msg.msg.msg.sd.shut = how;
 800f1f0:	f88d 1014 	strb.w	r1, [sp, #20]
  /* because of the LWIP_TCPIP_CORE_LOCKING implementation of do_close,
     don't use TCPIP_APIMSG here */
  err = tcpip_apimsg(&msg);
 800f1f4:	f001 fc34 	bl	8010a60 <tcpip_apimsg>

  NETCONN_SET_SAFE_ERR(conn, err);
 800f1f8:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800f1fc:	3309      	adds	r3, #9
 800f1fe:	bfa8      	it	ge
 800f200:	7220      	strbge	r0, [r4, #8]
  return err;
}
 800f202:	b240      	sxtb	r0, r0
 800f204:	b008      	add	sp, #32
 800f206:	bd10      	pop	{r4, pc}
netconn_close_shutdown(struct netconn *conn, u8_t how)
{
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
 800f208:	4b07      	ldr	r3, [pc, #28]	; (800f228 <netconn_close_shutdown+0x48>)
 800f20a:	9300      	str	r3, [sp, #0]
 800f20c:	4907      	ldr	r1, [pc, #28]	; (800f22c <netconn_close_shutdown+0x4c>)
 800f20e:	4a08      	ldr	r2, [pc, #32]	; (800f230 <netconn_close_shutdown+0x50>)
 800f210:	4808      	ldr	r0, [pc, #32]	; (800f234 <netconn_close_shutdown+0x54>)
 800f212:	f44f 7327 	mov.w	r3, #668	; 0x29c
 800f216:	f7ff ff23 	bl	800f060 <chprintf.constprop.2>
 800f21a:	4805      	ldr	r0, [pc, #20]	; (800f230 <netconn_close_shutdown+0x50>)
 800f21c:	f7f1 fea8 	bl	8000f70 <chSysHalt>
 800f220:	20f2      	movs	r0, #242	; 0xf2
 800f222:	e7ee      	b.n	800f202 <netconn_close_shutdown+0x22>
 800f224:	080106f1 	.word	0x080106f1
 800f228:	080187d0 	.word	0x080187d0
 800f22c:	08016fe0 	.word	0x08016fe0
 800f230:	0801884c 	.word	0x0801884c
 800f234:	200180c8 	.word	0x200180c8
 800f238:	f3af 8000 	nop.w
 800f23c:	f3af 8000 	nop.w

0800f240 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
 800f240:	b570      	push	{r4, r5, r6, lr}
 800f242:	460d      	mov	r5, r1
 800f244:	b088      	sub	sp, #32
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
 800f246:	4611      	mov	r1, r2
 800f248:	f000 ff2a 	bl	80100a0 <netconn_alloc>
  if (conn != NULL) {
 800f24c:	4604      	mov	r4, r0
 800f24e:	2800      	cmp	r0, #0
 800f250:	d054      	beq.n	800f2fc <netconn_new_with_proto_and_callback+0xbc>
    msg.function = do_newconn;
 800f252:	4b2c      	ldr	r3, [pc, #176]	; (800f304 <netconn_new_with_proto_and_callback+0xc4>)
    msg.msg.msg.n.proto = proto;
 800f254:	f88d 5014 	strb.w	r5, [sp, #20]
    msg.msg.conn = conn;
    if (TCPIP_APIMSG(&msg) != ERR_OK) {
 800f258:	a802      	add	r0, sp, #8

  conn = netconn_alloc(t, callback);
  if (conn != NULL) {
    msg.function = do_newconn;
    msg.msg.msg.n.proto = proto;
    msg.msg.conn = conn;
 800f25a:	9403      	str	r4, [sp, #12]
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  if (conn != NULL) {
    msg.function = do_newconn;
 800f25c:	9302      	str	r3, [sp, #8]
    msg.msg.msg.n.proto = proto;
    msg.msg.conn = conn;
    if (TCPIP_APIMSG(&msg) != ERR_OK) {
 800f25e:	f001 fbff 	bl	8010a60 <tcpip_apimsg>
 800f262:	b910      	cbnz	r0, 800f26a <netconn_new_with_proto_and_callback+0x2a>
 800f264:	4620      	mov	r0, r4
      memp_free(MEMP_NETCONN, conn);
      return NULL;
    }
  }
  return conn;
}
 800f266:	b008      	add	sp, #32
 800f268:	bd70      	pop	{r4, r5, r6, pc}
  if (conn != NULL) {
    msg.function = do_newconn;
    msg.msg.msg.n.proto = proto;
    msg.msg.conn = conn;
    if (TCPIP_APIMSG(&msg) != ERR_OK) {
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
 800f26a:	6863      	ldr	r3, [r4, #4]
 800f26c:	b153      	cbz	r3, 800f284 <netconn_new_with_proto_and_callback+0x44>
 800f26e:	4b26      	ldr	r3, [pc, #152]	; (800f308 <netconn_new_with_proto_and_callback+0xc8>)
 800f270:	9300      	str	r3, [sp, #0]
 800f272:	4826      	ldr	r0, [pc, #152]	; (800f30c <netconn_new_with_proto_and_callback+0xcc>)
 800f274:	4926      	ldr	r1, [pc, #152]	; (800f310 <netconn_new_with_proto_and_callback+0xd0>)
 800f276:	4a27      	ldr	r2, [pc, #156]	; (800f314 <netconn_new_with_proto_and_callback+0xd4>)
 800f278:	234f      	movs	r3, #79	; 0x4f
 800f27a:	f7ff fef1 	bl	800f060 <chprintf.constprop.2>
 800f27e:	4825      	ldr	r0, [pc, #148]	; (800f314 <netconn_new_with_proto_and_callback+0xd4>)
 800f280:	f7f1 fe76 	bl	8000f70 <chSysHalt>
      LWIP_ASSERT("conn has no op_completed", sys_sem_valid(&conn->op_completed));
 800f284:	f104 060c 	add.w	r6, r4, #12
 800f288:	4630      	mov	r0, r6
 800f28a:	f7f8 fc91 	bl	8007bb0 <sys_sem_valid>
 800f28e:	b950      	cbnz	r0, 800f2a6 <netconn_new_with_proto_and_callback+0x66>
 800f290:	4b1d      	ldr	r3, [pc, #116]	; (800f308 <netconn_new_with_proto_and_callback+0xc8>)
 800f292:	9300      	str	r3, [sp, #0]
 800f294:	481d      	ldr	r0, [pc, #116]	; (800f30c <netconn_new_with_proto_and_callback+0xcc>)
 800f296:	491e      	ldr	r1, [pc, #120]	; (800f310 <netconn_new_with_proto_and_callback+0xd0>)
 800f298:	4a1f      	ldr	r2, [pc, #124]	; (800f318 <netconn_new_with_proto_and_callback+0xd8>)
 800f29a:	2350      	movs	r3, #80	; 0x50
 800f29c:	f7ff fee0 	bl	800f060 <chprintf.constprop.2>
 800f2a0:	481d      	ldr	r0, [pc, #116]	; (800f318 <netconn_new_with_proto_and_callback+0xd8>)
 800f2a2:	f7f1 fe65 	bl	8000f70 <chSysHalt>
      LWIP_ASSERT("conn has no recvmbox", sys_mbox_valid(&conn->recvmbox));
 800f2a6:	f104 0510 	add.w	r5, r4, #16
 800f2aa:	4628      	mov	r0, r5
 800f2ac:	f7f8 fd30 	bl	8007d10 <sys_mbox_valid>
 800f2b0:	b950      	cbnz	r0, 800f2c8 <netconn_new_with_proto_and_callback+0x88>
 800f2b2:	4b15      	ldr	r3, [pc, #84]	; (800f308 <netconn_new_with_proto_and_callback+0xc8>)
 800f2b4:	9300      	str	r3, [sp, #0]
 800f2b6:	4815      	ldr	r0, [pc, #84]	; (800f30c <netconn_new_with_proto_and_callback+0xcc>)
 800f2b8:	4915      	ldr	r1, [pc, #84]	; (800f310 <netconn_new_with_proto_and_callback+0xd0>)
 800f2ba:	4a18      	ldr	r2, [pc, #96]	; (800f31c <netconn_new_with_proto_and_callback+0xdc>)
 800f2bc:	2351      	movs	r3, #81	; 0x51
 800f2be:	f7ff fecf 	bl	800f060 <chprintf.constprop.2>
 800f2c2:	4816      	ldr	r0, [pc, #88]	; (800f31c <netconn_new_with_proto_and_callback+0xdc>)
 800f2c4:	f7f1 fe54 	bl	8000f70 <chSysHalt>
#if LWIP_TCP
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", !sys_mbox_valid(&conn->acceptmbox));
 800f2c8:	f104 0014 	add.w	r0, r4, #20
 800f2cc:	f7f8 fd20 	bl	8007d10 <sys_mbox_valid>
 800f2d0:	b150      	cbz	r0, 800f2e8 <netconn_new_with_proto_and_callback+0xa8>
 800f2d2:	4b0d      	ldr	r3, [pc, #52]	; (800f308 <netconn_new_with_proto_and_callback+0xc8>)
 800f2d4:	9300      	str	r3, [sp, #0]
 800f2d6:	480d      	ldr	r0, [pc, #52]	; (800f30c <netconn_new_with_proto_and_callback+0xcc>)
 800f2d8:	490d      	ldr	r1, [pc, #52]	; (800f310 <netconn_new_with_proto_and_callback+0xd0>)
 800f2da:	4a11      	ldr	r2, [pc, #68]	; (800f320 <netconn_new_with_proto_and_callback+0xe0>)
 800f2dc:	2353      	movs	r3, #83	; 0x53
 800f2de:	f7ff febf 	bl	800f060 <chprintf.constprop.2>
 800f2e2:	480f      	ldr	r0, [pc, #60]	; (800f320 <netconn_new_with_proto_and_callback+0xe0>)
 800f2e4:	f7f1 fe44 	bl	8000f70 <chSysHalt>
#endif /* LWIP_TCP */
      sys_sem_free(&conn->op_completed);
 800f2e8:	4630      	mov	r0, r6
 800f2ea:	f7f8 fc29 	bl	8007b40 <sys_sem_free>
      sys_mbox_free(&conn->recvmbox);
 800f2ee:	4628      	mov	r0, r5
 800f2f0:	f7f8 fc96 	bl	8007c20 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
 800f2f4:	4621      	mov	r1, r4
 800f2f6:	2008      	movs	r0, #8
 800f2f8:	f7f9 fe62 	bl	8008fc0 <memp_free>
      return NULL;
 800f2fc:	2000      	movs	r0, #0
    }
  }
  return conn;
}
 800f2fe:	b008      	add	sp, #32
 800f300:	bd70      	pop	{r4, r5, r6, pc}
 800f302:	bf00      	nop
 800f304:	08010001 	.word	0x08010001
 800f308:	080187d0 	.word	0x080187d0
 800f30c:	200180c8 	.word	0x200180c8
 800f310:	08016fe0 	.word	0x08016fe0
 800f314:	08018868 	.word	0x08018868
 800f318:	0801888c 	.word	0x0801888c
 800f31c:	080188a8 	.word	0x080188a8
 800f320:	080188c0 	.word	0x080188c0
 800f324:	f3af 8000 	nop.w
 800f328:	f3af 8000 	nop.w
 800f32c:	f3af 8000 	nop.w

0800f330 <netconn_delete>:
netconn_delete(struct netconn *conn)
{
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
 800f330:	b170      	cbz	r0, 800f350 <netconn_delete+0x20>
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
 800f332:	b510      	push	{r4, lr}
 800f334:	b086      	sub	sp, #24
  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
    return ERR_OK;
  }

  msg.function = do_delconn;
 800f336:	4b07      	ldr	r3, [pc, #28]	; (800f354 <netconn_delete+0x24>)
  msg.msg.conn = conn;
 800f338:	9001      	str	r0, [sp, #4]
 800f33a:	4604      	mov	r4, r0
  tcpip_apimsg(&msg);
 800f33c:	4668      	mov	r0, sp
  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
    return ERR_OK;
  }

  msg.function = do_delconn;
 800f33e:	9300      	str	r3, [sp, #0]
  msg.msg.conn = conn;
  tcpip_apimsg(&msg);
 800f340:	f001 fb8e 	bl	8010a60 <tcpip_apimsg>

  netconn_free(conn);
 800f344:	4620      	mov	r0, r4
 800f346:	f000 ff03 	bl	8010150 <netconn_free>

  /* don't care for return value of do_delconn since it only calls void functions */

  return ERR_OK;
}
 800f34a:	2000      	movs	r0, #0
 800f34c:	b006      	add	sp, #24
 800f34e:	bd10      	pop	{r4, pc}
 800f350:	2000      	movs	r0, #0
 800f352:	4770      	bx	lr
 800f354:	08010371 	.word	0x08010371
 800f358:	f3af 8000 	nop.w
 800f35c:	f3af 8000 	nop.w

0800f360 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, ip_addr_t *addr, u16_t port)
{
 800f360:	b510      	push	{r4, lr}
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
 800f362:	4604      	mov	r4, r0
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, ip_addr_t *addr, u16_t port)
{
 800f364:	b088      	sub	sp, #32
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
 800f366:	b180      	cbz	r0, 800f38a <netconn_bind+0x2a>

  msg.function = do_bind;
 800f368:	4b0e      	ldr	r3, [pc, #56]	; (800f3a4 <netconn_bind+0x44>)
  msg.msg.conn = conn;
 800f36a:	9003      	str	r0, [sp, #12]
  msg.msg.msg.bc.ipaddr = addr;
  msg.msg.msg.bc.port = port;
  err = TCPIP_APIMSG(&msg);
 800f36c:	a802      	add	r0, sp, #8
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);

  msg.function = do_bind;
 800f36e:	9302      	str	r3, [sp, #8]
  msg.msg.conn = conn;
  msg.msg.msg.bc.ipaddr = addr;
 800f370:	9105      	str	r1, [sp, #20]
  msg.msg.msg.bc.port = port;
 800f372:	f8ad 2018 	strh.w	r2, [sp, #24]
  err = TCPIP_APIMSG(&msg);
 800f376:	f001 fb73 	bl	8010a60 <tcpip_apimsg>

  NETCONN_SET_SAFE_ERR(conn, err);
 800f37a:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800f37e:	3309      	adds	r3, #9
 800f380:	bfa8      	it	ge
 800f382:	7220      	strbge	r0, [r4, #8]
  return err;
}
 800f384:	b240      	sxtb	r0, r0
 800f386:	b008      	add	sp, #32
 800f388:	bd10      	pop	{r4, pc}
netconn_bind(struct netconn *conn, ip_addr_t *addr, u16_t port)
{
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
 800f38a:	4b07      	ldr	r3, [pc, #28]	; (800f3a8 <netconn_bind+0x48>)
 800f38c:	9300      	str	r3, [sp, #0]
 800f38e:	4907      	ldr	r1, [pc, #28]	; (800f3ac <netconn_bind+0x4c>)
 800f390:	4a07      	ldr	r2, [pc, #28]	; (800f3b0 <netconn_bind+0x50>)
 800f392:	4808      	ldr	r0, [pc, #32]	; (800f3b4 <netconn_bind+0x54>)
 800f394:	23ab      	movs	r3, #171	; 0xab
 800f396:	f7ff fe63 	bl	800f060 <chprintf.constprop.2>
 800f39a:	4805      	ldr	r0, [pc, #20]	; (800f3b0 <netconn_bind+0x50>)
 800f39c:	f7f1 fde8 	bl	8000f70 <chSysHalt>
 800f3a0:	20f2      	movs	r0, #242	; 0xf2
 800f3a2:	e7ef      	b.n	800f384 <netconn_bind+0x24>
 800f3a4:	080104a1 	.word	0x080104a1
 800f3a8:	080187d0 	.word	0x080187d0
 800f3ac:	08016fe0 	.word	0x08016fe0
 800f3b0:	08018944 	.word	0x08018944
 800f3b4:	200180c8 	.word	0x200180c8
 800f3b8:	f3af 8000 	nop.w
 800f3bc:	f3af 8000 	nop.w

0800f3c0 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
 800f3c0:	b510      	push	{r4, lr}
  err_t err;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
 800f3c2:	4604      	mov	r4, r0
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
 800f3c4:	b088      	sub	sp, #32
  err_t err;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
 800f3c6:	b168      	cbz	r0, 800f3e4 <netconn_listen_with_backlog+0x24>

  msg.function = do_listen;
 800f3c8:	4b0d      	ldr	r3, [pc, #52]	; (800f400 <netconn_listen_with_backlog+0x40>)
  msg.msg.conn = conn;
 800f3ca:	9003      	str	r0, [sp, #12]
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  err = TCPIP_APIMSG(&msg);
 800f3cc:	a802      	add	r0, sp, #8
  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);

  msg.function = do_listen;
 800f3ce:	9302      	str	r3, [sp, #8]
  msg.msg.conn = conn;
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  err = TCPIP_APIMSG(&msg);
 800f3d0:	f001 fb46 	bl	8010a60 <tcpip_apimsg>

  NETCONN_SET_SAFE_ERR(conn, err);
 800f3d4:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800f3d8:	3309      	adds	r3, #9
 800f3da:	bfa8      	it	ge
 800f3dc:	7220      	strbge	r0, [r4, #8]
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(backlog);
  return ERR_ARG;
#endif /* LWIP_TCP */
}
 800f3de:	b240      	sxtb	r0, r0
 800f3e0:	b008      	add	sp, #32
 800f3e2:	bd10      	pop	{r4, pc}
  err_t err;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
 800f3e4:	4b07      	ldr	r3, [pc, #28]	; (800f404 <netconn_listen_with_backlog+0x44>)
 800f3e6:	9300      	str	r3, [sp, #0]
 800f3e8:	4907      	ldr	r1, [pc, #28]	; (800f408 <netconn_listen_with_backlog+0x48>)
 800f3ea:	4a08      	ldr	r2, [pc, #32]	; (800f40c <netconn_listen_with_backlog+0x4c>)
 800f3ec:	4808      	ldr	r0, [pc, #32]	; (800f410 <netconn_listen_with_backlog+0x50>)
 800f3ee:	23fa      	movs	r3, #250	; 0xfa
 800f3f0:	f7ff fe36 	bl	800f060 <chprintf.constprop.2>
 800f3f4:	4805      	ldr	r0, [pc, #20]	; (800f40c <netconn_listen_with_backlog+0x4c>)
 800f3f6:	f7f1 fdbb 	bl	8000f70 <chSysHalt>
 800f3fa:	20f2      	movs	r0, #242	; 0xf2
 800f3fc:	e7ef      	b.n	800f3de <netconn_listen_with_backlog+0x1e>
 800f3fe:	bf00      	nop
 800f400:	08010531 	.word	0x08010531
 800f404:	080187d0 	.word	0x080187d0
 800f408:	08016fe0 	.word	0x08016fe0
 800f40c:	080189a4 	.word	0x080189a4
 800f410:	200180c8 	.word	0x200180c8
 800f414:	f3af 8000 	nop.w
 800f418:	f3af 8000 	nop.w
 800f41c:	f3af 8000 	nop.w

0800f420 <netconn_accept>:
 * @return ERR_OK if a new connection has been received or an error
 *                code otherwise
 */
err_t
netconn_accept(struct netconn *conn, struct netconn **new_conn)
{
 800f420:	b5f0      	push	{r4, r5, r6, r7, lr}
  err_t err;
#if TCP_LISTEN_BACKLOG
  struct api_msg msg;
#endif /* TCP_LISTEN_BACKLOG */

  LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
 800f422:	460d      	mov	r5, r1
 * @return ERR_OK if a new connection has been received or an error
 *                code otherwise
 */
err_t
netconn_accept(struct netconn *conn, struct netconn **new_conn)
{
 800f424:	b085      	sub	sp, #20
  err_t err;
#if TCP_LISTEN_BACKLOG
  struct api_msg msg;
#endif /* TCP_LISTEN_BACKLOG */

  LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
 800f426:	2900      	cmp	r1, #0
 800f428:	d047      	beq.n	800f4ba <netconn_accept+0x9a>
  *new_conn = NULL;
 800f42a:	2600      	movs	r6, #0
 800f42c:	4604      	mov	r4, r0
 800f42e:	600e      	str	r6, [r1, #0]
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return ERR_ARG;);
 800f430:	2800      	cmp	r0, #0
 800f432:	d034      	beq.n	800f49e <netconn_accept+0x7e>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", sys_mbox_valid(&conn->acceptmbox),   return ERR_ARG;);
 800f434:	f100 0714 	add.w	r7, r0, #20
 800f438:	4638      	mov	r0, r7
 800f43a:	f7f8 fc69 	bl	8007d10 <sys_mbox_valid>
 800f43e:	b300      	cbz	r0, 800f482 <netconn_accept+0x62>

  err = conn->last_err;
 800f440:	7a20      	ldrb	r0, [r4, #8]
  if (ERR_IS_FATAL(err)) {
 800f442:	b243      	sxtb	r3, r0
 800f444:	3309      	adds	r3, #9
 800f446:	da02      	bge.n	800f44e <netconn_accept+0x2e>
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(new_conn);
  return ERR_ARG;
#endif /* LWIP_TCP */
}
 800f448:	b240      	sxtb	r0, r0
 800f44a:	b005      	add	sp, #20
 800f44c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);
    return ERR_TIMEOUT;
  }
#else
  sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, 0);
 800f44e:	4638      	mov	r0, r7
 800f450:	a903      	add	r1, sp, #12
 800f452:	4632      	mov	r2, r6
 800f454:	f7f8 fc2c 	bl	8007cb0 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
 800f458:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800f45a:	b11b      	cbz	r3, 800f464 <netconn_accept+0x44>
 800f45c:	4632      	mov	r2, r6
 800f45e:	4620      	mov	r0, r4
 800f460:	2101      	movs	r1, #1
 800f462:	4798      	blx	r3

  if (newconn == NULL) {
 800f464:	9b03      	ldr	r3, [sp, #12]
 800f466:	b123      	cbz	r3, 800f472 <netconn_accept+0x52>
  TCPIP_APIMSG(&msg);
#endif /* TCP_LISTEN_BACKLOG */

  *new_conn = newconn;
  /* don't set conn->last_err: it's only ERR_OK, anyway */
  return ERR_OK;
 800f468:	2000      	movs	r0, #0
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(new_conn);
  return ERR_ARG;
#endif /* LWIP_TCP */
}
 800f46a:	b240      	sxtb	r0, r0
  msg.msg.conn = conn;
  /* don't care for the return value of do_recv */
  TCPIP_APIMSG(&msg);
#endif /* TCP_LISTEN_BACKLOG */

  *new_conn = newconn;
 800f46c:	602b      	str	r3, [r5, #0]
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(new_conn);
  return ERR_ARG;
#endif /* LWIP_TCP */
}
 800f46e:	b005      	add	sp, #20
 800f470:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);

  if (newconn == NULL) {
    /* connection has been aborted */
    NETCONN_SET_SAFE_ERR(conn, ERR_ABRT);
 800f472:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800f476:	3309      	adds	r3, #9
 800f478:	f04f 00f6 	mov.w	r0, #246	; 0xf6
 800f47c:	dbe4      	blt.n	800f448 <netconn_accept+0x28>
 800f47e:	7220      	strb	r0, [r4, #8]
 800f480:	e7e2      	b.n	800f448 <netconn_accept+0x28>
#endif /* TCP_LISTEN_BACKLOG */

  LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
  *new_conn = NULL;
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return ERR_ARG;);
  LWIP_ERROR("netconn_accept: invalid acceptmbox", sys_mbox_valid(&conn->acceptmbox),   return ERR_ARG;);
 800f482:	4b15      	ldr	r3, [pc, #84]	; (800f4d8 <netconn_accept+0xb8>)
 800f484:	9300      	str	r3, [sp, #0]
 800f486:	4915      	ldr	r1, [pc, #84]	; (800f4dc <netconn_accept+0xbc>)
 800f488:	4a15      	ldr	r2, [pc, #84]	; (800f4e0 <netconn_accept+0xc0>)
 800f48a:	4816      	ldr	r0, [pc, #88]	; (800f4e4 <netconn_accept+0xc4>)
 800f48c:	f240 1321 	movw	r3, #289	; 0x121
 800f490:	f7ff fde6 	bl	800f060 <chprintf.constprop.2>
 800f494:	4812      	ldr	r0, [pc, #72]	; (800f4e0 <netconn_accept+0xc0>)
 800f496:	f7f1 fd6b 	bl	8000f70 <chSysHalt>
 800f49a:	20f2      	movs	r0, #242	; 0xf2
 800f49c:	e7d4      	b.n	800f448 <netconn_accept+0x28>
  struct api_msg msg;
#endif /* TCP_LISTEN_BACKLOG */

  LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
  *new_conn = NULL;
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return ERR_ARG;);
 800f49e:	4b0e      	ldr	r3, [pc, #56]	; (800f4d8 <netconn_accept+0xb8>)
 800f4a0:	9300      	str	r3, [sp, #0]
 800f4a2:	490e      	ldr	r1, [pc, #56]	; (800f4dc <netconn_accept+0xbc>)
 800f4a4:	4a10      	ldr	r2, [pc, #64]	; (800f4e8 <netconn_accept+0xc8>)
 800f4a6:	480f      	ldr	r0, [pc, #60]	; (800f4e4 <netconn_accept+0xc4>)
 800f4a8:	f44f 7390 	mov.w	r3, #288	; 0x120
 800f4ac:	f7ff fdd8 	bl	800f060 <chprintf.constprop.2>
 800f4b0:	480d      	ldr	r0, [pc, #52]	; (800f4e8 <netconn_accept+0xc8>)
 800f4b2:	f7f1 fd5d 	bl	8000f70 <chSysHalt>
 800f4b6:	20f2      	movs	r0, #242	; 0xf2
 800f4b8:	e7c6      	b.n	800f448 <netconn_accept+0x28>
  err_t err;
#if TCP_LISTEN_BACKLOG
  struct api_msg msg;
#endif /* TCP_LISTEN_BACKLOG */

  LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
 800f4ba:	4b07      	ldr	r3, [pc, #28]	; (800f4d8 <netconn_accept+0xb8>)
 800f4bc:	9300      	str	r3, [sp, #0]
 800f4be:	4907      	ldr	r1, [pc, #28]	; (800f4dc <netconn_accept+0xbc>)
 800f4c0:	4a0a      	ldr	r2, [pc, #40]	; (800f4ec <netconn_accept+0xcc>)
 800f4c2:	4808      	ldr	r0, [pc, #32]	; (800f4e4 <netconn_accept+0xc4>)
 800f4c4:	f44f 738f 	mov.w	r3, #286	; 0x11e
 800f4c8:	f7ff fdca 	bl	800f060 <chprintf.constprop.2>
 800f4cc:	4807      	ldr	r0, [pc, #28]	; (800f4ec <netconn_accept+0xcc>)
 800f4ce:	f7f1 fd4f 	bl	8000f70 <chSysHalt>
 800f4d2:	20f2      	movs	r0, #242	; 0xf2
 800f4d4:	e7b8      	b.n	800f448 <netconn_accept+0x28>
 800f4d6:	bf00      	nop
 800f4d8:	080187d0 	.word	0x080187d0
 800f4dc:	08016fe0 	.word	0x08016fe0
 800f4e0:	08018a04 	.word	0x08018a04
 800f4e4:	200180c8 	.word	0x200180c8
 800f4e8:	080189e4 	.word	0x080189e4
 800f4ec:	080189c4 	.word	0x080189c4

0800f4f0 <netconn_recv>:
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
err_t
netconn_recv(struct netconn *conn, struct netbuf **new_buf)
{
 800f4f0:	b570      	push	{r4, r5, r6, lr}
#if LWIP_TCP
  struct netbuf *buf = NULL;
  err_t err;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 800f4f2:	460d      	mov	r5, r1
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
err_t
netconn_recv(struct netconn *conn, struct netbuf **new_buf)
{
 800f4f4:	b084      	sub	sp, #16
#if LWIP_TCP
  struct netbuf *buf = NULL;
  err_t err;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 800f4f6:	2900      	cmp	r1, #0
 800f4f8:	d061      	beq.n	800f5be <netconn_recv+0xce>
  *new_buf = NULL;
 800f4fa:	2600      	movs	r6, #0
 800f4fc:	4604      	mov	r4, r0
 800f4fe:	600e      	str	r6, [r1, #0]
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 800f500:	2800      	cmp	r0, #0
 800f502:	d04e      	beq.n	800f5a2 <netconn_recv+0xb2>
  LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
 800f504:	3010      	adds	r0, #16
 800f506:	f7f8 fc03 	bl	8007d10 <sys_mbox_valid>
 800f50a:	b370      	cbz	r0, 800f56a <netconn_recv+0x7a>

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (conn->type == NETCONN_TCP)
 800f50c:	7823      	ldrb	r3, [r4, #0]
 800f50e:	2b10      	cmp	r3, #16
 800f510:	d006      	beq.n	800f520 <netconn_recv+0x30>
#if LWIP_TCP && (LWIP_UDP || LWIP_RAW)
  else
#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
  {
#if (LWIP_UDP || LWIP_RAW)
    return netconn_recv_data(conn, (void **)new_buf);
 800f512:	4620      	mov	r0, r4
 800f514:	4629      	mov	r1, r5
 800f516:	f7ff fdbb 	bl	800f090 <netconn_recv_data>
#endif /* (LWIP_UDP || LWIP_RAW) */
  }
}
 800f51a:	b240      	sxtb	r0, r0
 800f51c:	b004      	add	sp, #16
 800f51e:	bd70      	pop	{r4, r5, r6, pc}
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    struct pbuf *p = NULL;
    /* This is not a listening netconn, since recvmbox is set */

    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 800f520:	2007      	movs	r0, #7
#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (conn->type == NETCONN_TCP)
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    struct pbuf *p = NULL;
 800f522:	9603      	str	r6, [sp, #12]
    /* This is not a listening netconn, since recvmbox is set */

    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 800f524:	f7f9 fcf4 	bl	8008f10 <memp_malloc>
    if (buf == NULL) {
 800f528:	4606      	mov	r6, r0
 800f52a:	b180      	cbz	r0, 800f54e <netconn_recv+0x5e>
      NETCONN_SET_SAFE_ERR(conn, ERR_MEM);
      return ERR_MEM;
    }

    err = netconn_recv_data(conn, (void **)&p);
 800f52c:	4620      	mov	r0, r4
 800f52e:	a903      	add	r1, sp, #12
 800f530:	f7ff fdae 	bl	800f090 <netconn_recv_data>
    if (err != ERR_OK) {
 800f534:	4604      	mov	r4, r0
 800f536:	b990      	cbnz	r0, 800f55e <netconn_recv+0x6e>
      memp_free(MEMP_NETBUF, buf);
      return err;
    }
    LWIP_ASSERT("p != NULL", p != NULL);
 800f538:	9b03      	ldr	r3, [sp, #12]
 800f53a:	b323      	cbz	r3, 800f586 <netconn_recv+0x96>

    buf->p = p;
    buf->ptr = p;
    buf->port = 0;
 800f53c:	2000      	movs	r0, #0
 800f53e:	81b0      	strh	r0, [r6, #12]
    ip_addr_set_any(&buf->addr);
 800f540:	60b0      	str	r0, [r6, #8]
  {
#if (LWIP_UDP || LWIP_RAW)
    return netconn_recv_data(conn, (void **)new_buf);
#endif /* (LWIP_UDP || LWIP_RAW) */
  }
}
 800f542:	b240      	sxtb	r0, r0
      memp_free(MEMP_NETBUF, buf);
      return err;
    }
    LWIP_ASSERT("p != NULL", p != NULL);

    buf->p = p;
 800f544:	6033      	str	r3, [r6, #0]
    buf->ptr = p;
 800f546:	6073      	str	r3, [r6, #4]
    buf->port = 0;
    ip_addr_set_any(&buf->addr);
    *new_buf = buf;
 800f548:	602e      	str	r6, [r5, #0]
  {
#if (LWIP_UDP || LWIP_RAW)
    return netconn_recv_data(conn, (void **)new_buf);
#endif /* (LWIP_UDP || LWIP_RAW) */
  }
}
 800f54a:	b004      	add	sp, #16
 800f54c:	bd70      	pop	{r4, r5, r6, pc}
    struct pbuf *p = NULL;
    /* This is not a listening netconn, since recvmbox is set */

    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
    if (buf == NULL) {
      NETCONN_SET_SAFE_ERR(conn, ERR_MEM);
 800f54e:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800f552:	3309      	adds	r3, #9
 800f554:	f04f 00ff 	mov.w	r0, #255	; 0xff
 800f558:	dbdf      	blt.n	800f51a <netconn_recv+0x2a>
 800f55a:	7220      	strb	r0, [r4, #8]
 800f55c:	e7dd      	b.n	800f51a <netconn_recv+0x2a>
      return ERR_MEM;
    }

    err = netconn_recv_data(conn, (void **)&p);
    if (err != ERR_OK) {
      memp_free(MEMP_NETBUF, buf);
 800f55e:	2007      	movs	r0, #7
 800f560:	4631      	mov	r1, r6
 800f562:	f7f9 fd2d 	bl	8008fc0 <memp_free>
      return err;
 800f566:	4620      	mov	r0, r4
 800f568:	e7d7      	b.n	800f51a <netconn_recv+0x2a>
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
  *new_buf = NULL;
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
  LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
 800f56a:	4b1c      	ldr	r3, [pc, #112]	; (800f5dc <netconn_recv+0xec>)
 800f56c:	9300      	str	r3, [sp, #0]
 800f56e:	491c      	ldr	r1, [pc, #112]	; (800f5e0 <netconn_recv+0xf0>)
 800f570:	4a1c      	ldr	r2, [pc, #112]	; (800f5e4 <netconn_recv+0xf4>)
 800f572:	481d      	ldr	r0, [pc, #116]	; (800f5e8 <netconn_recv+0xf8>)
 800f574:	f44f 73e8 	mov.w	r3, #464	; 0x1d0
 800f578:	f7ff fd72 	bl	800f060 <chprintf.constprop.2>
 800f57c:	4819      	ldr	r0, [pc, #100]	; (800f5e4 <netconn_recv+0xf4>)
 800f57e:	f7f1 fcf7 	bl	8000f70 <chSysHalt>
 800f582:	20f3      	movs	r0, #243	; 0xf3
 800f584:	e7c9      	b.n	800f51a <netconn_recv+0x2a>
    err = netconn_recv_data(conn, (void **)&p);
    if (err != ERR_OK) {
      memp_free(MEMP_NETBUF, buf);
      return err;
    }
    LWIP_ASSERT("p != NULL", p != NULL);
 800f586:	4b15      	ldr	r3, [pc, #84]	; (800f5dc <netconn_recv+0xec>)
 800f588:	9300      	str	r3, [sp, #0]
 800f58a:	4915      	ldr	r1, [pc, #84]	; (800f5e0 <netconn_recv+0xf0>)
 800f58c:	4a17      	ldr	r2, [pc, #92]	; (800f5ec <netconn_recv+0xfc>)
 800f58e:	4816      	ldr	r0, [pc, #88]	; (800f5e8 <netconn_recv+0xf8>)
 800f590:	f240 13e5 	movw	r3, #485	; 0x1e5
 800f594:	f7ff fd64 	bl	800f060 <chprintf.constprop.2>
 800f598:	4814      	ldr	r0, [pc, #80]	; (800f5ec <netconn_recv+0xfc>)
 800f59a:	f7f1 fce9 	bl	8000f70 <chSysHalt>
 800f59e:	9b03      	ldr	r3, [sp, #12]
 800f5a0:	e7cc      	b.n	800f53c <netconn_recv+0x4c>
  err_t err;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
  *new_buf = NULL;
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 800f5a2:	4b0e      	ldr	r3, [pc, #56]	; (800f5dc <netconn_recv+0xec>)
 800f5a4:	9300      	str	r3, [sp, #0]
 800f5a6:	490e      	ldr	r1, [pc, #56]	; (800f5e0 <netconn_recv+0xf0>)
 800f5a8:	4a11      	ldr	r2, [pc, #68]	; (800f5f0 <netconn_recv+0x100>)
 800f5aa:	480f      	ldr	r0, [pc, #60]	; (800f5e8 <netconn_recv+0xf8>)
 800f5ac:	f240 13cf 	movw	r3, #463	; 0x1cf
 800f5b0:	f7ff fd56 	bl	800f060 <chprintf.constprop.2>
 800f5b4:	480e      	ldr	r0, [pc, #56]	; (800f5f0 <netconn_recv+0x100>)
 800f5b6:	f7f1 fcdb 	bl	8000f70 <chSysHalt>
 800f5ba:	20f2      	movs	r0, #242	; 0xf2
 800f5bc:	e7ad      	b.n	800f51a <netconn_recv+0x2a>
#if LWIP_TCP
  struct netbuf *buf = NULL;
  err_t err;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 800f5be:	4b07      	ldr	r3, [pc, #28]	; (800f5dc <netconn_recv+0xec>)
 800f5c0:	9300      	str	r3, [sp, #0]
 800f5c2:	4907      	ldr	r1, [pc, #28]	; (800f5e0 <netconn_recv+0xf0>)
 800f5c4:	4a0b      	ldr	r2, [pc, #44]	; (800f5f4 <netconn_recv+0x104>)
 800f5c6:	4808      	ldr	r0, [pc, #32]	; (800f5e8 <netconn_recv+0xf8>)
 800f5c8:	f240 13cd 	movw	r3, #461	; 0x1cd
 800f5cc:	f7ff fd48 	bl	800f060 <chprintf.constprop.2>
 800f5d0:	4808      	ldr	r0, [pc, #32]	; (800f5f4 <netconn_recv+0x104>)
 800f5d2:	f7f1 fccd 	bl	8000f70 <chSysHalt>
 800f5d6:	20f2      	movs	r0, #242	; 0xf2
 800f5d8:	e79f      	b.n	800f51a <netconn_recv+0x2a>
 800f5da:	bf00      	nop
 800f5dc:	080187d0 	.word	0x080187d0
 800f5e0:	08016fe0 	.word	0x08016fe0
 800f5e4:	0801881c 	.word	0x0801881c
 800f5e8:	200180c8 	.word	0x200180c8
 800f5ec:	08018be8 	.word	0x08018be8
 800f5f0:	08018800 	.word	0x08018800
 800f5f4:	080187b0 	.word	0x080187b0
 800f5f8:	f3af 8000 	nop.w
 800f5fc:	f3af 8000 	nop.w

0800f600 <netconn_write_partly>:
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,
                     u8_t apiflags, size_t *bytes_written)
{
 800f600:	b530      	push	{r4, r5, lr}
  struct api_msg msg;
  err_t err;
  u8_t dontblock;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
 800f602:	4605      	mov	r5, r0
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,
                     u8_t apiflags, size_t *bytes_written)
{
 800f604:	b089      	sub	sp, #36	; 0x24
  struct api_msg msg;
  err_t err;
  u8_t dontblock;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
 800f606:	2800      	cmp	r0, #0
 800f608:	d049      	beq.n	800f69e <netconn_write_partly+0x9e>
 800f60a:	4614      	mov	r4, r2
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
 800f60c:	7802      	ldrb	r2, [r0, #0]
 800f60e:	2a10      	cmp	r2, #16
 800f610:	d135      	bne.n	800f67e <netconn_write_partly+0x7e>
  if (size == 0) {
 800f612:	2c00      	cmp	r4, #0
 800f614:	d02f      	beq.n	800f676 <netconn_write_partly+0x76>
    return ERR_OK;
  }
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
 800f616:	7f02      	ldrb	r2, [r0, #28]
 800f618:	0790      	lsls	r0, r2, #30
 800f61a:	d518      	bpl.n	800f64e <netconn_write_partly+0x4e>
  if (dontblock && !bytes_written) {
 800f61c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800f61e:	2a00      	cmp	r2, #0
 800f620:	d03b      	beq.n	800f69a <netconn_write_partly+0x9a>
       it has no way to return the number of bytes written. */
    return ERR_VAL;
  }

  /* non-blocking write sends as much  */
  msg.function = do_write;
 800f622:	4a26      	ldr	r2, [pc, #152]	; (800f6bc <netconn_write_partly+0xbc>)
  msg.msg.conn = conn;
 800f624:	9503      	str	r5, [sp, #12]
#endif /* LWIP_SO_SNDTIMEO */

  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  err = TCPIP_APIMSG(&msg);
 800f626:	a802      	add	r0, sp, #8
  }

  /* non-blocking write sends as much  */
  msg.function = do_write;
  msg.msg.conn = conn;
  msg.msg.msg.w.dataptr = dataptr;
 800f628:	9105      	str	r1, [sp, #20]
  msg.msg.msg.w.apiflags = apiflags;
 800f62a:	f88d 301c 	strb.w	r3, [sp, #28]
  msg.msg.msg.w.len = size;
 800f62e:	9406      	str	r4, [sp, #24]
       it has no way to return the number of bytes written. */
    return ERR_VAL;
  }

  /* non-blocking write sends as much  */
  msg.function = do_write;
 800f630:	9202      	str	r2, [sp, #8]
#endif /* LWIP_SO_SNDTIMEO */

  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  err = TCPIP_APIMSG(&msg);
 800f632:	f001 fa15 	bl	8010a60 <tcpip_apimsg>
  if ((err == ERR_OK) && (bytes_written != NULL)) {
 800f636:	b910      	cbnz	r0, 800f63e <netconn_write_partly+0x3e>
#if LWIP_SO_SNDTIMEO
        || (conn->send_timeout != 0)
#endif /* LWIP_SO_SNDTIMEO */
       ) {
      /* nonblocking write: maybe the data has been sent partly */
      *bytes_written = msg.msg.msg.w.len;
 800f638:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800f63a:	9b06      	ldr	r3, [sp, #24]
 800f63c:	6013      	str	r3, [r2, #0]
      /* blocking call succeeded: all data has been sent if it */
      *bytes_written = size;
    }
  }

  NETCONN_SET_SAFE_ERR(conn, err);
 800f63e:	f995 3008 	ldrsb.w	r3, [r5, #8]
 800f642:	3309      	adds	r3, #9
 800f644:	db00      	blt.n	800f648 <netconn_write_partly+0x48>
 800f646:	7228      	strb	r0, [r5, #8]
 800f648:	b240      	sxtb	r0, r0
  return err;
}
 800f64a:	b009      	add	sp, #36	; 0x24
 800f64c:	bd30      	pop	{r4, r5, pc}
  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  if (size == 0) {
    return ERR_OK;
  }
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
 800f64e:	075a      	lsls	r2, r3, #29
 800f650:	d4e4      	bmi.n	800f61c <netconn_write_partly+0x1c>
       it has no way to return the number of bytes written. */
    return ERR_VAL;
  }

  /* non-blocking write sends as much  */
  msg.function = do_write;
 800f652:	4a1a      	ldr	r2, [pc, #104]	; (800f6bc <netconn_write_partly+0xbc>)
  msg.msg.conn = conn;
 800f654:	9503      	str	r5, [sp, #12]
#endif /* LWIP_SO_SNDTIMEO */

  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  err = TCPIP_APIMSG(&msg);
 800f656:	a802      	add	r0, sp, #8
  }

  /* non-blocking write sends as much  */
  msg.function = do_write;
  msg.msg.conn = conn;
  msg.msg.msg.w.dataptr = dataptr;
 800f658:	9105      	str	r1, [sp, #20]
  msg.msg.msg.w.apiflags = apiflags;
 800f65a:	f88d 301c 	strb.w	r3, [sp, #28]
  msg.msg.msg.w.len = size;
 800f65e:	9406      	str	r4, [sp, #24]
       it has no way to return the number of bytes written. */
    return ERR_VAL;
  }

  /* non-blocking write sends as much  */
  msg.function = do_write;
 800f660:	9202      	str	r2, [sp, #8]
#endif /* LWIP_SO_SNDTIMEO */

  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  err = TCPIP_APIMSG(&msg);
 800f662:	f001 f9fd 	bl	8010a60 <tcpip_apimsg>
  if ((err == ERR_OK) && (bytes_written != NULL)) {
 800f666:	2800      	cmp	r0, #0
 800f668:	d1e9      	bne.n	800f63e <netconn_write_partly+0x3e>
 800f66a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800f66c:	2b00      	cmp	r3, #0
 800f66e:	d0e6      	beq.n	800f63e <netconn_write_partly+0x3e>
       ) {
      /* nonblocking write: maybe the data has been sent partly */
      *bytes_written = msg.msg.msg.w.len;
    } else {
      /* blocking call succeeded: all data has been sent if it */
      *bytes_written = size;
 800f670:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800f672:	601c      	str	r4, [r3, #0]
 800f674:	e7e3      	b.n	800f63e <netconn_write_partly+0x3e>
  u8_t dontblock;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  if (size == 0) {
    return ERR_OK;
 800f676:	4620      	mov	r0, r4
 800f678:	b240      	sxtb	r0, r0
    }
  }

  NETCONN_SET_SAFE_ERR(conn, err);
  return err;
}
 800f67a:	b009      	add	sp, #36	; 0x24
 800f67c:	bd30      	pop	{r4, r5, pc}
  struct api_msg msg;
  err_t err;
  u8_t dontblock;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
 800f67e:	4b10      	ldr	r3, [pc, #64]	; (800f6c0 <netconn_write_partly+0xc0>)
 800f680:	9300      	str	r3, [sp, #0]
 800f682:	4910      	ldr	r1, [pc, #64]	; (800f6c4 <netconn_write_partly+0xc4>)
 800f684:	4a10      	ldr	r2, [pc, #64]	; (800f6c8 <netconn_write_partly+0xc8>)
 800f686:	4811      	ldr	r0, [pc, #68]	; (800f6cc <netconn_write_partly+0xcc>)
 800f688:	f240 235e 	movw	r3, #606	; 0x25e
 800f68c:	f7ff fce8 	bl	800f060 <chprintf.constprop.2>
 800f690:	480d      	ldr	r0, [pc, #52]	; (800f6c8 <netconn_write_partly+0xc8>)
 800f692:	f7f1 fc6d 	bl	8000f70 <chSysHalt>
 800f696:	20fa      	movs	r0, #250	; 0xfa
 800f698:	e7d6      	b.n	800f648 <netconn_write_partly+0x48>
  }
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
  if (dontblock && !bytes_written) {
    /* This implies netconn_write() cannot be used for non-blocking send, since
       it has no way to return the number of bytes written. */
    return ERR_VAL;
 800f69a:	20fa      	movs	r0, #250	; 0xfa
 800f69c:	e7d4      	b.n	800f648 <netconn_write_partly+0x48>
{
  struct api_msg msg;
  err_t err;
  u8_t dontblock;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
 800f69e:	4b08      	ldr	r3, [pc, #32]	; (800f6c0 <netconn_write_partly+0xc0>)
 800f6a0:	9300      	str	r3, [sp, #0]
 800f6a2:	4908      	ldr	r1, [pc, #32]	; (800f6c4 <netconn_write_partly+0xc4>)
 800f6a4:	4a0a      	ldr	r2, [pc, #40]	; (800f6d0 <netconn_write_partly+0xd0>)
 800f6a6:	4809      	ldr	r0, [pc, #36]	; (800f6cc <netconn_write_partly+0xcc>)
 800f6a8:	f240 235d 	movw	r3, #605	; 0x25d
 800f6ac:	f7ff fcd8 	bl	800f060 <chprintf.constprop.2>
 800f6b0:	4807      	ldr	r0, [pc, #28]	; (800f6d0 <netconn_write_partly+0xd0>)
 800f6b2:	f7f1 fc5d 	bl	8000f70 <chSysHalt>
 800f6b6:	20f2      	movs	r0, #242	; 0xf2
 800f6b8:	e7c6      	b.n	800f648 <netconn_write_partly+0x48>
 800f6ba:	bf00      	nop
 800f6bc:	08010641 	.word	0x08010641
 800f6c0:	080187d0 	.word	0x080187d0
 800f6c4:	08016fe0 	.word	0x08016fe0
 800f6c8:	08018a60 	.word	0x08018a60
 800f6cc:	200180c8 	.word	0x200180c8
 800f6d0:	08018a44 	.word	0x08018a44
 800f6d4:	f3af 8000 	nop.w
 800f6d8:	f3af 8000 	nop.w
 800f6dc:	f3af 8000 	nop.w

0800f6e0 <netconn_close>:
 */
err_t
netconn_close(struct netconn *conn)
{
  /* shutting down both ends is the same as closing */
  return netconn_close_shutdown(conn, NETCONN_SHUT_RDWR);
 800f6e0:	2103      	movs	r1, #3
 800f6e2:	f7ff bd7d 	b.w	800f1e0 <netconn_close_shutdown>
 800f6e6:	bf00      	nop
 800f6e8:	f3af 8000 	nop.w
 800f6ec:	f3af 8000 	nop.w

0800f6f0 <recv_raw>:
  struct netconn *conn;

  LWIP_UNUSED_ARG(addr);
  conn = (struct netconn *)arg;

  if ((conn != NULL) && sys_mbox_valid(&conn->recvmbox)) {
 800f6f0:	2800      	cmp	r0, #0
 800f6f2:	d038      	beq.n	800f766 <recv_raw+0x76>
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    ip_addr_t *addr)
{
 800f6f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  struct netconn *conn;

  LWIP_UNUSED_ARG(addr);
  conn = (struct netconn *)arg;

  if ((conn != NULL) && sys_mbox_valid(&conn->recvmbox)) {
 800f6f8:	f100 0710 	add.w	r7, r0, #16
 800f6fc:	4605      	mov	r5, r0
 800f6fe:	4638      	mov	r0, r7
 800f700:	4614      	mov	r4, r2
 800f702:	460e      	mov	r6, r1
 800f704:	f7f8 fb04 	bl	8007d10 <sys_mbox_valid>
 800f708:	b910      	cbnz	r0, 800f710 <recv_raw+0x20>
      }
    }
  }

  return 0; /* do not eat the packet */
}
 800f70a:	2000      	movs	r0, #0
 800f70c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize) {
      return 0;
    }
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 800f710:	2003      	movs	r0, #3
 800f712:	8921      	ldrh	r1, [r4, #8]
 800f714:	2200      	movs	r2, #0
 800f716:	f7f9 fef3 	bl	8009500 <pbuf_alloc>
    if(q != NULL) {
 800f71a:	4680      	mov	r8, r0
 800f71c:	2800      	cmp	r0, #0
 800f71e:	d0f4      	beq.n	800f70a <recv_raw+0x1a>
      if (pbuf_copy(q, p) != ERR_OK) {
 800f720:	4621      	mov	r1, r4
 800f722:	f7fa f90d 	bl	8009940 <pbuf_copy>
 800f726:	bb00      	cbnz	r0, 800f76a <recv_raw+0x7a>
      }
    }

    if (q != NULL) {
      u16_t len;
      buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 800f728:	2007      	movs	r0, #7
 800f72a:	f7f9 fbf1 	bl	8008f10 <memp_malloc>
      if (buf == NULL) {
 800f72e:	4604      	mov	r4, r0
 800f730:	b1d8      	cbz	r0, 800f76a <recv_raw+0x7a>
        return 0;
      }

      buf->p = q;
      buf->ptr = q;
      ip_addr_copy(buf->addr, *ip_current_src_addr());
 800f732:	4b12      	ldr	r3, [pc, #72]	; (800f77c <recv_raw+0x8c>)
      if (buf == NULL) {
        pbuf_free(q);
        return 0;
      }

      buf->p = q;
 800f734:	f8c4 8000 	str.w	r8, [r4]
      buf->ptr = q;
      ip_addr_copy(buf->addr, *ip_current_src_addr());
 800f738:	681b      	ldr	r3, [r3, #0]
        pbuf_free(q);
        return 0;
      }

      buf->p = q;
      buf->ptr = q;
 800f73a:	f8c4 8004 	str.w	r8, [r4, #4]
      ip_addr_copy(buf->addr, *ip_current_src_addr());
 800f73e:	60a3      	str	r3, [r4, #8]
      buf->port = pcb->protocol;
 800f740:	7c33      	ldrb	r3, [r6, #16]
 800f742:	81a3      	strh	r3, [r4, #12]

      len = q->tot_len;
      if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 800f744:	4621      	mov	r1, r4
 800f746:	4638      	mov	r0, r7
      buf->p = q;
      buf->ptr = q;
      ip_addr_copy(buf->addr, *ip_current_src_addr());
      buf->port = pcb->protocol;

      len = q->tot_len;
 800f748:	f8b8 6008 	ldrh.w	r6, [r8, #8]
      if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 800f74c:	f7f8 fa98 	bl	8007c80 <sys_mbox_trypost>
 800f750:	4601      	mov	r1, r0
 800f752:	b970      	cbnz	r0, 800f772 <recv_raw+0x82>
      } else {
#if LWIP_SO_RCVBUF
        SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
        /* Register event with callback */
        API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 800f754:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800f756:	2b00      	cmp	r3, #0
 800f758:	d0d7      	beq.n	800f70a <recv_raw+0x1a>
 800f75a:	4628      	mov	r0, r5
 800f75c:	4632      	mov	r2, r6
 800f75e:	4798      	blx	r3
      }
    }
  }

  return 0; /* do not eat the packet */
}
 800f760:	2000      	movs	r0, #0
 800f762:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800f766:	2000      	movs	r0, #0
 800f768:	4770      	bx	lr

    if (q != NULL) {
      u16_t len;
      buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
 800f76a:	4640      	mov	r0, r8
 800f76c:	f7f9 fe48 	bl	8009400 <pbuf_free>
        return 0;
 800f770:	e7cb      	b.n	800f70a <recv_raw+0x1a>
      ip_addr_copy(buf->addr, *ip_current_src_addr());
      buf->port = pcb->protocol;

      len = q->tot_len;
      if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
        netbuf_delete(buf);
 800f772:	4620      	mov	r0, r4
 800f774:	f001 f834 	bl	80107e0 <netbuf_delete>
        return 0;
 800f778:	e7c7      	b.n	800f70a <recv_raw+0x1a>
 800f77a:	bf00      	nop
 800f77c:	2000cbac 	.word	0x2000cbac

0800f780 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
 800f780:	b510      	push	{r4, lr}
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
 800f782:	6844      	ldr	r4, [r0, #4]
  tcp_arg(pcb, conn);
 800f784:	4601      	mov	r1, r0
 800f786:	4620      	mov	r0, r4
 800f788:	f7fa fc82 	bl	800a090 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
 800f78c:	4620      	mov	r0, r4
 800f78e:	4909      	ldr	r1, [pc, #36]	; (800f7b4 <setup_tcp+0x34>)
 800f790:	f7fa fc86 	bl	800a0a0 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
 800f794:	4620      	mov	r0, r4
 800f796:	4908      	ldr	r1, [pc, #32]	; (800f7b8 <setup_tcp+0x38>)
 800f798:	f7fa fcaa 	bl	800a0f0 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
 800f79c:	4620      	mov	r0, r4
 800f79e:	4907      	ldr	r1, [pc, #28]	; (800f7bc <setup_tcp+0x3c>)
 800f7a0:	2204      	movs	r2, #4
 800f7a2:	f7fa fcfd 	bl	800a1a0 <tcp_poll>
  tcp_err(pcb, err_tcp);
 800f7a6:	4620      	mov	r0, r4
 800f7a8:	4905      	ldr	r1, [pc, #20]	; (800f7c0 <setup_tcp+0x40>)
}
 800f7aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  pcb = conn->pcb.tcp;
  tcp_arg(pcb, conn);
  tcp_recv(pcb, recv_tcp);
  tcp_sent(pcb, sent_tcp);
  tcp_poll(pcb, poll_tcp, 4);
  tcp_err(pcb, err_tcp);
 800f7ae:	f7fa bcc7 	b.w	800a140 <tcp_err>
 800f7b2:	bf00      	nop
 800f7b4:	0800f801 	.word	0x0800f801
 800f7b8:	0800fd91 	.word	0x0800fd91
 800f7bc:	0800fd01 	.word	0x0800fd01
 800f7c0:	0800fe11 	.word	0x0800fe11
 800f7c4:	f3af 8000 	nop.w
 800f7c8:	f3af 8000 	nop.w
 800f7cc:	f3af 8000 	nop.w

0800f7d0 <chprintf.constprop.1>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 800f7d0:	b40e      	push	{r1, r2, r3}
 800f7d2:	b500      	push	{lr}
 800f7d4:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800f7d6:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 800f7d8:	461a      	mov	r2, r3
 800f7da:	4905      	ldr	r1, [pc, #20]	; (800f7f0 <chprintf.constprop.1+0x20>)
 800f7dc:	4805      	ldr	r0, [pc, #20]	; (800f7f4 <chprintf.constprop.1+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800f7de:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800f7e0:	f001 fa8e 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 800f7e4:	b002      	add	sp, #8
 800f7e6:	f85d eb04 	ldr.w	lr, [sp], #4
 800f7ea:	b003      	add	sp, #12
 800f7ec:	4770      	bx	lr
 800f7ee:	bf00      	nop
 800f7f0:	08016fe0 	.word	0x08016fe0
 800f7f4:	200180c8 	.word	0x200180c8
 800f7f8:	f3af 8000 	nop.w
 800f7fc:	f3af 8000 	nop.w

0800f800 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 800f800:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800f804:	4604      	mov	r4, r0
 800f806:	b083      	sub	sp, #12
 800f808:	4616      	mov	r6, r2
 800f80a:	4699      	mov	r9, r3
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
 800f80c:	460f      	mov	r7, r1
 800f80e:	2900      	cmp	r1, #0
 800f810:	d040      	beq.n	800f894 <recv_tcp+0x94>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
 800f812:	2c00      	cmp	r4, #0
 800f814:	d04c      	beq.n	800f8b0 <recv_tcp+0xb0>
  conn = (struct netconn *)arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
 800f816:	6863      	ldr	r3, [r4, #4]
 800f818:	42bb      	cmp	r3, r7
 800f81a:	d00a      	beq.n	800f832 <recv_tcp+0x32>
 800f81c:	4b2b      	ldr	r3, [pc, #172]	; (800f8cc <recv_tcp+0xcc>)
 800f81e:	9300      	str	r3, [sp, #0]
 800f820:	482b      	ldr	r0, [pc, #172]	; (800f8d0 <recv_tcp+0xd0>)
 800f822:	492c      	ldr	r1, [pc, #176]	; (800f8d4 <recv_tcp+0xd4>)
 800f824:	4a2c      	ldr	r2, [pc, #176]	; (800f8d8 <recv_tcp+0xd8>)
 800f826:	23e1      	movs	r3, #225	; 0xe1
 800f828:	f7ff ffd2 	bl	800f7d0 <chprintf.constprop.1>
 800f82c:	482a      	ldr	r0, [pc, #168]	; (800f8d8 <recv_tcp+0xd8>)
 800f82e:	f7f1 fb9f 	bl	8000f70 <chSysHalt>

  if (conn == NULL) {
    return ERR_VAL;
  }
  if (!sys_mbox_valid(&conn->recvmbox)) {
 800f832:	f104 0810 	add.w	r8, r4, #16
 800f836:	4640      	mov	r0, r8
 800f838:	f7f8 fa6a 	bl	8007d10 <sys_mbox_valid>
 800f83c:	4605      	mov	r5, r0
 800f83e:	b980      	cbnz	r0, 800f862 <recv_tcp+0x62>
    /* recvmbox already deleted */
    if (p != NULL) {
 800f840:	b156      	cbz	r6, 800f858 <recv_tcp+0x58>
      tcp_recved(pcb, p->tot_len);
 800f842:	4638      	mov	r0, r7
 800f844:	8931      	ldrh	r1, [r6, #8]
 800f846:	f7fa fb9b 	bl	8009f80 <tcp_recved>
      pbuf_free(p);
 800f84a:	4630      	mov	r0, r6
 800f84c:	f7f9 fdd8 	bl	8009400 <pbuf_free>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  }

  return ERR_OK;
}
 800f850:	b268      	sxtb	r0, r5
 800f852:	b003      	add	sp, #12
 800f854:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    /* recvmbox already deleted */
    if (p != NULL) {
      tcp_recved(pcb, p->tot_len);
      pbuf_free(p);
    }
    return ERR_OK;
 800f858:	2500      	movs	r5, #0
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  }

  return ERR_OK;
}
 800f85a:	b268      	sxtb	r0, r5
 800f85c:	b003      	add	sp, #12
 800f85e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  /* Unlike for UDP or RAW pcbs, don't check for available space
     using recv_avail since that could break the connection
     (data is already ACKed) */

  /* don't overwrite fatal errors! */
  NETCONN_SET_SAFE_ERR(conn, err);
 800f862:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800f866:	3309      	adds	r3, #9
 800f868:	bfa8      	it	ge
 800f86a:	f884 9008 	strbge.w	r9, [r4, #8]

  if (p != NULL) {
 800f86e:	b1ee      	cbz	r6, 800f8ac <recv_tcp+0xac>
    len = p->tot_len;
 800f870:	8937      	ldrh	r7, [r6, #8]
  } else {
    len = 0;
  }

  if (sys_mbox_trypost(&conn->recvmbox, p) != ERR_OK) {
 800f872:	4640      	mov	r0, r8
 800f874:	4631      	mov	r1, r6
 800f876:	f7f8 fa03 	bl	8007c80 <sys_mbox_trypost>
 800f87a:	4605      	mov	r5, r0
 800f87c:	bb20      	cbnz	r0, 800f8c8 <recv_tcp+0xc8>
  } else {
#if LWIP_SO_RCVBUF
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 800f87e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800f880:	2b00      	cmp	r3, #0
 800f882:	d0e9      	beq.n	800f858 <recv_tcp+0x58>
 800f884:	4620      	mov	r0, r4
 800f886:	463a      	mov	r2, r7
 800f888:	4629      	mov	r1, r5
 800f88a:	4798      	blx	r3
  }

  return ERR_OK;
}
 800f88c:	b268      	sxtb	r0, r5
 800f88e:	b003      	add	sp, #12
 800f890:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
{
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
 800f894:	4b0d      	ldr	r3, [pc, #52]	; (800f8cc <recv_tcp+0xcc>)
 800f896:	9300      	str	r3, [sp, #0]
 800f898:	490e      	ldr	r1, [pc, #56]	; (800f8d4 <recv_tcp+0xd4>)
 800f89a:	4a10      	ldr	r2, [pc, #64]	; (800f8dc <recv_tcp+0xdc>)
 800f89c:	480c      	ldr	r0, [pc, #48]	; (800f8d0 <recv_tcp+0xd0>)
 800f89e:	23de      	movs	r3, #222	; 0xde
 800f8a0:	f7ff ff96 	bl	800f7d0 <chprintf.constprop.1>
 800f8a4:	480d      	ldr	r0, [pc, #52]	; (800f8dc <recv_tcp+0xdc>)
 800f8a6:	f7f1 fb63 	bl	8000f70 <chSysHalt>
 800f8aa:	e7b2      	b.n	800f812 <recv_tcp+0x12>
  NETCONN_SET_SAFE_ERR(conn, err);

  if (p != NULL) {
    len = p->tot_len;
  } else {
    len = 0;
 800f8ac:	4637      	mov	r7, r6
 800f8ae:	e7e0      	b.n	800f872 <recv_tcp+0x72>
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
 800f8b0:	4b06      	ldr	r3, [pc, #24]	; (800f8cc <recv_tcp+0xcc>)
 800f8b2:	9300      	str	r3, [sp, #0]
 800f8b4:	4907      	ldr	r1, [pc, #28]	; (800f8d4 <recv_tcp+0xd4>)
 800f8b6:	4a0a      	ldr	r2, [pc, #40]	; (800f8e0 <recv_tcp+0xe0>)
 800f8b8:	4805      	ldr	r0, [pc, #20]	; (800f8d0 <recv_tcp+0xd0>)
 800f8ba:	23df      	movs	r3, #223	; 0xdf
 800f8bc:	f7ff ff88 	bl	800f7d0 <chprintf.constprop.1>
 800f8c0:	4807      	ldr	r0, [pc, #28]	; (800f8e0 <recv_tcp+0xe0>)
 800f8c2:	f7f1 fb55 	bl	8000f70 <chSysHalt>
 800f8c6:	e7a6      	b.n	800f816 <recv_tcp+0x16>
    len = 0;
  }

  if (sys_mbox_trypost(&conn->recvmbox, p) != ERR_OK) {
    /* don't deallocate p: it is presented to us later again from tcp_fasttmr! */
    return ERR_MEM;
 800f8c8:	25ff      	movs	r5, #255	; 0xff
 800f8ca:	e7c1      	b.n	800f850 <recv_tcp+0x50>
 800f8cc:	08018ab4 	.word	0x08018ab4
 800f8d0:	200180c8 	.word	0x200180c8
 800f8d4:	08016fe0 	.word	0x08016fe0
 800f8d8:	08018b04 	.word	0x08018b04
 800f8dc:	08018a90 	.word	0x08018a90
 800f8e0:	08018ae4 	.word	0x08018ae4
 800f8e4:	f3af 8000 	nop.w
 800f8e8:	f3af 8000 	nop.w
 800f8ec:	f3af 8000 	nop.w

0800f8f0 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
 800f8f0:	b5f0      	push	{r4, r5, r6, r7, lr}
  err_t err;
  u8_t shut, shut_rx, shut_tx, close;

  LWIP_ASSERT("invalid conn", (conn != NULL));
 800f8f2:	4604      	mov	r4, r0
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
 800f8f4:	b083      	sub	sp, #12
  err_t err;
  u8_t shut, shut_rx, shut_tx, close;

  LWIP_ASSERT("invalid conn", (conn != NULL));
 800f8f6:	2800      	cmp	r0, #0
 800f8f8:	f000 80d2 	beq.w	800faa0 <do_close_internal+0x1b0>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
 800f8fc:	7823      	ldrb	r3, [r4, #0]
 800f8fe:	2b10      	cmp	r3, #16
 800f900:	d00b      	beq.n	800f91a <do_close_internal+0x2a>
 800f902:	4b70      	ldr	r3, [pc, #448]	; (800fac4 <do_close_internal+0x1d4>)
 800f904:	9300      	str	r3, [sp, #0]
 800f906:	4870      	ldr	r0, [pc, #448]	; (800fac8 <do_close_internal+0x1d8>)
 800f908:	4970      	ldr	r1, [pc, #448]	; (800facc <do_close_internal+0x1dc>)
 800f90a:	4a71      	ldr	r2, [pc, #452]	; (800fad0 <do_close_internal+0x1e0>)
 800f90c:	f240 23f1 	movw	r3, #753	; 0x2f1
 800f910:	f7ff ff5e 	bl	800f7d0 <chprintf.constprop.1>
 800f914:	486e      	ldr	r0, [pc, #440]	; (800fad0 <do_close_internal+0x1e0>)
 800f916:	f7f1 fb2b 	bl	8000f70 <chSysHalt>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
 800f91a:	7863      	ldrb	r3, [r4, #1]
 800f91c:	2b04      	cmp	r3, #4
 800f91e:	d00b      	beq.n	800f938 <do_close_internal+0x48>
 800f920:	4b68      	ldr	r3, [pc, #416]	; (800fac4 <do_close_internal+0x1d4>)
 800f922:	9300      	str	r3, [sp, #0]
 800f924:	4868      	ldr	r0, [pc, #416]	; (800fac8 <do_close_internal+0x1d8>)
 800f926:	4969      	ldr	r1, [pc, #420]	; (800facc <do_close_internal+0x1dc>)
 800f928:	4a6a      	ldr	r2, [pc, #424]	; (800fad4 <do_close_internal+0x1e4>)
 800f92a:	f240 23f2 	movw	r3, #754	; 0x2f2
 800f92e:	f7ff ff4f 	bl	800f7d0 <chprintf.constprop.1>
 800f932:	4868      	ldr	r0, [pc, #416]	; (800fad4 <do_close_internal+0x1e4>)
 800f934:	f7f1 fb1c 	bl	8000f70 <chSysHalt>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
 800f938:	6863      	ldr	r3, [r4, #4]
 800f93a:	2b00      	cmp	r3, #0
 800f93c:	f000 8095 	beq.w	800fa6a <do_close_internal+0x17a>
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 800f940:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800f942:	2b00      	cmp	r3, #0
 800f944:	f000 809e 	beq.w	800fa84 <do_close_internal+0x194>

  shut = conn->current_msg->msg.sd.shut;
 800f948:	7a19      	ldrb	r1, [r3, #8]
  /* shutting down both ends is the same as closing */
  close = shut == NETCONN_SHUT_RDWR;

  /* Set back some callback pointers */
  if (close) {
    tcp_arg(conn->pcb.tcp, NULL);
 800f94a:	6860      	ldr	r0, [r4, #4]
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);

  shut = conn->current_msg->msg.sd.shut;
  shut_rx = shut & NETCONN_SHUT_RD;
  shut_tx = shut & NETCONN_SHUT_WR;
 800f94c:	f001 0602 	and.w	r6, r1, #2
  /* shutting down both ends is the same as closing */
  close = shut == NETCONN_SHUT_RDWR;
 800f950:	f1a1 0703 	sub.w	r7, r1, #3
 800f954:	fab7 f787 	clz	r7, r7
 800f958:	097f      	lsrs	r7, r7, #5
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);

  shut = conn->current_msg->msg.sd.shut;
  shut_rx = shut & NETCONN_SHUT_RD;
  shut_tx = shut & NETCONN_SHUT_WR;
 800f95a:	b2f6      	uxtb	r6, r6
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);

  shut = conn->current_msg->msg.sd.shut;
  shut_rx = shut & NETCONN_SHUT_RD;
 800f95c:	f001 0501 	and.w	r5, r1, #1
  shut_tx = shut & NETCONN_SHUT_WR;
  /* shutting down both ends is the same as closing */
  close = shut == NETCONN_SHUT_RDWR;

  /* Set back some callback pointers */
  if (close) {
 800f960:	2f00      	cmp	r7, #0
 800f962:	d169      	bne.n	800fa38 <do_close_internal+0x148>
    tcp_arg(conn->pcb.tcp, NULL);
  }
  if (conn->pcb.tcp->state == LISTEN) {
 800f964:	7e03      	ldrb	r3, [r0, #24]
 800f966:	2b01      	cmp	r3, #1
 800f968:	f000 80a7 	beq.w	800faba <do_close_internal+0x1ca>
    tcp_accept(conn->pcb.tcp, NULL);
  } else {
    /* some callbacks have to be reset if tcp_close is not successful */
    if (shut_rx) {
 800f96c:	2d00      	cmp	r5, #0
 800f96e:	d158      	bne.n	800fa22 <do_close_internal+0x132>
      tcp_recv(conn->pcb.tcp, NULL);
      tcp_accept(conn->pcb.tcp, NULL);
    }
    if (shut_tx) {
 800f970:	2e00      	cmp	r6, #0
 800f972:	d136      	bne.n	800f9e2 <do_close_internal+0xf2>
      tcp_sent(conn->pcb.tcp, NULL);
    }
    if (close) {
 800f974:	2f00      	cmp	r7, #0
 800f976:	d13a      	bne.n	800f9ee <do_close_internal+0xfe>
  }
  /* Try to close the connection */
  if (close) {
    err = tcp_close(conn->pcb.tcp);
  } else {
    err = tcp_shutdown(conn->pcb.tcp, shut_rx, shut_tx);
 800f978:	4629      	mov	r1, r5
 800f97a:	4632      	mov	r2, r6
 800f97c:	f7fb f8c8 	bl	800ab10 <tcp_shutdown>
  }
  if (err == ERR_OK) {
 800f980:	b9c0      	cbnz	r0, 800f9b4 <do_close_internal+0xc4>
    /* Closing succeeded */
    conn->current_msg->err = ERR_OK;
 800f982:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800f984:	7118      	strb	r0, [r3, #4]
    conn->current_msg = NULL;
 800f986:	6260      	str	r0, [r4, #36]	; 0x24
    conn->state = NETCONN_NONE;
 800f988:	7060      	strb	r0, [r4, #1]
      conn->pcb.tcp = NULL;
      /* Trigger select() in socket layer. Make sure everybody notices activity
       on the connection, error first! */
      API_EVENT(conn, NETCONN_EVT_ERROR, 0);
    }
    if (shut_rx) {
 800f98a:	b12d      	cbz	r5, 800f998 <do_close_internal+0xa8>
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 800f98c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800f98e:	b153      	cbz	r3, 800f9a6 <do_close_internal+0xb6>
 800f990:	2100      	movs	r1, #0
 800f992:	460a      	mov	r2, r1
 800f994:	4620      	mov	r0, r4
 800f996:	4798      	blx	r3
    }
    if (shut_tx) {
 800f998:	b12e      	cbz	r6, 800f9a6 <do_close_internal+0xb6>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 800f99a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800f99c:	b11b      	cbz	r3, 800f9a6 <do_close_internal+0xb6>
 800f99e:	4620      	mov	r0, r4
 800f9a0:	2102      	movs	r1, #2
 800f9a2:	2200      	movs	r2, #0
 800f9a4:	4798      	blx	r3
    }
    /* wake up the application task */
    sys_sem_signal(&conn->op_completed);
 800f9a6:	f104 000c 	add.w	r0, r4, #12
    tcp_arg(conn->pcb.tcp, conn);
    /* don't restore recv callback: we don't want to receive any more data */
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
 800f9aa:	b003      	add	sp, #12
 800f9ac:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    }
    if (shut_tx) {
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
    }
    /* wake up the application task */
    sys_sem_signal(&conn->op_completed);
 800f9b0:	f7f8 b8d6 	b.w	8007b60 <sys_sem_signal>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
 800f9b4:	6860      	ldr	r0, [r4, #4]
 800f9b6:	7e03      	ldrb	r3, [r0, #24]
 800f9b8:	2b01      	cmp	r3, #1
 800f9ba:	d048      	beq.n	800fa4e <do_close_internal+0x15e>
    tcp_sent(conn->pcb.tcp, sent_tcp);
 800f9bc:	4946      	ldr	r1, [pc, #280]	; (800fad8 <do_close_internal+0x1e8>)
 800f9be:	f7fa fb97 	bl	800a0f0 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
 800f9c2:	6860      	ldr	r0, [r4, #4]
 800f9c4:	4945      	ldr	r1, [pc, #276]	; (800fadc <do_close_internal+0x1ec>)
 800f9c6:	2204      	movs	r2, #4
 800f9c8:	f7fa fbea 	bl	800a1a0 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
 800f9cc:	6860      	ldr	r0, [r4, #4]
 800f9ce:	4944      	ldr	r1, [pc, #272]	; (800fae0 <do_close_internal+0x1f0>)
 800f9d0:	f7fa fbb6 	bl	800a140 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
 800f9d4:	6860      	ldr	r0, [r4, #4]
 800f9d6:	4621      	mov	r1, r4
    /* don't restore recv callback: we don't want to receive any more data */
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
 800f9d8:	b003      	add	sp, #12
 800f9da:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
    tcp_sent(conn->pcb.tcp, sent_tcp);
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
    tcp_err(conn->pcb.tcp, err_tcp);
    tcp_arg(conn->pcb.tcp, conn);
 800f9de:	f7fa bb57 	b.w	800a090 <tcp_arg>
    if (shut_rx) {
      tcp_recv(conn->pcb.tcp, NULL);
      tcp_accept(conn->pcb.tcp, NULL);
    }
    if (shut_tx) {
      tcp_sent(conn->pcb.tcp, NULL);
 800f9e2:	2100      	movs	r1, #0
 800f9e4:	f7fa fb84 	bl	800a0f0 <tcp_sent>
 800f9e8:	6860      	ldr	r0, [r4, #4]
    }
    if (close) {
 800f9ea:	2f00      	cmp	r7, #0
 800f9ec:	d0c4      	beq.n	800f978 <do_close_internal+0x88>
      tcp_poll(conn->pcb.tcp, NULL, 4);
 800f9ee:	2100      	movs	r1, #0
 800f9f0:	2204      	movs	r2, #4
 800f9f2:	f7fa fbd5 	bl	800a1a0 <tcp_poll>
      tcp_err(conn->pcb.tcp, NULL);
 800f9f6:	6860      	ldr	r0, [r4, #4]
 800f9f8:	2100      	movs	r1, #0
 800f9fa:	f7fa fba1 	bl	800a140 <tcp_err>
    }
  }
  /* Try to close the connection */
  if (close) {
    err = tcp_close(conn->pcb.tcp);
 800f9fe:	6860      	ldr	r0, [r4, #4]
 800fa00:	f7fa ffd6 	bl	800a9b0 <tcp_close>
  } else {
    err = tcp_shutdown(conn->pcb.tcp, shut_rx, shut_tx);
  }
  if (err == ERR_OK) {
 800fa04:	2800      	cmp	r0, #0
 800fa06:	d1d5      	bne.n	800f9b4 <do_close_internal+0xc4>
    /* Closing succeeded */
    conn->current_msg->err = ERR_OK;
 800fa08:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800fa0a:	7118      	strb	r0, [r3, #4]
    if (close) {
      /* Set back some callback pointers as conn is going away */
      conn->pcb.tcp = NULL;
      /* Trigger select() in socket layer. Make sure everybody notices activity
       on the connection, error first! */
      API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 800fa0c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    err = tcp_shutdown(conn->pcb.tcp, shut_rx, shut_tx);
  }
  if (err == ERR_OK) {
    /* Closing succeeded */
    conn->current_msg->err = ERR_OK;
    conn->current_msg = NULL;
 800fa0e:	6260      	str	r0, [r4, #36]	; 0x24
    conn->state = NETCONN_NONE;
 800fa10:	7060      	strb	r0, [r4, #1]
    if (close) {
      /* Set back some callback pointers as conn is going away */
      conn->pcb.tcp = NULL;
 800fa12:	6060      	str	r0, [r4, #4]
      /* Trigger select() in socket layer. Make sure everybody notices activity
       on the connection, error first! */
      API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 800fa14:	2b00      	cmp	r3, #0
 800fa16:	d0bf      	beq.n	800f998 <do_close_internal+0xa8>
 800fa18:	4602      	mov	r2, r0
 800fa1a:	2104      	movs	r1, #4
 800fa1c:	4620      	mov	r0, r4
 800fa1e:	4798      	blx	r3
 800fa20:	e7b3      	b.n	800f98a <do_close_internal+0x9a>
  if (conn->pcb.tcp->state == LISTEN) {
    tcp_accept(conn->pcb.tcp, NULL);
  } else {
    /* some callbacks have to be reset if tcp_close is not successful */
    if (shut_rx) {
      tcp_recv(conn->pcb.tcp, NULL);
 800fa22:	2100      	movs	r1, #0
 800fa24:	f7fa fb3c 	bl	800a0a0 <tcp_recv>
      tcp_accept(conn->pcb.tcp, NULL);
 800fa28:	6860      	ldr	r0, [r4, #4]
 800fa2a:	2100      	movs	r1, #0
 800fa2c:	f7fa fbb0 	bl	800a190 <tcp_accept>
 800fa30:	6860      	ldr	r0, [r4, #4]
    }
    if (shut_tx) {
 800fa32:	2e00      	cmp	r6, #0
 800fa34:	d09e      	beq.n	800f974 <do_close_internal+0x84>
 800fa36:	e7d4      	b.n	800f9e2 <do_close_internal+0xf2>
  /* shutting down both ends is the same as closing */
  close = shut == NETCONN_SHUT_RDWR;

  /* Set back some callback pointers */
  if (close) {
    tcp_arg(conn->pcb.tcp, NULL);
 800fa38:	2100      	movs	r1, #0
 800fa3a:	f7fa fb29 	bl	800a090 <tcp_arg>
  }
  if (conn->pcb.tcp->state == LISTEN) {
 800fa3e:	6860      	ldr	r0, [r4, #4]
 800fa40:	7e03      	ldrb	r3, [r0, #24]
 800fa42:	2b01      	cmp	r3, #1
 800fa44:	d192      	bne.n	800f96c <do_close_internal+0x7c>
    tcp_accept(conn->pcb.tcp, NULL);
 800fa46:	2100      	movs	r1, #0
 800fa48:	f7fa fba2 	bl	800a190 <tcp_accept>
 800fa4c:	e7d7      	b.n	800f9fe <do_close_internal+0x10e>
    /* wake up the application task */
    sys_sem_signal(&conn->op_completed);
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
 800fa4e:	4b1d      	ldr	r3, [pc, #116]	; (800fac4 <do_close_internal+0x1d4>)
 800fa50:	9300      	str	r3, [sp, #0]
 800fa52:	491e      	ldr	r1, [pc, #120]	; (800facc <do_close_internal+0x1dc>)
 800fa54:	4a23      	ldr	r2, [pc, #140]	; (800fae4 <do_close_internal+0x1f4>)
 800fa56:	481c      	ldr	r0, [pc, #112]	; (800fac8 <do_close_internal+0x1d8>)
 800fa58:	f240 332d 	movw	r3, #813	; 0x32d
 800fa5c:	f7ff feb8 	bl	800f7d0 <chprintf.constprop.1>
 800fa60:	4820      	ldr	r0, [pc, #128]	; (800fae4 <do_close_internal+0x1f4>)
 800fa62:	f7f1 fa85 	bl	8000f70 <chSysHalt>
 800fa66:	6860      	ldr	r0, [r4, #4]
 800fa68:	e7a8      	b.n	800f9bc <do_close_internal+0xcc>
  u8_t shut, shut_rx, shut_tx, close;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
 800fa6a:	4b16      	ldr	r3, [pc, #88]	; (800fac4 <do_close_internal+0x1d4>)
 800fa6c:	9300      	str	r3, [sp, #0]
 800fa6e:	4917      	ldr	r1, [pc, #92]	; (800facc <do_close_internal+0x1dc>)
 800fa70:	4a1d      	ldr	r2, [pc, #116]	; (800fae8 <do_close_internal+0x1f8>)
 800fa72:	4815      	ldr	r0, [pc, #84]	; (800fac8 <do_close_internal+0x1d8>)
 800fa74:	f240 23f3 	movw	r3, #755	; 0x2f3
 800fa78:	f7ff feaa 	bl	800f7d0 <chprintf.constprop.1>
 800fa7c:	481a      	ldr	r0, [pc, #104]	; (800fae8 <do_close_internal+0x1f8>)
 800fa7e:	f7f1 fa77 	bl	8000f70 <chSysHalt>
 800fa82:	e75d      	b.n	800f940 <do_close_internal+0x50>
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 800fa84:	4b0f      	ldr	r3, [pc, #60]	; (800fac4 <do_close_internal+0x1d4>)
 800fa86:	9300      	str	r3, [sp, #0]
 800fa88:	4910      	ldr	r1, [pc, #64]	; (800facc <do_close_internal+0x1dc>)
 800fa8a:	4a18      	ldr	r2, [pc, #96]	; (800faec <do_close_internal+0x1fc>)
 800fa8c:	480e      	ldr	r0, [pc, #56]	; (800fac8 <do_close_internal+0x1d8>)
 800fa8e:	f44f 733d 	mov.w	r3, #756	; 0x2f4
 800fa92:	f7ff fe9d 	bl	800f7d0 <chprintf.constprop.1>
 800fa96:	4815      	ldr	r0, [pc, #84]	; (800faec <do_close_internal+0x1fc>)
 800fa98:	f7f1 fa6a 	bl	8000f70 <chSysHalt>
 800fa9c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800fa9e:	e753      	b.n	800f948 <do_close_internal+0x58>
do_close_internal(struct netconn *conn)
{
  err_t err;
  u8_t shut, shut_rx, shut_tx, close;

  LWIP_ASSERT("invalid conn", (conn != NULL));
 800faa0:	4b08      	ldr	r3, [pc, #32]	; (800fac4 <do_close_internal+0x1d4>)
 800faa2:	9300      	str	r3, [sp, #0]
 800faa4:	4909      	ldr	r1, [pc, #36]	; (800facc <do_close_internal+0x1dc>)
 800faa6:	4a12      	ldr	r2, [pc, #72]	; (800faf0 <do_close_internal+0x200>)
 800faa8:	4807      	ldr	r0, [pc, #28]	; (800fac8 <do_close_internal+0x1d8>)
 800faaa:	f44f 733c 	mov.w	r3, #752	; 0x2f0
 800faae:	f7ff fe8f 	bl	800f7d0 <chprintf.constprop.1>
 800fab2:	480f      	ldr	r0, [pc, #60]	; (800faf0 <do_close_internal+0x200>)
 800fab4:	f7f1 fa5c 	bl	8000f70 <chSysHalt>
 800fab8:	e720      	b.n	800f8fc <do_close_internal+0xc>
  /* Set back some callback pointers */
  if (close) {
    tcp_arg(conn->pcb.tcp, NULL);
  }
  if (conn->pcb.tcp->state == LISTEN) {
    tcp_accept(conn->pcb.tcp, NULL);
 800faba:	4639      	mov	r1, r7
 800fabc:	f7fa fb68 	bl	800a190 <tcp_accept>
 800fac0:	6860      	ldr	r0, [r4, #4]
 800fac2:	e759      	b.n	800f978 <do_close_internal+0x88>
 800fac4:	08018ab4 	.word	0x08018ab4
 800fac8:	200180c8 	.word	0x200180c8
 800facc:	08016fe0 	.word	0x08016fe0
 800fad0:	08018b24 	.word	0x08018b24
 800fad4:	08018b44 	.word	0x08018b44
 800fad8:	0800fd91 	.word	0x0800fd91
 800fadc:	0800fd01 	.word	0x0800fd01
 800fae0:	0800fe11 	.word	0x0800fe11
 800fae4:	08018b98 	.word	0x08018b98
 800fae8:	08018b68 	.word	0x08018b68
 800faec:	08018b7c 	.word	0x08018b7c
 800faf0:	080189b4 	.word	0x080189b4
 800faf4:	f3af 8000 	nop.w
 800faf8:	f3af 8000 	nop.w
 800fafc:	f3af 8000 	nop.w

0800fb00 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
 800fb00:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  size_t diff;
  u8_t dontblock = netconn_is_nonblocking(conn) ||
 800fb04:	7f03      	ldrb	r3, [r0, #28]
 800fb06:	f013 0f02 	tst.w	r3, #2
 800fb0a:	6a43      	ldr	r3, [r0, #36]	; 0x24
       (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
 800fb0c:	bf0c      	ite	eq
 800fb0e:	7c1e      	ldrbeq	r6, [r3, #16]
 800fb10:	7c1e      	ldrbne	r6, [r3, #16]
  u8_t apiflags = conn->current_msg->msg.w.apiflags;

  LWIP_ASSERT("conn != NULL", conn != NULL);
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
 800fb12:	7843      	ldrb	r3, [r0, #1]
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  size_t diff;
  u8_t dontblock = netconn_is_nonblocking(conn) ||
 800fb14:	bf14      	ite	ne
 800fb16:	f04f 0801 	movne.w	r8, #1
 800fb1a:	f3c6 0880 	ubfxeq	r8, r6, #2, #1
       (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
  u8_t apiflags = conn->current_msg->msg.w.apiflags;

  LWIP_ASSERT("conn != NULL", conn != NULL);
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
 800fb1e:	2b01      	cmp	r3, #1
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
 800fb20:	b083      	sub	sp, #12
 800fb22:	4604      	mov	r4, r0
  u8_t dontblock = netconn_is_nonblocking(conn) ||
       (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
  u8_t apiflags = conn->current_msg->msg.w.apiflags;

  LWIP_ASSERT("conn != NULL", conn != NULL);
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
 800fb24:	d00f      	beq.n	800fb46 <do_writemore+0x46>
 800fb26:	4d6e      	ldr	r5, [pc, #440]	; (800fce0 <do_writemore+0x1e0>)
 800fb28:	496e      	ldr	r1, [pc, #440]	; (800fce4 <do_writemore+0x1e4>)
 800fb2a:	4a6f      	ldr	r2, [pc, #444]	; (800fce8 <do_writemore+0x1e8>)
 800fb2c:	9500      	str	r5, [sp, #0]
 800fb2e:	f240 43c4 	movw	r3, #1220	; 0x4c4
 800fb32:	486e      	ldr	r0, [pc, #440]	; (800fcec <do_writemore+0x1ec>)
 800fb34:	f7ff fe4c 	bl	800f7d0 <chprintf.constprop.1>
 800fb38:	486b      	ldr	r0, [pc, #428]	; (800fce8 <do_writemore+0x1e8>)
 800fb3a:	f7f1 fa19 	bl	8000f70 <chSysHalt>
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 800fb3e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800fb40:	2b00      	cmp	r3, #0
 800fb42:	f000 80a0 	beq.w	800fc86 <do_writemore+0x186>
  LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
 800fb46:	6863      	ldr	r3, [r4, #4]
 800fb48:	2b00      	cmp	r3, #0
 800fb4a:	f000 80ae 	beq.w	800fcaa <do_writemore+0x1aa>
  LWIP_ASSERT("conn->write_offset < conn->current_msg->msg.w.len",
 800fb4e:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800fb50:	6a23      	ldr	r3, [r4, #32]
 800fb52:	68ca      	ldr	r2, [r1, #12]
 800fb54:	4293      	cmp	r3, r2
 800fb56:	d254      	bcs.n	800fc02 <do_writemore+0x102>
#endif
      apiflags |= TCP_WRITE_FLAG_MORE;
    } else {
      len = (u16_t)diff;
    }
    available = tcp_sndbuf(conn->pcb.tcp);
 800fb58:	6860      	ldr	r0, [r4, #4]
      conn->current_msg->msg.w.len = conn->write_offset;
    }
  } else
#endif /* LWIP_SO_SNDTIMEO */
  {
    dataptr = (u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
 800fb5a:	688f      	ldr	r7, [r1, #8]
#endif
      apiflags |= TCP_WRITE_FLAG_MORE;
    } else {
      len = (u16_t)diff;
    }
    available = tcp_sndbuf(conn->pcb.tcp);
 800fb5c:	f8b0 9066 	ldrh.w	r9, [r0, #102]	; 0x66
    }
  } else
#endif /* LWIP_SO_SNDTIMEO */
  {
    dataptr = (u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
    diff = conn->current_msg->msg.w.len - conn->write_offset;
 800fb60:	1ad5      	subs	r5, r2, r3
    if (diff > 0xffffUL) { /* max_u16_t */
 800fb62:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
      len = 0xffff;
 800fb66:	bf2a      	itet	cs
 800fb68:	f64f 75ff 	movwcs	r5, #65535	; 0xffff
#if LWIP_TCPIP_CORE_LOCKING
      conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
      apiflags |= TCP_WRITE_FLAG_MORE;
    } else {
      len = (u16_t)diff;
 800fb6c:	b2ad      	uxthcc	r5, r5
    if (diff > 0xffffUL) { /* max_u16_t */
      len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
      conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
      apiflags |= TCP_WRITE_FLAG_MORE;
 800fb6e:	f046 0602 	orrcs.w	r6, r6, #2
    } else {
      len = (u16_t)diff;
    }
    available = tcp_sndbuf(conn->pcb.tcp);
    if (available < len) {
 800fb72:	454d      	cmp	r5, r9
      conn->current_msg->msg.w.len = conn->write_offset;
    }
  } else
#endif /* LWIP_SO_SNDTIMEO */
  {
    dataptr = (u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
 800fb74:	441f      	add	r7, r3
      apiflags |= TCP_WRITE_FLAG_MORE;
    } else {
      len = (u16_t)diff;
    }
    available = tcp_sndbuf(conn->pcb.tcp);
    if (available < len) {
 800fb76:	d933      	bls.n	800fbe0 <do_writemore+0xe0>
      /* don't try to write more than sendbuf */
      len = available;
      if (dontblock){ 
 800fb78:	f1b8 0f00 	cmp.w	r8, #0
 800fb7c:	d02d      	beq.n	800fbda <do_writemore+0xda>
        if (!len) {
 800fb7e:	f1b9 0f00 	cmp.w	r9, #0
 800fb82:	d12c      	bne.n	800fbde <do_writemore+0xde>
    LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
    err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
    /* if OK or memory error, check available space */
    if ((err == ERR_OK) || (err == ERR_MEM)) {
err_mem:
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
 800fb84:	2a00      	cmp	r2, #0
 800fb86:	f040 809d 	bne.w	800fcc4 <do_writemore+0x1c4>
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
                 (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
        /* The queued byte- or pbuf-count exceeds the configured low-water limit,
           let select mark this pcb as non-writable. */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
 800fb8a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    if (available < len) {
      /* don't try to write more than sendbuf */
      len = available;
      if (dontblock){ 
        if (!len) {
          err = ERR_WOULDBLOCK;
 800fb8c:	26f9      	movs	r6, #249	; 0xf9
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
                 (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
        /* The queued byte- or pbuf-count exceeds the configured low-water limit,
           let select mark this pcb as non-writable. */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
 800fb8e:	2b00      	cmp	r3, #0
 800fb90:	d067      	beq.n	800fc62 <do_writemore+0x162>
 800fb92:	4615      	mov	r5, r2
 800fb94:	4620      	mov	r0, r4
 800fb96:	2103      	movs	r1, #3
 800fb98:	462a      	mov	r2, r5
 800fb9a:	4798      	blx	r3
      }
    }

    if (err == ERR_OK) {
 800fb9c:	2e00      	cmp	r6, #0
 800fb9e:	d160      	bne.n	800fc62 <do_writemore+0x162>
      conn->write_offset += len;
 800fba0:	6a23      	ldr	r3, [r4, #32]
      if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
 800fba2:	6a62      	ldr	r2, [r4, #36]	; 0x24
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
      }
    }

    if (err == ERR_OK) {
      conn->write_offset += len;
 800fba4:	441d      	add	r5, r3
 800fba6:	6225      	str	r5, [r4, #32]
      if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
 800fba8:	68d3      	ldr	r3, [r2, #12]
 800fbaa:	429d      	cmp	r5, r3
 800fbac:	d002      	beq.n	800fbb4 <do_writemore+0xb4>
 800fbae:	f1b8 0f00 	cmp.w	r8, #0
 800fbb2:	d05c      	beq.n	800fc6e <do_writemore+0x16e>
        /* return sent length */
        conn->current_msg->msg.w.len = conn->write_offset;
 800fbb4:	60d5      	str	r5, [r2, #12]
        /* everything was written */
        write_finished = 1;
        conn->write_offset = 0;
 800fbb6:	2300      	movs	r3, #0
      }
      tcp_output(conn->pcb.tcp);
 800fbb8:	6860      	ldr	r0, [r4, #4]
      if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
        /* return sent length */
        conn->current_msg->msg.w.len = conn->write_offset;
        /* everything was written */
        write_finished = 1;
        conn->write_offset = 0;
 800fbba:	6223      	str	r3, [r4, #32]
      }
      tcp_output(conn->pcb.tcp);
 800fbbc:	f7fd fa78 	bl	800d0b0 <tcp_output>
    }
  }
  if (write_finished) {
    /* everything was written: set back connection state
       and back to application task */
    conn->current_msg->err = err;
 800fbc0:	6a62      	ldr	r2, [r4, #36]	; 0x24
    conn->current_msg = NULL;
 800fbc2:	2300      	movs	r3, #0
    }
  }
  if (write_finished) {
    /* everything was written: set back connection state
       and back to application task */
    conn->current_msg->err = err;
 800fbc4:	7116      	strb	r6, [r2, #4]
    conn->state = NETCONN_NONE;
#if LWIP_TCPIP_CORE_LOCKING
    if ((conn->flags & NETCONN_FLAG_WRITE_DELAYED) != 0)
#endif
    {
      sys_sem_signal(&conn->op_completed);
 800fbc6:	f104 000c 	add.w	r0, r4, #12
  }
  if (write_finished) {
    /* everything was written: set back connection state
       and back to application task */
    conn->current_msg->err = err;
    conn->current_msg = NULL;
 800fbca:	6263      	str	r3, [r4, #36]	; 0x24
    conn->state = NETCONN_NONE;
 800fbcc:	7063      	strb	r3, [r4, #1]
#if LWIP_TCPIP_CORE_LOCKING
    if ((conn->flags & NETCONN_FLAG_WRITE_DELAYED) != 0)
#endif
    {
      sys_sem_signal(&conn->op_completed);
 800fbce:	f7f7 ffc7 	bl	8007b60 <sys_sem_signal>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
 800fbd2:	2000      	movs	r0, #0
 800fbd4:	b003      	add	sp, #12
 800fbd6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        }
      } else {
#if LWIP_TCPIP_CORE_LOCKING
        conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
        apiflags |= TCP_WRITE_FLAG_MORE;
 800fbda:	f046 0602 	orr.w	r6, r6, #2
 800fbde:	464d      	mov	r5, r9
      }
    }
    LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
 800fbe0:	442b      	add	r3, r5
 800fbe2:	4293      	cmp	r3, r2
 800fbe4:	d81d      	bhi.n	800fc22 <do_writemore+0x122>
    err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
 800fbe6:	4633      	mov	r3, r6
 800fbe8:	4639      	mov	r1, r7
 800fbea:	462a      	mov	r2, r5
 800fbec:	f7fc fe18 	bl	800c820 <tcp_write>
    /* if OK or memory error, check available space */
    if ((err == ERR_OK) || (err == ERR_MEM)) {
 800fbf0:	1c43      	adds	r3, r0, #1
 800fbf2:	b2db      	uxtb	r3, r3
 800fbf4:	2b01      	cmp	r3, #1
#endif
        apiflags |= TCP_WRITE_FLAG_MORE;
      }
    }
    LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
    err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
 800fbf6:	4606      	mov	r6, r0
    /* if OK or memory error, check available space */
    if ((err == ERR_OK) || (err == ERR_MEM)) {
 800fbf8:	d921      	bls.n	800fc3e <do_writemore+0x13e>
#endif
    } else {
      /* On errors != ERR_MEM, we don't try writing any more but return
         the error to the application thread. */
      write_finished = 1;
      conn->current_msg->msg.w.len = 0;
 800fbfa:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800fbfc:	2200      	movs	r2, #0
 800fbfe:	60da      	str	r2, [r3, #12]
 800fc00:	e7de      	b.n	800fbc0 <do_writemore+0xc0>

  LWIP_ASSERT("conn != NULL", conn != NULL);
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
  LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  LWIP_ASSERT("conn->write_offset < conn->current_msg->msg.w.len",
 800fc02:	4b37      	ldr	r3, [pc, #220]	; (800fce0 <do_writemore+0x1e0>)
 800fc04:	4937      	ldr	r1, [pc, #220]	; (800fce4 <do_writemore+0x1e4>)
 800fc06:	4a3a      	ldr	r2, [pc, #232]	; (800fcf0 <do_writemore+0x1f0>)
 800fc08:	9300      	str	r3, [sp, #0]
 800fc0a:	4838      	ldr	r0, [pc, #224]	; (800fcec <do_writemore+0x1ec>)
 800fc0c:	f44f 6399 	mov.w	r3, #1224	; 0x4c8
 800fc10:	f7ff fdde 	bl	800f7d0 <chprintf.constprop.1>
 800fc14:	4836      	ldr	r0, [pc, #216]	; (800fcf0 <do_writemore+0x1f0>)
 800fc16:	f7f1 f9ab 	bl	8000f70 <chSysHalt>
 800fc1a:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800fc1c:	6a23      	ldr	r3, [r4, #32]
 800fc1e:	68ca      	ldr	r2, [r1, #12]
 800fc20:	e79a      	b.n	800fb58 <do_writemore+0x58>
        conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
        apiflags |= TCP_WRITE_FLAG_MORE;
      }
    }
    LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
 800fc22:	4b2f      	ldr	r3, [pc, #188]	; (800fce0 <do_writemore+0x1e0>)
 800fc24:	9300      	str	r3, [sp, #0]
 800fc26:	492f      	ldr	r1, [pc, #188]	; (800fce4 <do_writemore+0x1e4>)
 800fc28:	4a32      	ldr	r2, [pc, #200]	; (800fcf4 <do_writemore+0x1f4>)
 800fc2a:	4830      	ldr	r0, [pc, #192]	; (800fcec <do_writemore+0x1ec>)
 800fc2c:	f240 43f5 	movw	r3, #1269	; 0x4f5
 800fc30:	f7ff fdce 	bl	800f7d0 <chprintf.constprop.1>
 800fc34:	482f      	ldr	r0, [pc, #188]	; (800fcf4 <do_writemore+0x1f4>)
 800fc36:	f7f1 f99b 	bl	8000f70 <chSysHalt>
 800fc3a:	6860      	ldr	r0, [r4, #4]
 800fc3c:	e7d3      	b.n	800fbe6 <do_writemore+0xe6>
    err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
    /* if OK or memory error, check available space */
    if ((err == ERR_OK) || (err == ERR_MEM)) {
err_mem:
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
 800fc3e:	f1b8 0f00 	cmp.w	r8, #0
 800fc42:	d12c      	bne.n	800fc9e <do_writemore+0x19e>
        /* non-blocking write did not write everything: mark the pcb non-writable
           and let poll_tcp check writable space to mark the pcb writable again */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
 800fc44:	6863      	ldr	r3, [r4, #4]
 800fc46:	f8b3 1066 	ldrh.w	r1, [r3, #102]	; 0x66
 800fc4a:	f240 52b4 	movw	r2, #1460	; 0x5b4
 800fc4e:	4291      	cmp	r1, r2
 800fc50:	d814      	bhi.n	800fc7c <do_writemore+0x17c>
                 (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
        /* The queued byte- or pbuf-count exceeds the configured low-water limit,
           let select mark this pcb as non-writable. */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
 800fc52:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800fc54:	2b00      	cmp	r3, #0
 800fc56:	d0a1      	beq.n	800fb9c <do_writemore+0x9c>
 800fc58:	4620      	mov	r0, r4
 800fc5a:	2103      	movs	r1, #3
 800fc5c:	462a      	mov	r2, r5
 800fc5e:	4798      	blx	r3
 800fc60:	e79c      	b.n	800fb9c <do_writemore+0x9c>
        /* everything was written */
        write_finished = 1;
        conn->write_offset = 0;
      }
      tcp_output(conn->pcb.tcp);
    } else if ((err == ERR_MEM) && !dontblock) {
 800fc62:	b273      	sxtb	r3, r6
 800fc64:	3301      	adds	r3, #1
 800fc66:	d1c8      	bne.n	800fbfa <do_writemore+0xfa>
 800fc68:	f1b8 0f00 	cmp.w	r8, #0
 800fc6c:	d1c5      	bne.n	800fbfa <do_writemore+0xfa>
        conn->current_msg->msg.w.len = conn->write_offset;
        /* everything was written */
        write_finished = 1;
        conn->write_offset = 0;
      }
      tcp_output(conn->pcb.tcp);
 800fc6e:	6860      	ldr	r0, [r4, #4]
 800fc70:	f7fd fa1e 	bl	800d0b0 <tcp_output>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
 800fc74:	2000      	movs	r0, #0
 800fc76:	b003      	add	sp, #12
 800fc78:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
        /* non-blocking write did not write everything: mark the pcb non-writable
           and let poll_tcp check writable space to mark the pcb writable again */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
 800fc7c:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
 800fc80:	2b03      	cmp	r3, #3
 800fc82:	d98b      	bls.n	800fb9c <do_writemore+0x9c>
 800fc84:	e7e5      	b.n	800fc52 <do_writemore+0x152>
       (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
  u8_t apiflags = conn->current_msg->msg.w.apiflags;

  LWIP_ASSERT("conn != NULL", conn != NULL);
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 800fc86:	9500      	str	r5, [sp, #0]
 800fc88:	4916      	ldr	r1, [pc, #88]	; (800fce4 <do_writemore+0x1e4>)
 800fc8a:	4a1b      	ldr	r2, [pc, #108]	; (800fcf8 <do_writemore+0x1f8>)
 800fc8c:	4817      	ldr	r0, [pc, #92]	; (800fcec <do_writemore+0x1ec>)
 800fc8e:	f240 43c5 	movw	r3, #1221	; 0x4c5
 800fc92:	f7ff fd9d 	bl	800f7d0 <chprintf.constprop.1>
 800fc96:	4818      	ldr	r0, [pc, #96]	; (800fcf8 <do_writemore+0x1f8>)
 800fc98:	f7f1 f96a 	bl	8000f70 <chSysHalt>
 800fc9c:	e753      	b.n	800fb46 <do_writemore+0x46>
 800fc9e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
    err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
    /* if OK or memory error, check available space */
    if ((err == ERR_OK) || (err == ERR_MEM)) {
err_mem:
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
 800fca0:	68db      	ldr	r3, [r3, #12]
 800fca2:	429d      	cmp	r5, r3
 800fca4:	d2ce      	bcs.n	800fc44 <do_writemore+0x144>
 800fca6:	46a9      	mov	r9, r5
 800fca8:	e00d      	b.n	800fcc6 <do_writemore+0x1c6>
  u8_t apiflags = conn->current_msg->msg.w.apiflags;

  LWIP_ASSERT("conn != NULL", conn != NULL);
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
  LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
 800fcaa:	4b0d      	ldr	r3, [pc, #52]	; (800fce0 <do_writemore+0x1e0>)
 800fcac:	9300      	str	r3, [sp, #0]
 800fcae:	490d      	ldr	r1, [pc, #52]	; (800fce4 <do_writemore+0x1e4>)
 800fcb0:	4a12      	ldr	r2, [pc, #72]	; (800fcfc <do_writemore+0x1fc>)
 800fcb2:	480e      	ldr	r0, [pc, #56]	; (800fcec <do_writemore+0x1ec>)
 800fcb4:	f240 43c6 	movw	r3, #1222	; 0x4c6
 800fcb8:	f7ff fd8a 	bl	800f7d0 <chprintf.constprop.1>
 800fcbc:	480f      	ldr	r0, [pc, #60]	; (800fcfc <do_writemore+0x1fc>)
 800fcbe:	f7f1 f957 	bl	8000f70 <chSysHalt>
 800fcc2:	e744      	b.n	800fb4e <do_writemore+0x4e>
    if (available < len) {
      /* don't try to write more than sendbuf */
      len = available;
      if (dontblock){ 
        if (!len) {
          err = ERR_WOULDBLOCK;
 800fcc4:	26f9      	movs	r6, #249	; 0xf9
    if ((err == ERR_OK) || (err == ERR_MEM)) {
err_mem:
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
        /* non-blocking write did not write everything: mark the pcb non-writable
           and let poll_tcp check writable space to mark the pcb writable again */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
 800fcc6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800fcc8:	b11b      	cbz	r3, 800fcd2 <do_writemore+0x1d2>
 800fcca:	4620      	mov	r0, r4
 800fccc:	2103      	movs	r1, #3
 800fcce:	464a      	mov	r2, r9
 800fcd0:	4798      	blx	r3
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
 800fcd2:	7f23      	ldrb	r3, [r4, #28]
 800fcd4:	f043 0310 	orr.w	r3, r3, #16
 800fcd8:	464d      	mov	r5, r9
 800fcda:	7723      	strb	r3, [r4, #28]
 800fcdc:	e75e      	b.n	800fb9c <do_writemore+0x9c>
 800fcde:	bf00      	nop
 800fce0:	08018ab4 	.word	0x08018ab4
 800fce4:	08016fe0 	.word	0x08016fe0
 800fce8:	08018bbc 	.word	0x08018bbc
 800fcec:	200180c8 	.word	0x200180c8
 800fcf0:	08018bf4 	.word	0x08018bf4
 800fcf4:	08018c28 	.word	0x08018c28
 800fcf8:	08018b7c 	.word	0x08018b7c
 800fcfc:	08018bdc 	.word	0x08018bdc

0800fd00 <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
 800fd00:	b530      	push	{r4, r5, lr}
  struct netconn *conn = (struct netconn *)arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 800fd02:	4604      	mov	r4, r0
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
 800fd04:	b083      	sub	sp, #12
  struct netconn *conn = (struct netconn *)arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 800fd06:	b338      	cbz	r0, 800fd58 <poll_tcp+0x58>

  if (conn->state == NETCONN_WRITE) {
 800fd08:	7863      	ldrb	r3, [r4, #1]
 800fd0a:	2b01      	cmp	r3, #1
 800fd0c:	d01c      	beq.n	800fd48 <poll_tcp+0x48>
    do_writemore(conn);
  } else if (conn->state == NETCONN_CLOSE) {
 800fd0e:	2b04      	cmp	r3, #4
 800fd10:	d01e      	beq.n	800fd50 <poll_tcp+0x50>
    do_close_internal(conn);
  }
  /* @todo: implement connect timeout here? */

  /* Did a nonblocking write fail before? Then check available write-space. */
  if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
 800fd12:	7f23      	ldrb	r3, [r4, #28]
 800fd14:	06da      	lsls	r2, r3, #27
 800fd16:	d514      	bpl.n	800fd42 <poll_tcp+0x42>
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 800fd18:	6862      	ldr	r2, [r4, #4]
 800fd1a:	b192      	cbz	r2, 800fd42 <poll_tcp+0x42>
 800fd1c:	f8b2 0066 	ldrh.w	r0, [r2, #102]	; 0x66
 800fd20:	f240 51b4 	movw	r1, #1460	; 0x5b4
 800fd24:	4288      	cmp	r0, r1
 800fd26:	d90c      	bls.n	800fd42 <poll_tcp+0x42>
 800fd28:	f8b2 2068 	ldrh.w	r2, [r2, #104]	; 0x68
 800fd2c:	2a03      	cmp	r2, #3
 800fd2e:	d808      	bhi.n	800fd42 <poll_tcp+0x42>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 800fd30:	6aa5      	ldr	r5, [r4, #40]	; 0x28
  if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
 800fd32:	f023 0310 	bic.w	r3, r3, #16
 800fd36:	7723      	strb	r3, [r4, #28]
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 800fd38:	b11d      	cbz	r5, 800fd42 <poll_tcp+0x42>
 800fd3a:	4620      	mov	r0, r4
 800fd3c:	2102      	movs	r1, #2
 800fd3e:	2200      	movs	r2, #0
 800fd40:	47a8      	blx	r5
    }
  }

  return ERR_OK;
}
 800fd42:	2000      	movs	r0, #0
 800fd44:	b003      	add	sp, #12
 800fd46:	bd30      	pop	{r4, r5, pc}

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  if (conn->state == NETCONN_WRITE) {
    do_writemore(conn);
 800fd48:	4620      	mov	r0, r4
 800fd4a:	f7ff fed9 	bl	800fb00 <do_writemore>
 800fd4e:	e7e0      	b.n	800fd12 <poll_tcp+0x12>
  } else if (conn->state == NETCONN_CLOSE) {
    do_close_internal(conn);
 800fd50:	4620      	mov	r0, r4
 800fd52:	f7ff fdcd 	bl	800f8f0 <do_close_internal>
 800fd56:	e7dc      	b.n	800fd12 <poll_tcp+0x12>
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  struct netconn *conn = (struct netconn *)arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 800fd58:	4b06      	ldr	r3, [pc, #24]	; (800fd74 <poll_tcp+0x74>)
 800fd5a:	9300      	str	r3, [sp, #0]
 800fd5c:	4906      	ldr	r1, [pc, #24]	; (800fd78 <poll_tcp+0x78>)
 800fd5e:	4a07      	ldr	r2, [pc, #28]	; (800fd7c <poll_tcp+0x7c>)
 800fd60:	4807      	ldr	r0, [pc, #28]	; (800fd80 <poll_tcp+0x80>)
 800fd62:	f44f 738d 	mov.w	r3, #282	; 0x11a
 800fd66:	f7ff fd33 	bl	800f7d0 <chprintf.constprop.1>
 800fd6a:	4804      	ldr	r0, [pc, #16]	; (800fd7c <poll_tcp+0x7c>)
 800fd6c:	f7f1 f900 	bl	8000f70 <chSysHalt>
 800fd70:	e7ca      	b.n	800fd08 <poll_tcp+0x8>
 800fd72:	bf00      	nop
 800fd74:	08018ab4 	.word	0x08018ab4
 800fd78:	08016fe0 	.word	0x08016fe0
 800fd7c:	08018c48 	.word	0x08018c48
 800fd80:	200180c8 	.word	0x200180c8
 800fd84:	f3af 8000 	nop.w
 800fd88:	f3af 8000 	nop.w
 800fd8c:	f3af 8000 	nop.w

0800fd90 <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
 800fd90:	b570      	push	{r4, r5, r6, lr}
 800fd92:	4615      	mov	r5, r2
 800fd94:	b082      	sub	sp, #8
  struct netconn *conn = (struct netconn *)arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 800fd96:	4604      	mov	r4, r0
 800fd98:	b328      	cbz	r0, 800fde6 <sent_tcp+0x56>

  if (conn->state == NETCONN_WRITE) {
 800fd9a:	7863      	ldrb	r3, [r4, #1]
 800fd9c:	2b01      	cmp	r3, #1
 800fd9e:	d01a      	beq.n	800fdd6 <sent_tcp+0x46>
    do_writemore(conn);
  } else if (conn->state == NETCONN_CLOSE) {
 800fda0:	2b04      	cmp	r3, #4
 800fda2:	d01c      	beq.n	800fdde <sent_tcp+0x4e>
  }

  if (conn) {
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 800fda4:	6863      	ldr	r3, [r4, #4]
 800fda6:	b19b      	cbz	r3, 800fdd0 <sent_tcp+0x40>
 800fda8:	f8b3 1066 	ldrh.w	r1, [r3, #102]	; 0x66
 800fdac:	f240 52b4 	movw	r2, #1460	; 0x5b4
 800fdb0:	4291      	cmp	r1, r2
 800fdb2:	d90d      	bls.n	800fdd0 <sent_tcp+0x40>
 800fdb4:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
 800fdb8:	2b03      	cmp	r3, #3
 800fdba:	d809      	bhi.n	800fdd0 <sent_tcp+0x40>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
 800fdbc:	7f23      	ldrb	r3, [r4, #28]
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
 800fdbe:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  if (conn) {
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
 800fdc0:	f023 0310 	bic.w	r3, r3, #16
 800fdc4:	7723      	strb	r3, [r4, #28]
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
 800fdc6:	b11e      	cbz	r6, 800fdd0 <sent_tcp+0x40>
 800fdc8:	4620      	mov	r0, r4
 800fdca:	462a      	mov	r2, r5
 800fdcc:	2102      	movs	r1, #2
 800fdce:	47b0      	blx	r6
    }
  }
  
  return ERR_OK;
}
 800fdd0:	2000      	movs	r0, #0
 800fdd2:	b002      	add	sp, #8
 800fdd4:	bd70      	pop	{r4, r5, r6, pc}

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  if (conn->state == NETCONN_WRITE) {
    do_writemore(conn);
 800fdd6:	4620      	mov	r0, r4
 800fdd8:	f7ff fe92 	bl	800fb00 <do_writemore>
 800fddc:	e7e2      	b.n	800fda4 <sent_tcp+0x14>
  } else if (conn->state == NETCONN_CLOSE) {
    do_close_internal(conn);
 800fdde:	4620      	mov	r0, r4
 800fde0:	f7ff fd86 	bl	800f8f0 <do_close_internal>
 800fde4:	e7de      	b.n	800fda4 <sent_tcp+0x14>
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  struct netconn *conn = (struct netconn *)arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 800fde6:	4b06      	ldr	r3, [pc, #24]	; (800fe00 <sent_tcp+0x70>)
 800fde8:	9300      	str	r3, [sp, #0]
 800fdea:	4906      	ldr	r1, [pc, #24]	; (800fe04 <sent_tcp+0x74>)
 800fdec:	4a06      	ldr	r2, [pc, #24]	; (800fe08 <sent_tcp+0x78>)
 800fdee:	4807      	ldr	r0, [pc, #28]	; (800fe0c <sent_tcp+0x7c>)
 800fdf0:	f44f 739f 	mov.w	r3, #318	; 0x13e
 800fdf4:	f7ff fcec 	bl	800f7d0 <chprintf.constprop.1>
 800fdf8:	4803      	ldr	r0, [pc, #12]	; (800fe08 <sent_tcp+0x78>)
 800fdfa:	f7f1 f8b9 	bl	8000f70 <chSysHalt>
 800fdfe:	e7cc      	b.n	800fd9a <sent_tcp+0xa>
 800fe00:	08018ab4 	.word	0x08018ab4
 800fe04:	08016fe0 	.word	0x08016fe0
 800fe08:	08018c48 	.word	0x08018c48
 800fe0c:	200180c8 	.word	0x200180c8

0800fe10 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
 800fe10:	b5f0      	push	{r4, r5, r6, r7, lr}
 800fe12:	460f      	mov	r7, r1
 800fe14:	b083      	sub	sp, #12
  struct netconn *conn;
  enum netconn_state old_state;
  SYS_ARCH_DECL_PROTECT(lev);

  conn = (struct netconn *)arg;
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 800fe16:	4604      	mov	r4, r0
 800fe18:	2800      	cmp	r0, #0
 800fe1a:	d057      	beq.n	800fecc <err_tcp+0xbc>
  old_state = conn->state;
  conn->state = NETCONN_NONE;

  /* Notify the user layer about a connection error. Used to signal
     select. */
  API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 800fe1c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  SYS_ARCH_PROTECT(lev);
  conn->last_err = err;
  SYS_ARCH_UNPROTECT(lev);

  /* reset conn->state now before waking up other threads */
  old_state = conn->state;
 800fe1e:	7866      	ldrb	r6, [r4, #1]

  conn->pcb.tcp = NULL;

  /* no check since this is always fatal! */
  SYS_ARCH_PROTECT(lev);
  conn->last_err = err;
 800fe20:	7227      	strb	r7, [r4, #8]
  SYS_ARCH_DECL_PROTECT(lev);

  conn = (struct netconn *)arg;
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  conn->pcb.tcp = NULL;
 800fe22:	2500      	movs	r5, #0
 800fe24:	6065      	str	r5, [r4, #4]
  conn->last_err = err;
  SYS_ARCH_UNPROTECT(lev);

  /* reset conn->state now before waking up other threads */
  old_state = conn->state;
  conn->state = NETCONN_NONE;
 800fe26:	7065      	strb	r5, [r4, #1]

  /* Notify the user layer about a connection error. Used to signal
     select. */
  API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 800fe28:	b17b      	cbz	r3, 800fe4a <err_tcp+0x3a>
 800fe2a:	4620      	mov	r0, r4
 800fe2c:	2104      	movs	r1, #4
 800fe2e:	462a      	mov	r2, r5
 800fe30:	4798      	blx	r3
  /* Try to release selects pending on 'read' or 'write', too.
     They will get an error if they actually try to read or write. */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 800fe32:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800fe34:	b14b      	cbz	r3, 800fe4a <err_tcp+0x3a>
 800fe36:	4620      	mov	r0, r4
 800fe38:	4629      	mov	r1, r5
 800fe3a:	462a      	mov	r2, r5
 800fe3c:	4798      	blx	r3
 800fe3e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 800fe40:	b11b      	cbz	r3, 800fe4a <err_tcp+0x3a>
 800fe42:	462a      	mov	r2, r5
 800fe44:	4620      	mov	r0, r4
 800fe46:	2102      	movs	r1, #2
 800fe48:	4798      	blx	r3

  /* pass NULL-message to recvmbox to wake up pending recv */
  if (sys_mbox_valid(&conn->recvmbox)) {
 800fe4a:	f104 0510 	add.w	r5, r4, #16
 800fe4e:	4628      	mov	r0, r5
 800fe50:	f7f7 ff5e 	bl	8007d10 <sys_mbox_valid>
 800fe54:	2800      	cmp	r0, #0
 800fe56:	d134      	bne.n	800fec2 <err_tcp+0xb2>
    /* use trypost to prevent deadlock */
    sys_mbox_trypost(&conn->recvmbox, NULL);
  }
  /* pass NULL-message to acceptmbox to wake up pending accept */
  if (sys_mbox_valid(&conn->acceptmbox)) {
 800fe58:	f104 0514 	add.w	r5, r4, #20
 800fe5c:	4628      	mov	r0, r5
 800fe5e:	f7f7 ff57 	bl	8007d10 <sys_mbox_valid>
 800fe62:	bb48      	cbnz	r0, 800feb8 <err_tcp+0xa8>
    /* use trypost to preven deadlock */
    sys_mbox_trypost(&conn->acceptmbox, NULL);
  }

  if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
 800fe64:	2e01      	cmp	r6, #1
 800fe66:	d013      	beq.n	800fe90 <err_tcp+0x80>
 800fe68:	3e03      	subs	r6, #3
 800fe6a:	2e01      	cmp	r6, #1
 800fe6c:	d910      	bls.n	800fe90 <err_tcp+0x80>
      conn->current_msg = NULL;
      /* wake up the waiting task */
      sys_sem_signal(&conn->op_completed);
    }
  } else {
    LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
 800fe6e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800fe70:	b303      	cbz	r3, 800feb4 <err_tcp+0xa4>
 800fe72:	4b24      	ldr	r3, [pc, #144]	; (800ff04 <err_tcp+0xf4>)
 800fe74:	9300      	str	r3, [sp, #0]
 800fe76:	4924      	ldr	r1, [pc, #144]	; (800ff08 <err_tcp+0xf8>)
 800fe78:	4a24      	ldr	r2, [pc, #144]	; (800ff0c <err_tcp+0xfc>)
 800fe7a:	4825      	ldr	r0, [pc, #148]	; (800ff10 <err_tcp+0x100>)
 800fe7c:	f44f 73c9 	mov.w	r3, #402	; 0x192
 800fe80:	f7ff fca6 	bl	800f7d0 <chprintf.constprop.1>
 800fe84:	4821      	ldr	r0, [pc, #132]	; (800ff0c <err_tcp+0xfc>)
  }
}
 800fe86:	b003      	add	sp, #12
 800fe88:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 800fe8c:	f7f1 b870 	b.w	8000f70 <chSysHalt>

  if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
      (old_state == NETCONN_CONNECT)) {
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
 800fe90:	7f23      	ldrb	r3, [r4, #28]
    SET_NONBLOCKING_CONNECT(conn, 0);
 800fe92:	f023 0204 	bic.w	r2, r3, #4

    if (!was_nonblocking_connect) {
 800fe96:	075b      	lsls	r3, r3, #29
  if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
      (old_state == NETCONN_CONNECT)) {
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
    SET_NONBLOCKING_CONNECT(conn, 0);
 800fe98:	7722      	strb	r2, [r4, #28]

    if (!was_nonblocking_connect) {
 800fe9a:	d40b      	bmi.n	800feb4 <err_tcp+0xa4>
      /* set error return code */
      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 800fe9c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800fe9e:	b313      	cbz	r3, 800fee6 <err_tcp+0xd6>
      conn->current_msg->err = err;
 800fea0:	711f      	strb	r7, [r3, #4]
      conn->current_msg = NULL;
      /* wake up the waiting task */
      sys_sem_signal(&conn->op_completed);
 800fea2:	f104 000c 	add.w	r0, r4, #12

    if (!was_nonblocking_connect) {
      /* set error return code */
      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
      conn->current_msg->err = err;
      conn->current_msg = NULL;
 800fea6:	2300      	movs	r3, #0
 800fea8:	6263      	str	r3, [r4, #36]	; 0x24
      sys_sem_signal(&conn->op_completed);
    }
  } else {
    LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
  }
}
 800feaa:	b003      	add	sp, #12
 800feac:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
      /* set error return code */
      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
      conn->current_msg->err = err;
      conn->current_msg = NULL;
      /* wake up the waiting task */
      sys_sem_signal(&conn->op_completed);
 800feb0:	f7f7 be56 	b.w	8007b60 <sys_sem_signal>
    }
  } else {
    LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
  }
}
 800feb4:	b003      	add	sp, #12
 800feb6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    sys_mbox_trypost(&conn->recvmbox, NULL);
  }
  /* pass NULL-message to acceptmbox to wake up pending accept */
  if (sys_mbox_valid(&conn->acceptmbox)) {
    /* use trypost to preven deadlock */
    sys_mbox_trypost(&conn->acceptmbox, NULL);
 800feb8:	4628      	mov	r0, r5
 800feba:	2100      	movs	r1, #0
 800febc:	f7f7 fee0 	bl	8007c80 <sys_mbox_trypost>
 800fec0:	e7d0      	b.n	800fe64 <err_tcp+0x54>
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);

  /* pass NULL-message to recvmbox to wake up pending recv */
  if (sys_mbox_valid(&conn->recvmbox)) {
    /* use trypost to prevent deadlock */
    sys_mbox_trypost(&conn->recvmbox, NULL);
 800fec2:	4628      	mov	r0, r5
 800fec4:	2100      	movs	r1, #0
 800fec6:	f7f7 fedb 	bl	8007c80 <sys_mbox_trypost>
 800feca:	e7c5      	b.n	800fe58 <err_tcp+0x48>
  struct netconn *conn;
  enum netconn_state old_state;
  SYS_ARCH_DECL_PROTECT(lev);

  conn = (struct netconn *)arg;
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 800fecc:	4b0d      	ldr	r3, [pc, #52]	; (800ff04 <err_tcp+0xf4>)
 800fece:	9300      	str	r3, [sp, #0]
 800fed0:	490d      	ldr	r1, [pc, #52]	; (800ff08 <err_tcp+0xf8>)
 800fed2:	4a10      	ldr	r2, [pc, #64]	; (800ff14 <err_tcp+0x104>)
 800fed4:	480e      	ldr	r0, [pc, #56]	; (800ff10 <err_tcp+0x100>)
 800fed6:	f44f 73b1 	mov.w	r3, #354	; 0x162
 800feda:	f7ff fc79 	bl	800f7d0 <chprintf.constprop.1>
 800fede:	480d      	ldr	r0, [pc, #52]	; (800ff14 <err_tcp+0x104>)
 800fee0:	f7f1 f846 	bl	8000f70 <chSysHalt>
 800fee4:	e79a      	b.n	800fe1c <err_tcp+0xc>
    int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
    SET_NONBLOCKING_CONNECT(conn, 0);

    if (!was_nonblocking_connect) {
      /* set error return code */
      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 800fee6:	4b07      	ldr	r3, [pc, #28]	; (800ff04 <err_tcp+0xf4>)
 800fee8:	9300      	str	r3, [sp, #0]
 800feea:	4907      	ldr	r1, [pc, #28]	; (800ff08 <err_tcp+0xf8>)
 800feec:	4a0a      	ldr	r2, [pc, #40]	; (800ff18 <err_tcp+0x108>)
 800feee:	4808      	ldr	r0, [pc, #32]	; (800ff10 <err_tcp+0x100>)
 800fef0:	f240 138b 	movw	r3, #395	; 0x18b
 800fef4:	f7ff fc6c 	bl	800f7d0 <chprintf.constprop.1>
 800fef8:	4807      	ldr	r0, [pc, #28]	; (800ff18 <err_tcp+0x108>)
 800fefa:	f7f1 f839 	bl	8000f70 <chSysHalt>
 800fefe:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800ff00:	e7ce      	b.n	800fea0 <err_tcp+0x90>
 800ff02:	bf00      	nop
 800ff04:	08018ab4 	.word	0x08018ab4
 800ff08:	08016fe0 	.word	0x08016fe0
 800ff0c:	08018cb8 	.word	0x08018cb8
 800ff10:	200180c8 	.word	0x200180c8
 800ff14:	08018c48 	.word	0x08018c48
 800ff18:	08018b7c 	.word	0x08018b7c
 800ff1c:	f3af 8000 	nop.w

0800ff20 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   ip_addr_t *addr, u16_t port)
{
 800ff20:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800ff24:	b083      	sub	sp, #12
 800ff26:	4604      	mov	r4, r0
 800ff28:	4616      	mov	r6, r2
 800ff2a:	461f      	mov	r7, r3
 800ff2c:	f8bd 9028 	ldrh.w	r9, [sp, #40]	; 0x28
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
 800ff30:	460d      	mov	r5, r1
 800ff32:	2900      	cmp	r1, #0
 800ff34:	d037      	beq.n	800ffa6 <recv_udp+0x86>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
 800ff36:	2c00      	cmp	r4, #0
 800ff38:	d047      	beq.n	800ffca <recv_udp+0xaa>
  conn = (struct netconn *)arg;
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
 800ff3a:	6863      	ldr	r3, [r4, #4]
 800ff3c:	42ab      	cmp	r3, r5
 800ff3e:	d00a      	beq.n	800ff56 <recv_udp+0x36>
 800ff40:	4b29      	ldr	r3, [pc, #164]	; (800ffe8 <recv_udp+0xc8>)
 800ff42:	9300      	str	r3, [sp, #0]
 800ff44:	4829      	ldr	r0, [pc, #164]	; (800ffec <recv_udp+0xcc>)
 800ff46:	492a      	ldr	r1, [pc, #168]	; (800fff0 <recv_udp+0xd0>)
 800ff48:	4a2a      	ldr	r2, [pc, #168]	; (800fff4 <recv_udp+0xd4>)
 800ff4a:	239e      	movs	r3, #158	; 0x9e
 800ff4c:	f7ff fc40 	bl	800f7d0 <chprintf.constprop.1>
 800ff50:	4828      	ldr	r0, [pc, #160]	; (800fff4 <recv_udp+0xd4>)
 800ff52:	f7f1 f80d 	bl	8000f70 <chSysHalt>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox)) {
 800ff56:	f104 0810 	add.w	r8, r4, #16
 800ff5a:	4640      	mov	r0, r8
 800ff5c:	f7f7 fed8 	bl	8007d10 <sys_mbox_valid>
 800ff60:	b928      	cbnz	r0, 800ff6e <recv_udp+0x4e>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
 800ff62:	4630      	mov	r0, r6
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  }
}
 800ff64:	b003      	add	sp, #12
 800ff66:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox)) {
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
 800ff6a:	f7f9 ba49 	b.w	8009400 <pbuf_free>
    return;
  }

  buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 800ff6e:	2007      	movs	r0, #7
 800ff70:	f7f8 ffce 	bl	8008f10 <memp_malloc>
  if (buf == NULL) {
 800ff74:	4605      	mov	r5, r0
 800ff76:	2800      	cmp	r0, #0
 800ff78:	d0f3      	beq.n	800ff62 <recv_udp+0x42>
    pbuf_free(p);
    return;
  } else {
    buf->p = p;
 800ff7a:	6006      	str	r6, [r0, #0]
    buf->ptr = p;
 800ff7c:	6046      	str	r6, [r0, #4]
    ip_addr_set(&buf->addr, addr);
 800ff7e:	b107      	cbz	r7, 800ff82 <recv_udp+0x62>
 800ff80:	683f      	ldr	r7, [r7, #0]
 800ff82:	60af      	str	r7, [r5, #8]
    }
#endif /* LWIP_NETBUF_RECVINFO */
  }

  len = p->tot_len;
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 800ff84:	4629      	mov	r1, r5
    return;
  } else {
    buf->p = p;
    buf->ptr = p;
    ip_addr_set(&buf->addr, addr);
    buf->port = port;
 800ff86:	f8a5 900c 	strh.w	r9, [r5, #12]
    }
#endif /* LWIP_NETBUF_RECVINFO */
  }

  len = p->tot_len;
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 800ff8a:	4640      	mov	r0, r8
      buf->toport_chksum = udphdr->dest;
    }
#endif /* LWIP_NETBUF_RECVINFO */
  }

  len = p->tot_len;
 800ff8c:	8936      	ldrh	r6, [r6, #8]
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 800ff8e:	f7f7 fe77 	bl	8007c80 <sys_mbox_trypost>
 800ff92:	4601      	mov	r1, r0
 800ff94:	b998      	cbnz	r0, 800ffbe <recv_udp+0x9e>
  } else {
#if LWIP_SO_RCVBUF
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 800ff96:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800ff98:	b31b      	cbz	r3, 800ffe2 <recv_udp+0xc2>
 800ff9a:	4620      	mov	r0, r4
 800ff9c:	4632      	mov	r2, r6
  }
}
 800ff9e:	b003      	add	sp, #12
 800ffa0:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  } else {
#if LWIP_SO_RCVBUF
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 800ffa4:	4718      	bx	r3
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
 800ffa6:	4b10      	ldr	r3, [pc, #64]	; (800ffe8 <recv_udp+0xc8>)
 800ffa8:	9300      	str	r3, [sp, #0]
 800ffaa:	4911      	ldr	r1, [pc, #68]	; (800fff0 <recv_udp+0xd0>)
 800ffac:	4a12      	ldr	r2, [pc, #72]	; (800fff8 <recv_udp+0xd8>)
 800ffae:	480f      	ldr	r0, [pc, #60]	; (800ffec <recv_udp+0xcc>)
 800ffb0:	239b      	movs	r3, #155	; 0x9b
 800ffb2:	f7ff fc0d 	bl	800f7d0 <chprintf.constprop.1>
 800ffb6:	4810      	ldr	r0, [pc, #64]	; (800fff8 <recv_udp+0xd8>)
 800ffb8:	f7f0 ffda 	bl	8000f70 <chSysHalt>
 800ffbc:	e7bb      	b.n	800ff36 <recv_udp+0x16>
#endif /* LWIP_NETBUF_RECVINFO */
  }

  len = p->tot_len;
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
    netbuf_delete(buf);
 800ffbe:	4628      	mov	r0, r5
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  }
}
 800ffc0:	b003      	add	sp, #12
 800ffc2:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
#endif /* LWIP_NETBUF_RECVINFO */
  }

  len = p->tot_len;
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
    netbuf_delete(buf);
 800ffc6:	f000 bc0b 	b.w	80107e0 <netbuf_delete>
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
 800ffca:	4b07      	ldr	r3, [pc, #28]	; (800ffe8 <recv_udp+0xc8>)
 800ffcc:	9300      	str	r3, [sp, #0]
 800ffce:	4908      	ldr	r1, [pc, #32]	; (800fff0 <recv_udp+0xd0>)
 800ffd0:	4a0a      	ldr	r2, [pc, #40]	; (800fffc <recv_udp+0xdc>)
 800ffd2:	4806      	ldr	r0, [pc, #24]	; (800ffec <recv_udp+0xcc>)
 800ffd4:	239c      	movs	r3, #156	; 0x9c
 800ffd6:	f7ff fbfb 	bl	800f7d0 <chprintf.constprop.1>
 800ffda:	4808      	ldr	r0, [pc, #32]	; (800fffc <recv_udp+0xdc>)
 800ffdc:	f7f0 ffc8 	bl	8000f70 <chSysHalt>
 800ffe0:	e7ab      	b.n	800ff3a <recv_udp+0x1a>
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  }
}
 800ffe2:	b003      	add	sp, #12
 800ffe4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800ffe8:	08018ab4 	.word	0x08018ab4
 800ffec:	200180c8 	.word	0x200180c8
 800fff0:	08016fe0 	.word	0x08016fe0
 800fff4:	08018d18 	.word	0x08018d18
 800fff8:	08018cd4 	.word	0x08018cd4
 800fffc:	08018cf8 	.word	0x08018cf8

08010000 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
 8010000:	b538      	push	{r3, r4, r5, lr}
  msg->err = ERR_OK;
 8010002:	2300      	movs	r3, #0
  if(msg->conn->pcb.tcp == NULL) {
 8010004:	6804      	ldr	r4, [r0, #0]
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  msg->err = ERR_OK;
 8010006:	7103      	strb	r3, [r0, #4]
  if(msg->conn->pcb.tcp == NULL) {
 8010008:	6863      	ldr	r3, [r4, #4]
 801000a:	b12b      	cbz	r3, 8010018 <do_newconn+0x18>
  }
  /* Else? This "new" connection already has a PCB allocated. */
  /* Is this an error condition? Should it be deleted? */
  /* We currently just are happy and return. */

  TCPIP_APIMSG_ACK(msg);
 801000c:	f104 000c 	add.w	r0, r4, #12
}
 8010010:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  }
  /* Else? This "new" connection already has a PCB allocated. */
  /* Is this an error condition? Should it be deleted? */
  /* We currently just are happy and return. */

  TCPIP_APIMSG_ACK(msg);
 8010014:	f7f7 bda4 	b.w	8007b60 <sys_sem_signal>
pcb_new(struct api_msg_msg *msg)
{
  LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);

  /* Allocate a PCB for this connection */
  switch(NETCONNTYPE_GROUP(msg->conn->type)) {
 8010018:	7823      	ldrb	r3, [r4, #0]
 801001a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 801001e:	2b20      	cmp	r3, #32
 8010020:	4605      	mov	r5, r0
 8010022:	d01e      	beq.n	8010062 <do_newconn+0x62>
 8010024:	2b40      	cmp	r3, #64	; 0x40
 8010026:	d00f      	beq.n	8010048 <do_newconn+0x48>
 8010028:	2b10      	cmp	r3, #16
 801002a:	d002      	beq.n	8010032 <do_newconn+0x32>
    setup_tcp(msg->conn);
    break;
#endif /* LWIP_TCP */
  default:
    /* Unsupported netconn type, e.g. protocol disabled */
    msg->err = ERR_VAL;
 801002c:	23fa      	movs	r3, #250	; 0xfa
 801002e:	7103      	strb	r3, [r0, #4]
 8010030:	e7ec      	b.n	801000c <do_newconn+0xc>
    udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
    break;
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->pcb.tcp = tcp_new();
 8010032:	f7fa fecd 	bl	800add0 <tcp_new>
 8010036:	6060      	str	r0, [r4, #4]
    if(msg->conn->pcb.tcp == NULL) {
 8010038:	682c      	ldr	r4, [r5, #0]
 801003a:	6863      	ldr	r3, [r4, #4]
 801003c:	b323      	cbz	r3, 8010088 <do_newconn+0x88>
      msg->err = ERR_MEM;
      break;
    }
    setup_tcp(msg->conn);
 801003e:	4620      	mov	r0, r4
 8010040:	f7ff fb9e 	bl	800f780 <setup_tcp>
 8010044:	682c      	ldr	r4, [r5, #0]
 8010046:	e7e1      	b.n	801000c <do_newconn+0xc>

  /* Allocate a PCB for this connection */
  switch(NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
 8010048:	7a00      	ldrb	r0, [r0, #8]
 801004a:	f7f9 fe19 	bl	8009c80 <raw_new>
 801004e:	6060      	str	r0, [r4, #4]
    if(msg->conn->pcb.raw == NULL) {
 8010050:	682c      	ldr	r4, [r5, #0]
 8010052:	6860      	ldr	r0, [r4, #4]
 8010054:	b1c0      	cbz	r0, 8010088 <do_newconn+0x88>
      msg->err = ERR_MEM;
      break;
    }
    raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
 8010056:	4622      	mov	r2, r4
 8010058:	490d      	ldr	r1, [pc, #52]	; (8010090 <do_newconn+0x90>)
 801005a:	f7f9 fde9 	bl	8009c30 <raw_recv>
 801005e:	682c      	ldr	r4, [r5, #0]
 8010060:	e7d4      	b.n	801000c <do_newconn+0xc>
    break;
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->pcb.udp = udp_new();
 8010062:	f7fd fd15 	bl	800da90 <udp_new>
 8010066:	6060      	str	r0, [r4, #4]
    if(msg->conn->pcb.udp == NULL) {
 8010068:	682c      	ldr	r4, [r5, #0]
 801006a:	6860      	ldr	r0, [r4, #4]
 801006c:	b160      	cbz	r0, 8010088 <do_newconn+0x88>
#if LWIP_UDPLITE
    if (msg->conn->type==NETCONN_UDPLITE) {
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
    }
#endif /* LWIP_UDPLITE */
    if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
 801006e:	7823      	ldrb	r3, [r4, #0]
 8010070:	2b22      	cmp	r3, #34	; 0x22
 8010072:	d103      	bne.n	801007c <do_newconn+0x7c>
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
 8010074:	2301      	movs	r3, #1
 8010076:	7403      	strb	r3, [r0, #16]
 8010078:	682c      	ldr	r4, [r5, #0]
 801007a:	6860      	ldr	r0, [r4, #4]
    }
    udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
 801007c:	4905      	ldr	r1, [pc, #20]	; (8010094 <do_newconn+0x94>)
 801007e:	4622      	mov	r2, r4
 8010080:	f7fd fcde 	bl	800da40 <udp_recv>
 8010084:	682c      	ldr	r4, [r5, #0]
 8010086:	e7c1      	b.n	801000c <do_newconn+0xc>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->pcb.tcp = tcp_new();
    if(msg->conn->pcb.tcp == NULL) {
      msg->err = ERR_MEM;
 8010088:	23ff      	movs	r3, #255	; 0xff
 801008a:	712b      	strb	r3, [r5, #4]
 801008c:	e7be      	b.n	801000c <do_newconn+0xc>
 801008e:	bf00      	nop
 8010090:	0800f6f1 	.word	0x0800f6f1
 8010094:	0800ff21 	.word	0x0800ff21
 8010098:	f3af 8000 	nop.w
 801009c:	f3af 8000 	nop.w

080100a0 <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
 80100a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80100a2:	4605      	mov	r5, r0
 80100a4:	b083      	sub	sp, #12
  struct netconn *conn;
  int size;

  conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
 80100a6:	2008      	movs	r0, #8
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
 80100a8:	460e      	mov	r6, r1
  struct netconn *conn;
  int size;

  conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
 80100aa:	f7f8 ff31 	bl	8008f10 <memp_malloc>
  if (conn == NULL) {
 80100ae:	4604      	mov	r4, r0
 80100b0:	b1e0      	cbz	r0, 80100ec <netconn_alloc+0x4c>

#if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
    (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
  size = DEFAULT_RAW_RECVMBOX_SIZE;
#else
  switch(NETCONNTYPE_GROUP(t)) {
 80100b2:	f005 03f0 	and.w	r3, r5, #240	; 0xf0
  conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
  if (conn == NULL) {
    return NULL;
  }

  conn->last_err = ERR_OK;
 80100b6:	2200      	movs	r2, #0

#if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
    (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
  size = DEFAULT_RAW_RECVMBOX_SIZE;
#else
  switch(NETCONNTYPE_GROUP(t)) {
 80100b8:	2b20      	cmp	r3, #32
  if (conn == NULL) {
    return NULL;
  }

  conn->last_err = ERR_OK;
  conn->type = t;
 80100ba:	7005      	strb	r5, [r0, #0]
  conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
  if (conn == NULL) {
    return NULL;
  }

  conn->last_err = ERR_OK;
 80100bc:	7202      	strb	r2, [r0, #8]
  conn->type = t;
  conn->pcb.tcp = NULL;
 80100be:	6042      	str	r2, [r0, #4]

#if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
    (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
  size = DEFAULT_RAW_RECVMBOX_SIZE;
#else
  switch(NETCONNTYPE_GROUP(t)) {
 80100c0:	d035      	beq.n	801012e <netconn_alloc+0x8e>
 80100c2:	2b40      	cmp	r3, #64	; 0x40
 80100c4:	d033      	beq.n	801012e <netconn_alloc+0x8e>
 80100c6:	2b10      	cmp	r3, #16
 80100c8:	d012      	beq.n	80100f0 <netconn_alloc+0x50>
  case NETCONN_TCP:
    size = DEFAULT_TCP_RECVMBOX_SIZE;
    break;
#endif /* LWIP_TCP */
  default:
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
 80100ca:	4b1c      	ldr	r3, [pc, #112]	; (801013c <netconn_alloc+0x9c>)
 80100cc:	9300      	str	r3, [sp, #0]
 80100ce:	481c      	ldr	r0, [pc, #112]	; (8010140 <netconn_alloc+0xa0>)
 80100d0:	491c      	ldr	r1, [pc, #112]	; (8010144 <netconn_alloc+0xa4>)
 80100d2:	4a1d      	ldr	r2, [pc, #116]	; (8010148 <netconn_alloc+0xa8>)
 80100d4:	f240 235f 	movw	r3, #607	; 0x25f
 80100d8:	f7ff fb7a 	bl	800f7d0 <chprintf.constprop.1>
 80100dc:	481a      	ldr	r0, [pc, #104]	; (8010148 <netconn_alloc+0xa8>)
 80100de:	f7f0 ff47 	bl	8000f70 <chSysHalt>
  conn->recv_avail   = 0;
#endif /* LWIP_SO_RCVBUF */
  conn->flags = 0;
  return conn;
free_and_return:
  memp_free(MEMP_NETCONN, conn);
 80100e2:	2008      	movs	r0, #8
 80100e4:	4621      	mov	r1, r4
 80100e6:	f7f8 ff6b 	bl	8008fc0 <memp_free>
  return NULL;
 80100ea:	2000      	movs	r0, #0
}
 80100ec:	b003      	add	sp, #12
 80100ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
    size = DEFAULT_UDP_RECVMBOX_SIZE;
    break;
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    size = DEFAULT_TCP_RECVMBOX_SIZE;
 80100f0:	2528      	movs	r5, #40	; 0x28
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    goto free_and_return;
  }
#endif

  if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
 80100f2:	f104 070c 	add.w	r7, r4, #12
 80100f6:	4638      	mov	r0, r7
 80100f8:	2100      	movs	r1, #0
 80100fa:	f7f7 fcf9 	bl	8007af0 <sys_sem_new>
 80100fe:	2800      	cmp	r0, #0
 8010100:	d1ef      	bne.n	80100e2 <netconn_alloc+0x42>
    goto free_and_return;
  }
  if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
 8010102:	4629      	mov	r1, r5
 8010104:	f104 0010 	add.w	r0, r4, #16
 8010108:	f7f7 fd62 	bl	8007bd0 <sys_mbox_new>
 801010c:	4605      	mov	r5, r0
 801010e:	b980      	cbnz	r0, 8010132 <netconn_alloc+0x92>
    sys_sem_free(&conn->op_completed);
    goto free_and_return;
  }

#if LWIP_TCP
  sys_mbox_set_invalid(&conn->acceptmbox);
 8010110:	f104 0014 	add.w	r0, r4, #20
 8010114:	f7f7 fe04 	bl	8007d20 <sys_mbox_set_invalid>
#endif
  conn->state        = NETCONN_NONE;
#if LWIP_SOCKET
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
 8010118:	f04f 33ff 	mov.w	r3, #4294967295
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = RECV_BUFSIZE_DEFAULT;
  conn->recv_avail   = 0;
#endif /* LWIP_SO_RCVBUF */
  conn->flags = 0;
  return conn;
 801011c:	4620      	mov	r0, r4
  }

#if LWIP_TCP
  sys_mbox_set_invalid(&conn->acceptmbox);
#endif
  conn->state        = NETCONN_NONE;
 801011e:	7065      	strb	r5, [r4, #1]
#if LWIP_SOCKET
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
#endif /* LWIP_SOCKET */
  conn->callback     = callback;
 8010120:	62a6      	str	r6, [r4, #40]	; 0x28
#if LWIP_TCP
  conn->current_msg  = NULL;
 8010122:	6265      	str	r5, [r4, #36]	; 0x24
  conn->write_offset = 0;
 8010124:	6225      	str	r5, [r4, #32]
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = RECV_BUFSIZE_DEFAULT;
  conn->recv_avail   = 0;
#endif /* LWIP_SO_RCVBUF */
  conn->flags = 0;
 8010126:	7725      	strb	r5, [r4, #28]
  sys_mbox_set_invalid(&conn->acceptmbox);
#endif
  conn->state        = NETCONN_NONE;
#if LWIP_SOCKET
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
 8010128:	61a3      	str	r3, [r4, #24]
  conn->flags = 0;
  return conn;
free_and_return:
  memp_free(MEMP_NETCONN, conn);
  return NULL;
}
 801012a:	b003      	add	sp, #12
 801012c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  size = DEFAULT_RAW_RECVMBOX_SIZE;
#else
  switch(NETCONNTYPE_GROUP(t)) {
#if LWIP_RAW
  case NETCONN_RAW:
    size = DEFAULT_RAW_RECVMBOX_SIZE;
 801012e:	2504      	movs	r5, #4
 8010130:	e7df      	b.n	80100f2 <netconn_alloc+0x52>

  if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
    goto free_and_return;
  }
  if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
    sys_sem_free(&conn->op_completed);
 8010132:	4638      	mov	r0, r7
 8010134:	f7f7 fd04 	bl	8007b40 <sys_sem_free>
    goto free_and_return;
 8010138:	e7d3      	b.n	80100e2 <netconn_alloc+0x42>
 801013a:	bf00      	nop
 801013c:	08018ab4 	.word	0x08018ab4
 8010140:	200180c8 	.word	0x200180c8
 8010144:	08016fe0 	.word	0x08016fe0
 8010148:	08018d38 	.word	0x08018d38
 801014c:	f3af 8000 	nop.w

08010150 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
 8010150:	b530      	push	{r4, r5, lr}
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
 8010152:	6843      	ldr	r3, [r0, #4]
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
 8010154:	b083      	sub	sp, #12
 8010156:	4604      	mov	r4, r0
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
 8010158:	b15b      	cbz	r3, 8010172 <netconn_free+0x22>
 801015a:	4b1f      	ldr	r3, [pc, #124]	; (80101d8 <netconn_free+0x88>)
 801015c:	9300      	str	r3, [sp, #0]
 801015e:	481f      	ldr	r0, [pc, #124]	; (80101dc <netconn_free+0x8c>)
 8010160:	491f      	ldr	r1, [pc, #124]	; (80101e0 <netconn_free+0x90>)
 8010162:	4a20      	ldr	r2, [pc, #128]	; (80101e4 <netconn_free+0x94>)
 8010164:	f240 2393 	movw	r3, #659	; 0x293
 8010168:	f7ff fb32 	bl	800f7d0 <chprintf.constprop.1>
 801016c:	481d      	ldr	r0, [pc, #116]	; (80101e4 <netconn_free+0x94>)
 801016e:	f7f0 feff 	bl	8000f70 <chSysHalt>
  LWIP_ASSERT("recvmbox must be deallocated before calling this function",
 8010172:	f104 0010 	add.w	r0, r4, #16
 8010176:	f7f7 fdcb 	bl	8007d10 <sys_mbox_valid>
 801017a:	b9f8      	cbnz	r0, 80101bc <netconn_free+0x6c>
    !sys_mbox_valid(&conn->recvmbox));
#if LWIP_TCP
  LWIP_ASSERT("acceptmbox must be deallocated before calling this function",
 801017c:	f104 0014 	add.w	r0, r4, #20
 8010180:	f7f7 fdc6 	bl	8007d10 <sys_mbox_valid>
 8010184:	b158      	cbz	r0, 801019e <netconn_free+0x4e>
 8010186:	4b14      	ldr	r3, [pc, #80]	; (80101d8 <netconn_free+0x88>)
 8010188:	9300      	str	r3, [sp, #0]
 801018a:	4814      	ldr	r0, [pc, #80]	; (80101dc <netconn_free+0x8c>)
 801018c:	4914      	ldr	r1, [pc, #80]	; (80101e0 <netconn_free+0x90>)
 801018e:	4a16      	ldr	r2, [pc, #88]	; (80101e8 <netconn_free+0x98>)
 8010190:	f44f 7326 	mov.w	r3, #664	; 0x298
 8010194:	f7ff fb1c 	bl	800f7d0 <chprintf.constprop.1>
 8010198:	4813      	ldr	r0, [pc, #76]	; (80101e8 <netconn_free+0x98>)
 801019a:	f7f0 fee9 	bl	8000f70 <chSysHalt>
    !sys_mbox_valid(&conn->acceptmbox));
#endif /* LWIP_TCP */

  sys_sem_free(&conn->op_completed);
 801019e:	f104 050c 	add.w	r5, r4, #12
 80101a2:	4628      	mov	r0, r5
 80101a4:	f7f7 fccc 	bl	8007b40 <sys_sem_free>
  sys_sem_set_invalid(&conn->op_completed);
 80101a8:	4628      	mov	r0, r5
 80101aa:	f7f7 fd09 	bl	8007bc0 <sys_sem_set_invalid>

  memp_free(MEMP_NETCONN, conn);
 80101ae:	4621      	mov	r1, r4
 80101b0:	2008      	movs	r0, #8
}
 80101b2:	b003      	add	sp, #12
 80101b4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
#endif /* LWIP_TCP */

  sys_sem_free(&conn->op_completed);
  sys_sem_set_invalid(&conn->op_completed);

  memp_free(MEMP_NETCONN, conn);
 80101b8:	f7f8 bf02 	b.w	8008fc0 <memp_free>
 */
void
netconn_free(struct netconn *conn)
{
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  LWIP_ASSERT("recvmbox must be deallocated before calling this function",
 80101bc:	4b06      	ldr	r3, [pc, #24]	; (80101d8 <netconn_free+0x88>)
 80101be:	9300      	str	r3, [sp, #0]
 80101c0:	4907      	ldr	r1, [pc, #28]	; (80101e0 <netconn_free+0x90>)
 80101c2:	4a0a      	ldr	r2, [pc, #40]	; (80101ec <netconn_free+0x9c>)
 80101c4:	4805      	ldr	r0, [pc, #20]	; (80101dc <netconn_free+0x8c>)
 80101c6:	f240 2395 	movw	r3, #661	; 0x295
 80101ca:	f7ff fb01 	bl	800f7d0 <chprintf.constprop.1>
 80101ce:	4807      	ldr	r0, [pc, #28]	; (80101ec <netconn_free+0x9c>)
 80101d0:	f7f0 fece 	bl	8000f70 <chSysHalt>
 80101d4:	e7d2      	b.n	801017c <netconn_free+0x2c>
 80101d6:	bf00      	nop
 80101d8:	08018ab4 	.word	0x08018ab4
 80101dc:	200180c8 	.word	0x200180c8
 80101e0:	08016fe0 	.word	0x08016fe0
 80101e4:	08018d60 	.word	0x08018d60
 80101e8:	08018dcc 	.word	0x08018dcc
 80101ec:	08018d90 	.word	0x08018d90

080101f0 <netconn_drain>:
 * @bytes_drained bytes drained from recvmbox
 * @accepts_drained pending connections drained from acceptmbox
 */
static void
netconn_drain(struct netconn *conn)
{
 80101f0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
#endif /* LWIP_TCP */

  /* This runs in tcpip_thread, so we don't need to lock against rx packets */

  /* Delete and drain the recvmbox. */
  if (sys_mbox_valid(&conn->recvmbox)) {
 80101f4:	f100 0410 	add.w	r4, r0, #16
 * @bytes_drained bytes drained from recvmbox
 * @accepts_drained pending connections drained from acceptmbox
 */
static void
netconn_drain(struct netconn *conn)
{
 80101f8:	b085      	sub	sp, #20
 80101fa:	4606      	mov	r6, r0
#endif /* LWIP_TCP */

  /* This runs in tcpip_thread, so we don't need to lock against rx packets */

  /* Delete and drain the recvmbox. */
  if (sys_mbox_valid(&conn->recvmbox)) {
 80101fc:	4620      	mov	r0, r4
 80101fe:	f7f7 fd87 	bl	8007d10 <sys_mbox_valid>
 8010202:	b308      	cbz	r0, 8010248 <netconn_drain+0x58>
 8010204:	af03      	add	r7, sp, #12
    while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
 8010206:	4620      	mov	r0, r4
 8010208:	4639      	mov	r1, r7
 801020a:	f7f7 fd71 	bl	8007cf0 <sys_arch_mbox_tryfetch>
 801020e:	3001      	adds	r0, #1
 8010210:	d014      	beq.n	801023c <netconn_drain+0x4c>
#if LWIP_TCP
      if (conn->type == NETCONN_TCP) {
 8010212:	7833      	ldrb	r3, [r6, #0]
 8010214:	2b10      	cmp	r3, #16
 8010216:	d14e      	bne.n	80102b6 <netconn_drain+0xc6>
        if(mem != NULL) {
 8010218:	9d03      	ldr	r5, [sp, #12]
 801021a:	2d00      	cmp	r5, #0
 801021c:	d0f3      	beq.n	8010206 <netconn_drain+0x16>
          p = (struct pbuf*)mem;
          /* pcb might be set to NULL already by err_tcp() */
          if (conn->pcb.tcp != NULL) {
 801021e:	6873      	ldr	r3, [r6, #4]
            tcp_recved(conn->pcb.tcp, p->tot_len);
 8010220:	4618      	mov	r0, r3
#if LWIP_TCP
      if (conn->type == NETCONN_TCP) {
        if(mem != NULL) {
          p = (struct pbuf*)mem;
          /* pcb might be set to NULL already by err_tcp() */
          if (conn->pcb.tcp != NULL) {
 8010222:	b113      	cbz	r3, 801022a <netconn_drain+0x3a>
            tcp_recved(conn->pcb.tcp, p->tot_len);
 8010224:	8929      	ldrh	r1, [r5, #8]
 8010226:	f7f9 feab 	bl	8009f80 <tcp_recved>
          }
          pbuf_free(p);
 801022a:	4628      	mov	r0, r5
 801022c:	f7f9 f8e8 	bl	8009400 <pbuf_free>

  /* This runs in tcpip_thread, so we don't need to lock against rx packets */

  /* Delete and drain the recvmbox. */
  if (sys_mbox_valid(&conn->recvmbox)) {
    while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
 8010230:	4620      	mov	r0, r4
 8010232:	4639      	mov	r1, r7
 8010234:	f7f7 fd5c 	bl	8007cf0 <sys_arch_mbox_tryfetch>
 8010238:	3001      	adds	r0, #1
 801023a:	d1ea      	bne.n	8010212 <netconn_drain+0x22>
#endif /* LWIP_TCP */
      {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(&conn->recvmbox);
 801023c:	4620      	mov	r0, r4
 801023e:	f7f7 fcef 	bl	8007c20 <sys_mbox_free>
    sys_mbox_set_invalid(&conn->recvmbox);
 8010242:	4620      	mov	r0, r4
 8010244:	f7f7 fd6c 	bl	8007d20 <sys_mbox_set_invalid>
  }

  /* Delete and drain the acceptmbox. */
#if LWIP_TCP
  if (sys_mbox_valid(&conn->acceptmbox)) {
 8010248:	f106 0814 	add.w	r8, r6, #20
 801024c:	4640      	mov	r0, r8
 801024e:	f7f7 fd5f 	bl	8007d10 <sys_mbox_valid>
 8010252:	b368      	cbz	r0, 80102b0 <netconn_drain+0xc0>
 8010254:	af03      	add	r7, sp, #12
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      struct netconn *newconn = (struct netconn *)mem;
      /* Only tcp pcbs have an acceptmbox, so no need to check conn->type */
      /* pcb might be set to NULL already by err_tcp() */
      if (conn->pcb.tcp != NULL) {
        tcp_accepted(conn->pcb.tcp);
 8010256:	f8df 9074 	ldr.w	r9, [pc, #116]	; 80102cc <netconn_drain+0xdc>
 801025a:	e01d      	b.n	8010298 <netconn_drain+0xa8>
  if (sys_mbox_valid(&conn->acceptmbox)) {
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      struct netconn *newconn = (struct netconn *)mem;
      /* Only tcp pcbs have an acceptmbox, so no need to check conn->type */
      /* pcb might be set to NULL already by err_tcp() */
      if (conn->pcb.tcp != NULL) {
 801025c:	6875      	ldr	r5, [r6, #4]
        tcp_accepted(conn->pcb.tcp);
 801025e:	4918      	ldr	r1, [pc, #96]	; (80102c0 <netconn_drain+0xd0>)
 8010260:	4a18      	ldr	r2, [pc, #96]	; (80102c4 <netconn_drain+0xd4>)
 8010262:	4819      	ldr	r0, [pc, #100]	; (80102c8 <netconn_drain+0xd8>)

  /* Delete and drain the acceptmbox. */
#if LWIP_TCP
  if (sys_mbox_valid(&conn->acceptmbox)) {
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      struct netconn *newconn = (struct netconn *)mem;
 8010264:	9c03      	ldr	r4, [sp, #12]
      /* Only tcp pcbs have an acceptmbox, so no need to check conn->type */
      /* pcb might be set to NULL already by err_tcp() */
      if (conn->pcb.tcp != NULL) {
        tcp_accepted(conn->pcb.tcp);
 8010266:	f240 23d2 	movw	r3, #722	; 0x2d2
  if (sys_mbox_valid(&conn->acceptmbox)) {
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      struct netconn *newconn = (struct netconn *)mem;
      /* Only tcp pcbs have an acceptmbox, so no need to check conn->type */
      /* pcb might be set to NULL already by err_tcp() */
      if (conn->pcb.tcp != NULL) {
 801026a:	b14d      	cbz	r5, 8010280 <netconn_drain+0x90>
        tcp_accepted(conn->pcb.tcp);
 801026c:	7e2d      	ldrb	r5, [r5, #24]
 801026e:	2d01      	cmp	r5, #1
 8010270:	d006      	beq.n	8010280 <netconn_drain+0x90>
 8010272:	f8cd 9000 	str.w	r9, [sp]
 8010276:	f7ff faab 	bl	800f7d0 <chprintf.constprop.1>
 801027a:	4812      	ldr	r0, [pc, #72]	; (80102c4 <netconn_drain+0xd4>)
 801027c:	f7f0 fe78 	bl	8000f70 <chSysHalt>
      }
      /* drain recvmbox */
      netconn_drain(newconn);
 8010280:	4620      	mov	r0, r4
 8010282:	f7ff ffb5 	bl	80101f0 <netconn_drain>
      if (newconn->pcb.tcp != NULL) {
 8010286:	6860      	ldr	r0, [r4, #4]
 8010288:	b118      	cbz	r0, 8010292 <netconn_drain+0xa2>
        tcp_abort(newconn->pcb.tcp);
 801028a:	f7fa fcf1 	bl	800ac70 <tcp_abort>
        newconn->pcb.tcp = NULL;
 801028e:	2300      	movs	r3, #0
 8010290:	6063      	str	r3, [r4, #4]
      }
      netconn_free(newconn);
 8010292:	4620      	mov	r0, r4
 8010294:	f7ff ff5c 	bl	8010150 <netconn_free>
  }

  /* Delete and drain the acceptmbox. */
#if LWIP_TCP
  if (sys_mbox_valid(&conn->acceptmbox)) {
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
 8010298:	4640      	mov	r0, r8
 801029a:	4639      	mov	r1, r7
 801029c:	f7f7 fd28 	bl	8007cf0 <sys_arch_mbox_tryfetch>
 80102a0:	3001      	adds	r0, #1
 80102a2:	d1db      	bne.n	801025c <netconn_drain+0x6c>
        tcp_abort(newconn->pcb.tcp);
        newconn->pcb.tcp = NULL;
      }
      netconn_free(newconn);
    }
    sys_mbox_free(&conn->acceptmbox);
 80102a4:	4640      	mov	r0, r8
 80102a6:	f7f7 fcbb 	bl	8007c20 <sys_mbox_free>
    sys_mbox_set_invalid(&conn->acceptmbox);
 80102aa:	4640      	mov	r0, r8
 80102ac:	f7f7 fd38 	bl	8007d20 <sys_mbox_set_invalid>
  }
#endif /* LWIP_TCP */
}
 80102b0:	b005      	add	sp, #20
 80102b2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
          pbuf_free(p);
        }
      } else
#endif /* LWIP_TCP */
      {
        netbuf_delete((struct netbuf *)mem);
 80102b6:	9803      	ldr	r0, [sp, #12]
 80102b8:	f000 fa92 	bl	80107e0 <netbuf_delete>
 80102bc:	e7a3      	b.n	8010206 <netconn_drain+0x16>
 80102be:	bf00      	nop
 80102c0:	08016fe0 	.word	0x08016fe0
 80102c4:	08018e08 	.word	0x08018e08
 80102c8:	200180c8 	.word	0x200180c8
 80102cc:	08018ab4 	.word	0x08018ab4

080102d0 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
 80102d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  struct netconn *newconn;
  struct netconn *conn = (struct netconn *)arg;

  LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->tate: %s\n", tcp_debug_state_str(newpcb->state)));

  if (!sys_mbox_valid(&conn->acceptmbox)) {
 80102d4:	f100 0514 	add.w	r5, r0, #20
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
 80102d8:	4604      	mov	r4, r0
  struct netconn *newconn;
  struct netconn *conn = (struct netconn *)arg;

  LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->tate: %s\n", tcp_debug_state_str(newpcb->state)));

  if (!sys_mbox_valid(&conn->acceptmbox)) {
 80102da:	4628      	mov	r0, r5
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
 80102dc:	4688      	mov	r8, r1
 80102de:	4617      	mov	r7, r2
  struct netconn *newconn;
  struct netconn *conn = (struct netconn *)arg;

  LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->tate: %s\n", tcp_debug_state_str(newpcb->state)));

  if (!sys_mbox_valid(&conn->acceptmbox)) {
 80102e0:	f7f7 fd16 	bl	8007d10 <sys_mbox_valid>
 80102e4:	b1c8      	cbz	r0, 801031a <accept_function+0x4a>
    return ERR_VAL;
  }

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
 80102e6:	7820      	ldrb	r0, [r4, #0]
 80102e8:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80102ea:	f7ff fed9 	bl	80100a0 <netconn_alloc>
  if (newconn == NULL) {
 80102ee:	4606      	mov	r6, r0
 80102f0:	b1a8      	cbz	r0, 801031e <accept_function+0x4e>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
 80102f2:	f8c0 8004 	str.w	r8, [r0, #4]
  setup_tcp(newconn);
 80102f6:	f7ff fa43 	bl	800f780 <setup_tcp>
  /* no protection: when creating the pcb, the netconn is not yet known
     to the application thread */
  newconn->last_err = err;

  if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
 80102fa:	4628      	mov	r0, r5
  }
  newconn->pcb.tcp = newpcb;
  setup_tcp(newconn);
  /* no protection: when creating the pcb, the netconn is not yet known
     to the application thread */
  newconn->last_err = err;
 80102fc:	7237      	strb	r7, [r6, #8]

  if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
 80102fe:	4631      	mov	r1, r6
 8010300:	f7f7 fcbe 	bl	8007c80 <sys_mbox_trypost>
 8010304:	4605      	mov	r5, r0
 8010306:	b960      	cbnz	r0, 8010322 <accept_function+0x52>
    sys_mbox_set_invalid(&newconn->recvmbox);
    netconn_free(newconn);
    return ERR_MEM;
  } else {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 8010308:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 801030a:	b11b      	cbz	r3, 8010314 <accept_function+0x44>
 801030c:	4620      	mov	r0, r4
 801030e:	4629      	mov	r1, r5
 8010310:	462a      	mov	r2, r5
 8010312:	4798      	blx	r3
  }

  return ERR_OK;
}
 8010314:	b268      	sxtb	r0, r5
 8010316:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->tate: %s\n", tcp_debug_state_str(newpcb->state)));

  if (!sys_mbox_valid(&conn->acceptmbox)) {
    LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: acceptmbox already deleted\n"));
    return ERR_VAL;
 801031a:	25fa      	movs	r5, #250	; 0xfa
 801031c:	e7fa      	b.n	8010314 <accept_function+0x44>

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  if (newconn == NULL) {
    return ERR_MEM;
 801031e:	25ff      	movs	r5, #255	; 0xff
 8010320:	e7f8      	b.n	8010314 <accept_function+0x44>

  if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
    /* When returning != ERR_OK, the pcb is aborted in tcp_process(),
       so do nothing here! */
    /* remove all references to this netconn from the pcb */
    struct tcp_pcb* pcb = newconn->pcb.tcp;
 8010322:	6874      	ldr	r4, [r6, #4]
    tcp_arg(pcb, NULL);
 8010324:	2100      	movs	r1, #0
 8010326:	4620      	mov	r0, r4
 8010328:	f7f9 feb2 	bl	800a090 <tcp_arg>
    tcp_recv(pcb, NULL);
 801032c:	4620      	mov	r0, r4
 801032e:	2100      	movs	r1, #0
 8010330:	f7f9 feb6 	bl	800a0a0 <tcp_recv>
    tcp_sent(pcb, NULL);
 8010334:	4620      	mov	r0, r4
 8010336:	2100      	movs	r1, #0
 8010338:	f7f9 feda 	bl	800a0f0 <tcp_sent>
    tcp_poll(pcb, NULL, 4);
 801033c:	2204      	movs	r2, #4
 801033e:	4620      	mov	r0, r4
 8010340:	2100      	movs	r1, #0
 8010342:	f7f9 ff2d 	bl	800a1a0 <tcp_poll>
    tcp_err(pcb, NULL);
 8010346:	2100      	movs	r1, #0
 8010348:	4620      	mov	r0, r4
 801034a:	f7f9 fef9 	bl	800a140 <tcp_err>
    /* remove reference from to the pcb from this netconn */
    newconn->pcb.tcp = NULL;
    /* no need to drain since we know the recvmbox is empty. */
    sys_mbox_free(&newconn->recvmbox);
 801034e:	f106 0410 	add.w	r4, r6, #16
    tcp_recv(pcb, NULL);
    tcp_sent(pcb, NULL);
    tcp_poll(pcb, NULL, 4);
    tcp_err(pcb, NULL);
    /* remove reference from to the pcb from this netconn */
    newconn->pcb.tcp = NULL;
 8010352:	2300      	movs	r3, #0
 8010354:	6073      	str	r3, [r6, #4]
    /* no need to drain since we know the recvmbox is empty. */
    sys_mbox_free(&newconn->recvmbox);
 8010356:	4620      	mov	r0, r4
 8010358:	f7f7 fc62 	bl	8007c20 <sys_mbox_free>
    sys_mbox_set_invalid(&newconn->recvmbox);
 801035c:	4620      	mov	r0, r4
 801035e:	f7f7 fcdf 	bl	8007d20 <sys_mbox_set_invalid>
    netconn_free(newconn);
 8010362:	4630      	mov	r0, r6
 8010364:	f7ff fef4 	bl	8010150 <netconn_free>
    return ERR_MEM;
 8010368:	25ff      	movs	r5, #255	; 0xff
 801036a:	e7d3      	b.n	8010314 <accept_function+0x44>
 801036c:	f3af 8000 	nop.w

08010370 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
 8010370:	b530      	push	{r4, r5, lr}
  /* @todo TCP: abort running write/connect? */
 if ((msg->conn->state != NETCONN_NONE) &&
 8010372:	6803      	ldr	r3, [r0, #0]
 8010374:	785a      	ldrb	r2, [r3, #1]
 8010376:	f012 0ffd 	tst.w	r2, #253	; 0xfd
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
 801037a:	b083      	sub	sp, #12
 801037c:	4604      	mov	r4, r0
  /* @todo TCP: abort running write/connect? */
 if ((msg->conn->state != NETCONN_NONE) &&
 801037e:	d02b      	beq.n	80103d8 <do_delconn+0x68>
     (msg->conn->state != NETCONN_LISTEN) &&
 8010380:	2a03      	cmp	r2, #3
 8010382:	d019      	beq.n	80103b8 <do_delconn+0x48>
     (msg->conn->state != NETCONN_CONNECT)) {
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
 8010384:	781a      	ldrb	r2, [r3, #0]
 8010386:	2a10      	cmp	r2, #16
 8010388:	d00c      	beq.n	80103a4 <do_delconn+0x34>
 801038a:	4b3f      	ldr	r3, [pc, #252]	; (8010488 <do_delconn+0x118>)
 801038c:	9300      	str	r3, [sp, #0]
 801038e:	493f      	ldr	r1, [pc, #252]	; (801048c <do_delconn+0x11c>)
 8010390:	4a3f      	ldr	r2, [pc, #252]	; (8010490 <do_delconn+0x120>)
 8010392:	4840      	ldr	r0, [pc, #256]	; (8010494 <do_delconn+0x124>)
 8010394:	f240 3347 	movw	r3, #839	; 0x347
 8010398:	f7ff fa1a 	bl	800f7d0 <chprintf.constprop.1>
 801039c:	483c      	ldr	r0, [pc, #240]	; (8010490 <do_delconn+0x120>)
 801039e:	f7f0 fde7 	bl	8000f70 <chSysHalt>
 80103a2:	6823      	ldr	r3, [r4, #0]
    msg->err = ERR_INPROGRESS;
 80103a4:	22fb      	movs	r2, #251	; 0xfb
 80103a6:	7122      	strb	r2, [r4, #4]
    /* @todo: this lets select make the socket readable and writable,
       which is wrong! errfd instead? */
    API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
    API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  }
  if (sys_sem_valid(&msg->conn->op_completed)) {
 80103a8:	f103 000c 	add.w	r0, r3, #12
 80103ac:	f7f7 fc00 	bl	8007bb0 <sys_sem_valid>
 80103b0:	2800      	cmp	r0, #0
 80103b2:	d139      	bne.n	8010428 <do_delconn+0xb8>
    sys_sem_signal(&msg->conn->op_completed);
  }
}
 80103b4:	b003      	add	sp, #12
 80103b6:	bd30      	pop	{r4, r5, pc}
     (msg->conn->state != NETCONN_CONNECT)) {
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
  } else {
    LWIP_ASSERT("blocking connect in progress",
 80103b8:	7f1a      	ldrb	r2, [r3, #28]
 80103ba:	0752      	lsls	r2, r2, #29
 80103bc:	d40c      	bmi.n	80103d8 <do_delconn+0x68>
 80103be:	4b32      	ldr	r3, [pc, #200]	; (8010488 <do_delconn+0x118>)
 80103c0:	9300      	str	r3, [sp, #0]
 80103c2:	4932      	ldr	r1, [pc, #200]	; (801048c <do_delconn+0x11c>)
 80103c4:	4a34      	ldr	r2, [pc, #208]	; (8010498 <do_delconn+0x128>)
 80103c6:	4833      	ldr	r0, [pc, #204]	; (8010494 <do_delconn+0x124>)
 80103c8:	f240 334b 	movw	r3, #843	; 0x34b
 80103cc:	f7ff fa00 	bl	800f7d0 <chprintf.constprop.1>
 80103d0:	4831      	ldr	r0, [pc, #196]	; (8010498 <do_delconn+0x128>)
 80103d2:	f7f0 fdcd 	bl	8000f70 <chSysHalt>
 80103d6:	6823      	ldr	r3, [r4, #0]
      (msg->conn->state != NETCONN_CONNECT) || IN_NONBLOCKING_CONNECT(msg->conn));
    /* Drain and delete mboxes */
    netconn_drain(msg->conn);
 80103d8:	4618      	mov	r0, r3
 80103da:	f7ff ff09 	bl	80101f0 <netconn_drain>

    if (msg->conn->pcb.tcp != NULL) {
 80103de:	6823      	ldr	r3, [r4, #0]
 80103e0:	6858      	ldr	r0, [r3, #4]
 80103e2:	b158      	cbz	r0, 80103fc <do_delconn+0x8c>

      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 80103e4:	781a      	ldrb	r2, [r3, #0]
 80103e6:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 80103ea:	2a20      	cmp	r2, #32
 80103ec:	d023      	beq.n	8010436 <do_delconn+0xc6>
 80103ee:	2a40      	cmp	r2, #64	; 0x40
 80103f0:	d042      	beq.n	8010478 <do_delconn+0x108>
 80103f2:	2a10      	cmp	r2, #16
 80103f4:	d026      	beq.n	8010444 <do_delconn+0xd4>
        return;
#endif /* LWIP_TCP */
      default:
        break;
      }
      msg->conn->pcb.tcp = NULL;
 80103f6:	2200      	movs	r2, #0
 80103f8:	605a      	str	r2, [r3, #4]
 80103fa:	6823      	ldr	r3, [r4, #0]
    }
    /* tcp netconns don't come here! */

    /* @todo: this lets select make the socket readable and writable,
       which is wrong! errfd instead? */
    API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
 80103fc:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 80103fe:	2d00      	cmp	r5, #0
 8010400:	d0d2      	beq.n	80103a8 <do_delconn+0x38>
 8010402:	2100      	movs	r1, #0
 8010404:	4618      	mov	r0, r3
 8010406:	460a      	mov	r2, r1
 8010408:	47a8      	blx	r5
    API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
 801040a:	6823      	ldr	r3, [r4, #0]
 801040c:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 801040e:	2d00      	cmp	r5, #0
 8010410:	d0ca      	beq.n	80103a8 <do_delconn+0x38>
 8010412:	4618      	mov	r0, r3
 8010414:	2102      	movs	r1, #2
 8010416:	2200      	movs	r2, #0
 8010418:	47a8      	blx	r5
 801041a:	6823      	ldr	r3, [r4, #0]
  }
  if (sys_sem_valid(&msg->conn->op_completed)) {
 801041c:	f103 000c 	add.w	r0, r3, #12
 8010420:	f7f7 fbc6 	bl	8007bb0 <sys_sem_valid>
 8010424:	2800      	cmp	r0, #0
 8010426:	d0c5      	beq.n	80103b4 <do_delconn+0x44>
    sys_sem_signal(&msg->conn->op_completed);
 8010428:	6820      	ldr	r0, [r4, #0]
 801042a:	300c      	adds	r0, #12
  }
}
 801042c:	b003      	add	sp, #12
 801042e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
       which is wrong! errfd instead? */
    API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
    API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  }
  if (sys_sem_valid(&msg->conn->op_completed)) {
    sys_sem_signal(&msg->conn->op_completed);
 8010432:	f7f7 bb95 	b.w	8007b60 <sys_sem_signal>
        raw_remove(msg->conn->pcb.raw);
        break;
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->pcb.udp->recv_arg = NULL;
 8010436:	2200      	movs	r2, #0
 8010438:	61c2      	str	r2, [r0, #28]
        udp_remove(msg->conn->pcb.udp);
 801043a:	6858      	ldr	r0, [r3, #4]
 801043c:	f7fd fb08 	bl	800da50 <udp_remove>
 8010440:	6823      	ldr	r3, [r4, #0]
        break;
 8010442:	e7d8      	b.n	80103f6 <do_delconn+0x86>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
 8010444:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8010446:	b1da      	cbz	r2, 8010480 <do_delconn+0x110>
 8010448:	4b0f      	ldr	r3, [pc, #60]	; (8010488 <do_delconn+0x118>)
 801044a:	9300      	str	r3, [sp, #0]
 801044c:	490f      	ldr	r1, [pc, #60]	; (801048c <do_delconn+0x11c>)
 801044e:	4a13      	ldr	r2, [pc, #76]	; (801049c <do_delconn+0x12c>)
 8010450:	4810      	ldr	r0, [pc, #64]	; (8010494 <do_delconn+0x124>)
 8010452:	f44f 7358 	mov.w	r3, #864	; 0x360
 8010456:	f7ff f9bb 	bl	800f7d0 <chprintf.constprop.1>
 801045a:	4810      	ldr	r0, [pc, #64]	; (801049c <do_delconn+0x12c>)
 801045c:	f7f0 fd88 	bl	8000f70 <chSysHalt>
 8010460:	6823      	ldr	r3, [r4, #0]
          msg->conn->write_offset == 0);
        msg->conn->state = NETCONN_CLOSE;
 8010462:	2104      	movs	r1, #4
        msg->msg.sd.shut = NETCONN_SHUT_RDWR;
 8010464:	2203      	movs	r2, #3
        msg->conn->current_msg = msg;
        do_close_internal(msg->conn);
 8010466:	4618      	mov	r0, r3
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
          msg->conn->write_offset == 0);
        msg->conn->state = NETCONN_CLOSE;
 8010468:	7059      	strb	r1, [r3, #1]
        msg->msg.sd.shut = NETCONN_SHUT_RDWR;
 801046a:	7222      	strb	r2, [r4, #8]
        msg->conn->current_msg = msg;
 801046c:	625c      	str	r4, [r3, #36]	; 0x24
    API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  }
  if (sys_sem_valid(&msg->conn->op_completed)) {
    sys_sem_signal(&msg->conn->op_completed);
  }
}
 801046e:	b003      	add	sp, #12
 8010470:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
          msg->conn->write_offset == 0);
        msg->conn->state = NETCONN_CLOSE;
        msg->msg.sd.shut = NETCONN_SHUT_RDWR;
        msg->conn->current_msg = msg;
        do_close_internal(msg->conn);
 8010474:	f7ff ba3c 	b.w	800f8f0 <do_close_internal>
    if (msg->conn->pcb.tcp != NULL) {

      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        raw_remove(msg->conn->pcb.raw);
 8010478:	f7f9 fbe2 	bl	8009c40 <raw_remove>
 801047c:	6823      	ldr	r3, [r4, #0]
        break;
 801047e:	e7ba      	b.n	80103f6 <do_delconn+0x86>
        udp_remove(msg->conn->pcb.udp);
        break;
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
 8010480:	6a1a      	ldr	r2, [r3, #32]
 8010482:	2a00      	cmp	r2, #0
 8010484:	d1e0      	bne.n	8010448 <do_delconn+0xd8>
 8010486:	e7ec      	b.n	8010462 <do_delconn+0xf2>
 8010488:	08018ab4 	.word	0x08018ab4
 801048c:	08016fe0 	.word	0x08016fe0
 8010490:	08018e38 	.word	0x08018e38
 8010494:	200180c8 	.word	0x200180c8
 8010498:	08018e58 	.word	0x08018e58
 801049c:	08018e78 	.word	0x08018e78

080104a0 <do_bind>:
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 80104a0:	6803      	ldr	r3, [r0, #0]
 80104a2:	7a1a      	ldrb	r2, [r3, #8]
 80104a4:	b251      	sxtb	r1, r2
 80104a6:	3109      	adds	r1, #9
 80104a8:	db14      	blt.n	80104d4 <do_bind+0x34>
    msg->err = msg->conn->last_err;
  } else {
    msg->err = ERR_VAL;
 80104aa:	22fa      	movs	r2, #250	; 0xfa
 80104ac:	7102      	strb	r2, [r0, #4]
    if (msg->conn->pcb.tcp != NULL) {
 80104ae:	6859      	ldr	r1, [r3, #4]
 80104b0:	b189      	cbz	r1, 80104d6 <do_bind+0x36>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 80104b2:	781a      	ldrb	r2, [r3, #0]
 80104b4:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 80104b8:	2a20      	cmp	r2, #32
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
 80104ba:	b510      	push	{r4, lr}
 80104bc:	4604      	mov	r4, r0
  if (ERR_IS_FATAL(msg->conn->last_err)) {
    msg->err = msg->conn->last_err;
  } else {
    msg->err = ERR_VAL;
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 80104be:	d00e      	beq.n	80104de <do_bind+0x3e>
 80104c0:	2a40      	cmp	r2, #64	; 0x40
 80104c2:	d026      	beq.n	8010512 <do_bind+0x72>
 80104c4:	2a10      	cmp	r2, #16
 80104c6:	d017      	beq.n	80104f8 <do_bind+0x58>
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 80104c8:	f103 000c 	add.w	r0, r3, #12
}
 80104cc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 80104d0:	f7f7 bb46 	b.w	8007b60 <sys_sem_signal>
 */
void
do_bind(struct api_msg_msg *msg)
{
  if (ERR_IS_FATAL(msg->conn->last_err)) {
    msg->err = msg->conn->last_err;
 80104d4:	7102      	strb	r2, [r0, #4]
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 80104d6:	f103 000c 	add.w	r0, r3, #12
 80104da:	f7f7 bb41 	b.w	8007b60 <sys_sem_signal>
        msg->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
        break;
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
 80104de:	4608      	mov	r0, r1
 80104e0:	89a2      	ldrh	r2, [r4, #12]
 80104e2:	68a1      	ldr	r1, [r4, #8]
 80104e4:	f7fd fa2c 	bl	800d940 <udp_bind>
 80104e8:	6823      	ldr	r3, [r4, #0]
 80104ea:	7120      	strb	r0, [r4, #4]
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
}
 80104ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 80104f0:	f103 000c 	add.w	r0, r3, #12
 80104f4:	f7f7 bb34 	b.w	8007b60 <sys_sem_signal>
        msg->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
        break;
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
 80104f8:	4608      	mov	r0, r1
 80104fa:	89a2      	ldrh	r2, [r4, #12]
 80104fc:	68a1      	ldr	r1, [r4, #8]
 80104fe:	f7f9 fc37 	bl	8009d70 <tcp_bind>
 8010502:	6823      	ldr	r3, [r4, #0]
 8010504:	7120      	strb	r0, [r4, #4]
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
}
 8010506:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 801050a:	f103 000c 	add.w	r0, r3, #12
 801050e:	f7f7 bb27 	b.w	8007b60 <sys_sem_signal>
    msg->err = ERR_VAL;
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        msg->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
 8010512:	4608      	mov	r0, r1
 8010514:	68a1      	ldr	r1, [r4, #8]
 8010516:	f7f9 fb83 	bl	8009c20 <raw_bind>
 801051a:	6823      	ldr	r3, [r4, #0]
 801051c:	7120      	strb	r0, [r4, #4]
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
}
 801051e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 8010522:	f103 000c 	add.w	r0, r3, #12
 8010526:	f7f7 bb1b 	b.w	8007b60 <sys_sem_signal>
 801052a:	bf00      	nop
 801052c:	f3af 8000 	nop.w

08010530 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
 8010530:	b538      	push	{r3, r4, r5, lr}
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 8010532:	6803      	ldr	r3, [r0, #0]
 8010534:	7a1a      	ldrb	r2, [r3, #8]
 8010536:	b251      	sxtb	r1, r2
 8010538:	3109      	adds	r1, #9
 801053a:	db07      	blt.n	801054c <do_listen+0x1c>
    msg->err = msg->conn->last_err;
  } else {
    msg->err = ERR_CONN;
 801053c:	22f3      	movs	r2, #243	; 0xf3
 801053e:	7102      	strb	r2, [r0, #4]
    if (msg->conn->pcb.tcp != NULL) {
 8010540:	685a      	ldr	r2, [r3, #4]
 8010542:	b122      	cbz	r2, 801054e <do_listen+0x1e>
      if (msg->conn->type == NETCONN_TCP) {
 8010544:	7819      	ldrb	r1, [r3, #0]
 8010546:	2910      	cmp	r1, #16
 8010548:	d007      	beq.n	801055a <do_listen+0x2a>
              msg->conn->pcb.tcp = NULL;
            }
          }
        }
      } else {
        msg->err = ERR_ARG;
 801054a:	22f2      	movs	r2, #242	; 0xf2
 801054c:	7102      	strb	r2, [r0, #4]
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 801054e:	f103 000c 	add.w	r0, r3, #12
}
 8010552:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      } else {
        msg->err = ERR_ARG;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 8010556:	f7f7 bb03 	b.w	8007b60 <sys_sem_signal>
    msg->err = msg->conn->last_err;
  } else {
    msg->err = ERR_CONN;
    if (msg->conn->pcb.tcp != NULL) {
      if (msg->conn->type == NETCONN_TCP) {
        if (msg->conn->state == NETCONN_NONE) {
 801055a:	7859      	ldrb	r1, [r3, #1]
 801055c:	2900      	cmp	r1, #0
 801055e:	d1f6      	bne.n	801054e <do_listen+0x1e>
 8010560:	4604      	mov	r4, r0
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
 8010562:	21ff      	movs	r1, #255	; 0xff
 8010564:	4610      	mov	r0, r2
 8010566:	f7f9 fc5b 	bl	8009e20 <tcp_listen_with_backlog>
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
 801056a:	4605      	mov	r5, r0
 801056c:	b1e0      	cbz	r0, 80105a8 <do_listen+0x78>
            /* in this case, the old pcb is still allocated */
            msg->err = ERR_MEM;
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (sys_mbox_valid(&msg->conn->recvmbox)) {
 801056e:	6820      	ldr	r0, [r4, #0]
 8010570:	3010      	adds	r0, #16
 8010572:	f7f7 fbcd 	bl	8007d10 <sys_mbox_valid>
 8010576:	bb50      	cbnz	r0, 80105ce <do_listen+0x9e>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(&msg->conn->recvmbox);
              sys_mbox_set_invalid(&msg->conn->recvmbox);
            }
            msg->err = ERR_OK;
            if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
 8010578:	6820      	ldr	r0, [r4, #0]
            if (sys_mbox_valid(&msg->conn->recvmbox)) {
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(&msg->conn->recvmbox);
              sys_mbox_set_invalid(&msg->conn->recvmbox);
            }
            msg->err = ERR_OK;
 801057a:	2300      	movs	r3, #0
            if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
 801057c:	3014      	adds	r0, #20
            if (sys_mbox_valid(&msg->conn->recvmbox)) {
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(&msg->conn->recvmbox);
              sys_mbox_set_invalid(&msg->conn->recvmbox);
            }
            msg->err = ERR_OK;
 801057e:	7123      	strb	r3, [r4, #4]
            if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
 8010580:	f7f7 fbc6 	bl	8007d10 <sys_mbox_valid>
 8010584:	b1e0      	cbz	r0, 80105c0 <do_listen+0x90>
 8010586:	7920      	ldrb	r0, [r4, #4]
              msg->err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
            }
            if (msg->err == ERR_OK) {
 8010588:	b990      	cbnz	r0, 80105b0 <do_listen+0x80>
              msg->conn->state = NETCONN_LISTEN;
 801058a:	6823      	ldr	r3, [r4, #0]
              msg->conn->pcb.tcp = lpcb;
 801058c:	605d      	str	r5, [r3, #4]
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
 801058e:	6821      	ldr	r1, [r4, #0]
            msg->err = ERR_OK;
            if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
              msg->err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
            }
            if (msg->err == ERR_OK) {
              msg->conn->state = NETCONN_LISTEN;
 8010590:	2202      	movs	r2, #2
 8010592:	705a      	strb	r2, [r3, #1]
              msg->conn->pcb.tcp = lpcb;
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
 8010594:	6848      	ldr	r0, [r1, #4]
 8010596:	f7f9 fd7b 	bl	800a090 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
 801059a:	6823      	ldr	r3, [r4, #0]
 801059c:	4910      	ldr	r1, [pc, #64]	; (80105e0 <do_listen+0xb0>)
 801059e:	6858      	ldr	r0, [r3, #4]
 80105a0:	f7f9 fdf6 	bl	800a190 <tcp_accept>
 80105a4:	6823      	ldr	r3, [r4, #0]
 80105a6:	e7d2      	b.n	801054e <do_listen+0x1e>
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
            /* in this case, the old pcb is still allocated */
            msg->err = ERR_MEM;
 80105a8:	23ff      	movs	r3, #255	; 0xff
 80105aa:	7123      	strb	r3, [r4, #4]
 80105ac:	6823      	ldr	r3, [r4, #0]
 80105ae:	e7ce      	b.n	801054e <do_listen+0x1e>
              msg->conn->pcb.tcp = lpcb;
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
              tcp_accept(msg->conn->pcb.tcp, accept_function);
            } else {
              /* since the old pcb is already deallocated, free lpcb now */
              tcp_close(lpcb);
 80105b0:	4628      	mov	r0, r5
 80105b2:	f7fa f9fd 	bl	800a9b0 <tcp_close>
              msg->conn->pcb.tcp = NULL;
 80105b6:	6823      	ldr	r3, [r4, #0]
 80105b8:	2200      	movs	r2, #0
 80105ba:	605a      	str	r2, [r3, #4]
 80105bc:	6823      	ldr	r3, [r4, #0]
 80105be:	e7c6      	b.n	801054e <do_listen+0x1e>
              sys_mbox_free(&msg->conn->recvmbox);
              sys_mbox_set_invalid(&msg->conn->recvmbox);
            }
            msg->err = ERR_OK;
            if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
              msg->err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
 80105c0:	6820      	ldr	r0, [r4, #0]
 80105c2:	2104      	movs	r1, #4
 80105c4:	3014      	adds	r0, #20
 80105c6:	f7f7 fb03 	bl	8007bd0 <sys_mbox_new>
 80105ca:	7120      	strb	r0, [r4, #4]
 80105cc:	e7dc      	b.n	8010588 <do_listen+0x58>
            msg->err = ERR_MEM;
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (sys_mbox_valid(&msg->conn->recvmbox)) {
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(&msg->conn->recvmbox);
 80105ce:	6820      	ldr	r0, [r4, #0]
 80105d0:	3010      	adds	r0, #16
 80105d2:	f7f7 fb25 	bl	8007c20 <sys_mbox_free>
              sys_mbox_set_invalid(&msg->conn->recvmbox);
 80105d6:	6820      	ldr	r0, [r4, #0]
 80105d8:	3010      	adds	r0, #16
 80105da:	f7f7 fba1 	bl	8007d20 <sys_mbox_set_invalid>
 80105de:	e7cb      	b.n	8010578 <do_listen+0x48>
 80105e0:	080102d1 	.word	0x080102d1
 80105e4:	f3af 8000 	nop.w
 80105e8:	f3af 8000 	nop.w
 80105ec:	f3af 8000 	nop.w

080105f0 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
 80105f0:	b570      	push	{r4, r5, r6, lr}
  msg->err = ERR_OK;
 80105f2:	2200      	movs	r2, #0
  if (msg->conn->pcb.tcp != NULL) {
 80105f4:	6803      	ldr	r3, [r0, #0]
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  msg->err = ERR_OK;
 80105f6:	7102      	strb	r2, [r0, #4]
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
 80105f8:	4606      	mov	r6, r0
  msg->err = ERR_OK;
  if (msg->conn->pcb.tcp != NULL) {
 80105fa:	6858      	ldr	r0, [r3, #4]
 80105fc:	b110      	cbz	r0, 8010604 <do_recv+0x14>
    if (msg->conn->type == NETCONN_TCP) {
 80105fe:	781a      	ldrb	r2, [r3, #0]
 8010600:	2a10      	cmp	r2, #16
 8010602:	d005      	beq.n	8010610 <do_recv+0x20>
          remaining -= recved;
        }while(remaining != 0);
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 8010604:	f103 000c 	add.w	r0, r3, #12
}
 8010608:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
          remaining -= recved;
        }while(remaining != 0);
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 801060c:	f7f7 baa8 	b.w	8007b60 <sys_sem_signal>
      if (msg->conn->pcb.tcp->state == LISTEN) {
        tcp_accepted(msg->conn->pcb.tcp);
      } else
#endif /* TCP_LISTEN_BACKLOG */
      {
        u32_t remaining = msg->msg.r.len;
 8010610:	68b4      	ldr	r4, [r6, #8]
 8010612:	e000      	b.n	8010616 <do_recv+0x26>
 8010614:	6858      	ldr	r0, [r3, #4]
        do {
          u16_t recved = (remaining > 0xffff) ? 0xffff : (u16_t)remaining;
 8010616:	f5b4 3f80 	cmp.w	r4, #65536	; 0x10000
 801061a:	bf2d      	iteet	cs
 801061c:	f64f 75ff 	movwcs	r5, #65535	; 0xffff
 8010620:	b2a1      	uxthcc	r1, r4
 8010622:	4625      	movcc	r5, r4
 8010624:	4629      	movcs	r1, r5
          tcp_recved(msg->conn->pcb.tcp, recved);
 8010626:	f7f9 fcab 	bl	8009f80 <tcp_recved>
          remaining -= recved;
        }while(remaining != 0);
 801062a:	1b64      	subs	r4, r4, r5
 801062c:	6833      	ldr	r3, [r6, #0]
 801062e:	d1f1      	bne.n	8010614 <do_recv+0x24>
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 8010630:	f103 000c 	add.w	r0, r3, #12
}
 8010634:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
          remaining -= recved;
        }while(remaining != 0);
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 8010638:	f7f7 ba92 	b.w	8007b60 <sys_sem_signal>
 801063c:	f3af 8000 	nop.w

08010640 <do_write>:
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 8010640:	6803      	ldr	r3, [r0, #0]
 8010642:	7a1a      	ldrb	r2, [r3, #8]
 8010644:	b251      	sxtb	r1, r2
 8010646:	3109      	adds	r1, #9
 8010648:	db03      	blt.n	8010652 <do_write+0x12>
    msg->err = msg->conn->last_err;
  } else {
    if (msg->conn->type == NETCONN_TCP) {
 801064a:	781a      	ldrb	r2, [r3, #0]
 801064c:	2a10      	cmp	r2, #16
 801064e:	d005      	beq.n	801065c <do_write+0x1c>
#else /* LWIP_TCP */
      msg->err = ERR_VAL;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->err = ERR_VAL;
 8010650:	22fa      	movs	r2, #250	; 0xfa
 8010652:	7102      	strb	r2, [r0, #4]
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
 8010654:	f103 000c 	add.w	r0, r3, #12
 8010658:	f7f7 ba82 	b.w	8007b60 <sys_sem_signal>
  if (ERR_IS_FATAL(msg->conn->last_err)) {
    msg->err = msg->conn->last_err;
  } else {
    if (msg->conn->type == NETCONN_TCP) {
#if LWIP_TCP
      if (msg->conn->state != NETCONN_NONE) {
 801065c:	785a      	ldrb	r2, [r3, #1]
 801065e:	b112      	cbz	r2, 8010666 <do_write+0x26>
        /* netconn is connecting, closing or in blocking write */
        msg->err = ERR_INPROGRESS;
 8010660:	22fb      	movs	r2, #251	; 0xfb
 8010662:	7102      	strb	r2, [r0, #4]
 8010664:	e7f6      	b.n	8010654 <do_write+0x14>
      } else if (msg->conn->pcb.tcp != NULL) {
 8010666:	685a      	ldr	r2, [r3, #4]
 8010668:	2a00      	cmp	r2, #0
 801066a:	d02e      	beq.n	80106ca <do_write+0x8a>
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
 801066c:	b510      	push	{r4, lr}
        /* netconn is connecting, closing or in blocking write */
        msg->err = ERR_INPROGRESS;
      } else if (msg->conn->pcb.tcp != NULL) {
        msg->conn->state = NETCONN_WRITE;
        /* set all the variables used by do_writemore */
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
 801066e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
#if LWIP_TCP
      if (msg->conn->state != NETCONN_NONE) {
        /* netconn is connecting, closing or in blocking write */
        msg->err = ERR_INPROGRESS;
      } else if (msg->conn->pcb.tcp != NULL) {
        msg->conn->state = NETCONN_WRITE;
 8010670:	2101      	movs	r1, #1
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
 8010672:	b082      	sub	sp, #8
 8010674:	4604      	mov	r4, r0
#if LWIP_TCP
      if (msg->conn->state != NETCONN_NONE) {
        /* netconn is connecting, closing or in blocking write */
        msg->err = ERR_INPROGRESS;
      } else if (msg->conn->pcb.tcp != NULL) {
        msg->conn->state = NETCONN_WRITE;
 8010676:	7059      	strb	r1, [r3, #1]
        /* set all the variables used by do_writemore */
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
 8010678:	b31a      	cbz	r2, 80106c2 <do_write+0x82>
 801067a:	4b15      	ldr	r3, [pc, #84]	; (80106d0 <do_write+0x90>)
 801067c:	9300      	str	r3, [sp, #0]
 801067e:	4815      	ldr	r0, [pc, #84]	; (80106d4 <do_write+0x94>)
 8010680:	4915      	ldr	r1, [pc, #84]	; (80106d8 <do_write+0x98>)
 8010682:	4a16      	ldr	r2, [pc, #88]	; (80106dc <do_write+0x9c>)
 8010684:	f240 534d 	movw	r3, #1357	; 0x54d
 8010688:	f7ff f8a2 	bl	800f7d0 <chprintf.constprop.1>
 801068c:	4813      	ldr	r0, [pc, #76]	; (80106dc <do_write+0x9c>)
 801068e:	f7f0 fc6f 	bl	8000f70 <chSysHalt>
          msg->conn->write_offset == 0);
        LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
 8010692:	68e3      	ldr	r3, [r4, #12]
 8010694:	b143      	cbz	r3, 80106a8 <do_write+0x68>
        msg->conn->current_msg = msg;
 8010696:	6820      	ldr	r0, [r4, #0]
        msg->conn->write_offset = 0;
 8010698:	2300      	movs	r3, #0
        msg->conn->state = NETCONN_WRITE;
        /* set all the variables used by do_writemore */
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
          msg->conn->write_offset == 0);
        LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
        msg->conn->current_msg = msg;
 801069a:	6244      	str	r4, [r0, #36]	; 0x24
        msg->conn->write_offset = 0;
 801069c:	6203      	str	r3, [r0, #32]
      msg->err = ERR_VAL;
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
}
 801069e:	b002      	add	sp, #8
 80106a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
          sys_arch_sem_wait(&msg->conn->op_completed, 0);
          LOCK_TCPIP_CORE();
          LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
        }
#else /* LWIP_TCPIP_CORE_LOCKING */
        do_writemore(msg->conn);
 80106a4:	f7ff ba2c 	b.w	800fb00 <do_writemore>
      } else if (msg->conn->pcb.tcp != NULL) {
        msg->conn->state = NETCONN_WRITE;
        /* set all the variables used by do_writemore */
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
          msg->conn->write_offset == 0);
        LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
 80106a8:	4b09      	ldr	r3, [pc, #36]	; (80106d0 <do_write+0x90>)
 80106aa:	9300      	str	r3, [sp, #0]
 80106ac:	490a      	ldr	r1, [pc, #40]	; (80106d8 <do_write+0x98>)
 80106ae:	4a0c      	ldr	r2, [pc, #48]	; (80106e0 <do_write+0xa0>)
 80106b0:	4808      	ldr	r0, [pc, #32]	; (80106d4 <do_write+0x94>)
 80106b2:	f240 534e 	movw	r3, #1358	; 0x54e
 80106b6:	f7ff f88b 	bl	800f7d0 <chprintf.constprop.1>
 80106ba:	4809      	ldr	r0, [pc, #36]	; (80106e0 <do_write+0xa0>)
 80106bc:	f7f0 fc58 	bl	8000f70 <chSysHalt>
 80106c0:	e7e9      	b.n	8010696 <do_write+0x56>
        /* netconn is connecting, closing or in blocking write */
        msg->err = ERR_INPROGRESS;
      } else if (msg->conn->pcb.tcp != NULL) {
        msg->conn->state = NETCONN_WRITE;
        /* set all the variables used by do_writemore */
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
 80106c2:	6a1b      	ldr	r3, [r3, #32]
 80106c4:	2b00      	cmp	r3, #0
 80106c6:	d0e4      	beq.n	8010692 <do_write+0x52>
 80106c8:	e7d7      	b.n	801067a <do_write+0x3a>
#endif /* LWIP_TCPIP_CORE_LOCKING */
        /* for both cases: if do_writemore was called, don't ACK the APIMSG
           since do_writemore ACKs it! */
        return;
      } else {
        msg->err = ERR_CONN;
 80106ca:	22f3      	movs	r2, #243	; 0xf3
 80106cc:	7102      	strb	r2, [r0, #4]
 80106ce:	e7c1      	b.n	8010654 <do_write+0x14>
 80106d0:	08018ab4 	.word	0x08018ab4
 80106d4:	200180c8 	.word	0x200180c8
 80106d8:	08016fe0 	.word	0x08016fe0
 80106dc:	08018e78 	.word	0x08018e78
 80106e0:	08018eac 	.word	0x08018eac
 80106e4:	f3af 8000 	nop.w
 80106e8:	f3af 8000 	nop.w
 80106ec:	f3af 8000 	nop.w

080106f0 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
 80106f0:	b510      	push	{r4, lr}
 80106f2:	4604      	mov	r4, r0
#if LWIP_TCP
  /* @todo: abort running write/connect? */
  if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
 80106f4:	6800      	ldr	r0, [r0, #0]
 80106f6:	7843      	ldrb	r3, [r0, #1]
 80106f8:	f013 0ffd 	tst.w	r3, #253	; 0xfd
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
 80106fc:	b082      	sub	sp, #8
#if LWIP_TCP
  /* @todo: abort running write/connect? */
  if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
 80106fe:	d017      	beq.n	8010730 <do_close+0x40>
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
 8010700:	7803      	ldrb	r3, [r0, #0]
 8010702:	2b10      	cmp	r3, #16
 8010704:	d00c      	beq.n	8010720 <do_close+0x30>
 8010706:	4b25      	ldr	r3, [pc, #148]	; (801079c <do_close+0xac>)
 8010708:	9300      	str	r3, [sp, #0]
 801070a:	4925      	ldr	r1, [pc, #148]	; (80107a0 <do_close+0xb0>)
 801070c:	4a25      	ldr	r2, [pc, #148]	; (80107a4 <do_close+0xb4>)
 801070e:	4826      	ldr	r0, [pc, #152]	; (80107a8 <do_close+0xb8>)
 8010710:	f240 53b1 	movw	r3, #1457	; 0x5b1
 8010714:	f7ff f85c 	bl	800f7d0 <chprintf.constprop.1>
 8010718:	4822      	ldr	r0, [pc, #136]	; (80107a4 <do_close+0xb4>)
 801071a:	f7f0 fc29 	bl	8000f70 <chSysHalt>
 801071e:	6820      	ldr	r0, [r4, #0]
    msg->err = ERR_INPROGRESS;
 8010720:	23fb      	movs	r3, #251	; 0xfb
  } else
#endif /* LWIP_TCP */
  {
    msg->err = ERR_VAL;
  }
  sys_sem_signal(&msg->conn->op_completed);
 8010722:	300c      	adds	r0, #12
#if LWIP_TCP
  /* @todo: abort running write/connect? */
  if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
 8010724:	7123      	strb	r3, [r4, #4]
#endif /* LWIP_TCP */
  {
    msg->err = ERR_VAL;
  }
  sys_sem_signal(&msg->conn->op_completed);
}
 8010726:	b002      	add	sp, #8
 8010728:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  } else
#endif /* LWIP_TCP */
  {
    msg->err = ERR_VAL;
  }
  sys_sem_signal(&msg->conn->op_completed);
 801072c:	f7f7 ba18 	b.w	8007b60 <sys_sem_signal>
  /* @todo: abort running write/connect? */
  if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
  } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
 8010730:	6842      	ldr	r2, [r0, #4]
 8010732:	b112      	cbz	r2, 801073a <do_close+0x4a>
 8010734:	7802      	ldrb	r2, [r0, #0]
 8010736:	2a10      	cmp	r2, #16
 8010738:	d007      	beq.n	801074a <do_close+0x5a>
      return;
    }
  } else
#endif /* LWIP_TCP */
  {
    msg->err = ERR_VAL;
 801073a:	23fa      	movs	r3, #250	; 0xfa
 801073c:	7123      	strb	r3, [r4, #4]
  }
  sys_sem_signal(&msg->conn->op_completed);
 801073e:	300c      	adds	r0, #12
}
 8010740:	b002      	add	sp, #8
 8010742:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  } else
#endif /* LWIP_TCP */
  {
    msg->err = ERR_VAL;
  }
  sys_sem_signal(&msg->conn->op_completed);
 8010746:	f7f7 ba0b 	b.w	8007b60 <sys_sem_signal>
  if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
  } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
    if ((msg->msg.sd.shut != NETCONN_SHUT_RDWR) && (msg->conn->state == NETCONN_LISTEN)) {
 801074a:	7a22      	ldrb	r2, [r4, #8]
 801074c:	2a03      	cmp	r2, #3
 801074e:	d01e      	beq.n	801078e <do_close+0x9e>
 8010750:	2b02      	cmp	r3, #2
 8010752:	d020      	beq.n	8010796 <do_close+0xa6>
      /* LISTEN doesn't support half shutdown */
      msg->err = ERR_CONN;
    } else {
      if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
 8010754:	07d3      	lsls	r3, r2, #31
 8010756:	d41a      	bmi.n	801078e <do_close+0x9e>
        /* Drain and delete mboxes */
        netconn_drain(msg->conn);
      }
      LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
 8010758:	6a43      	ldr	r3, [r0, #36]	; 0x24
 801075a:	b1a3      	cbz	r3, 8010786 <do_close+0x96>
 801075c:	4b0f      	ldr	r3, [pc, #60]	; (801079c <do_close+0xac>)
 801075e:	9300      	str	r3, [sp, #0]
 8010760:	490f      	ldr	r1, [pc, #60]	; (80107a0 <do_close+0xb0>)
 8010762:	4a12      	ldr	r2, [pc, #72]	; (80107ac <do_close+0xbc>)
 8010764:	4810      	ldr	r0, [pc, #64]	; (80107a8 <do_close+0xb8>)
 8010766:	f240 53bd 	movw	r3, #1469	; 0x5bd
 801076a:	f7ff f831 	bl	800f7d0 <chprintf.constprop.1>
 801076e:	480f      	ldr	r0, [pc, #60]	; (80107ac <do_close+0xbc>)
 8010770:	f7f0 fbfe 	bl	8000f70 <chSysHalt>
 8010774:	6820      	ldr	r0, [r4, #0]
        msg->conn->write_offset == 0);
      msg->conn->state = NETCONN_CLOSE;
      msg->conn->current_msg = msg;
 8010776:	6244      	str	r4, [r0, #36]	; 0x24
        /* Drain and delete mboxes */
        netconn_drain(msg->conn);
      }
      LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
        msg->conn->write_offset == 0);
      msg->conn->state = NETCONN_CLOSE;
 8010778:	2304      	movs	r3, #4
 801077a:	7043      	strb	r3, [r0, #1]
#endif /* LWIP_TCP */
  {
    msg->err = ERR_VAL;
  }
  sys_sem_signal(&msg->conn->op_completed);
}
 801077c:	b002      	add	sp, #8
 801077e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      }
      LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
        msg->conn->write_offset == 0);
      msg->conn->state = NETCONN_CLOSE;
      msg->conn->current_msg = msg;
      do_close_internal(msg->conn);
 8010782:	f7ff b8b5 	b.w	800f8f0 <do_close_internal>
    } else {
      if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
        /* Drain and delete mboxes */
        netconn_drain(msg->conn);
      }
      LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
 8010786:	6a03      	ldr	r3, [r0, #32]
 8010788:	2b00      	cmp	r3, #0
 801078a:	d1e7      	bne.n	801075c <do_close+0x6c>
 801078c:	e7f3      	b.n	8010776 <do_close+0x86>
      /* LISTEN doesn't support half shutdown */
      msg->err = ERR_CONN;
    } else {
      if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
        /* Drain and delete mboxes */
        netconn_drain(msg->conn);
 801078e:	f7ff fd2f 	bl	80101f0 <netconn_drain>
 8010792:	6820      	ldr	r0, [r4, #0]
 8010794:	e7e0      	b.n	8010758 <do_close+0x68>
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
  } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
    if ((msg->msg.sd.shut != NETCONN_SHUT_RDWR) && (msg->conn->state == NETCONN_LISTEN)) {
      /* LISTEN doesn't support half shutdown */
      msg->err = ERR_CONN;
 8010796:	23f3      	movs	r3, #243	; 0xf3
 8010798:	7123      	strb	r3, [r4, #4]
  if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
  } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
    if ((msg->msg.sd.shut != NETCONN_SHUT_RDWR) && (msg->conn->state == NETCONN_LISTEN)) {
 801079a:	e7d0      	b.n	801073e <do_close+0x4e>
 801079c:	08018ab4 	.word	0x08018ab4
 80107a0:	08016fe0 	.word	0x08016fe0
 80107a4:	08018e38 	.word	0x08018e38
 80107a8:	200180c8 	.word	0x200180c8
 80107ac:	08018e78 	.word	0x08018e78

080107b0 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80107b0:	b40e      	push	{r1, r2, r3}
 80107b2:	b500      	push	{lr}
 80107b4:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80107b6:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 80107b8:	461a      	mov	r2, r3
 80107ba:	4905      	ldr	r1, [pc, #20]	; (80107d0 <chprintf.constprop.0+0x20>)
 80107bc:	4805      	ldr	r0, [pc, #20]	; (80107d4 <chprintf.constprop.0+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80107be:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80107c0:	f000 fa9e 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 80107c4:	b002      	add	sp, #8
 80107c6:	f85d eb04 	ldr.w	lr, [sp], #4
 80107ca:	b003      	add	sp, #12
 80107cc:	4770      	bx	lr
 80107ce:	bf00      	nop
 80107d0:	08016fe0 	.word	0x08016fe0
 80107d4:	200180c8 	.word	0x200180c8
 80107d8:	f3af 8000 	nop.w
 80107dc:	f3af 8000 	nop.w

080107e0 <netbuf_delete>:
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  if (buf != NULL) {
 80107e0:	b170      	cbz	r0, 8010800 <netbuf_delete+0x20>
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
 80107e2:	b510      	push	{r4, lr}
 80107e4:	4604      	mov	r4, r0
  if (buf != NULL) {
    if (buf->p != NULL) {
 80107e6:	6800      	ldr	r0, [r0, #0]
 80107e8:	b120      	cbz	r0, 80107f4 <netbuf_delete+0x14>
      pbuf_free(buf->p);
 80107ea:	f7f8 fe09 	bl	8009400 <pbuf_free>
      buf->p = buf->ptr = NULL;
 80107ee:	2300      	movs	r3, #0
 80107f0:	6063      	str	r3, [r4, #4]
 80107f2:	6023      	str	r3, [r4, #0]
    }
    memp_free(MEMP_NETBUF, buf);
 80107f4:	4621      	mov	r1, r4
 80107f6:	2007      	movs	r0, #7
  }
}
 80107f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if (buf != NULL) {
    if (buf->p != NULL) {
      pbuf_free(buf->p);
      buf->p = buf->ptr = NULL;
    }
    memp_free(MEMP_NETBUF, buf);
 80107fc:	f7f8 bbe0 	b.w	8008fc0 <memp_free>
 8010800:	4770      	bx	lr
 8010802:	bf00      	nop
 8010804:	f3af 8000 	nop.w
 8010808:	f3af 8000 	nop.w
 801080c:	f3af 8000 	nop.w

08010810 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
 8010810:	b500      	push	{lr}
 8010812:	b083      	sub	sp, #12
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
 8010814:	b348      	cbz	r0, 801086a <netbuf_data+0x5a>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 8010816:	b1d9      	cbz	r1, 8010850 <netbuf_data+0x40>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
 8010818:	b16a      	cbz	r2, 8010836 <netbuf_data+0x26>

  if (buf->ptr == NULL) {
 801081a:	6843      	ldr	r3, [r0, #4]
 801081c:	b14b      	cbz	r3, 8010832 <netbuf_data+0x22>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
 801081e:	685b      	ldr	r3, [r3, #4]
 8010820:	600b      	str	r3, [r1, #0]
  *len = buf->ptr->len;
 8010822:	6843      	ldr	r3, [r0, #4]
 8010824:	895b      	ldrh	r3, [r3, #10]
 8010826:	8013      	strh	r3, [r2, #0]
  return ERR_OK;
 8010828:	2000      	movs	r0, #0
}
 801082a:	b240      	sxtb	r0, r0
 801082c:	b003      	add	sp, #12
 801082e:	f85d fb04 	ldr.w	pc, [sp], #4
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);

  if (buf->ptr == NULL) {
    return ERR_BUF;
 8010832:	20fe      	movs	r0, #254	; 0xfe
 8010834:	e7f9      	b.n	801082a <netbuf_data+0x1a>
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
 8010836:	4b13      	ldr	r3, [pc, #76]	; (8010884 <netbuf_data+0x74>)
 8010838:	9300      	str	r3, [sp, #0]
 801083a:	4913      	ldr	r1, [pc, #76]	; (8010888 <netbuf_data+0x78>)
 801083c:	4a13      	ldr	r2, [pc, #76]	; (801088c <netbuf_data+0x7c>)
 801083e:	4814      	ldr	r0, [pc, #80]	; (8010890 <netbuf_data+0x80>)
 8010840:	23c5      	movs	r3, #197	; 0xc5
 8010842:	f7ff ffb5 	bl	80107b0 <chprintf.constprop.0>
 8010846:	4811      	ldr	r0, [pc, #68]	; (801088c <netbuf_data+0x7c>)
 8010848:	f7f0 fb92 	bl	8000f70 <chSysHalt>
 801084c:	20f2      	movs	r0, #242	; 0xf2
 801084e:	e7ec      	b.n	801082a <netbuf_data+0x1a>
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 8010850:	4b0c      	ldr	r3, [pc, #48]	; (8010884 <netbuf_data+0x74>)
 8010852:	9300      	str	r3, [sp, #0]
 8010854:	490c      	ldr	r1, [pc, #48]	; (8010888 <netbuf_data+0x78>)
 8010856:	4a0f      	ldr	r2, [pc, #60]	; (8010894 <netbuf_data+0x84>)
 8010858:	480d      	ldr	r0, [pc, #52]	; (8010890 <netbuf_data+0x80>)
 801085a:	23c4      	movs	r3, #196	; 0xc4
 801085c:	f7ff ffa8 	bl	80107b0 <chprintf.constprop.0>
 8010860:	480c      	ldr	r0, [pc, #48]	; (8010894 <netbuf_data+0x84>)
 8010862:	f7f0 fb85 	bl	8000f70 <chSysHalt>
 8010866:	20f2      	movs	r0, #242	; 0xf2
 8010868:	e7df      	b.n	801082a <netbuf_data+0x1a>
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
 801086a:	4b06      	ldr	r3, [pc, #24]	; (8010884 <netbuf_data+0x74>)
 801086c:	9300      	str	r3, [sp, #0]
 801086e:	4906      	ldr	r1, [pc, #24]	; (8010888 <netbuf_data+0x78>)
 8010870:	4a09      	ldr	r2, [pc, #36]	; (8010898 <netbuf_data+0x88>)
 8010872:	4807      	ldr	r0, [pc, #28]	; (8010890 <netbuf_data+0x80>)
 8010874:	23c3      	movs	r3, #195	; 0xc3
 8010876:	f7ff ff9b 	bl	80107b0 <chprintf.constprop.0>
 801087a:	4807      	ldr	r0, [pc, #28]	; (8010898 <netbuf_data+0x88>)
 801087c:	f7f0 fb78 	bl	8000f70 <chSysHalt>
 8010880:	20f2      	movs	r0, #242	; 0xf2
 8010882:	e7d2      	b.n	801082a <netbuf_data+0x1a>
 8010884:	08018efc 	.word	0x08018efc
 8010888:	08016fe0 	.word	0x08016fe0
 801088c:	08018ff4 	.word	0x08018ff4
 8010890:	200180c8 	.word	0x200180c8
 8010894:	08018fd4 	.word	0x08018fd4
 8010898:	08018fb8 	.word	0x08018fb8
 801089c:	f3af 8000 	nop.w

080108a0 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
 80108a0:	4770      	bx	lr
 80108a2:	bf00      	nop
 80108a4:	f3af 8000 	nop.w
 80108a8:	f3af 8000 	nop.w
 80108ac:	f3af 8000 	nop.w

080108b0 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80108b0:	b40e      	push	{r1, r2, r3}
 80108b2:	b500      	push	{lr}
 80108b4:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80108b6:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 80108b8:	461a      	mov	r2, r3
 80108ba:	4905      	ldr	r1, [pc, #20]	; (80108d0 <chprintf.constprop.0+0x20>)
 80108bc:	4805      	ldr	r0, [pc, #20]	; (80108d4 <chprintf.constprop.0+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80108be:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80108c0:	f000 fa1e 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 80108c4:	b002      	add	sp, #8
 80108c6:	f85d eb04 	ldr.w	lr, [sp], #4
 80108ca:	b003      	add	sp, #12
 80108cc:	4770      	bx	lr
 80108ce:	bf00      	nop
 80108d0:	08016fe0 	.word	0x08016fe0
 80108d4:	200180c8 	.word	0x200180c8
 80108d8:	f3af 8000 	nop.w
 80108dc:	f3af 8000 	nop.w

080108e0 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
 80108e0:	b510      	push	{r4, lr}
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

  if (tcpip_init_done != NULL) {
 80108e2:	4b2a      	ldr	r3, [pc, #168]	; (801098c <tcpip_thread+0xac>)
 80108e4:	681b      	ldr	r3, [r3, #0]
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
 80108e6:	b084      	sub	sp, #16
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

  if (tcpip_init_done != NULL) {
 80108e8:	b113      	cbz	r3, 80108f0 <tcpip_thread+0x10>
    tcpip_init_done(tcpip_init_done_arg);
 80108ea:	4a29      	ldr	r2, [pc, #164]	; (8010990 <tcpip_thread+0xb0>)
 80108ec:	6810      	ldr	r0, [r2, #0]
 80108ee:	4798      	blx	r3
 80108f0:	4c28      	ldr	r4, [pc, #160]	; (8010994 <tcpip_thread+0xb4>)
  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    UNLOCK_TCPIP_CORE();
    LWIP_TCPIP_THREAD_ALIVE();
    /* wait for a message, timeouts are processed while waiting */
    sys_timeouts_mbox_fetch(&mbox, (void **)&msg);
 80108f2:	4829      	ldr	r0, [pc, #164]	; (8010998 <tcpip_thread+0xb8>)
 80108f4:	a903      	add	r1, sp, #12
 80108f6:	f7fe fb7b 	bl	800eff0 <sys_timeouts_mbox_fetch>
    LOCK_TCPIP_CORE();
    switch (msg->type) {
 80108fa:	9b03      	ldr	r3, [sp, #12]
 80108fc:	781a      	ldrb	r2, [r3, #0]
 80108fe:	2a05      	cmp	r2, #5
 8010900:	d836      	bhi.n	8010970 <tcpip_thread+0x90>
 8010902:	e8df f002 	tbb	[pc, r2]
 8010906:	2230      	.short	0x2230
 8010908:	03070f18 	.word	0x03070f18
      memp_free(MEMP_TCPIP_MSG_API, msg);
      break;

    case TCPIP_MSG_CALLBACK_STATIC:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK_STATIC %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
 801090c:	689a      	ldr	r2, [r3, #8]
 801090e:	68d8      	ldr	r0, [r3, #12]
 8010910:	4790      	blx	r2
      break;
 8010912:	e7ee      	b.n	80108f2 <tcpip_thread+0x12>
      break;
#endif /* LWIP_TCPIP_TIMEOUT */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
 8010914:	68d8      	ldr	r0, [r3, #12]
 8010916:	689a      	ldr	r2, [r3, #8]
 8010918:	4790      	blx	r2
      memp_free(MEMP_TCPIP_MSG_API, msg);
 801091a:	2009      	movs	r0, #9
 801091c:	9903      	ldr	r1, [sp, #12]
 801091e:	f7f8 fb4f 	bl	8008fc0 <memp_free>
      break;
 8010922:	e7e6      	b.n	80108f2 <tcpip_thread+0x12>
      sys_timeout(msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
      break;
    case TCPIP_MSG_UNTIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: UNTIMEOUT %p\n", (void *)msg));
      sys_untimeout(msg->msg.tmo.h, msg->msg.tmo.arg);
 8010924:	68d8      	ldr	r0, [r3, #12]
 8010926:	6919      	ldr	r1, [r3, #16]
 8010928:	f7fe fb3a 	bl	800efa0 <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
 801092c:	2009      	movs	r0, #9
 801092e:	9903      	ldr	r1, [sp, #12]
 8010930:	f7f8 fb46 	bl	8008fc0 <memp_free>
      break;
 8010934:	e7dd      	b.n	80108f2 <tcpip_thread+0x12>
#endif /* LWIP_NETIF_API */

#if LWIP_TCPIP_TIMEOUT
    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));
      sys_timeout(msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
 8010936:	f103 0008 	add.w	r0, r3, #8
 801093a:	c807      	ldmia	r0, {r0, r1, r2}
 801093c:	f7fe fa68 	bl	800ee10 <sys_timeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
 8010940:	2009      	movs	r0, #9
 8010942:	9903      	ldr	r1, [sp, #12]
 8010944:	f7f8 fb3c 	bl	8008fc0 <memp_free>
      break;
 8010948:	e7d3      	b.n	80108f2 <tcpip_thread+0x12>

#if !LWIP_TCPIP_CORE_LOCKING_INPUT
    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ETHERNET
      if (msg->msg.inp.netif->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
 801094a:	68d9      	ldr	r1, [r3, #12]
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
 801094c:	6898      	ldr	r0, [r3, #8]

#if !LWIP_TCPIP_CORE_LOCKING_INPUT
    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ETHERNET
      if (msg->msg.inp.netif->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
 801094e:	f891 2029 	ldrb.w	r2, [r1, #41]	; 0x29
 8010952:	f012 0f60 	tst.w	r2, #96	; 0x60
 8010956:	d016      	beq.n	8010986 <tcpip_thread+0xa6>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
 8010958:	f7f7 fdfa 	bl	8008550 <ethernet_input>
      } else
#endif /* LWIP_ETHERNET */
      {
        ip_input(msg->msg.inp.p, msg->msg.inp.netif);
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
 801095c:	200a      	movs	r0, #10
 801095e:	9903      	ldr	r1, [sp, #12]
 8010960:	f7f8 fb2e 	bl	8008fc0 <memp_free>
      break;
 8010964:	e7c5      	b.n	80108f2 <tcpip_thread+0x12>
    LOCK_TCPIP_CORE();
    switch (msg->type) {
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
 8010966:	6898      	ldr	r0, [r3, #8]
 8010968:	6803      	ldr	r3, [r0, #0]
 801096a:	3004      	adds	r0, #4
 801096c:	4798      	blx	r3
      break;
 801096e:	e7c0      	b.n	80108f2 <tcpip_thread+0x12>
      msg->msg.cb.function(msg->msg.cb.ctx);
      break;

    default:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: %d\n", msg->type));
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
 8010970:	9400      	str	r4, [sp, #0]
 8010972:	490a      	ldr	r1, [pc, #40]	; (801099c <tcpip_thread+0xbc>)
 8010974:	4a0a      	ldr	r2, [pc, #40]	; (80109a0 <tcpip_thread+0xc0>)
 8010976:	480b      	ldr	r0, [pc, #44]	; (80109a4 <tcpip_thread+0xc4>)
 8010978:	2392      	movs	r3, #146	; 0x92
 801097a:	f7ff ff99 	bl	80108b0 <chprintf.constprop.0>
 801097e:	4808      	ldr	r0, [pc, #32]	; (80109a0 <tcpip_thread+0xc0>)
 8010980:	f7f0 faf6 	bl	8000f70 <chSysHalt>
 8010984:	e7b5      	b.n	80108f2 <tcpip_thread+0x12>
      if (msg->msg.inp.netif->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
      } else
#endif /* LWIP_ETHERNET */
      {
        ip_input(msg->msg.inp.p, msg->msg.inp.netif);
 8010986:	f7fd fb6b 	bl	800e060 <ip_input>
 801098a:	e7e7      	b.n	801095c <tcpip_thread+0x7c>
 801098c:	2000cbd0 	.word	0x2000cbd0
 8010990:	2000cbcc 	.word	0x2000cbcc
 8010994:	08019030 	.word	0x08019030
 8010998:	2000cbc8 	.word	0x2000cbc8
 801099c:	08016fe0 	.word	0x08016fe0
 80109a0:	08019010 	.word	0x08019010
 80109a4:	200180c8 	.word	0x200180c8
 80109a8:	f3af 8000 	nop.w
 80109ac:	f3af 8000 	nop.w

080109b0 <tcpip_input>:
 *          NETIF_FLAG_ETHERNET flags)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
 80109b0:	b570      	push	{r4, r5, r6, lr}
 80109b2:	4606      	mov	r6, r0
  UNLOCK_TCPIP_CORE();
  return ret;
#else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
  struct tcpip_msg *msg;

  if (!sys_mbox_valid(&mbox)) {
 80109b4:	480f      	ldr	r0, [pc, #60]	; (80109f4 <tcpip_input+0x44>)
 *          NETIF_FLAG_ETHERNET flags)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
 80109b6:	460d      	mov	r5, r1
  UNLOCK_TCPIP_CORE();
  return ret;
#else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
  struct tcpip_msg *msg;

  if (!sys_mbox_valid(&mbox)) {
 80109b8:	f7f7 f9aa 	bl	8007d10 <sys_mbox_valid>
 80109bc:	b178      	cbz	r0, 80109de <tcpip_input+0x2e>
    return ERR_VAL;
  }
  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
 80109be:	200a      	movs	r0, #10
 80109c0:	f7f8 faa6 	bl	8008f10 <memp_malloc>
  if (msg == NULL) {
 80109c4:	4604      	mov	r4, r0
 80109c6:	b160      	cbz	r0, 80109e2 <tcpip_input+0x32>
    return ERR_MEM;
  }

  msg->type = TCPIP_MSG_INPKT;
 80109c8:	2301      	movs	r3, #1
  msg->msg.inp.p = p;
 80109ca:	6086      	str	r6, [r0, #8]
  msg->msg.inp.netif = inp;
 80109cc:	60c5      	str	r5, [r0, #12]
  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
  if (msg == NULL) {
    return ERR_MEM;
  }

  msg->type = TCPIP_MSG_INPKT;
 80109ce:	7003      	strb	r3, [r0, #0]
  msg->msg.inp.p = p;
  msg->msg.inp.netif = inp;
  if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
 80109d0:	4621      	mov	r1, r4
 80109d2:	4808      	ldr	r0, [pc, #32]	; (80109f4 <tcpip_input+0x44>)
 80109d4:	f7f7 f954 	bl	8007c80 <sys_mbox_trypost>
 80109d8:	b928      	cbnz	r0, 80109e6 <tcpip_input+0x36>
    memp_free(MEMP_TCPIP_MSG_INPKT, msg);
    return ERR_MEM;
  }
  return ERR_OK;
#endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
}
 80109da:	b240      	sxtb	r0, r0
 80109dc:	bd70      	pop	{r4, r5, r6, pc}
  return ret;
#else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
  struct tcpip_msg *msg;

  if (!sys_mbox_valid(&mbox)) {
    return ERR_VAL;
 80109de:	20fa      	movs	r0, #250	; 0xfa
 80109e0:	e7fb      	b.n	80109da <tcpip_input+0x2a>
  }
  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
  if (msg == NULL) {
    return ERR_MEM;
 80109e2:	20ff      	movs	r0, #255	; 0xff
 80109e4:	e7f9      	b.n	80109da <tcpip_input+0x2a>

  msg->type = TCPIP_MSG_INPKT;
  msg->msg.inp.p = p;
  msg->msg.inp.netif = inp;
  if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
    memp_free(MEMP_TCPIP_MSG_INPKT, msg);
 80109e6:	200a      	movs	r0, #10
 80109e8:	4621      	mov	r1, r4
 80109ea:	f7f8 fae9 	bl	8008fc0 <memp_free>
    return ERR_MEM;
 80109ee:	20ff      	movs	r0, #255	; 0xff
 80109f0:	e7f3      	b.n	80109da <tcpip_input+0x2a>
 80109f2:	bf00      	nop
 80109f4:	2000cbc8 	.word	0x2000cbc8
 80109f8:	f3af 8000 	nop.w
 80109fc:	f3af 8000 	nop.w

08010a00 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block)
{
 8010a00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8010a02:	4607      	mov	r7, r0
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
 8010a04:	4813      	ldr	r0, [pc, #76]	; (8010a54 <tcpip_callback_with_block+0x54>)
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block)
{
 8010a06:	460e      	mov	r6, r1
 8010a08:	4615      	mov	r5, r2
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
 8010a0a:	f7f7 f981 	bl	8007d10 <sys_mbox_valid>
 8010a0e:	b1b8      	cbz	r0, 8010a40 <tcpip_callback_with_block+0x40>
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 8010a10:	2009      	movs	r0, #9
 8010a12:	f7f8 fa7d 	bl	8008f10 <memp_malloc>
    if (msg == NULL) {
 8010a16:	4604      	mov	r4, r0
 8010a18:	b1d0      	cbz	r0, 8010a50 <tcpip_callback_with_block+0x50>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
 8010a1a:	2304      	movs	r3, #4
    msg->msg.cb.function = function;
 8010a1c:	6087      	str	r7, [r0, #8]
    msg->msg.cb.ctx = ctx;
 8010a1e:	60c6      	str	r6, [r0, #12]
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
 8010a20:	7003      	strb	r3, [r0, #0]
    msg->msg.cb.function = function;
    msg->msg.cb.ctx = ctx;
    if (block) {
 8010a22:	b935      	cbnz	r5, 8010a32 <tcpip_callback_with_block+0x32>
      sys_mbox_post(&mbox, msg);
    } else {
      if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
 8010a24:	480b      	ldr	r0, [pc, #44]	; (8010a54 <tcpip_callback_with_block+0x54>)
 8010a26:	4621      	mov	r1, r4
 8010a28:	f7f7 f92a 	bl	8007c80 <sys_mbox_trypost>
 8010a2c:	b950      	cbnz	r0, 8010a44 <tcpip_callback_with_block+0x44>
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
 8010a2e:	b240      	sxtb	r0, r0
 8010a30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

    msg->type = TCPIP_MSG_CALLBACK;
    msg->msg.cb.function = function;
    msg->msg.cb.ctx = ctx;
    if (block) {
      sys_mbox_post(&mbox, msg);
 8010a32:	4601      	mov	r1, r0
 8010a34:	4807      	ldr	r0, [pc, #28]	; (8010a54 <tcpip_callback_with_block+0x54>)
 8010a36:	f7f7 f91b 	bl	8007c70 <sys_mbox_post>
      if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
 8010a3a:	2000      	movs	r0, #0
  }
  return ERR_VAL;
}
 8010a3c:	b240      	sxtb	r0, r0
 8010a3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return ERR_MEM;
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
 8010a40:	20fa      	movs	r0, #250	; 0xfa
 8010a42:	e7f4      	b.n	8010a2e <tcpip_callback_with_block+0x2e>
    msg->msg.cb.ctx = ctx;
    if (block) {
      sys_mbox_post(&mbox, msg);
    } else {
      if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
 8010a44:	2009      	movs	r0, #9
 8010a46:	4621      	mov	r1, r4
 8010a48:	f7f8 faba 	bl	8008fc0 <memp_free>
        return ERR_MEM;
 8010a4c:	20ff      	movs	r0, #255	; 0xff
 8010a4e:	e7ee      	b.n	8010a2e <tcpip_callback_with_block+0x2e>
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
 8010a50:	20ff      	movs	r0, #255	; 0xff
 8010a52:	e7ec      	b.n	8010a2e <tcpip_callback_with_block+0x2e>
 8010a54:	2000cbc8 	.word	0x2000cbc8
 8010a58:	f3af 8000 	nop.w
 8010a5c:	f3af 8000 	nop.w

08010a60 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
 8010a60:	b530      	push	{r4, r5, lr}
 8010a62:	4604      	mov	r4, r0
 8010a64:	b087      	sub	sp, #28
#ifdef LWIP_DEBUG
  /* catch functions that don't set err */
  apimsg->msg.err = ERR_VAL;
#endif
  
  if (sys_mbox_valid(&mbox)) {
 8010a66:	480b      	ldr	r0, [pc, #44]	; (8010a94 <tcpip_apimsg+0x34>)
 8010a68:	f7f7 f952 	bl	8007d10 <sys_mbox_valid>
 8010a6c:	b180      	cbz	r0, 8010a90 <tcpip_apimsg+0x30>
    msg.type = TCPIP_MSG_API;
 8010a6e:	2500      	movs	r5, #0
    msg.msg.apimsg = apimsg;
    sys_mbox_post(&mbox, &msg);
 8010a70:	4808      	ldr	r0, [pc, #32]	; (8010a94 <tcpip_apimsg+0x34>)
  apimsg->msg.err = ERR_VAL;
#endif
  
  if (sys_mbox_valid(&mbox)) {
    msg.type = TCPIP_MSG_API;
    msg.msg.apimsg = apimsg;
 8010a72:	9403      	str	r4, [sp, #12]
    sys_mbox_post(&mbox, &msg);
 8010a74:	a901      	add	r1, sp, #4
  /* catch functions that don't set err */
  apimsg->msg.err = ERR_VAL;
#endif
  
  if (sys_mbox_valid(&mbox)) {
    msg.type = TCPIP_MSG_API;
 8010a76:	f88d 5004 	strb.w	r5, [sp, #4]
    msg.msg.apimsg = apimsg;
    sys_mbox_post(&mbox, &msg);
 8010a7a:	f7f7 f8f9 	bl	8007c70 <sys_mbox_post>
    sys_arch_sem_wait(&apimsg->msg.conn->op_completed, 0);
 8010a7e:	6860      	ldr	r0, [r4, #4]
 8010a80:	4629      	mov	r1, r5
 8010a82:	300c      	adds	r0, #12
 8010a84:	f7f7 f874 	bl	8007b70 <sys_arch_sem_wait>
    return apimsg->msg.err;
 8010a88:	7a20      	ldrb	r0, [r4, #8]
  }
  return ERR_VAL;
}
 8010a8a:	b240      	sxtb	r0, r0
 8010a8c:	b007      	add	sp, #28
 8010a8e:	bd30      	pop	{r4, r5, pc}
    msg.msg.apimsg = apimsg;
    sys_mbox_post(&mbox, &msg);
    sys_arch_sem_wait(&apimsg->msg.conn->op_completed, 0);
    return apimsg->msg.err;
  }
  return ERR_VAL;
 8010a90:	20fa      	movs	r0, #250	; 0xfa
 8010a92:	e7fa      	b.n	8010a8a <tcpip_apimsg+0x2a>
 8010a94:	2000cbc8 	.word	0x2000cbc8
 8010a98:	f3af 8000 	nop.w
 8010a9c:	f3af 8000 	nop.w

08010aa0 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(tcpip_init_done_fn initfunc, void *arg)
{
 8010aa0:	b530      	push	{r4, r5, lr}
 8010aa2:	b083      	sub	sp, #12
 8010aa4:	4605      	mov	r5, r0
 8010aa6:	460c      	mov	r4, r1
  lwip_init();
 8010aa8:	f7f7 fe9a 	bl	80087e0 <lwip_init>

  tcpip_init_done = initfunc;
 8010aac:	4a0f      	ldr	r2, [pc, #60]	; (8010aec <tcpip_init+0x4c>)
  tcpip_init_done_arg = arg;
 8010aae:	4b10      	ldr	r3, [pc, #64]	; (8010af0 <tcpip_init+0x50>)
  if(sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
 8010ab0:	4810      	ldr	r0, [pc, #64]	; (8010af4 <tcpip_init+0x54>)
void
tcpip_init(tcpip_init_done_fn initfunc, void *arg)
{
  lwip_init();

  tcpip_init_done = initfunc;
 8010ab2:	6015      	str	r5, [r2, #0]
  tcpip_init_done_arg = arg;
  if(sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
 8010ab4:	2108      	movs	r1, #8
tcpip_init(tcpip_init_done_fn initfunc, void *arg)
{
  lwip_init();

  tcpip_init_done = initfunc;
  tcpip_init_done_arg = arg;
 8010ab6:	601c      	str	r4, [r3, #0]
  if(sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
 8010ab8:	f7f7 f88a 	bl	8007bd0 <sys_mbox_new>
 8010abc:	b158      	cbz	r0, 8010ad6 <tcpip_init+0x36>
    LWIP_ASSERT("failed to create tcpip_thread mbox", 0);
 8010abe:	4b0e      	ldr	r3, [pc, #56]	; (8010af8 <tcpip_init+0x58>)
 8010ac0:	9300      	str	r3, [sp, #0]
 8010ac2:	480e      	ldr	r0, [pc, #56]	; (8010afc <tcpip_init+0x5c>)
 8010ac4:	490e      	ldr	r1, [pc, #56]	; (8010b00 <tcpip_init+0x60>)
 8010ac6:	4a0f      	ldr	r2, [pc, #60]	; (8010b04 <tcpip_init+0x64>)
 8010ac8:	f44f 73e7 	mov.w	r3, #462	; 0x1ce
 8010acc:	f7ff fef0 	bl	80108b0 <chprintf.constprop.0>
 8010ad0:	480c      	ldr	r0, [pc, #48]	; (8010b04 <tcpip_init+0x64>)
 8010ad2:	f7f0 fa4d 	bl	8000f70 <chSysHalt>
  if(sys_mutex_new(&lock_tcpip_core) != ERR_OK) {
    LWIP_ASSERT("failed to create lock_tcpip_core", 0);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
 8010ad6:	2341      	movs	r3, #65	; 0x41
 8010ad8:	9300      	str	r3, [sp, #0]
 8010ada:	490b      	ldr	r1, [pc, #44]	; (8010b08 <tcpip_init+0x68>)
 8010adc:	480b      	ldr	r0, [pc, #44]	; (8010b0c <tcpip_init+0x6c>)
 8010ade:	2200      	movs	r2, #0
 8010ae0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8010ae4:	f7f7 f924 	bl	8007d30 <sys_thread_new>
}
 8010ae8:	b003      	add	sp, #12
 8010aea:	bd30      	pop	{r4, r5, pc}
 8010aec:	2000cbd0 	.word	0x2000cbd0
 8010af0:	2000cbcc 	.word	0x2000cbcc
 8010af4:	2000cbc8 	.word	0x2000cbc8
 8010af8:	08019030 	.word	0x08019030
 8010afc:	200180c8 	.word	0x200180c8
 8010b00:	08016fe0 	.word	0x08016fe0
 8010b04:	0801905c 	.word	0x0801905c
 8010b08:	080108e1 	.word	0x080108e1
 8010b0c:	08019080 	.word	0x08019080

08010b10 <tmrcb>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static void tmrcb(void *p) {
 8010b10:	b510      	push	{r4, lr}
 8010b12:	2320      	movs	r3, #32
 8010b14:	4604      	mov	r4, r0
 8010b16:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {

  chEvtBroadcastFlagsI(esp, 0);
 8010b1a:	2100      	movs	r1, #0
 8010b1c:	3014      	adds	r0, #20
 8010b1e:	f7f1 fa1f 	bl	8001f60 <chEvtBroadcastFlagsI>
  event_timer_t *etp = p;

  chSysLockFromISR();
  chEvtBroadcastI(&etp->et_es);
  chVTDoSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);
 8010b22:	4623      	mov	r3, r4
 8010b24:	4620      	mov	r0, r4
 8010b26:	69a1      	ldr	r1, [r4, #24]
 8010b28:	4a03      	ldr	r2, [pc, #12]	; (8010b38 <tmrcb+0x28>)
 8010b2a:	f7f0 fc29 	bl	8001380 <chVTDoSetI>
 8010b2e:	2300      	movs	r3, #0
 8010b30:	f383 8811 	msr	BASEPRI, r3
 8010b34:	bd10      	pop	{r4, pc}
 8010b36:	bf00      	nop
 8010b38:	08010b11 	.word	0x08010b11
 8010b3c:	f3af 8000 	nop.w

08010b40 <evtObjectInit>:
 * @param[out] etp      the @p event_timer_t structure to be initialized
 * @param[in] time      the interval in system ticks
 */
void evtObjectInit(event_timer_t *etp, systime_t time) {

  chEvtObjectInit(&etp->et_es);
 8010b40:	f100 0214 	add.w	r2, r0, #20
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->vt_func = NULL;
 8010b44:	2300      	movs	r3, #0
  chVTObjectInit(&etp->et_vt);
  etp->et_interval = time;
 8010b46:	6181      	str	r1, [r0, #24]
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)(void *)esp;
 8010b48:	6142      	str	r2, [r0, #20]
 8010b4a:	60c3      	str	r3, [r0, #12]
 8010b4c:	4770      	bx	lr
 8010b4e:	bf00      	nop

08010b50 <evtStart>:
 * @brief   Starts the timer
 * @details If the timer was already running then the function has no effect.
 *
 * @param[in] etp       pointer to an initialized @p event_timer_t structure.
 */
void evtStart(event_timer_t *etp) {
 8010b50:	b538      	push	{r3, r4, r5, lr}
 8010b52:	4604      	mov	r4, r0
 8010b54:	2320      	movs	r3, #32

  chVTSet(&etp->et_vt, etp->et_interval, tmrcb, etp);
 8010b56:	6985      	ldr	r5, [r0, #24]
 8010b58:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8010b5c:	68c3      	ldr	r3, [r0, #12]
 8010b5e:	b10b      	cbz	r3, 8010b64 <evtStart+0x14>
    chVTDoResetI(vtp);
 8010b60:	f7f0 fc46 	bl	80013f0 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8010b64:	4623      	mov	r3, r4
 8010b66:	4629      	mov	r1, r5
 8010b68:	4620      	mov	r0, r4
 8010b6a:	4a03      	ldr	r2, [pc, #12]	; (8010b78 <evtStart+0x28>)
 8010b6c:	f7f0 fc08 	bl	8001380 <chVTDoSetI>
 8010b70:	2300      	movs	r3, #0
 8010b72:	f383 8811 	msr	BASEPRI, r3
 8010b76:	bd38      	pop	{r3, r4, r5, pc}
 8010b78:	08010b11 	.word	0x08010b11
 8010b7c:	f3af 8000 	nop.w

08010b80 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8010b80:	b40e      	push	{r1, r2, r3}
 8010b82:	b500      	push	{lr}
 8010b84:	b082      	sub	sp, #8
 8010b86:	aa03      	add	r2, sp, #12
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
 8010b88:	4805      	ldr	r0, [pc, #20]	; (8010ba0 <chprintf.constprop.0+0x20>)
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8010b8a:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8010b8e:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8010b90:	f000 f8b6 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8010b94:	b002      	add	sp, #8
 8010b96:	f85d eb04 	ldr.w	lr, [sp], #4
 8010b9a:	b003      	add	sp, #12
 8010b9c:	4770      	bx	lr
 8010b9e:	bf00      	nop
 8010ba0:	200180c8 	.word	0x200180c8
 8010ba4:	f3af 8000 	nop.w
 8010ba8:	f3af 8000 	nop.w
 8010bac:	f3af 8000 	nop.w

08010bb0 <_read_r>:
  len = sdRead(&STDIN_SD, (uint8_t *)ptr, (size_t)len);
  return len;
#else
  //chprintf((BaseSequentialStream *)&itm_port, "file descript: %i\n", file);
  
  if (!len || (file == -1)) {
 8010bb0:	b1eb      	cbz	r3, 8010bee <_read_r+0x3e>
 8010bb2:	f1b1 3fff 	cmp.w	r1, #4294967295
 8010bb6:	d01a      	beq.n	8010bee <_read_r+0x3e>
 8010bb8:	480f      	ldr	r0, [pc, #60]	; (8010bf8 <_read_r+0x48>)
}

/***************************************************************************/

int _read_r(struct _reent *r, int file, char *ptr, int len)
{
 8010bba:	b470      	push	{r4, r5, r6}
 8010bbc:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
  len = sdRead(&STDIN_SD, (uint8_t *)ptr, (size_t)len);
  return len;
#else
  //chprintf((BaseSequentialStream *)&itm_port, "file descript: %i\n", file);
  
  if (!len || (file == -1)) {
 8010bc0:	461d      	mov	r5, r3
 8010bc2:	684e      	ldr	r6, [r1, #4]
 8010bc4:	7831      	ldrb	r1, [r6, #0]
 8010bc6:	2400      	movs	r4, #0
    __errno_r(r) = EBADF;
    return -1;
  }else {
		do{
			if(lcfg_table[file].data[i] != EOF){
				*ptr = lcfg_table[file].data[i++];
 8010bc8:	3401      	adds	r4, #1
 8010bca:	b2e4      	uxtb	r4, r4
				//chprintf((BaseSequentialStream *)&itm_port, "character: %c in file: %i with len: %i\n", ascii, file, len);
			
				ptr++;
			}

			len--;
 8010bcc:	3d01      	subs	r5, #1
  if (!len || (file == -1)) {
    __errno_r(r) = EBADF;
    return -1;
  }else {
		do{
			if(lcfg_table[file].data[i] != EOF){
 8010bce:	b919      	cbnz	r1, 8010bd8 <_read_r+0x28>
			}

			len--;
		}while((len > 0) && (lcfg_table[file].data[i] != EOF));
		
		return buffersize - len;
 8010bd0:	b2db      	uxtb	r3, r3
 8010bd2:	1b58      	subs	r0, r3, r5
	}

  __errno_r(r) = EINVAL;
  return -1;
#endif
}
 8010bd4:	bc70      	pop	{r4, r5, r6}
 8010bd6:	4770      	bx	lr
			
				ptr++;
			}

			len--;
		}while((len > 0) && (lcfg_table[file].data[i] != EOF));
 8010bd8:	2d00      	cmp	r5, #0
    __errno_r(r) = EBADF;
    return -1;
  }else {
		do{
			if(lcfg_table[file].data[i] != EOF){
				*ptr = lcfg_table[file].data[i++];
 8010bda:	f802 1b01 	strb.w	r1, [r2], #1
			
				ptr++;
			}

			len--;
		}while((len > 0) && (lcfg_table[file].data[i] != EOF));
 8010bde:	ddf7      	ble.n	8010bd0 <_read_r+0x20>
 8010be0:	5d31      	ldrb	r1, [r6, r4]
 8010be2:	2900      	cmp	r1, #0
 8010be4:	d1f0      	bne.n	8010bc8 <_read_r+0x18>
		
		return buffersize - len;
 8010be6:	b2db      	uxtb	r3, r3
 8010be8:	1b58      	subs	r0, r3, r5
	}

  __errno_r(r) = EINVAL;
  return -1;
#endif
}
 8010bea:	bc70      	pop	{r4, r5, r6}
 8010bec:	4770      	bx	lr
  return len;
#else
  //chprintf((BaseSequentialStream *)&itm_port, "file descript: %i\n", file);
  
  if (!len || (file == -1)) {
    __errno_r(r) = EBADF;
 8010bee:	2309      	movs	r3, #9
 8010bf0:	6003      	str	r3, [r0, #0]
    return -1;
 8010bf2:	f04f 30ff 	mov.w	r0, #4294967295
	}

  __errno_r(r) = EINVAL;
  return -1;
#endif
}
 8010bf6:	4770      	bx	lr
 8010bf8:	08019120 	.word	0x08019120
 8010bfc:	f3af 8000 	nop.w

08010c00 <_lseek_r>:
  (void)file;
  (void)ptr;
  (void)dir;

  return 0;
}
 8010c00:	2000      	movs	r0, #0
 8010c02:	4770      	bx	lr
 8010c04:	f3af 8000 	nop.w
 8010c08:	f3af 8000 	nop.w
 8010c0c:	f3af 8000 	nop.w

08010c10 <_write_r>:
    __errno_r(r) = EINVAL;
    return -1;
  }
  sdWrite(&STDOUT_SD, (uint8_t *)ptr, (size_t)len);
#endif
  switch (file) {
 8010c10:	3901      	subs	r1, #1
 8010c12:	2901      	cmp	r1, #1
}

/***************************************************************************/

int _write_r(struct _reent *r, int file, char * ptr, int len)
{
 8010c14:	b570      	push	{r4, r5, r6, lr}
    __errno_r(r) = EINVAL;
    return -1;
  }
  sdWrite(&STDOUT_SD, (uint8_t *)ptr, (size_t)len);
#endif
  switch (file) {
 8010c16:	d80e      	bhi.n	8010c36 <_write_r+0x26>
      case STDOUT_FILENO: /*stdout*/
      case STDERR_FILENO: /* stderr */
          for (n = 0; n < len; n++) {
 8010c18:	2b00      	cmp	r3, #0
 8010c1a:	461d      	mov	r5, r3
 8010c1c:	dd09      	ble.n	8010c32 <_write_r+0x22>
 8010c1e:	4616      	mov	r6, r2
 8010c20:	2400      	movs	r4, #0
 8010c22:	3401      	adds	r4, #1
        	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", ptr);
 8010c24:	4807      	ldr	r0, [pc, #28]	; (8010c44 <_write_r+0x34>)
 8010c26:	4908      	ldr	r1, [pc, #32]	; (8010c48 <_write_r+0x38>)
 8010c28:	4632      	mov	r2, r6
 8010c2a:	f7ff ffa9 	bl	8010b80 <chprintf.constprop.0>
  sdWrite(&STDOUT_SD, (uint8_t *)ptr, (size_t)len);
#endif
  switch (file) {
      case STDOUT_FILENO: /*stdout*/
      case STDERR_FILENO: /* stderr */
          for (n = 0; n < len; n++) {
 8010c2e:	42ac      	cmp	r4, r5
 8010c30:	d1f7      	bne.n	8010c22 <_write_r+0x12>
        	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", ptr);
          }
          break;
      default:
          errno = EBADF;
          return -1;
 8010c32:	4628      	mov	r0, r5
 8010c34:	bd70      	pop	{r4, r5, r6, pc}
          for (n = 0; n < len; n++) {
        	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", ptr);
          }
          break;
      default:
          errno = EBADF;
 8010c36:	f002 fddb 	bl	80137f0 <__errno>
 8010c3a:	2309      	movs	r3, #9
 8010c3c:	6003      	str	r3, [r0, #0]
          return -1;
 8010c3e:	f04f 30ff 	mov.w	r0, #4294967295
  }
  return len;
}
 8010c42:	bd70      	pop	{r4, r5, r6, pc}
 8010c44:	200180c8 	.word	0x200180c8
 8010c48:	08017004 	.word	0x08017004
 8010c4c:	f3af 8000 	nop.w

08010c50 <_close_r>:
{
  (void)r;
  (void)file;

  return 0;
}
 8010c50:	2000      	movs	r0, #0
 8010c52:	4770      	bx	lr
 8010c54:	f3af 8000 	nop.w
 8010c58:	f3af 8000 	nop.w
 8010c5c:	f3af 8000 	nop.w

08010c60 <_sbrk_r>:

/***************************************************************************/

caddr_t _sbrk_r(struct _reent *r, int incr)
{
 8010c60:	b510      	push	{r4, lr}
 8010c62:	4604      	mov	r4, r0
#if CH_CFG_USE_MEMCORE
  void *p;

  chDbgCheck(incr > 0);

  p = chCoreAlloc((size_t)incr);
 8010c64:	4608      	mov	r0, r1
 8010c66:	f7f1 fd93 	bl	8002790 <chCoreAlloc>
  if (p == NULL) {
 8010c6a:	b100      	cbz	r0, 8010c6e <_sbrk_r+0xe>
#else
  (void)incr;
  __errno_r(r) = ENOMEM;
  return (caddr_t)-1;
#endif
}
 8010c6c:	bd10      	pop	{r4, pc}

  chDbgCheck(incr > 0);

  p = chCoreAlloc((size_t)incr);
  if (p == NULL) {
    __errno_r(r) = ENOMEM;
 8010c6e:	230c      	movs	r3, #12
 8010c70:	6023      	str	r3, [r4, #0]
    return (caddr_t)-1;
 8010c72:	f04f 30ff 	mov.w	r0, #4294967295
#else
  (void)incr;
  __errno_r(r) = ENOMEM;
  return (caddr_t)-1;
#endif
}
 8010c76:	bd10      	pop	{r4, pc}
 8010c78:	f3af 8000 	nop.w
 8010c7c:	f3af 8000 	nop.w

08010c80 <_fstat_r>:

/***************************************************************************/

int _fstat_r(struct _reent *r, int file, struct stat * st)
{
 8010c80:	b510      	push	{r4, lr}
  (void)r;
  (void)file;

  memset(st, 0, sizeof(*st));
 8010c82:	4610      	mov	r0, r2
}

/***************************************************************************/

int _fstat_r(struct _reent *r, int file, struct stat * st)
{
 8010c84:	4614      	mov	r4, r2
  (void)r;
  (void)file;

  memset(st, 0, sizeof(*st));
 8010c86:	2100      	movs	r1, #0
 8010c88:	223c      	movs	r2, #60	; 0x3c
 8010c8a:	f003 f8a1 	bl	8013dd0 <memset>
  st->st_mode = S_IFCHR;
 8010c8e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8010c92:	6063      	str	r3, [r4, #4]
  return 0;
}
 8010c94:	2000      	movs	r0, #0
 8010c96:	bd10      	pop	{r4, pc}
 8010c98:	f3af 8000 	nop.w
 8010c9c:	f3af 8000 	nop.w

08010ca0 <_isatty_r>:
{
  (void)r;
  (void)fd;

  return 1;
}
 8010ca0:	2001      	movs	r0, #1
 8010ca2:	4770      	bx	lr
 8010ca4:	f3af 8000 	nop.w
 8010ca8:	f3af 8000 	nop.w
 8010cac:	f3af 8000 	nop.w

08010cb0 <long_to_string_with_divisor.constprop.0>:
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
 8010cb0:	b4f0      	push	{r4, r5, r6, r7}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8010cb2:	f100 070b 	add.w	r7, r0, #11
 8010cb6:	463c      	mov	r4, r7
 8010cb8:	460d      	mov	r5, r1
  do {
    i = (int)(l % radix);
 8010cba:	fbb1 f6f2 	udiv	r6, r1, r2
 8010cbe:	fb02 1116 	mls	r1, r2, r6, r1
    i += '0';
 8010cc2:	f101 0330 	add.w	r3, r1, #48	; 0x30
    if (i > '9')
 8010cc6:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
 8010cc8:	bfc8      	it	gt
 8010cca:	f101 0337 	addgt.w	r3, r1, #55	; 0x37
    *--q = i;
 8010cce:	b2db      	uxtb	r3, r3
 8010cd0:	f804 3d01 	strb.w	r3, [r4, #-1]!
    l /= radix;
  } while ((ll /= radix) != 0);
 8010cd4:	fbb5 f5f2 	udiv	r5, r5, r2
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
 8010cd8:	4631      	mov	r1, r6
  } while ((ll /= radix) != 0);
 8010cda:	2d00      	cmp	r5, #0
 8010cdc:	d1ed      	bne.n	8010cba <long_to_string_with_divisor.constprop.0+0xa>

  i = (int)(p + MAX_FILLER - q);
 8010cde:	1b3a      	subs	r2, r7, r4
 8010ce0:	4402      	add	r2, r0
 8010ce2:	e001      	b.n	8010ce8 <long_to_string_with_divisor.constprop.0+0x38>
 8010ce4:	f814 3f01 	ldrb.w	r3, [r4, #1]!
  do
    *p++ = *q++;
 8010ce8:	f800 3b01 	strb.w	r3, [r0], #1
  while (--i);
 8010cec:	4290      	cmp	r0, r2
 8010cee:	d1f9      	bne.n	8010ce4 <long_to_string_with_divisor.constprop.0+0x34>

  return p;
}
 8010cf0:	bcf0      	pop	{r4, r5, r6, r7}
 8010cf2:	4770      	bx	lr
 8010cf4:	f3af 8000 	nop.w
 8010cf8:	f3af 8000 	nop.w
 8010cfc:	f3af 8000 	nop.w

08010d00 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8010d00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010d04:	b087      	sub	sp, #28
 8010d06:	4615      	mov	r5, r2
 8010d08:	f10d 030d 	add.w	r3, sp, #13
 8010d0c:	aa03      	add	r2, sp, #12
 8010d0e:	1a9b      	subs	r3, r3, r2
 8010d10:	4681      	mov	r9, r0
 8010d12:	468a      	mov	sl, r1
 8010d14:	9301      	str	r3, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8010d16:	f04f 0800 	mov.w	r8, #0
 8010d1a:	468b      	mov	fp, r1
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 8010d1c:	f89b 1000 	ldrb.w	r1, [fp]
 8010d20:	f10b 0301 	add.w	r3, fp, #1
    if (c == 0)
 8010d24:	b179      	cbz	r1, 8010d46 <chvprintf+0x46>
      return n;
    if (c != '%') {
 8010d26:	2925      	cmp	r1, #37	; 0x25
 8010d28:	d011      	beq.n	8010d4e <chvprintf+0x4e>
      chSequentialStreamPut(chp, (uint8_t)c);
 8010d2a:	f8d9 2000 	ldr.w	r2, [r9]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 8010d2e:	469b      	mov	fp, r3
    if (c == 0)
      return n;
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
 8010d30:	6892      	ldr	r2, [r2, #8]
 8010d32:	4648      	mov	r0, r9
 8010d34:	4790      	blx	r2
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 8010d36:	f89b 1000 	ldrb.w	r1, [fp]
    if (c == 0)
      return n;
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
 8010d3a:	f108 0801 	add.w	r8, r8, #1
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 8010d3e:	f10b 0301 	add.w	r3, fp, #1
    if (c == 0)
 8010d42:	2900      	cmp	r1, #0
 8010d44:	d1ef      	bne.n	8010d26 <chvprintf+0x26>
      chSequentialStreamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 8010d46:	4640      	mov	r0, r8
 8010d48:	b007      	add	sp, #28
 8010d4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 8010d4e:	f89b 2001 	ldrb.w	r2, [fp, #1]
 8010d52:	2a2d      	cmp	r2, #45	; 0x2d
 8010d54:	bf03      	ittte	eq
 8010d56:	f89b 2002 	ldrbeq.w	r2, [fp, #2]
      fmt++;
 8010d5a:	f10b 0302 	addeq.w	r3, fp, #2
      left_align = TRUE;
 8010d5e:	f04f 0a01 	moveq.w	sl, #1
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
 8010d62:	f04f 0a00 	movne.w	sl, #0
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
 8010d66:	2a30      	cmp	r2, #48	; 0x30
 8010d68:	bf03      	ittte	eq
 8010d6a:	785a      	ldrbeq	r2, [r3, #1]
      fmt++;
 8010d6c:	3301      	addeq	r3, #1
      filler = '0';
 8010d6e:	2730      	moveq	r7, #48	; 0x30
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
 8010d70:	2720      	movne	r7, #32
 8010d72:	1c59      	adds	r1, r3, #1
    if (*fmt == '0') {
      fmt++;
      filler = '0';
    }
    width = 0;
 8010d74:	2600      	movs	r6, #0
 8010d76:	e006      	b.n	8010d86 <chvprintf+0x86>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
 8010d78:	782b      	ldrb	r3, [r5, #0]
 8010d7a:	3504      	adds	r5, #4
 8010d7c:	f89b 2000 	ldrb.w	r2, [fp]
      else
        break;
      width = width * 10 + c;
 8010d80:	eb03 0640 	add.w	r6, r3, r0, lsl #1
 8010d84:	3101      	adds	r1, #1
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 8010d86:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8010d8a:	b2db      	uxtb	r3, r3
 8010d8c:	2b09      	cmp	r3, #9
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
 8010d8e:	468b      	mov	fp, r1
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
 8010d90:	eb06 0086 	add.w	r0, r6, r6, lsl #2
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 8010d94:	d9f2      	bls.n	8010d7c <chvprintf+0x7c>
        c -= '0';
      else if (c == '*')
 8010d96:	2a2a      	cmp	r2, #42	; 0x2a
 8010d98:	d0ee      	beq.n	8010d78 <chvprintf+0x78>
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
 8010d9a:	2a2e      	cmp	r2, #46	; 0x2e
 8010d9c:	f04f 0100 	mov.w	r1, #0
 8010da0:	d043      	beq.n	8010e2a <chvprintf+0x12a>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8010da2:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 8010da6:	2b4c      	cmp	r3, #76	; 0x4c
 8010da8:	d04e      	beq.n	8010e48 <chvprintf+0x148>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8010daa:	f1a2 0044 	sub.w	r0, r2, #68	; 0x44
 8010dae:	2834      	cmp	r0, #52	; 0x34
 8010db0:	f200 80f7 	bhi.w	8010fa2 <chvprintf+0x2a2>
 8010db4:	e8df f010 	tbh	[pc, r0, lsl #1]
 8010db8:	00f500ea 	.word	0x00f500ea
 8010dbc:	00f500f5 	.word	0x00f500f5
 8010dc0:	00ea00f5 	.word	0x00ea00f5
 8010dc4:	00f500f5 	.word	0x00f500f5
 8010dc8:	00f500f5 	.word	0x00f500f5
 8010dcc:	00e800f5 	.word	0x00e800f5
 8010dd0:	00f500f5 	.word	0x00f500f5
 8010dd4:	00f500f5 	.word	0x00f500f5
 8010dd8:	00dd00f5 	.word	0x00dd00f5
 8010ddc:	00f500f5 	.word	0x00f500f5
 8010de0:	00f500f2 	.word	0x00f500f2
 8010de4:	00f500f5 	.word	0x00f500f5
 8010de8:	00f500f5 	.word	0x00f500f5
 8010dec:	00f500f5 	.word	0x00f500f5
 8010df0:	00f500f5 	.word	0x00f500f5
 8010df4:	00a100f5 	.word	0x00a100f5
 8010df8:	00f500ea 	.word	0x00f500ea
 8010dfc:	00f500f5 	.word	0x00f500f5
 8010e00:	00ea00f5 	.word	0x00ea00f5
 8010e04:	00f500f5 	.word	0x00f500f5
 8010e08:	00f500f5 	.word	0x00f500f5
 8010e0c:	00e800f5 	.word	0x00e800f5
 8010e10:	00f500f5 	.word	0x00f500f5
 8010e14:	007100f5 	.word	0x007100f5
 8010e18:	00dd00f5 	.word	0x00dd00f5
 8010e1c:	00f500f5 	.word	0x00f500f5
 8010e20:	00f2      	.short	0x00f2
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
 8010e22:	782b      	ldrb	r3, [r5, #0]
 8010e24:	3504      	adds	r5, #4
        else
          break;
        precision *= 10;
        precision += c;
 8010e26:	eb03 0140 	add.w	r1, r3, r0, lsl #1
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 8010e2a:	f81b 2b01 	ldrb.w	r2, [fp], #1
        if (c >= '0' && c <= '9')
 8010e2e:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8010e32:	b2db      	uxtb	r3, r3
 8010e34:	2b09      	cmp	r3, #9
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
        else
          break;
        precision *= 10;
 8010e36:	eb01 0081 	add.w	r0, r1, r1, lsl #2
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
 8010e3a:	d9f4      	bls.n	8010e26 <chvprintf+0x126>
          c -= '0';
        else if (c == '*')
 8010e3c:	2a2a      	cmp	r2, #42	; 0x2a
 8010e3e:	d0f0      	beq.n	8010e22 <chvprintf+0x122>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8010e40:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 8010e44:	2b4c      	cmp	r3, #76	; 0x4c
 8010e46:	d1b0      	bne.n	8010daa <chvprintf+0xaa>
      is_long = TRUE;
      if (*fmt)
 8010e48:	f89b 3000 	ldrb.w	r3, [fp]
 8010e4c:	2b00      	cmp	r3, #0
 8010e4e:	f000 80a8 	beq.w	8010fa2 <chvprintf+0x2a2>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8010e52:	f1a3 0244 	sub.w	r2, r3, #68	; 0x44
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 8010e56:	f10b 0b01 	add.w	fp, fp, #1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8010e5a:	2a34      	cmp	r2, #52	; 0x34
 8010e5c:	f200 80a0 	bhi.w	8010fa0 <chvprintf+0x2a0>
 8010e60:	e8df f002 	tbb	[pc, r2]
 8010e64:	9e9e9e94 	.word	0x9e9e9e94
 8010e68:	9e9e949e 	.word	0x9e9e949e
 8010e6c:	929e9e9e 	.word	0x929e9e9e
 8010e70:	9e9e9e9e 	.word	0x9e9e9e9e
 8010e74:	9e9e879e 	.word	0x9e9e879e
 8010e78:	9e9e9e9c 	.word	0x9e9e9e9c
 8010e7c:	9e9e9e9e 	.word	0x9e9e9e9e
 8010e80:	4b9e9e9e 	.word	0x4b9e9e9e
 8010e84:	9e9e9e94 	.word	0x9e9e9e94
 8010e88:	9e9e949e 	.word	0x9e9e949e
 8010e8c:	929e9e9e 	.word	0x929e9e9e
 8010e90:	1b9e9e9e 	.word	0x1b9e9e9e
 8010e94:	9e9e879e 	.word	0x9e9e879e
 8010e98:	9c          	.byte	0x9c
 8010e99:	00          	.byte	0x00
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8010e9a:	682c      	ldr	r4, [r5, #0]
        s = "(null)";
 8010e9c:	4b5a      	ldr	r3, [pc, #360]	; (8011008 <chvprintf+0x308>)
 8010e9e:	2c00      	cmp	r4, #0
 8010ea0:	bf08      	it	eq
 8010ea2:	461c      	moveq	r4, r3
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8010ea4:	3504      	adds	r5, #4
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8010ea6:	7823      	ldrb	r3, [r4, #0]
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
 8010ea8:	2900      	cmp	r1, #0
 8010eaa:	f000 8094 	beq.w	8010fd6 <chvprintf+0x2d6>
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8010eae:	2b00      	cmp	r3, #0
 8010eb0:	f000 8096 	beq.w	8010fe0 <chvprintf+0x2e0>
 8010eb4:	3901      	subs	r1, #1
 8010eb6:	4620      	mov	r0, r4
 8010eb8:	e001      	b.n	8010ebe <chvprintf+0x1be>
 8010eba:	3901      	subs	r1, #1
 8010ebc:	d403      	bmi.n	8010ec6 <chvprintf+0x1c6>
 8010ebe:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8010ec2:	2b00      	cmp	r3, #0
 8010ec4:	d1f9      	bne.n	8010eba <chvprintf+0x1ba>
 8010ec6:	1b00      	subs	r0, r0, r4
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 8010ec8:	1a36      	subs	r6, r6, r0
 8010eca:	1e43      	subs	r3, r0, #1
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 8010ecc:	2720      	movs	r7, #32
 8010ece:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8010ed2:	f1ba 0f00 	cmp.w	sl, #0
 8010ed6:	d01f      	beq.n	8010f18 <chvprintf+0x218>
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8010ed8:	2b00      	cmp	r3, #0
 8010eda:	9300      	str	r3, [sp, #0]
 8010edc:	da34      	bge.n	8010f48 <chvprintf+0x248>
      chSequentialStreamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8010ede:	2e00      	cmp	r6, #0
 8010ee0:	f43f af1c 	beq.w	8010d1c <chvprintf+0x1c>
 8010ee4:	4634      	mov	r4, r6
      chSequentialStreamPut(chp, (uint8_t)filler);
 8010ee6:	f8d9 3000 	ldr.w	r3, [r9]
 8010eea:	4648      	mov	r0, r9
 8010eec:	689b      	ldr	r3, [r3, #8]
 8010eee:	4639      	mov	r1, r7
 8010ef0:	4798      	blx	r3
    while (--i >= 0) {
      chSequentialStreamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8010ef2:	3c01      	subs	r4, #1
 8010ef4:	d1f7      	bne.n	8010ee6 <chvprintf+0x1e6>
 8010ef6:	44b0      	add	r8, r6
 8010ef8:	e710      	b.n	8010d1c <chvprintf+0x1c>

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 8010efa:	682b      	ldr	r3, [r5, #0]
 8010efc:	f88d 300c 	strb.w	r3, [sp, #12]
 8010f00:	9b01      	ldr	r3, [sp, #4]
 8010f02:	3504      	adds	r5, #4
 8010f04:	4618      	mov	r0, r3
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 8010f06:	2720      	movs	r7, #32
 8010f08:	3b01      	subs	r3, #1
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8010f0a:	ac03      	add	r4, sp, #12
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 8010f0c:	1a36      	subs	r6, r6, r0
 8010f0e:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      width = 0;
    if (left_align == FALSE)
 8010f12:	f1ba 0f00 	cmp.w	sl, #0
 8010f16:	d1df      	bne.n	8010ed8 <chvprintf+0x1d8>
 8010f18:	9300      	str	r3, [sp, #0]
      width = -width;
 8010f1a:	f1c6 0a00 	rsb	sl, r6, #0
    if (width < 0) {
 8010f1e:	f1ba 0f00 	cmp.w	sl, #0
 8010f22:	d045      	beq.n	8010fb0 <chvprintf+0x2b0>
      if (*s == '-' && filler == '0') {
 8010f24:	7821      	ldrb	r1, [r4, #0]
 8010f26:	292d      	cmp	r1, #45	; 0x2d
 8010f28:	d047      	beq.n	8010fba <chvprintf+0x2ba>
        chSequentialStreamPut(chp, (uint8_t)*s++);
        n++;
 8010f2a:	4656      	mov	r6, sl
        i--;
      }
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
 8010f2c:	f8d9 3000 	ldr.w	r3, [r9]
 8010f30:	4648      	mov	r0, r9
 8010f32:	689b      	ldr	r3, [r3, #8]
 8010f34:	4639      	mov	r1, r7
 8010f36:	4798      	blx	r3
        n++;
      } while (++width != 0);
 8010f38:	3601      	adds	r6, #1
 8010f3a:	d1f7      	bne.n	8010f2c <chvprintf+0x22c>
    }
    while (--i >= 0) {
 8010f3c:	9b00      	ldr	r3, [sp, #0]
 8010f3e:	2b00      	cmp	r3, #0
 8010f40:	ebca 0808 	rsb	r8, sl, r8
 8010f44:	f6ff aeea 	blt.w	8010d1c <chvprintf+0x1c>
 8010f48:	f8dd a000 	ldr.w	sl, [sp]
      chSequentialStreamPut(chp, (uint8_t)*s++);
 8010f4c:	f8d9 3000 	ldr.w	r3, [r9]
 8010f50:	f814 1b01 	ldrb.w	r1, [r4], #1
 8010f54:	689b      	ldr	r3, [r3, #8]
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8010f56:	f10a 3aff 	add.w	sl, sl, #4294967295
      chSequentialStreamPut(chp, (uint8_t)*s++);
 8010f5a:	4648      	mov	r0, r9
 8010f5c:	4798      	blx	r3
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8010f5e:	f1ba 3fff 	cmp.w	sl, #4294967295
 8010f62:	d1f3      	bne.n	8010f4c <chvprintf+0x24c>
 8010f64:	9b00      	ldr	r3, [sp, #0]
 8010f66:	f108 0801 	add.w	r8, r8, #1
 8010f6a:	2b00      	cmp	r3, #0
 8010f6c:	bfa8      	it	ge
 8010f6e:	4498      	addge	r8, r3
 8010f70:	e7b5      	b.n	8010ede <chvprintf+0x1de>
      c = 16;
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
      goto unsigned_common;
 8010f72:	220a      	movs	r2, #10
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 8010f74:	6829      	ldr	r1, [r5, #0]
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8010f76:	a803      	add	r0, sp, #12
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 8010f78:	3504      	adds	r5, #4
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8010f7a:	f7ff fe99 	bl	8010cb0 <long_to_string_with_divisor.constprop.0>
 8010f7e:	ab03      	add	r3, sp, #12
 8010f80:	1ac0      	subs	r0, r0, r3
 8010f82:	1e43      	subs	r3, r0, #1
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8010f84:	ac03      	add	r4, sp, #12
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
 8010f86:	e7c1      	b.n	8010f0c <chvprintf+0x20c>
 8010f88:	2208      	movs	r2, #8
 8010f8a:	e7f3      	b.n	8010f74 <chvprintf+0x274>
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 8010f8c:	6829      	ldr	r1, [r5, #0]
      if (l < 0) {
 8010f8e:	2900      	cmp	r1, #0
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 8010f90:	f105 0504 	add.w	r5, r5, #4
      if (l < 0) {
 8010f94:	db2e      	blt.n	8010ff4 <chvprintf+0x2f4>
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 8010f96:	a803      	add	r0, sp, #12
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8010f98:	220a      	movs	r2, #10
 8010f9a:	e7ee      	b.n	8010f7a <chvprintf+0x27a>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8010f9c:	2210      	movs	r2, #16
 8010f9e:	e7e9      	b.n	8010f74 <chvprintf+0x274>
 8010fa0:	461a      	mov	r2, r3
 8010fa2:	9b01      	ldr	r3, [sp, #4]
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8010fa4:	f88d 200c 	strb.w	r2, [sp, #12]
 8010fa8:	4618      	mov	r0, r3
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8010faa:	ac03      	add	r4, sp, #12
 8010fac:	3b01      	subs	r3, #1
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
      break;
 8010fae:	e7ad      	b.n	8010f0c <chvprintf+0x20c>
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8010fb0:	9b00      	ldr	r3, [sp, #0]
 8010fb2:	2b00      	cmp	r3, #0
 8010fb4:	4656      	mov	r6, sl
 8010fb6:	dac7      	bge.n	8010f48 <chvprintf+0x248>
 8010fb8:	e6b0      	b.n	8010d1c <chvprintf+0x1c>
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
 8010fba:	2f30      	cmp	r7, #48	; 0x30
 8010fbc:	d1b5      	bne.n	8010f2a <chvprintf+0x22a>
        chSequentialStreamPut(chp, (uint8_t)*s++);
 8010fbe:	f8d9 3000 	ldr.w	r3, [r9]
 8010fc2:	4648      	mov	r0, r9
 8010fc4:	689b      	ldr	r3, [r3, #8]
 8010fc6:	4798      	blx	r3
 8010fc8:	9b00      	ldr	r3, [sp, #0]
 8010fca:	3b01      	subs	r3, #1
 8010fcc:	3401      	adds	r4, #1
        n++;
 8010fce:	f108 0801 	add.w	r8, r8, #1
 8010fd2:	9300      	str	r3, [sp, #0]
 8010fd4:	e7a9      	b.n	8010f2a <chvprintf+0x22a>
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8010fd6:	f647 71fe 	movw	r1, #32766	; 0x7ffe
 8010fda:	2b00      	cmp	r3, #0
 8010fdc:	f47f af6b 	bne.w	8010eb6 <chvprintf+0x1b6>
 8010fe0:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8010fe4:	f1ba 0f00 	cmp.w	sl, #0
 8010fe8:	d10b      	bne.n	8011002 <chvprintf+0x302>
 8010fea:	f04f 33ff 	mov.w	r3, #4294967295
 8010fee:	9300      	str	r3, [sp, #0]
 8010ff0:	2720      	movs	r7, #32
 8010ff2:	e792      	b.n	8010f1a <chvprintf+0x21a>
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8010ff4:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 8010ff6:	4249      	negs	r1, r1
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8010ff8:	f88d 300c 	strb.w	r3, [sp, #12]
 8010ffc:	f10d 000d 	add.w	r0, sp, #13
 8011000:	e7ca      	b.n	8010f98 <chvprintf+0x298>
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8011002:	2720      	movs	r7, #32
 8011004:	e76b      	b.n	8010ede <chvprintf+0x1de>
 8011006:	bf00      	nop
 8011008:	08019130 	.word	0x08019130
 801100c:	f3af 8000 	nop.w

08011010 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8011010:	b40e      	push	{r1, r2, r3}
 8011012:	b500      	push	{lr}
 8011014:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8011016:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 8011018:	461a      	mov	r2, r3
 801101a:	4905      	ldr	r1, [pc, #20]	; (8011030 <chprintf.constprop.0+0x20>)
 801101c:	4805      	ldr	r0, [pc, #20]	; (8011034 <chprintf.constprop.0+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 801101e:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8011020:	f7ff fe6e 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8011024:	b002      	add	sp, #8
 8011026:	f85d eb04 	ldr.w	lr, [sp], #4
 801102a:	b003      	add	sp, #12
 801102c:	4770      	bx	lr
 801102e:	bf00      	nop
 8011030:	08019140 	.word	0x08019140
 8011034:	200180c8 	.word	0x200180c8
 8011038:	f3af 8000 	nop.w
 801103c:	f3af 8000 	nop.w

08011040 <eMBMasterReqReadCoils>:
 *
 * @return error code
 */
eMBMasterReqErrCode
eMBMasterReqReadCoils( UCHAR ucSndAddr, USHORT usCoilAddr, USHORT usNCoils ,LONG lTimeOut )
{
 8011040:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011044:	4607      	mov	r7, r0
 8011046:	b08d      	sub	sp, #52	; 0x34
    UCHAR                 *ucMBFrame;
    eMBMasterReqErrCode    eErrStatus = MB_MRE_NO_ERR;
	
	chprintf((BaseSequentialStream *)&itm_port, "Resource Taken %s\n", xMBMasterRunResTake( lTimeOut ) ? "true" : "false");
 8011048:	4618      	mov	r0, r3
 *
 * @return error code
 */
eMBMasterReqErrCode
eMBMasterReqReadCoils( UCHAR ucSndAddr, USHORT usCoilAddr, USHORT usNCoils ,LONG lTimeOut )
{
 801104a:	4689      	mov	r9, r1
 801104c:	4690      	mov	r8, r2
 801104e:	469a      	mov	sl, r3
    UCHAR                 *ucMBFrame;
    eMBMasterReqErrCode    eErrStatus = MB_MRE_NO_ERR;
	
	chprintf((BaseSequentialStream *)&itm_port, "Resource Taken %s\n", xMBMasterRunResTake( lTimeOut ) ? "true" : "false");
 8011050:	f001 fa16 	bl	8012480 <xMBMasterRunResTake>
 8011054:	4b30      	ldr	r3, [pc, #192]	; (8011118 <eMBMasterReqReadCoils+0xd8>)
 8011056:	4a31      	ldr	r2, [pc, #196]	; (801111c <eMBMasterReqReadCoils+0xdc>)
 8011058:	4931      	ldr	r1, [pc, #196]	; (8011120 <eMBMasterReqReadCoils+0xe0>)
	
	populate(&list_RTC, (DeviceElement){ucSndAddr, "RTC", CONNECTIONLESS, 0, nReqs++, 1, usCoilAddr, usNCoils, 0, 0});
 801105a:	4d32      	ldr	r5, [pc, #200]	; (8011124 <eMBMasterReqReadCoils+0xe4>)
eMBMasterReqReadCoils( UCHAR ucSndAddr, USHORT usCoilAddr, USHORT usNCoils ,LONG lTimeOut )
{
    UCHAR                 *ucMBFrame;
    eMBMasterReqErrCode    eErrStatus = MB_MRE_NO_ERR;
	
	chprintf((BaseSequentialStream *)&itm_port, "Resource Taken %s\n", xMBMasterRunResTake( lTimeOut ) ? "true" : "false");
 801105c:	2800      	cmp	r0, #0
 801105e:	bf18      	it	ne
 8011060:	461a      	movne	r2, r3
 8011062:	4831      	ldr	r0, [pc, #196]	; (8011128 <eMBMasterReqReadCoils+0xe8>)
 8011064:	f7ff ffd4 	bl	8011010 <chprintf.constprop.0>
	
	populate(&list_RTC, (DeviceElement){ucSndAddr, "RTC", CONNECTIONLESS, 0, nReqs++, 1, usCoilAddr, usNCoils, 0, 0});
 8011068:	f8df e0c4 	ldr.w	lr, [pc, #196]	; 8011130 <eMBMasterReqReadCoils+0xf0>
 801106c:	f8ad 9028 	strh.w	r9, [sp, #40]	; 0x28
 8011070:	f8be 3000 	ldrh.w	r3, [lr]
 8011074:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
 8011078:	f04f 0b01 	mov.w	fp, #1
 801107c:	2400      	movs	r4, #0
 801107e:	f8ad 802a 	strh.w	r8, [sp, #42]	; 0x2a
 8011082:	f88d b026 	strb.w	fp, [sp, #38]	; 0x26
 8011086:	f88d 402c 	strb.w	r4, [sp, #44]	; 0x2c
 801108a:	f88d 402d 	strb.w	r4, [sp, #45]	; 0x2d
 801108e:	aa0c      	add	r2, sp, #48	; 0x30
 8011090:	e912 0007 	ldmdb	r2, {r0, r1, r2}
 8011094:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 8011098:	9507      	str	r5, [sp, #28]
 801109a:	f88d 7018 	strb.w	r7, [sp, #24]
 801109e:	f88d b020 	strb.w	fp, [sp, #32]
 80110a2:	f8ad 4022 	strh.w	r4, [sp, #34]	; 0x22
 80110a6:	eb03 050b 	add.w	r5, r3, fp
 80110aa:	ae06      	add	r6, sp, #24
 80110ac:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
 80110b0:	481e      	ldr	r0, [pc, #120]	; (801112c <eMBMasterReqReadCoils+0xec>)
 80110b2:	f8ae 5000 	strh.w	r5, [lr]
 80110b6:	f002 fa23 	bl	8013500 <populate>

    if ( ucSndAddr > MB_MASTER_TOTAL_SLAVE_NUM ) eErrStatus = MB_MRE_ILL_ARG;
 80110ba:	2f10      	cmp	r7, #16
 80110bc:	d903      	bls.n	80110c6 <eMBMasterReqReadCoils+0x86>
 80110be:	2002      	movs	r0, #2
		xMBMasterRunResLock();
		//eErrStatus = eMBMasterWaitRequestFinish( );

    }
    return eErrStatus;
}
 80110c0:	b00d      	add	sp, #52	; 0x34
 80110c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	chprintf((BaseSequentialStream *)&itm_port, "Resource Taken %s\n", xMBMasterRunResTake( lTimeOut ) ? "true" : "false");
	
	populate(&list_RTC, (DeviceElement){ucSndAddr, "RTC", CONNECTIONLESS, 0, nReqs++, 1, usCoilAddr, usNCoils, 0, 0});

    if ( ucSndAddr > MB_MASTER_TOTAL_SLAVE_NUM ) eErrStatus = MB_MRE_ILL_ARG;
    else if ( xMBMasterRunResTake( lTimeOut ) == FALSE ) eErrStatus = MB_MRE_MASTER_BUSY;
 80110c6:	4650      	mov	r0, sl
 80110c8:	f001 f9da 	bl	8012480 <xMBMasterRunResTake>
 80110cc:	b918      	cbnz	r0, 80110d6 <eMBMasterReqReadCoils+0x96>
 80110ce:	2005      	movs	r0, #5
		xMBMasterRunResLock();
		//eErrStatus = eMBMasterWaitRequestFinish( );

    }
    return eErrStatus;
}
 80110d0:	b00d      	add	sp, #52	; 0x34
 80110d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

    if ( ucSndAddr > MB_MASTER_TOTAL_SLAVE_NUM ) eErrStatus = MB_MRE_ILL_ARG;
    else if ( xMBMasterRunResTake( lTimeOut ) == FALSE ) eErrStatus = MB_MRE_MASTER_BUSY;
    else
    {
		vMBMasterGetPDUSndBuf(&ucMBFrame);
 80110d6:	a805      	add	r0, sp, #20
 80110d8:	f000 fdea 	bl	8011cb0 <vMBMasterGetPDUSndBuf>
		vMBMasterSetDestAddress(ucSndAddr);
 80110dc:	4638      	mov	r0, r7
 80110de:	f000 ffc7 	bl	8012070 <vMBMasterSetDestAddress>
		ucMBFrame[MB_PDU_FUNC_OFF]                 = MB_FUNC_READ_COILS;
 80110e2:	9b05      	ldr	r3, [sp, #20]
 80110e4:	f883 b000 	strb.w	fp, [r3]
		ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF]        = usCoilAddr >> 8;
 80110e8:	9b05      	ldr	r3, [sp, #20]
 80110ea:	ea4f 2219 	mov.w	r2, r9, lsr #8
 80110ee:	705a      	strb	r2, [r3, #1]
		ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF + 1]    = usCoilAddr;
 80110f0:	9b05      	ldr	r3, [sp, #20]
 80110f2:	f883 9002 	strb.w	r9, [r3, #2]
		ucMBFrame[MB_PDU_REQ_READ_COILCNT_OFF ]    = usNCoils >> 8;
 80110f6:	9b05      	ldr	r3, [sp, #20]
 80110f8:	ea4f 2218 	mov.w	r2, r8, lsr #8
 80110fc:	70da      	strb	r2, [r3, #3]
		ucMBFrame[MB_PDU_REQ_READ_COILCNT_OFF + 1] = usNCoils;
 80110fe:	9b05      	ldr	r3, [sp, #20]
		vMBMasterSetPDUSndLength( MB_PDU_SIZE_MIN + MB_PDU_REQ_READ_SIZE );
 8011100:	2005      	movs	r0, #5
		vMBMasterSetDestAddress(ucSndAddr);
		ucMBFrame[MB_PDU_FUNC_OFF]                 = MB_FUNC_READ_COILS;
		ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF]        = usCoilAddr >> 8;
		ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF + 1]    = usCoilAddr;
		ucMBFrame[MB_PDU_REQ_READ_COILCNT_OFF ]    = usNCoils >> 8;
		ucMBFrame[MB_PDU_REQ_READ_COILCNT_OFF + 1] = usNCoils;
 8011102:	f883 8004 	strb.w	r8, [r3, #4]
		vMBMasterSetPDUSndLength( MB_PDU_SIZE_MIN + MB_PDU_REQ_READ_SIZE );
 8011106:	f000 fddb 	bl	8011cc0 <vMBMasterSetPDUSndLength>
		( void ) xMBMasterPortEventPost( EV_MASTER_FRAME_SENT );
 801110a:	2008      	movs	r0, #8
 801110c:	f001 f990 	bl	8012430 <xMBMasterPortEventPost>
		xMBMasterRunResLock();
 8011110:	f001 f9be 	bl	8012490 <xMBMasterRunResLock>
 */
eMBMasterReqErrCode
eMBMasterReqReadCoils( UCHAR ucSndAddr, USHORT usCoilAddr, USHORT usNCoils ,LONG lTimeOut )
{
    UCHAR                 *ucMBFrame;
    eMBMasterReqErrCode    eErrStatus = MB_MRE_NO_ERR;
 8011114:	4620      	mov	r0, r4
 8011116:	e7d3      	b.n	80110c0 <eMBMasterReqReadCoils+0x80>
 8011118:	08019154 	.word	0x08019154
 801111c:	0801915c 	.word	0x0801915c
 8011120:	08019140 	.word	0x08019140
 8011124:	08019164 	.word	0x08019164
 8011128:	200180c8 	.word	0x200180c8
 801112c:	20018420 	.word	0x20018420
 8011130:	2000cbd4 	.word	0x2000cbd4
 8011134:	f3af 8000 	nop.w
 8011138:	f3af 8000 	nop.w
 801113c:	f3af 8000 	nop.w

08011140 <eMBMasterFuncReadCoils>:
    return eErrStatus;
}

eMBException
eMBMasterFuncReadCoils( UCHAR * pucFrame, USHORT * usLen )
{
 8011140:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8011144:	b093      	sub	sp, #76	; 0x4c
 8011146:	4606      	mov	r6, r0
 8011148:	460c      	mov	r4, r1

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    /* If this request is broadcast, and it's read mode. This request don't need execute. */
    if ( xMBMasterRequestIsBroadcast() )
 801114a:	f000 fdd1 	bl	8011cf0 <xMBMasterRequestIsBroadcast>
 801114e:	2800      	cmp	r0, #0
 8011150:	d173      	bne.n	801123a <eMBMasterFuncReadCoils+0xfa>
    {
    	eStatus = MB_EX_NONE;
    }
    else if ( *usLen >= MB_PDU_SIZE_MIN + MB_PDU_FUNC_READ_SIZE_MIN )
 8011152:	8823      	ldrh	r3, [r4, #0]
 8011154:	2b01      	cmp	r3, #1
 8011156:	d804      	bhi.n	8011162 <eMBMasterFuncReadCoils+0x22>
    }
    else
    {
        /* Can't be a valid read coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8011158:	2403      	movs	r4, #3
    }
    return eStatus;
}
 801115a:	4620      	mov	r0, r4
 801115c:	b013      	add	sp, #76	; 0x4c
 801115e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    {
    	eStatus = MB_EX_NONE;
    }
    else if ( *usLen >= MB_PDU_SIZE_MIN + MB_PDU_FUNC_READ_SIZE_MIN )
    {
    	vMBMasterGetPDUSndBuf(&ucMBFrame);
 8011162:	a805      	add	r0, sp, #20
 8011164:	f000 fda4 	bl	8011cb0 <vMBMasterGetPDUSndBuf>
        usRegAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF] << 8 );
 8011168:	9b05      	ldr	r3, [sp, #20]
        usRegAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF + 1] );
        usRegAddress++;

        usCoilCount = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_COILCNT_OFF] << 8 );
 801116a:	78dd      	ldrb	r5, [r3, #3]
        usCoilCount |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_COILCNT_OFF + 1] );
 801116c:	791a      	ldrb	r2, [r3, #4]
    	eStatus = MB_EX_NONE;
    }
    else if ( *usLen >= MB_PDU_SIZE_MIN + MB_PDU_FUNC_READ_SIZE_MIN )
    {
    	vMBMasterGetPDUSndBuf(&ucMBFrame);
        usRegAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF] << 8 );
 801116e:	785f      	ldrb	r7, [r3, #1]
        usRegAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF + 1] );
 8011170:	7899      	ldrb	r1, [r3, #2]
        usRegAddress++;

        usCoilCount = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_COILCNT_OFF] << 8 );
        usCoilCount |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_COILCNT_OFF + 1] );
 8011172:	ea42 2505 	orr.w	r5, r2, r5, lsl #8

        /* Test if the quantity of coils is a multiple of 8. If not last
         * byte is only partially field with unused coils set to zero. */
        if( ( usCoilCount & 0x0007 ) != 0 )
 8011176:	076b      	lsls	r3, r5, #29
 8011178:	d064      	beq.n	8011244 <eMBMasterFuncReadCoils+0x104>
        {
        	ucByteCount = ( UCHAR )( usCoilCount / 8 + 1 );
 801117a:	08eb      	lsrs	r3, r5, #3
 801117c:	3301      	adds	r3, #1
 801117e:	b2db      	uxtb	r3, r3
        }

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception. 
         */
        if( ( usCoilCount >= 1 ) &&
 8011180:	7872      	ldrb	r2, [r6, #1]
 8011182:	429a      	cmp	r2, r3
 8011184:	d1e8      	bne.n	8011158 <eMBMasterFuncReadCoils+0x18>
    }
    else if ( *usLen >= MB_PDU_SIZE_MIN + MB_PDU_FUNC_READ_SIZE_MIN )
    {
    	vMBMasterGetPDUSndBuf(&ucMBFrame);
        usRegAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF + 1] );
 8011186:	ea41 2707 	orr.w	r7, r1, r7, lsl #8
        usRegAddress++;
 801118a:	3701      	adds	r7, #1
 801118c:	b2bf      	uxth	r7, r7
         */
        if( ( usCoilCount >= 1 ) &&
            ( ucByteCount == pucFrame[MB_PDU_FUNC_READ_COILCNT_OFF] ) )
        {
        	/* Make callback to fill the buffer. */
            eRegStatus = eMBMasterRegCoilsCB( &pucFrame[MB_PDU_FUNC_READ_VALUES_OFF], usRegAddress, usCoilCount, MB_REG_READ );
 801118e:	4639      	mov	r1, r7
 8011190:	462a      	mov	r2, r5
 8011192:	2300      	movs	r3, #0
 8011194:	1cb0      	adds	r0, r6, #2
 8011196:	f001 f873 	bl	8012280 <eMBMasterRegCoilsCB>
			populate(&list_RTC, (DeviceElement){(uint32_t)ucMBMasterGetDestAddress(), "RTC", CONNECTED, 0, nReqs, 1, usRegAddress, usCoilCount, 0, 0});
 801119a:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 801125c <eMBMasterFuncReadCoils+0x11c>
         */
        if( ( usCoilCount >= 1 ) &&
            ( ucByteCount == pucFrame[MB_PDU_FUNC_READ_COILCNT_OFF] ) )
        {
        	/* Make callback to fill the buffer. */
            eRegStatus = eMBMasterRegCoilsCB( &pucFrame[MB_PDU_FUNC_READ_VALUES_OFF], usRegAddress, usCoilCount, MB_REG_READ );
 801119e:	4604      	mov	r4, r0
			populate(&list_RTC, (DeviceElement){(uint32_t)ucMBMasterGetDestAddress(), "RTC", CONNECTED, 0, nReqs, 1, usRegAddress, usCoilCount, 0, 0});
 80111a0:	f000 ff5e 	bl	8012060 <ucMBMasterGetDestAddress>
 80111a4:	2600      	movs	r6, #0
 80111a6:	f8b9 3000 	ldrh.w	r3, [r9]
 80111aa:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
 80111ae:	f04f 0801 	mov.w	r8, #1
 80111b2:	ab09      	add	r3, sp, #36	; 0x24
 80111b4:	f8ad 7028 	strh.w	r7, [sp, #40]	; 0x28
 80111b8:	f8ad 502a 	strh.w	r5, [sp, #42]	; 0x2a
 80111bc:	f88d 602c 	strb.w	r6, [sp, #44]	; 0x2c
 80111c0:	f88d 602d 	strb.w	r6, [sp, #45]	; 0x2d
 80111c4:	f88d 8026 	strb.w	r8, [sp, #38]	; 0x26
 80111c8:	f88d 0018 	strb.w	r0, [sp, #24]
 80111cc:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80111d0:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 80111d4:	4b1e      	ldr	r3, [pc, #120]	; (8011250 <eMBMasterFuncReadCoils+0x110>)
 80111d6:	9307      	str	r3, [sp, #28]
 80111d8:	f88d 6020 	strb.w	r6, [sp, #32]
 80111dc:	f8ad 6022 	strh.w	r6, [sp, #34]	; 0x22
 80111e0:	ab06      	add	r3, sp, #24
 80111e2:	cb0e      	ldmia	r3, {r1, r2, r3}
 80111e4:	481b      	ldr	r0, [pc, #108]	; (8011254 <eMBMasterFuncReadCoils+0x114>)
 80111e6:	f002 f98b 	bl	8013500 <populate>

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
 80111ea:	b334      	cbz	r4, 801123a <eMBMasterFuncReadCoils+0xfa>
            {
                eStatus = prveMBError2Exception( eRegStatus );
 80111ec:	4620      	mov	r0, r4
 80111ee:	f000 fb2f 	bl	8011850 <prveMBError2Exception>
 80111f2:	4604      	mov	r4, r0
				populate(&list_RTC, (DeviceElement){(uint32_t)ucMBMasterGetDestAddress(), "RTC(E)", CONNECTIONLESS, 0, nReqs, 1, usRegAddress, usCoilCount, 0, 0});
 80111f4:	f000 ff34 	bl	8012060 <ucMBMasterGetDestAddress>
 80111f8:	f8b9 3000 	ldrh.w	r3, [r9]
 80111fc:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
 8011200:	f88d 803e 	strb.w	r8, [sp, #62]	; 0x3e
 8011204:	ab12      	add	r3, sp, #72	; 0x48
 8011206:	f8ad 7040 	strh.w	r7, [sp, #64]	; 0x40
 801120a:	f8ad 5042 	strh.w	r5, [sp, #66]	; 0x42
 801120e:	f88d 6044 	strb.w	r6, [sp, #68]	; 0x44
 8011212:	f88d 6045 	strb.w	r6, [sp, #69]	; 0x45
 8011216:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
 801121a:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 801121e:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 8011222:	4b0d      	ldr	r3, [pc, #52]	; (8011258 <eMBMasterFuncReadCoils+0x118>)
 8011224:	930d      	str	r3, [sp, #52]	; 0x34
 8011226:	f88d 8038 	strb.w	r8, [sp, #56]	; 0x38
 801122a:	f8ad 603a 	strh.w	r6, [sp, #58]	; 0x3a
 801122e:	ab0c      	add	r3, sp, #48	; 0x30
 8011230:	cb0e      	ldmia	r3, {r1, r2, r3}
 8011232:	4808      	ldr	r0, [pc, #32]	; (8011254 <eMBMasterFuncReadCoils+0x114>)
 8011234:	f002 f964 	bl	8013500 <populate>
 8011238:	e78f      	b.n	801115a <eMBMasterFuncReadCoils+0x1a>
    eMBErrorCode    eRegStatus;

    /* If this request is broadcast, and it's read mode. This request don't need execute. */
    if ( xMBMasterRequestIsBroadcast() )
    {
    	eStatus = MB_EX_NONE;
 801123a:	2400      	movs	r4, #0
        /* Can't be a valid read coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
 801123c:	4620      	mov	r0, r4
 801123e:	b013      	add	sp, #76	; 0x4c
 8011240:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        }

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception. 
         */
        if( ( usCoilCount >= 1 ) &&
 8011244:	2d00      	cmp	r5, #0
 8011246:	d087      	beq.n	8011158 <eMBMasterFuncReadCoils+0x18>
        {
        	ucByteCount = ( UCHAR )( usCoilCount / 8 + 1 );
        }
        else
        {
        	ucByteCount = ( UCHAR )( usCoilCount / 8 );
 8011248:	f3c5 03c7 	ubfx	r3, r5, #3, #8
 801124c:	e798      	b.n	8011180 <eMBMasterFuncReadCoils+0x40>
 801124e:	bf00      	nop
 8011250:	08019164 	.word	0x08019164
 8011254:	20018420 	.word	0x20018420
 8011258:	08019168 	.word	0x08019168
 801125c:	2000cbd4 	.word	0x2000cbd4

08011260 <eMBMasterFuncWriteCoil>:
    UCHAR           ucBuf[2];

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
 8011260:	880b      	ldrh	r3, [r1, #0]
 8011262:	2b05      	cmp	r3, #5
 8011264:	d001      	beq.n	801126a <eMBMasterFuncWriteCoil+0xa>
    }
    else
    {
        /* Can't be a valid write coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8011266:	2003      	movs	r0, #3
 8011268:	4770      	bx	lr
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
        usRegAddress++;

        if( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF + 1] == 0x00 ) &&
 801126a:	7903      	ldrb	r3, [r0, #4]
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
 801126c:	7841      	ldrb	r1, [r0, #1]
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
 801126e:	7882      	ldrb	r2, [r0, #2]
        usRegAddress++;

        if( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF + 1] == 0x00 ) &&
 8011270:	2b00      	cmp	r3, #0
 8011272:	d1f8      	bne.n	8011266 <eMBMasterFuncWriteCoil+0x6>
    return eErrStatus;
}

eMBException
eMBMasterFuncWriteCoil( UCHAR * pucFrame, USHORT * usLen )
{
 8011274:	b510      	push	{r4, lr}
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
        usRegAddress++;

        if( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF + 1] == 0x00 ) &&
            ( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0xFF ) ||
 8011276:	78c4      	ldrb	r4, [r0, #3]
 8011278:	1e60      	subs	r0, r4, #1
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
        usRegAddress++;

        if( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF + 1] == 0x00 ) &&
 801127a:	b2c0      	uxtb	r0, r0
 801127c:	28fd      	cmp	r0, #253	; 0xfd
    return eErrStatus;
}

eMBException
eMBMasterFuncWriteCoil( UCHAR * pucFrame, USHORT * usLen )
{
 801127e:	b082      	sub	sp, #8
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
        usRegAddress++;

        if( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF + 1] == 0x00 ) &&
 8011280:	d802      	bhi.n	8011288 <eMBMasterFuncWriteCoil+0x28>
    }
    else
    {
        /* Can't be a valid write coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8011282:	2003      	movs	r0, #3
    }
    return eStatus;
}
 8011284:	b002      	add	sp, #8
 8011286:	bd10      	pop	{r4, pc}
        if( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF + 1] == 0x00 ) &&
            ( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0xFF ) ||
              ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0x00 ) ) )
        {
            ucBuf[1] = 0;
            if( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0xFF )
 8011288:	2cff      	cmp	r4, #255	; 0xff
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
 801128a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8

        if( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF + 1] == 0x00 ) &&
            ( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0xFF ) ||
              ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0x00 ) ) )
        {
            ucBuf[1] = 0;
 801128e:	f88d 3005 	strb.w	r3, [sp, #5]

    if( *usLen == ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
        usRegAddress++;
 8011292:	f102 0101 	add.w	r1, r2, #1
              ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0x00 ) ) )
        {
            ucBuf[1] = 0;
            if( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0xFF )
            {
                ucBuf[0] = 1;
 8011296:	bf08      	it	eq
 8011298:	2301      	moveq	r3, #1
            }
            else
            {
                ucBuf[0] = 0;
            }
            eRegStatus =
 801129a:	2201      	movs	r2, #1
            {
                ucBuf[0] = 1;
            }
            else
            {
                ucBuf[0] = 0;
 801129c:	f88d 3004 	strb.w	r3, [sp, #4]
            }
            eRegStatus =
 80112a0:	b289      	uxth	r1, r1
 80112a2:	4613      	mov	r3, r2
 80112a4:	a801      	add	r0, sp, #4
 80112a6:	f000 ffeb 	bl	8012280 <eMBMasterRegCoilsCB>
                eMBMasterRegCoilsCB( &ucBuf[0], usRegAddress, 1, MB_REG_WRITE );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
 80112aa:	b900      	cbnz	r0, 80112ae <eMBMasterFuncWriteCoil+0x4e>
 80112ac:	e7ea      	b.n	8011284 <eMBMasterFuncWriteCoil+0x24>
            {
                eStatus = prveMBError2Exception( eRegStatus );
 80112ae:	f000 facf 	bl	8011850 <prveMBError2Exception>
 80112b2:	e7e7      	b.n	8011284 <eMBMasterFuncWriteCoil+0x24>
 80112b4:	f3af 8000 	nop.w
 80112b8:	f3af 8000 	nop.w
 80112bc:	f3af 8000 	nop.w

080112c0 <eMBMasterFuncWriteMultipleCoils>:
    return eErrStatus;
}

eMBException
eMBMasterFuncWriteMultipleCoils( UCHAR * pucFrame, USHORT * usLen )
{
 80112c0:	b530      	push	{r4, r5, lr}

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    /* If this request is broadcast, the *usLen is not need check. */
    if( ( *usLen == MB_PDU_FUNC_WRITE_MUL_SIZE ) || xMBMasterRequestIsBroadcast() )
 80112c2:	880b      	ldrh	r3, [r1, #0]
 80112c4:	2b05      	cmp	r3, #5
    return eErrStatus;
}

eMBException
eMBMasterFuncWriteMultipleCoils( UCHAR * pucFrame, USHORT * usLen )
{
 80112c6:	b083      	sub	sp, #12
 80112c8:	4604      	mov	r4, r0

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    /* If this request is broadcast, the *usLen is not need check. */
    if( ( *usLen == MB_PDU_FUNC_WRITE_MUL_SIZE ) || xMBMasterRequestIsBroadcast() )
 80112ca:	d005      	beq.n	80112d8 <eMBMasterFuncWriteMultipleCoils+0x18>
 80112cc:	f000 fd10 	bl	8011cf0 <xMBMasterRequestIsBroadcast>
 80112d0:	b910      	cbnz	r0, 80112d8 <eMBMasterFuncWriteMultipleCoils+0x18>
    }
    else
    {
        /* Can't be a valid write coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 80112d2:	2003      	movs	r0, #3
    }
    return eStatus;
}
 80112d4:	b003      	add	sp, #12
 80112d6:	bd30      	pop	{r4, r5, pc}
    eMBErrorCode    eRegStatus;

    /* If this request is broadcast, the *usLen is not need check. */
    if( ( *usLen == MB_PDU_FUNC_WRITE_MUL_SIZE ) || xMBMasterRequestIsBroadcast() )
    {
    	vMBMasterGetPDUSndBuf(&ucMBFrame);
 80112d8:	a801      	add	r0, sp, #4
 80112da:	f000 fce9 	bl	8011cb0 <vMBMasterGetPDUSndBuf>
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF + 1] );
        usRegAddress++;

        usCoilCnt = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_COILCNT_OFF] << 8 );
        usCoilCnt |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_COILCNT_OFF + 1] );
 80112de:	7923      	ldrb	r3, [r4, #4]
    	vMBMasterGetPDUSndBuf(&ucMBFrame);
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF + 1] );
        usRegAddress++;

        usCoilCnt = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_COILCNT_OFF] << 8 );
 80112e0:	78e2      	ldrb	r2, [r4, #3]
        usCoilCnt |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_COILCNT_OFF + 1] );

        ucByteCount = ucMBFrame[MB_PDU_REQ_WRITE_MUL_BYTECNT_OFF];
 80112e2:	9801      	ldr	r0, [sp, #4]

    /* If this request is broadcast, the *usLen is not need check. */
    if( ( *usLen == MB_PDU_FUNC_WRITE_MUL_SIZE ) || xMBMasterRequestIsBroadcast() )
    {
    	vMBMasterGetPDUSndBuf(&ucMBFrame);
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF] << 8 );
 80112e4:	7865      	ldrb	r5, [r4, #1]
        usRegAddress++;

        usCoilCnt = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_COILCNT_OFF] << 8 );
        usCoilCnt |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_COILCNT_OFF + 1] );

        ucByteCount = ucMBFrame[MB_PDU_REQ_WRITE_MUL_BYTECNT_OFF];
 80112e6:	7941      	ldrb	r1, [r0, #5]
    /* If this request is broadcast, the *usLen is not need check. */
    if( ( *usLen == MB_PDU_FUNC_WRITE_MUL_SIZE ) || xMBMasterRequestIsBroadcast() )
    {
    	vMBMasterGetPDUSndBuf(&ucMBFrame);
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF + 1] );
 80112e8:	78a4      	ldrb	r4, [r4, #2]
        usRegAddress++;

        usCoilCnt = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_COILCNT_OFF] << 8 );
        usCoilCnt |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_COILCNT_OFF + 1] );
 80112ea:	ea43 2202 	orr.w	r2, r3, r2, lsl #8

        ucByteCount = ucMBFrame[MB_PDU_REQ_WRITE_MUL_BYTECNT_OFF];

        /* Compute the number of expected bytes in the request. */
        if( ( usCoilCnt & 0x0007 ) != 0 )
 80112ee:	0753      	lsls	r3, r2, #29
 80112f0:	d00e      	beq.n	8011310 <eMBMasterFuncWriteMultipleCoils+0x50>
        {
            ucByteCountVerify = ( UCHAR )( usCoilCnt / 8 + 1 );
 80112f2:	08d3      	lsrs	r3, r2, #3
 80112f4:	3301      	adds	r3, #1
 80112f6:	b2db      	uxtb	r3, r3
        else
        {
            ucByteCountVerify = ( UCHAR )( usCoilCnt / 8 );
        }

        if( ( usCoilCnt >= 1 ) && ( ucByteCountVerify == ucByteCount ) )
 80112f8:	428b      	cmp	r3, r1
 80112fa:	d1ea      	bne.n	80112d2 <eMBMasterFuncWriteMultipleCoils+0x12>
    /* If this request is broadcast, the *usLen is not need check. */
    if( ( *usLen == MB_PDU_FUNC_WRITE_MUL_SIZE ) || xMBMasterRequestIsBroadcast() )
    {
    	vMBMasterGetPDUSndBuf(&ucMBFrame);
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF + 1] );
 80112fc:	ea44 2105 	orr.w	r1, r4, r5, lsl #8
        usRegAddress++;
 8011300:	3101      	adds	r1, #1
            ucByteCountVerify = ( UCHAR )( usCoilCnt / 8 );
        }

        if( ( usCoilCnt >= 1 ) && ( ucByteCountVerify == ucByteCount ) )
        {
            eRegStatus =
 8011302:	b289      	uxth	r1, r1
 8011304:	3006      	adds	r0, #6
 8011306:	2301      	movs	r3, #1
 8011308:	f000 ffba 	bl	8012280 <eMBMasterRegCoilsCB>
                eMBMasterRegCoilsCB( &ucMBFrame[MB_PDU_REQ_WRITE_MUL_VALUES_OFF],
                               usRegAddress, usCoilCnt, MB_REG_WRITE );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
 801130c:	b928      	cbnz	r0, 801131a <eMBMasterFuncWriteMultipleCoils+0x5a>
 801130e:	e7e1      	b.n	80112d4 <eMBMasterFuncWriteMultipleCoils+0x14>
        else
        {
            ucByteCountVerify = ( UCHAR )( usCoilCnt / 8 );
        }

        if( ( usCoilCnt >= 1 ) && ( ucByteCountVerify == ucByteCount ) )
 8011310:	2a00      	cmp	r2, #0
 8011312:	d0de      	beq.n	80112d2 <eMBMasterFuncWriteMultipleCoils+0x12>
        {
            ucByteCountVerify = ( UCHAR )( usCoilCnt / 8 + 1 );
        }
        else
        {
            ucByteCountVerify = ( UCHAR )( usCoilCnt / 8 );
 8011314:	f3c2 03c7 	ubfx	r3, r2, #3, #8
 8011318:	e7ee      	b.n	80112f8 <eMBMasterFuncWriteMultipleCoils+0x38>
                               usRegAddress, usCoilCnt, MB_REG_WRITE );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
            {
                eStatus = prveMBError2Exception( eRegStatus );
 801131a:	f000 fa99 	bl	8011850 <prveMBError2Exception>
 801131e:	e7d9      	b.n	80112d4 <eMBMasterFuncWriteMultipleCoils+0x14>

08011320 <eMBMasterFuncReadDiscreteInputs>:
    return eErrStatus;
}

eMBException
eMBMasterFuncReadDiscreteInputs( UCHAR * pucFrame, USHORT * usLen )
{
 8011320:	b530      	push	{r4, r5, lr}
 8011322:	b083      	sub	sp, #12
 8011324:	4605      	mov	r5, r0
 8011326:	460c      	mov	r4, r1

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    /* If this request is broadcast, and it's read mode. This request don't need execute. */
    if ( xMBMasterRequestIsBroadcast() )
 8011328:	f000 fce2 	bl	8011cf0 <xMBMasterRequestIsBroadcast>
 801132c:	bb10      	cbnz	r0, 8011374 <eMBMasterFuncReadDiscreteInputs+0x54>
    {
    	eStatus = MB_EX_NONE;
    }
    else if( *usLen >= MB_PDU_SIZE_MIN + MB_PDU_FUNC_READ_SIZE_MIN )
 801132e:	8823      	ldrh	r3, [r4, #0]
 8011330:	2b01      	cmp	r3, #1
 8011332:	d802      	bhi.n	801133a <eMBMasterFuncReadDiscreteInputs+0x1a>
    }
    else
    {
        /* Can't be a valid read coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8011334:	2003      	movs	r0, #3
    }
    return eStatus;
}
 8011336:	b003      	add	sp, #12
 8011338:	bd30      	pop	{r4, r5, pc}
    {
    	eStatus = MB_EX_NONE;
    }
    else if( *usLen >= MB_PDU_SIZE_MIN + MB_PDU_FUNC_READ_SIZE_MIN )
    {
    	vMBMasterGetPDUSndBuf(&ucMBFrame);
 801133a:	a801      	add	r0, sp, #4
 801133c:	f000 fcb8 	bl	8011cb0 <vMBMasterGetPDUSndBuf>
        usRegAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF] << 8 );
 8011340:	9901      	ldr	r1, [sp, #4]
        usRegAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF + 1] );
        usRegAddress++;

        usDiscreteCnt = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_DISCCNT_OFF] << 8 );
        usDiscreteCnt |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_DISCCNT_OFF + 1] );
 8011342:	790b      	ldrb	r3, [r1, #4]
    	vMBMasterGetPDUSndBuf(&ucMBFrame);
        usRegAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF + 1] );
        usRegAddress++;

        usDiscreteCnt = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_DISCCNT_OFF] << 8 );
 8011344:	78ca      	ldrb	r2, [r1, #3]
    	eStatus = MB_EX_NONE;
    }
    else if( *usLen >= MB_PDU_SIZE_MIN + MB_PDU_FUNC_READ_SIZE_MIN )
    {
    	vMBMasterGetPDUSndBuf(&ucMBFrame);
        usRegAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF] << 8 );
 8011346:	7848      	ldrb	r0, [r1, #1]
        usRegAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF + 1] );
 8011348:	7889      	ldrb	r1, [r1, #2]
        usRegAddress++;

        usDiscreteCnt = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_DISCCNT_OFF] << 8 );
        usDiscreteCnt |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_DISCCNT_OFF + 1] );
 801134a:	ea43 2202 	orr.w	r2, r3, r2, lsl #8

        /* Test if the quantity of coils is a multiple of 8. If not last
         * byte is only partially field with unused coils set to zero. */
        if( ( usDiscreteCnt & 0x0007 ) != 0 )
 801134e:	0753      	lsls	r3, r2, #29
 8011350:	d013      	beq.n	801137a <eMBMasterFuncReadDiscreteInputs+0x5a>
        {
        	ucNBytes = ( UCHAR )( usDiscreteCnt / 8 + 1 );
 8011352:	08d3      	lsrs	r3, r2, #3
 8011354:	3301      	adds	r3, #1
 8011356:	b2db      	uxtb	r3, r3
        }

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception. 
         */
		if ((usDiscreteCnt >= 1) && ucNBytes == pucFrame[MB_PDU_FUNC_READ_DISCCNT_OFF])
 8011358:	786c      	ldrb	r4, [r5, #1]
 801135a:	429c      	cmp	r4, r3
 801135c:	d1ea      	bne.n	8011334 <eMBMasterFuncReadDiscreteInputs+0x14>
    }
    else if( *usLen >= MB_PDU_SIZE_MIN + MB_PDU_FUNC_READ_SIZE_MIN )
    {
    	vMBMasterGetPDUSndBuf(&ucMBFrame);
        usRegAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF + 1] );
 801135e:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
        usRegAddress++;
 8011362:	3101      	adds	r1, #1
         * return Modbus illegal data value exception. 
         */
		if ((usDiscreteCnt >= 1) && ucNBytes == pucFrame[MB_PDU_FUNC_READ_DISCCNT_OFF])
        {
	       	/* Make callback to fill the buffer. */
			eRegStatus = eMBMasterRegDiscreteCB( &pucFrame[MB_PDU_FUNC_READ_VALUES_OFF], usRegAddress, usDiscreteCnt );
 8011364:	b289      	uxth	r1, r1
 8011366:	1ca8      	adds	r0, r5, #2
 8011368:	f000 fff2 	bl	8012350 <eMBMasterRegDiscreteCB>

			/* If an error occured convert it into a Modbus exception. */
			if( eRegStatus != MB_ENOERR )
 801136c:	b110      	cbz	r0, 8011374 <eMBMasterFuncReadDiscreteInputs+0x54>
			{
				eStatus = prveMBError2Exception( eRegStatus );
 801136e:	f000 fa6f 	bl	8011850 <prveMBError2Exception>
 8011372:	e7e0      	b.n	8011336 <eMBMasterFuncReadDiscreteInputs+0x16>
    eMBErrorCode    eRegStatus;

    /* If this request is broadcast, and it's read mode. This request don't need execute. */
    if ( xMBMasterRequestIsBroadcast() )
    {
    	eStatus = MB_EX_NONE;
 8011374:	2000      	movs	r0, #0
        /* Can't be a valid read coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
 8011376:	b003      	add	sp, #12
 8011378:	bd30      	pop	{r4, r5, pc}
        }

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception. 
         */
		if ((usDiscreteCnt >= 1) && ucNBytes == pucFrame[MB_PDU_FUNC_READ_DISCCNT_OFF])
 801137a:	2a00      	cmp	r2, #0
 801137c:	d0da      	beq.n	8011334 <eMBMasterFuncReadDiscreteInputs+0x14>
        {
        	ucNBytes = ( UCHAR )( usDiscreteCnt / 8 + 1 );
        }
        else
        {
        	ucNBytes = ( UCHAR )( usDiscreteCnt / 8 );
 801137e:	f3c2 03c7 	ubfx	r3, r2, #3, #8
 8011382:	e7e9      	b.n	8011358 <eMBMasterFuncReadDiscreteInputs+0x38>
 8011384:	f3af 8000 	nop.w
 8011388:	f3af 8000 	nop.w
 801138c:	f3af 8000 	nop.w

08011390 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8011390:	b40e      	push	{r1, r2, r3}
 8011392:	b500      	push	{lr}
 8011394:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8011396:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 8011398:	461a      	mov	r2, r3
 801139a:	4905      	ldr	r1, [pc, #20]	; (80113b0 <chprintf.constprop.0+0x20>)
 801139c:	4805      	ldr	r0, [pc, #20]	; (80113b4 <chprintf.constprop.0+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 801139e:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80113a0:	f7ff fcae 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 80113a4:	b002      	add	sp, #8
 80113a6:	f85d eb04 	ldr.w	lr, [sp], #4
 80113aa:	b003      	add	sp, #12
 80113ac:	4770      	bx	lr
 80113ae:	bf00      	nop
 80113b0:	08019140 	.word	0x08019140
 80113b4:	200180c8 	.word	0x200180c8
 80113b8:	f3af 8000 	nop.w
 80113bc:	f3af 8000 	nop.w

080113c0 <eMBMasterFuncWriteHoldingRegister>:
    return eErrStatus;
}

eMBException
eMBMasterFuncWriteHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
 80113c0:	b508      	push	{r3, lr}
    USHORT          usRegAddress;
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_SIZE_MIN + MB_PDU_FUNC_WRITE_SIZE ) )
 80113c2:	880b      	ldrh	r3, [r1, #0]
 80113c4:	2b05      	cmp	r3, #5
 80113c6:	d001      	beq.n	80113cc <eMBMasterFuncWriteHoldingRegister+0xc>
        }
    }
    else
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 80113c8:	2003      	movs	r0, #3
 80113ca:	bd08      	pop	{r3, pc}
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_SIZE_MIN + MB_PDU_FUNC_WRITE_SIZE ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
 80113cc:	7883      	ldrb	r3, [r0, #2]
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_SIZE_MIN + MB_PDU_FUNC_WRITE_SIZE ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
 80113ce:	7841      	ldrb	r1, [r0, #1]
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
 80113d0:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
        usRegAddress++;
 80113d4:	3101      	adds	r1, #1

        /* Make callback to update the value. */
        eRegStatus = eMBMasterRegHoldingCB( &pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF],
 80113d6:	2201      	movs	r2, #1
 80113d8:	b289      	uxth	r1, r1
 80113da:	3003      	adds	r0, #3
 80113dc:	4613      	mov	r3, r2
 80113de:	f000 ff17 	bl	8012210 <eMBMasterRegHoldingCB>
                                      usRegAddress, 1, MB_REG_WRITE );

        /* If an error occured convert it into a Modbus exception. */
        if( eRegStatus != MB_ENOERR )
 80113e2:	b900      	cbnz	r0, 80113e6 <eMBMasterFuncWriteHoldingRegister+0x26>
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
 80113e4:	bd08      	pop	{r3, pc}
 80113e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
                                      usRegAddress, 1, MB_REG_WRITE );

        /* If an error occured convert it into a Modbus exception. */
        if( eRegStatus != MB_ENOERR )
        {
            eStatus = prveMBError2Exception( eRegStatus );
 80113ea:	f000 ba31 	b.w	8011850 <prveMBError2Exception>
 80113ee:	bf00      	nop

080113f0 <eMBMasterFuncWriteMultipleHoldingRegister>:
    return eErrStatus;
}

eMBException
eMBMasterFuncWriteMultipleHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
 80113f0:	b530      	push	{r4, r5, lr}

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    /* If this request is broadcast, the *usLen is not need check. */
    if( ( *usLen == MB_PDU_SIZE_MIN + MB_PDU_FUNC_WRITE_MUL_SIZE ) || xMBMasterRequestIsBroadcast() )
 80113f2:	880b      	ldrh	r3, [r1, #0]
 80113f4:	2b05      	cmp	r3, #5
    return eErrStatus;
}

eMBException
eMBMasterFuncWriteMultipleHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
 80113f6:	b083      	sub	sp, #12

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    /* If this request is broadcast, the *usLen is not need check. */
    if( ( *usLen == MB_PDU_SIZE_MIN + MB_PDU_FUNC_WRITE_MUL_SIZE ) || xMBMasterRequestIsBroadcast() )
 80113f8:	d005      	beq.n	8011406 <eMBMasterFuncWriteMultipleHoldingRegister+0x16>
 80113fa:	f000 fc79 	bl	8011cf0 <xMBMasterRequestIsBroadcast>
 80113fe:	b910      	cbnz	r0, 8011406 <eMBMasterFuncWriteMultipleHoldingRegister+0x16>
        }
    }
    else
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8011400:	2003      	movs	r0, #3
    }
    return eStatus;
}
 8011402:	b003      	add	sp, #12
 8011404:	bd30      	pop	{r4, r5, pc}
    eMBErrorCode    eRegStatus;

    /* If this request is broadcast, the *usLen is not need check. */
    if( ( *usLen == MB_PDU_SIZE_MIN + MB_PDU_FUNC_WRITE_MUL_SIZE ) || xMBMasterRequestIsBroadcast() )
    {
		vMBMasterGetPDUSndBuf(&ucMBFrame);
 8011406:	a801      	add	r0, sp, #4
 8011408:	f000 fc52 	bl	8011cb0 <vMBMasterGetPDUSndBuf>
        usRegAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_WRITE_MUL_ADDR_OFF] << 8 );
 801140c:	9801      	ldr	r0, [sp, #4]
        usRegAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_WRITE_MUL_ADDR_OFF + 1] );
        usRegAddress++;

        usRegCount = ( USHORT )( ucMBFrame[MB_PDU_REQ_WRITE_MUL_REGCNT_OFF] << 8 );
 801140e:	78c2      	ldrb	r2, [r0, #3]
        usRegCount |= ( USHORT )( ucMBFrame[MB_PDU_REQ_WRITE_MUL_REGCNT_OFF + 1] );
 8011410:	7903      	ldrb	r3, [r0, #4]

        ucRegByteCount = ucMBFrame[MB_PDU_REQ_WRITE_MUL_BYTECNT_OFF];

        if( ucRegByteCount == 2 * usRegCount )
 8011412:	7941      	ldrb	r1, [r0, #5]

    /* If this request is broadcast, the *usLen is not need check. */
    if( ( *usLen == MB_PDU_SIZE_MIN + MB_PDU_FUNC_WRITE_MUL_SIZE ) || xMBMasterRequestIsBroadcast() )
    {
		vMBMasterGetPDUSndBuf(&ucMBFrame);
        usRegAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_WRITE_MUL_ADDR_OFF] << 8 );
 8011414:	7845      	ldrb	r5, [r0, #1]
        usRegAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_WRITE_MUL_ADDR_OFF + 1] );
 8011416:	7884      	ldrb	r4, [r0, #2]
        usRegAddress++;

        usRegCount = ( USHORT )( ucMBFrame[MB_PDU_REQ_WRITE_MUL_REGCNT_OFF] << 8 );
        usRegCount |= ( USHORT )( ucMBFrame[MB_PDU_REQ_WRITE_MUL_REGCNT_OFF + 1] );
 8011418:	ea43 2202 	orr.w	r2, r3, r2, lsl #8

        ucRegByteCount = ucMBFrame[MB_PDU_REQ_WRITE_MUL_BYTECNT_OFF];

        if( ucRegByteCount == 2 * usRegCount )
 801141c:	ebb1 0f42 	cmp.w	r1, r2, lsl #1
 8011420:	d1ee      	bne.n	8011400 <eMBMasterFuncWriteMultipleHoldingRegister+0x10>
    /* If this request is broadcast, the *usLen is not need check. */
    if( ( *usLen == MB_PDU_SIZE_MIN + MB_PDU_FUNC_WRITE_MUL_SIZE ) || xMBMasterRequestIsBroadcast() )
    {
		vMBMasterGetPDUSndBuf(&ucMBFrame);
        usRegAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_WRITE_MUL_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_WRITE_MUL_ADDR_OFF + 1] );
 8011422:	ea44 2105 	orr.w	r1, r4, r5, lsl #8
        usRegAddress++;
 8011426:	3101      	adds	r1, #1
        ucRegByteCount = ucMBFrame[MB_PDU_REQ_WRITE_MUL_BYTECNT_OFF];

        if( ucRegByteCount == 2 * usRegCount )
        {
            /* Make callback to update the register values. */
            eRegStatus =
 8011428:	b289      	uxth	r1, r1
 801142a:	3006      	adds	r0, #6
 801142c:	2301      	movs	r3, #1
 801142e:	f000 feef 	bl	8012210 <eMBMasterRegHoldingCB>
                eMBMasterRegHoldingCB( &ucMBFrame[MB_PDU_REQ_WRITE_MUL_VALUES_OFF],
                                 usRegAddress, usRegCount, MB_REG_WRITE );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
 8011432:	b900      	cbnz	r0, 8011436 <eMBMasterFuncWriteMultipleHoldingRegister+0x46>
 8011434:	e7e5      	b.n	8011402 <eMBMasterFuncWriteMultipleHoldingRegister+0x12>
            {
                eStatus = prveMBError2Exception( eRegStatus );
 8011436:	f000 fa0b 	bl	8011850 <prveMBError2Exception>
 801143a:	e7e2      	b.n	8011402 <eMBMasterFuncWriteMultipleHoldingRegister+0x12>
 801143c:	f3af 8000 	nop.w

08011440 <eMBMasterReqReadHoldingRegister>:
 *
 * @return error code
 */
eMBMasterReqErrCode
eMBMasterReqReadHoldingRegister( UCHAR ucSndAddr, USHORT usRegAddr, USHORT usNRegs, LONG lTimeOut )
{
 8011440:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011444:	4607      	mov	r7, r0
 8011446:	b08d      	sub	sp, #52	; 0x34
    UCHAR                 *ucMBFrame;
    eMBMasterReqErrCode    eErrStatus = MB_MRE_NO_ERR;
	
	chprintf((BaseSequentialStream *)&itm_port, "Resource Taken %s\n", xMBMasterRunResTake( lTimeOut ) ? "true" : "false");
 8011448:	4618      	mov	r0, r3
 *
 * @return error code
 */
eMBMasterReqErrCode
eMBMasterReqReadHoldingRegister( UCHAR ucSndAddr, USHORT usRegAddr, USHORT usNRegs, LONG lTimeOut )
{
 801144a:	4689      	mov	r9, r1
 801144c:	4690      	mov	r8, r2
 801144e:	469b      	mov	fp, r3
    UCHAR                 *ucMBFrame;
    eMBMasterReqErrCode    eErrStatus = MB_MRE_NO_ERR;
	
	chprintf((BaseSequentialStream *)&itm_port, "Resource Taken %s\n", xMBMasterRunResTake( lTimeOut ) ? "true" : "false");
 8011450:	f001 f816 	bl	8012480 <xMBMasterRunResTake>
 8011454:	4b32      	ldr	r3, [pc, #200]	; (8011520 <eMBMasterReqReadHoldingRegister+0xe0>)
 8011456:	4a33      	ldr	r2, [pc, #204]	; (8011524 <eMBMasterReqReadHoldingRegister+0xe4>)
 8011458:	4933      	ldr	r1, [pc, #204]	; (8011528 <eMBMasterReqReadHoldingRegister+0xe8>)
	
	populate(&list_RTC, (DeviceElement){ucSndAddr, "RTC", CONNECTIONLESS, nReqTimeOut, nReqs++, 3, usRegAddr, usNRegs, 0, 0});
 801145a:	4d34      	ldr	r5, [pc, #208]	; (801152c <eMBMasterReqReadHoldingRegister+0xec>)
 801145c:	4e34      	ldr	r6, [pc, #208]	; (8011530 <eMBMasterReqReadHoldingRegister+0xf0>)
eMBMasterReqReadHoldingRegister( UCHAR ucSndAddr, USHORT usRegAddr, USHORT usNRegs, LONG lTimeOut )
{
    UCHAR                 *ucMBFrame;
    eMBMasterReqErrCode    eErrStatus = MB_MRE_NO_ERR;
	
	chprintf((BaseSequentialStream *)&itm_port, "Resource Taken %s\n", xMBMasterRunResTake( lTimeOut ) ? "true" : "false");
 801145e:	2800      	cmp	r0, #0
 8011460:	bf18      	it	ne
 8011462:	461a      	movne	r2, r3
 8011464:	4833      	ldr	r0, [pc, #204]	; (8011534 <eMBMasterReqReadHoldingRegister+0xf4>)
 8011466:	f7ff ff93 	bl	8011390 <chprintf.constprop.0>
	
	populate(&list_RTC, (DeviceElement){ucSndAddr, "RTC", CONNECTIONLESS, nReqTimeOut, nReqs++, 3, usRegAddr, usNRegs, 0, 0});
 801146a:	f8df e0d0 	ldr.w	lr, [pc, #208]	; 801153c <eMBMasterReqReadHoldingRegister+0xfc>
 801146e:	f8ad 9028 	strh.w	r9, [sp, #40]	; 0x28
 8011472:	f8be 3000 	ldrh.w	r3, [lr]
 8011476:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
 801147a:	2400      	movs	r4, #0
 801147c:	f04f 0a03 	mov.w	sl, #3
 8011480:	f8ad 802a 	strh.w	r8, [sp, #42]	; 0x2a
 8011484:	f88d a026 	strb.w	sl, [sp, #38]	; 0x26
 8011488:	f88d 402c 	strb.w	r4, [sp, #44]	; 0x2c
 801148c:	f88d 402d 	strb.w	r4, [sp, #45]	; 0x2d
 8011490:	aa0c      	add	r2, sp, #48	; 0x30
 8011492:	e912 0007 	ldmdb	r2, {r0, r1, r2}
 8011496:	f8b5 c000 	ldrh.w	ip, [r5]
 801149a:	9607      	str	r6, [sp, #28]
 801149c:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 80114a0:	2501      	movs	r5, #1
 80114a2:	f88d 5020 	strb.w	r5, [sp, #32]
 80114a6:	f88d 7018 	strb.w	r7, [sp, #24]
 80114aa:	f8ad c022 	strh.w	ip, [sp, #34]	; 0x22
 80114ae:	195d      	adds	r5, r3, r5
 80114b0:	ae06      	add	r6, sp, #24
 80114b2:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
 80114b6:	4820      	ldr	r0, [pc, #128]	; (8011538 <eMBMasterReqReadHoldingRegister+0xf8>)
 80114b8:	f8ae 5000 	strh.w	r5, [lr]
 80114bc:	f002 f820 	bl	8013500 <populate>

    if ( ucSndAddr > MB_MASTER_TOTAL_SLAVE_NUM ) eErrStatus = MB_MRE_ILL_ARG;
 80114c0:	2f10      	cmp	r7, #16
 80114c2:	d903      	bls.n	80114cc <eMBMasterReqReadHoldingRegister+0x8c>
 80114c4:	2002      	movs	r0, #2
		( void ) xMBMasterPortEventPost( EV_MASTER_FRAME_SENT );
		xMBMasterRunResLock();
		//eErrStatus = eMBMasterWaitRequestFinish( );
    }
    return eErrStatus;
}
 80114c6:	b00d      	add	sp, #52	; 0x34
 80114c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	chprintf((BaseSequentialStream *)&itm_port, "Resource Taken %s\n", xMBMasterRunResTake( lTimeOut ) ? "true" : "false");
	
	populate(&list_RTC, (DeviceElement){ucSndAddr, "RTC", CONNECTIONLESS, nReqTimeOut, nReqs++, 3, usRegAddr, usNRegs, 0, 0});

    if ( ucSndAddr > MB_MASTER_TOTAL_SLAVE_NUM ) eErrStatus = MB_MRE_ILL_ARG;
    else if ( xMBMasterRunResTake( lTimeOut ) == FALSE ) eErrStatus = MB_MRE_MASTER_BUSY;
 80114cc:	4658      	mov	r0, fp
 80114ce:	f000 ffd7 	bl	8012480 <xMBMasterRunResTake>
 80114d2:	b918      	cbnz	r0, 80114dc <eMBMasterReqReadHoldingRegister+0x9c>
 80114d4:	2005      	movs	r0, #5
		( void ) xMBMasterPortEventPost( EV_MASTER_FRAME_SENT );
		xMBMasterRunResLock();
		//eErrStatus = eMBMasterWaitRequestFinish( );
    }
    return eErrStatus;
}
 80114d6:	b00d      	add	sp, #52	; 0x34
 80114d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

    if ( ucSndAddr > MB_MASTER_TOTAL_SLAVE_NUM ) eErrStatus = MB_MRE_ILL_ARG;
    else if ( xMBMasterRunResTake( lTimeOut ) == FALSE ) eErrStatus = MB_MRE_MASTER_BUSY;
    else
    {
		vMBMasterGetPDUSndBuf(&ucMBFrame);
 80114dc:	a805      	add	r0, sp, #20
 80114de:	f000 fbe7 	bl	8011cb0 <vMBMasterGetPDUSndBuf>
		vMBMasterSetDestAddress(ucSndAddr);
 80114e2:	4638      	mov	r0, r7
 80114e4:	f000 fdc4 	bl	8012070 <vMBMasterSetDestAddress>
		ucMBFrame[MB_PDU_FUNC_OFF]                = MB_FUNC_READ_HOLDING_REGISTER;
 80114e8:	9b05      	ldr	r3, [sp, #20]
 80114ea:	f883 a000 	strb.w	sl, [r3]
		ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF]       = usRegAddr >> 8;
 80114ee:	9b05      	ldr	r3, [sp, #20]
 80114f0:	ea4f 2219 	mov.w	r2, r9, lsr #8
 80114f4:	705a      	strb	r2, [r3, #1]
		ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF + 1]   = usRegAddr;
 80114f6:	9b05      	ldr	r3, [sp, #20]
 80114f8:	f883 9002 	strb.w	r9, [r3, #2]
		ucMBFrame[MB_PDU_REQ_READ_REGCNT_OFF]     = usNRegs >> 8;
 80114fc:	9b05      	ldr	r3, [sp, #20]
 80114fe:	ea4f 2218 	mov.w	r2, r8, lsr #8
 8011502:	70da      	strb	r2, [r3, #3]
		ucMBFrame[MB_PDU_REQ_READ_REGCNT_OFF + 1] = usNRegs;
 8011504:	9b05      	ldr	r3, [sp, #20]
		vMBMasterSetPDUSndLength( MB_PDU_SIZE_MIN + MB_PDU_REQ_READ_SIZE );
 8011506:	2005      	movs	r0, #5
		vMBMasterSetDestAddress(ucSndAddr);
		ucMBFrame[MB_PDU_FUNC_OFF]                = MB_FUNC_READ_HOLDING_REGISTER;
		ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF]       = usRegAddr >> 8;
		ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF + 1]   = usRegAddr;
		ucMBFrame[MB_PDU_REQ_READ_REGCNT_OFF]     = usNRegs >> 8;
		ucMBFrame[MB_PDU_REQ_READ_REGCNT_OFF + 1] = usNRegs;
 8011508:	f883 8004 	strb.w	r8, [r3, #4]
		vMBMasterSetPDUSndLength( MB_PDU_SIZE_MIN + MB_PDU_REQ_READ_SIZE );
 801150c:	f000 fbd8 	bl	8011cc0 <vMBMasterSetPDUSndLength>
		( void ) xMBMasterPortEventPost( EV_MASTER_FRAME_SENT );
 8011510:	2008      	movs	r0, #8
 8011512:	f000 ff8d 	bl	8012430 <xMBMasterPortEventPost>
		xMBMasterRunResLock();
 8011516:	f000 ffbb 	bl	8012490 <xMBMasterRunResLock>
 */
eMBMasterReqErrCode
eMBMasterReqReadHoldingRegister( UCHAR ucSndAddr, USHORT usRegAddr, USHORT usNRegs, LONG lTimeOut )
{
    UCHAR                 *ucMBFrame;
    eMBMasterReqErrCode    eErrStatus = MB_MRE_NO_ERR;
 801151a:	4620      	mov	r0, r4
 801151c:	e7d3      	b.n	80114c6 <eMBMasterReqReadHoldingRegister+0x86>
 801151e:	bf00      	nop
 8011520:	08019154 	.word	0x08019154
 8011524:	0801915c 	.word	0x0801915c
 8011528:	08019140 	.word	0x08019140
 801152c:	2000cbd8 	.word	0x2000cbd8
 8011530:	08019164 	.word	0x08019164
 8011534:	200180c8 	.word	0x200180c8
 8011538:	20018420 	.word	0x20018420
 801153c:	2000cbd6 	.word	0x2000cbd6

08011540 <eMBMasterFuncReadHoldingRegister>:
    return eErrStatus;
}

eMBException
eMBMasterFuncReadHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
 8011540:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011544:	b099      	sub	sp, #100	; 0x64
 8011546:	4605      	mov	r5, r0
 8011548:	460c      	mov	r4, r1

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    /* If this request is broadcast, and it's read mode. This request don't need execute. */
    if ( xMBMasterRequestIsBroadcast() )
 801154a:	f000 fbd1 	bl	8011cf0 <xMBMasterRequestIsBroadcast>
 801154e:	4606      	mov	r6, r0
 8011550:	2800      	cmp	r0, #0
 8011552:	d145      	bne.n	80115e0 <eMBMasterFuncReadHoldingRegister+0xa0>
    {
    	eStatus = MB_EX_NONE;
    }
    else if( *usLen >= MB_PDU_SIZE_MIN + MB_PDU_FUNC_READ_SIZE_MIN )
 8011554:	8822      	ldrh	r2, [r4, #0]
 8011556:	2a01      	cmp	r2, #1
 8011558:	d804      	bhi.n	8011564 <eMBMasterFuncReadHoldingRegister+0x24>
        }
    }
    else
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 801155a:	2403      	movs	r4, #3
    }
    return eStatus;
}
 801155c:	4620      	mov	r0, r4
 801155e:	b019      	add	sp, #100	; 0x64
 8011560:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    {
    	eStatus = MB_EX_NONE;
    }
    else if( *usLen >= MB_PDU_SIZE_MIN + MB_PDU_FUNC_READ_SIZE_MIN )
    {
		vMBMasterGetPDUSndBuf(&ucMBFrame);
 8011564:	a805      	add	r0, sp, #20
 8011566:	f000 fba3 	bl	8011cb0 <vMBMasterGetPDUSndBuf>
        usRegAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF] << 8 );
 801156a:	9905      	ldr	r1, [sp, #20]
 801156c:	784b      	ldrb	r3, [r1, #1]
        usRegAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF + 1] );
 801156e:	788a      	ldrb	r2, [r1, #2]
        usRegAddress++;

        usRegCount = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_REGCNT_OFF] << 8 );
 8011570:	78c8      	ldrb	r0, [r1, #3]
        usRegCount |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_REGCNT_OFF + 1] );
 8011572:	7909      	ldrb	r1, [r1, #4]
    }
    else if( *usLen >= MB_PDU_SIZE_MIN + MB_PDU_FUNC_READ_SIZE_MIN )
    {
		vMBMasterGetPDUSndBuf(&ucMBFrame);
        usRegAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF + 1] );
 8011574:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
        usRegAddress++;
 8011578:	3201      	adds	r2, #1
        usRegCount |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_REGCNT_OFF + 1] );

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception.
         */
        if( ( usRegCount >= 1 ) && ( 2 * usRegCount == pucFrame[MB_PDU_FUNC_READ_BYTECNT_OFF] ) )
 801157a:	ea51 2800 	orrs.w	r8, r1, r0, lsl #8
    else if( *usLen >= MB_PDU_SIZE_MIN + MB_PDU_FUNC_READ_SIZE_MIN )
    {
		vMBMasterGetPDUSndBuf(&ucMBFrame);
        usRegAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF + 1] );
        usRegAddress++;
 801157e:	b297      	uxth	r7, r2
        usRegCount |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_REGCNT_OFF + 1] );

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception.
         */
        if( ( usRegCount >= 1 ) && ( 2 * usRegCount == pucFrame[MB_PDU_FUNC_READ_BYTECNT_OFF] ) )
 8011580:	d003      	beq.n	801158a <eMBMasterFuncReadHoldingRegister+0x4a>
 8011582:	786b      	ldrb	r3, [r5, #1]
 8011584:	ebb3 0f48 	cmp.w	r3, r8, lsl #1
 8011588:	d02f      	beq.n	80115ea <eMBMasterFuncReadHoldingRegister+0xaa>
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
			populate(&list_RTC, (DeviceElement){(uint32_t)ucMBMasterGetDestAddress(), "RTC(IDV)", CONNECTIONLESS, nReqTimeOut, nReqs, 3, usRegAddress, usRegCount, 0, 0});
 801158a:	f000 fd69 	bl	8012060 <ucMBMasterGetDestAddress>
 801158e:	4b4d      	ldr	r3, [pc, #308]	; (80116c4 <eMBMasterFuncReadHoldingRegister+0x184>)
 8011590:	f8ad 7058 	strh.w	r7, [sp, #88]	; 0x58
 8011594:	881a      	ldrh	r2, [r3, #0]
 8011596:	f8ad 805a 	strh.w	r8, [sp, #90]	; 0x5a
 801159a:	2300      	movs	r3, #0
 801159c:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
 80115a0:	f88d 305d 	strb.w	r3, [sp, #93]	; 0x5d
 80115a4:	4b48      	ldr	r3, [pc, #288]	; (80116c8 <eMBMasterFuncReadHoldingRegister+0x188>)
 80115a6:	f8ad 2054 	strh.w	r2, [sp, #84]	; 0x54
 80115aa:	881b      	ldrh	r3, [r3, #0]
 80115ac:	f8ad 3052 	strh.w	r3, [sp, #82]	; 0x52
 80115b0:	2403      	movs	r4, #3
 80115b2:	f88d 4056 	strb.w	r4, [sp, #86]	; 0x56
 80115b6:	ab18      	add	r3, sp, #96	; 0x60
 80115b8:	f88d 0048 	strb.w	r0, [sp, #72]	; 0x48
 80115bc:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 80115c0:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 80115c4:	4d41      	ldr	r5, [pc, #260]	; (80116cc <eMBMasterFuncReadHoldingRegister+0x18c>)
 80115c6:	9513      	str	r5, [sp, #76]	; 0x4c
 80115c8:	2301      	movs	r3, #1
 80115ca:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
 80115ce:	ab12      	add	r3, sp, #72	; 0x48
 80115d0:	cb0e      	ldmia	r3, {r1, r2, r3}
 80115d2:	483f      	ldr	r0, [pc, #252]	; (80116d0 <eMBMasterFuncReadHoldingRegister+0x190>)
 80115d4:	f001 ff94 	bl	8013500 <populate>
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
 80115d8:	4620      	mov	r0, r4
 80115da:	b019      	add	sp, #100	; 0x64
 80115dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    eMBErrorCode    eRegStatus;

    /* If this request is broadcast, and it's read mode. This request don't need execute. */
    if ( xMBMasterRequestIsBroadcast() )
    {
    	eStatus = MB_EX_NONE;
 80115e0:	2400      	movs	r4, #0
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
 80115e2:	4620      	mov	r0, r4
 80115e4:	b019      	add	sp, #100	; 0x64
 80115e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
         * return Modbus illegal data value exception.
         */
        if( ( usRegCount >= 1 ) && ( 2 * usRegCount == pucFrame[MB_PDU_FUNC_READ_BYTECNT_OFF] ) )
        {
            /* Make callback to fill the buffer. */
            eRegStatus = eMBMasterRegHoldingCB( &pucFrame[MB_PDU_FUNC_READ_VALUES_OFF], usRegAddress, usRegCount, MB_REG_READ );
 80115ea:	4633      	mov	r3, r6
 80115ec:	4639      	mov	r1, r7
 80115ee:	4642      	mov	r2, r8
 80115f0:	1ca8      	adds	r0, r5, #2
 80115f2:	f000 fe0d 	bl	8012210 <eMBMasterRegHoldingCB>
 80115f6:	4604      	mov	r4, r0
			if(eMBMasterGetErrorType() == EV_ERROR_RESPOND_TIMEOUT) nReqTimeOut++;
 80115f8:	f000 fd42 	bl	8012080 <eMBMasterGetErrorType>
 80115fc:	f8df b0c8 	ldr.w	fp, [pc, #200]	; 80116c8 <eMBMasterFuncReadHoldingRegister+0x188>
			vMBMasterSetErrorType(EV_NO_ERROR);
			populate(&list_RTC, (DeviceElement){(uint32_t)ucMBMasterGetDestAddress(), "RTC", CONNECTED, nReqTimeOut, nReqs, 3, usRegAddress, usRegCount, 0, 0});
 8011600:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 80116c4 <eMBMasterFuncReadHoldingRegister+0x184>
 8011604:	f8df a0c0 	ldr.w	sl, [pc, #192]	; 80116c8 <eMBMasterFuncReadHoldingRegister+0x188>
         */
        if( ( usRegCount >= 1 ) && ( 2 * usRegCount == pucFrame[MB_PDU_FUNC_READ_BYTECNT_OFF] ) )
        {
            /* Make callback to fill the buffer. */
            eRegStatus = eMBMasterRegHoldingCB( &pucFrame[MB_PDU_FUNC_READ_VALUES_OFF], usRegAddress, usRegCount, MB_REG_READ );
			if(eMBMasterGetErrorType() == EV_ERROR_RESPOND_TIMEOUT) nReqTimeOut++;
 8011608:	2801      	cmp	r0, #1
 801160a:	bf08      	it	eq
 801160c:	f8bb 3000 	ldrheq.w	r3, [fp]
			vMBMasterSetErrorType(EV_NO_ERROR);
 8011610:	f04f 0000 	mov.w	r0, #0
         */
        if( ( usRegCount >= 1 ) && ( 2 * usRegCount == pucFrame[MB_PDU_FUNC_READ_BYTECNT_OFF] ) )
        {
            /* Make callback to fill the buffer. */
            eRegStatus = eMBMasterRegHoldingCB( &pucFrame[MB_PDU_FUNC_READ_VALUES_OFF], usRegAddress, usRegCount, MB_REG_READ );
			if(eMBMasterGetErrorType() == EV_ERROR_RESPOND_TIMEOUT) nReqTimeOut++;
 8011614:	bf04      	itt	eq
 8011616:	3301      	addeq	r3, #1
 8011618:	f8ab 3000 	strheq.w	r3, [fp]
			vMBMasterSetErrorType(EV_NO_ERROR);
 801161c:	f000 fd38 	bl	8012090 <vMBMasterSetErrorType>
			populate(&list_RTC, (DeviceElement){(uint32_t)ucMBMasterGetDestAddress(), "RTC", CONNECTED, nReqTimeOut, nReqs, 3, usRegAddress, usRegCount, 0, 0});
 8011620:	f000 fd1e 	bl	8012060 <ucMBMasterGetDestAddress>
 8011624:	2500      	movs	r5, #0
 8011626:	f8b9 3000 	ldrh.w	r3, [r9]
 801162a:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
 801162e:	2603      	movs	r6, #3
 8011630:	ab09      	add	r3, sp, #36	; 0x24
 8011632:	f8ad 7028 	strh.w	r7, [sp, #40]	; 0x28
 8011636:	f8ad 802a 	strh.w	r8, [sp, #42]	; 0x2a
 801163a:	f88d 502c 	strb.w	r5, [sp, #44]	; 0x2c
 801163e:	f88d 502d 	strb.w	r5, [sp, #45]	; 0x2d
 8011642:	f88d 6026 	strb.w	r6, [sp, #38]	; 0x26
 8011646:	f88d 0018 	strb.w	r0, [sp, #24]
 801164a:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 801164e:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 8011652:	4b20      	ldr	r3, [pc, #128]	; (80116d4 <eMBMasterFuncReadHoldingRegister+0x194>)
 8011654:	f8bb e000 	ldrh.w	lr, [fp]
 8011658:	9307      	str	r3, [sp, #28]
 801165a:	f8ad e022 	strh.w	lr, [sp, #34]	; 0x22
 801165e:	f88d 5020 	strb.w	r5, [sp, #32]
 8011662:	ab06      	add	r3, sp, #24
 8011664:	cb0e      	ldmia	r3, {r1, r2, r3}
 8011666:	481a      	ldr	r0, [pc, #104]	; (80116d0 <eMBMasterFuncReadHoldingRegister+0x190>)
 8011668:	f001 ff4a 	bl	8013500 <populate>
            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
 801166c:	2c00      	cmp	r4, #0
 801166e:	d0b7      	beq.n	80115e0 <eMBMasterFuncReadHoldingRegister+0xa0>
            {
                eStatus = prveMBError2Exception( eRegStatus );
 8011670:	4620      	mov	r0, r4
 8011672:	f000 f8ed 	bl	8011850 <prveMBError2Exception>
 8011676:	4604      	mov	r4, r0
				populate(&list_RTC, (DeviceElement){(uint32_t)ucMBMasterGetDestAddress(), "RTC(E)", CONNECTIONLESS, nReqTimeOut, nReqs, 3, usRegAddress, usRegCount, 0, 0});
 8011678:	f000 fcf2 	bl	8012060 <ucMBMasterGetDestAddress>
 801167c:	f8b9 3000 	ldrh.w	r3, [r9]
 8011680:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
 8011684:	f88d 5044 	strb.w	r5, [sp, #68]	; 0x44
 8011688:	f88d 5045 	strb.w	r5, [sp, #69]	; 0x45
 801168c:	f88d 603e 	strb.w	r6, [sp, #62]	; 0x3e
 8011690:	f8ad 7040 	strh.w	r7, [sp, #64]	; 0x40
 8011694:	f8ad 8042 	strh.w	r8, [sp, #66]	; 0x42
 8011698:	ab0f      	add	r3, sp, #60	; 0x3c
 801169a:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
 801169e:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80116a2:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 80116a6:	f8ba 3000 	ldrh.w	r3, [sl]
 80116aa:	f8ad 303a 	strh.w	r3, [sp, #58]	; 0x3a
 80116ae:	4d0a      	ldr	r5, [pc, #40]	; (80116d8 <eMBMasterFuncReadHoldingRegister+0x198>)
 80116b0:	950d      	str	r5, [sp, #52]	; 0x34
 80116b2:	2301      	movs	r3, #1
 80116b4:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
 80116b8:	ab0c      	add	r3, sp, #48	; 0x30
 80116ba:	cb0e      	ldmia	r3, {r1, r2, r3}
 80116bc:	4804      	ldr	r0, [pc, #16]	; (80116d0 <eMBMasterFuncReadHoldingRegister+0x190>)
 80116be:	f001 ff1f 	bl	8013500 <populate>
 80116c2:	e74b      	b.n	801155c <eMBMasterFuncReadHoldingRegister+0x1c>
 80116c4:	2000cbd6 	.word	0x2000cbd6
 80116c8:	2000cbd8 	.word	0x2000cbd8
 80116cc:	08019170 	.word	0x08019170
 80116d0:	20018420 	.word	0x20018420
 80116d4:	08019164 	.word	0x08019164
 80116d8:	08019168 	.word	0x08019168
 80116dc:	f3af 8000 	nop.w

080116e0 <eMBMasterFuncReadWriteMultipleHoldingRegister>:
    return eErrStatus;
}

eMBException
eMBMasterFuncReadWriteMultipleHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
 80116e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80116e4:	b082      	sub	sp, #8
 80116e6:	4605      	mov	r5, r0
 80116e8:	460c      	mov	r4, r1

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    /* If this request is broadcast, and it's read mode. This request don't need execute. */
    if ( xMBMasterRequestIsBroadcast() )
 80116ea:	f000 fb01 	bl	8011cf0 <xMBMasterRequestIsBroadcast>
 80116ee:	2800      	cmp	r0, #0
 80116f0:	d134      	bne.n	801175c <eMBMasterFuncReadWriteMultipleHoldingRegister+0x7c>
    {
    	eStatus = MB_EX_NONE;
    }
    else if( *usLen >= MB_PDU_SIZE_MIN + MB_PDU_FUNC_READWRITE_SIZE_MIN )
 80116f2:	8823      	ldrh	r3, [r4, #0]
 80116f4:	2b01      	cmp	r3, #1
 80116f6:	d931      	bls.n	801175c <eMBMasterFuncReadWriteMultipleHoldingRegister+0x7c>
    {
    	vMBMasterGetPDUSndBuf(&ucMBFrame);
 80116f8:	a801      	add	r0, sp, #4
 80116fa:	f000 fad9 	bl	8011cb0 <vMBMasterGetPDUSndBuf>
        usRegReadAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_READ_ADDR_OFF] << 8U );
 80116fe:	9801      	ldr	r0, [sp, #4]
        usRegWriteAddress++;

        usRegWriteCount = ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_WRITE_REGCNT_OFF] << 8U );
        usRegWriteCount |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_WRITE_REGCNT_OFF + 1] );

        if( ( 2 * usRegReadCount ) == pucFrame[MB_PDU_FUNC_READWRITE_READ_BYTECNT_OFF] )
 8011700:	786b      	ldrb	r3, [r5, #1]
    	vMBMasterGetPDUSndBuf(&ucMBFrame);
        usRegReadAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_READ_ADDR_OFF] << 8U );
        usRegReadAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_READ_ADDR_OFF + 1] );
        usRegReadAddress++;

        usRegReadCount = ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_READ_REGCNT_OFF] << 8U );
 8011702:	78c4      	ldrb	r4, [r0, #3]
        usRegReadCount |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_READ_REGCNT_OFF + 1] );
 8011704:	7901      	ldrb	r1, [r0, #4]
    	eStatus = MB_EX_NONE;
    }
    else if( *usLen >= MB_PDU_SIZE_MIN + MB_PDU_FUNC_READWRITE_SIZE_MIN )
    {
    	vMBMasterGetPDUSndBuf(&ucMBFrame);
        usRegReadAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_READ_ADDR_OFF] << 8U );
 8011706:	f890 8001 	ldrb.w	r8, [r0, #1]
        usRegReadAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_READ_ADDR_OFF + 1] );
 801170a:	7887      	ldrb	r7, [r0, #2]
        usRegReadAddress++;

        usRegReadCount = ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_READ_REGCNT_OFF] << 8U );
        usRegReadCount |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_READ_REGCNT_OFF + 1] );

        usRegWriteAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_WRITE_ADDR_OFF] << 8U );
 801170c:	f890 c005 	ldrb.w	ip, [r0, #5]
        usRegWriteAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_WRITE_ADDR_OFF + 1] );
 8011710:	7986      	ldrb	r6, [r0, #6]
        usRegWriteAddress++;

        usRegWriteCount = ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_WRITE_REGCNT_OFF] << 8U );
 8011712:	f890 e007 	ldrb.w	lr, [r0, #7]
        usRegWriteCount |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_WRITE_REGCNT_OFF + 1] );
 8011716:	7a02      	ldrb	r2, [r0, #8]
        usRegReadAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_READ_ADDR_OFF] << 8U );
        usRegReadAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_READ_ADDR_OFF + 1] );
        usRegReadAddress++;

        usRegReadCount = ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_READ_REGCNT_OFF] << 8U );
        usRegReadCount |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_READ_REGCNT_OFF + 1] );
 8011718:	ea41 2404 	orr.w	r4, r1, r4, lsl #8
        usRegWriteAddress++;

        usRegWriteCount = ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_WRITE_REGCNT_OFF] << 8U );
        usRegWriteCount |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_WRITE_REGCNT_OFF + 1] );

        if( ( 2 * usRegReadCount ) == pucFrame[MB_PDU_FUNC_READWRITE_READ_BYTECNT_OFF] )
 801171c:	ebb3 0f44 	cmp.w	r3, r4, lsl #1
                eStatus = prveMBError2Exception( eRegStatus );
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8011720:	bf18      	it	ne
 8011722:	2003      	movne	r0, #3
        usRegWriteAddress++;

        usRegWriteCount = ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_WRITE_REGCNT_OFF] << 8U );
        usRegWriteCount |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_WRITE_REGCNT_OFF + 1] );

        if( ( 2 * usRegReadCount ) == pucFrame[MB_PDU_FUNC_READWRITE_READ_BYTECNT_OFF] )
 8011724:	d11b      	bne.n	801175e <eMBMasterFuncReadWriteMultipleHoldingRegister+0x7e>

        usRegReadCount = ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_READ_REGCNT_OFF] << 8U );
        usRegReadCount |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_READ_REGCNT_OFF + 1] );

        usRegWriteAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_WRITE_ADDR_OFF] << 8U );
        usRegWriteAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_WRITE_ADDR_OFF + 1] );
 8011726:	ea46 210c 	orr.w	r1, r6, ip, lsl #8
        usRegWriteAddress++;
 801172a:	3101      	adds	r1, #1
        usRegWriteCount |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_WRITE_REGCNT_OFF + 1] );

        if( ( 2 * usRegReadCount ) == pucFrame[MB_PDU_FUNC_READWRITE_READ_BYTECNT_OFF] )
        {
            /* Make callback to update the register values. */
            eRegStatus = eMBMasterRegHoldingCB( &ucMBFrame[MB_PDU_REQ_READWRITE_WRITE_VALUES_OFF],
 801172c:	2301      	movs	r3, #1
 801172e:	b289      	uxth	r1, r1
 8011730:	300a      	adds	r0, #10
 8011732:	ea42 220e 	orr.w	r2, r2, lr, lsl #8
 8011736:	f000 fd6b 	bl	8012210 <eMBMasterRegHoldingCB>
                                           usRegWriteAddress, usRegWriteCount, MB_REG_WRITE );

            if( eRegStatus == MB_ENOERR )
 801173a:	4603      	mov	r3, r0
 801173c:	b118      	cbz	r0, 8011746 <eMBMasterFuncReadWriteMultipleHoldingRegister+0x66>
				eRegStatus = eMBMasterRegHoldingCB(&pucFrame[MB_PDU_FUNC_READWRITE_READ_VALUES_OFF],
						                      usRegReadAddress, usRegReadCount, MB_REG_READ);
            }
            if( eRegStatus != MB_ENOERR )
            {
                eStatus = prveMBError2Exception( eRegStatus );
 801173e:	4618      	mov	r0, r3
 8011740:	f000 f886 	bl	8011850 <prveMBError2Exception>
 8011744:	e00b      	b.n	801175e <eMBMasterFuncReadWriteMultipleHoldingRegister+0x7e>
    }
    else if( *usLen >= MB_PDU_SIZE_MIN + MB_PDU_FUNC_READWRITE_SIZE_MIN )
    {
    	vMBMasterGetPDUSndBuf(&ucMBFrame);
        usRegReadAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_READ_ADDR_OFF] << 8U );
        usRegReadAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READWRITE_READ_ADDR_OFF + 1] );
 8011746:	ea47 2108 	orr.w	r1, r7, r8, lsl #8
        usRegReadAddress++;
 801174a:	3101      	adds	r1, #1
                                           usRegWriteAddress, usRegWriteCount, MB_REG_WRITE );

            if( eRegStatus == MB_ENOERR )
            {
                /* Make the read callback. */
				eRegStatus = eMBMasterRegHoldingCB(&pucFrame[MB_PDU_FUNC_READWRITE_READ_VALUES_OFF],
 801174c:	b289      	uxth	r1, r1
 801174e:	1ca8      	adds	r0, r5, #2
 8011750:	4622      	mov	r2, r4
 8011752:	f000 fd5d 	bl	8012210 <eMBMasterRegHoldingCB>
						                      usRegReadAddress, usRegReadCount, MB_REG_READ);
            }
            if( eRegStatus != MB_ENOERR )
 8011756:	4603      	mov	r3, r0
 8011758:	2800      	cmp	r0, #0
 801175a:	d1f0      	bne.n	801173e <eMBMasterFuncReadWriteMultipleHoldingRegister+0x5e>
    eMBErrorCode    eRegStatus;

    /* If this request is broadcast, and it's read mode. This request don't need execute. */
    if ( xMBMasterRequestIsBroadcast() )
    {
    	eStatus = MB_EX_NONE;
 801175c:	2000      	movs	r0, #0
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
        }
    }
    return eStatus;
}
 801175e:	b002      	add	sp, #8
 8011760:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8011764:	f3af 8000 	nop.w
 8011768:	f3af 8000 	nop.w
 801176c:	f3af 8000 	nop.w

08011770 <eMBMasterFuncReadInputRegister>:
    return eErrStatus;
}

eMBException
eMBMasterFuncReadInputRegister( UCHAR * pucFrame, USHORT * usLen )
{
 8011770:	b530      	push	{r4, r5, lr}
 8011772:	b083      	sub	sp, #12
 8011774:	4605      	mov	r5, r0
 8011776:	460c      	mov	r4, r1

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    /* If this request is broadcast, and it's read mode. This request don't need execute. */
	if ( xMBMasterRequestIsBroadcast() )
 8011778:	f000 faba 	bl	8011cf0 <xMBMasterRequestIsBroadcast>
 801177c:	b9f8      	cbnz	r0, 80117be <eMBMasterFuncReadInputRegister+0x4e>
	{
		eStatus = MB_EX_NONE;
	}
	else if( *usLen >= MB_PDU_SIZE_MIN + MB_PDU_FUNC_READ_SIZE_MIN )
 801177e:	8823      	ldrh	r3, [r4, #0]
 8011780:	2b01      	cmp	r3, #1
 8011782:	d802      	bhi.n	801178a <eMBMasterFuncReadInputRegister+0x1a>
        }
    }
    else
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8011784:	2003      	movs	r0, #3
    }
    return eStatus;
}
 8011786:	b003      	add	sp, #12
 8011788:	bd30      	pop	{r4, r5, pc}
	{
		eStatus = MB_EX_NONE;
	}
	else if( *usLen >= MB_PDU_SIZE_MIN + MB_PDU_FUNC_READ_SIZE_MIN )
    {
		vMBMasterGetPDUSndBuf(&ucMBFrame);
 801178a:	a801      	add	r0, sp, #4
 801178c:	f000 fa90 	bl	8011cb0 <vMBMasterGetPDUSndBuf>
        usRegAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF] << 8 );
 8011790:	9b01      	ldr	r3, [sp, #4]
        usRegAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF + 1] );
        usRegAddress++;

        usRegCount = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_REGCNT_OFF] << 8 );
 8011792:	78d9      	ldrb	r1, [r3, #3]
        usRegCount |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_REGCNT_OFF + 1] );
 8011794:	791a      	ldrb	r2, [r3, #4]
		eStatus = MB_EX_NONE;
	}
	else if( *usLen >= MB_PDU_SIZE_MIN + MB_PDU_FUNC_READ_SIZE_MIN )
    {
		vMBMasterGetPDUSndBuf(&ucMBFrame);
        usRegAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF] << 8 );
 8011796:	7858      	ldrb	r0, [r3, #1]
        usRegAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF + 1] );
 8011798:	789b      	ldrb	r3, [r3, #2]
        usRegCount |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_REGCNT_OFF + 1] );

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception.
         */
        if( ( usRegCount >= 1 ) && ( 2 * usRegCount == pucFrame[MB_PDU_FUNC_READ_BYTECNT_OFF] ) )
 801179a:	ea52 2201 	orrs.w	r2, r2, r1, lsl #8
 801179e:	d0f1      	beq.n	8011784 <eMBMasterFuncReadInputRegister+0x14>
 80117a0:	7869      	ldrb	r1, [r5, #1]
 80117a2:	ebb1 0f42 	cmp.w	r1, r2, lsl #1
 80117a6:	d1ed      	bne.n	8011784 <eMBMasterFuncReadInputRegister+0x14>
	}
	else if( *usLen >= MB_PDU_SIZE_MIN + MB_PDU_FUNC_READ_SIZE_MIN )
    {
		vMBMasterGetPDUSndBuf(&ucMBFrame);
        usRegAddress = ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( ucMBFrame[MB_PDU_REQ_READ_ADDR_OFF + 1] );
 80117a8:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
        usRegAddress++;
 80117ac:	1c59      	adds	r1, r3, #1
         * return Modbus illegal data value exception.
         */
        if( ( usRegCount >= 1 ) && ( 2 * usRegCount == pucFrame[MB_PDU_FUNC_READ_BYTECNT_OFF] ) )
        {
            /* Make callback to fill the buffer. */
            eRegStatus = eMBMasterRegInputCB( &pucFrame[MB_PDU_FUNC_READ_VALUES_OFF], usRegAddress, usRegCount );
 80117ae:	b289      	uxth	r1, r1
 80117b0:	1ca8      	adds	r0, r5, #2
 80117b2:	f000 fcf5 	bl	80121a0 <eMBMasterRegInputCB>
            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
 80117b6:	b110      	cbz	r0, 80117be <eMBMasterFuncReadInputRegister+0x4e>
            {
                eStatus = prveMBError2Exception( eRegStatus );
 80117b8:	f000 f84a 	bl	8011850 <prveMBError2Exception>
 80117bc:	e7e3      	b.n	8011786 <eMBMasterFuncReadInputRegister+0x16>
    eMBErrorCode    eRegStatus;

    /* If this request is broadcast, and it's read mode. This request don't need execute. */
	if ( xMBMasterRequestIsBroadcast() )
	{
		eStatus = MB_EX_NONE;
 80117be:	2000      	movs	r0, #0
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
 80117c0:	b003      	add	sp, #12
 80117c2:	bd30      	pop	{r4, r5, pc}
 80117c4:	f3af 8000 	nop.w
 80117c8:	f3af 8000 	nop.w
 80117cc:	f3af 8000 	nop.w

080117d0 <eMBFuncReportSlaveID>:
    return eStatus;
}

eMBException
eMBFuncReportSlaveID( UCHAR * pucFrame, USHORT * usLen )
{
 80117d0:	b538      	push	{r3, r4, r5, lr}
    memcpy( &pucFrame[MB_PDU_DATA_OFF], &ucMBSlaveID[0], ( size_t )usMBSlaveIDLen );
 80117d2:	4b06      	ldr	r3, [pc, #24]	; (80117ec <eMBFuncReportSlaveID+0x1c>)
 80117d4:	881c      	ldrh	r4, [r3, #0]
    return eStatus;
}

eMBException
eMBFuncReportSlaveID( UCHAR * pucFrame, USHORT * usLen )
{
 80117d6:	460d      	mov	r5, r1
    memcpy( &pucFrame[MB_PDU_DATA_OFF], &ucMBSlaveID[0], ( size_t )usMBSlaveIDLen );
 80117d8:	4622      	mov	r2, r4
 80117da:	4905      	ldr	r1, [pc, #20]	; (80117f0 <eMBFuncReportSlaveID+0x20>)
    *usLen = ( USHORT )( MB_PDU_DATA_OFF + usMBSlaveIDLen );
 80117dc:	3401      	adds	r4, #1
}

eMBException
eMBFuncReportSlaveID( UCHAR * pucFrame, USHORT * usLen )
{
    memcpy( &pucFrame[MB_PDU_DATA_OFF], &ucMBSlaveID[0], ( size_t )usMBSlaveIDLen );
 80117de:	3001      	adds	r0, #1
 80117e0:	f7ef f86e 	bl	80008c0 <memcpy>
    *usLen = ( USHORT )( MB_PDU_DATA_OFF + usMBSlaveIDLen );
 80117e4:	802c      	strh	r4, [r5, #0]
    return MB_EX_NONE;
}
 80117e6:	2000      	movs	r0, #0
 80117e8:	bd38      	pop	{r3, r4, r5, pc}
 80117ea:	bf00      	nop
 80117ec:	2000cbda 	.word	0x2000cbda
 80117f0:	2000cbdc 	.word	0x2000cbdc
 80117f4:	f3af 8000 	nop.w
 80117f8:	f3af 8000 	nop.w
 80117fc:	f3af 8000 	nop.w

08011800 <xMBUtilSetBits>:
    USHORT          usMask;
    USHORT          usByteOffset;
    USHORT          usNPreBits;
    USHORT          usValue = ucValue;

    assert( ucNBits <= 8 );
 8011800:	2a08      	cmp	r2, #8

/* ----------------------- Start implementation -----------------------------*/
void
xMBUtilSetBits( UCHAR * ucByteBuf, USHORT usBitOffset, UCHAR ucNBits,
                UCHAR ucValue )
{
 8011802:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8011804:	4616      	mov	r6, r2
    USHORT          usMask;
    USHORT          usByteOffset;
    USHORT          usNPreBits;
    USHORT          usValue = ucValue;

    assert( ucNBits <= 8 );
 8011806:	d816      	bhi.n	8011836 <xMBUtilSetBits+0x36>
    assert( ( size_t )BITS_UCHAR == sizeof( UCHAR ) * 8 );

    /* Calculate byte offset for first byte containing the bit values starting
     * at usBitOffset. */
    usByteOffset = ( USHORT )( ( usBitOffset ) / BITS_UCHAR );
 8011808:	08cc      	lsrs	r4, r1, #3

    /* Move bit field into position over bits to set */
    usValue <<= usNPreBits;

    /* Prepare a mask for setting the new bits. */
    usMask = ( USHORT )( ( 1 << ( USHORT ) ucNBits ) - 1 );
 801180a:	2201      	movs	r2, #1
    usMask <<= usBitOffset - usByteOffset * BITS_UCHAR;

    /* copy bits into temporary storage. */
    usWordBuf = ucByteBuf[usByteOffset];
    usWordBuf |= ucByteBuf[usByteOffset + 1] << BITS_UCHAR;
 801180c:	18a5      	adds	r5, r4, r2

    /* Move bit field into position over bits to set */
    usValue <<= usNPreBits;

    /* Prepare a mask for setting the new bits. */
    usMask = ( USHORT )( ( 1 << ( USHORT ) ucNBits ) - 1 );
 801180e:	40b2      	lsls	r2, r6
    usMask <<= usBitOffset - usByteOffset * BITS_UCHAR;

    /* copy bits into temporary storage. */
    usWordBuf = ucByteBuf[usByteOffset];
    usWordBuf |= ucByteBuf[usByteOffset + 1] << BITS_UCHAR;
 8011810:	5d47      	ldrb	r7, [r0, r5]
 8011812:	5d06      	ldrb	r6, [r0, r4]

    /* Move bit field into position over bits to set */
    usValue <<= usNPreBits;

    /* Prepare a mask for setting the new bits. */
    usMask = ( USHORT )( ( 1 << ( USHORT ) ucNBits ) - 1 );
 8011814:	3a01      	subs	r2, #1
    usMask <<= usBitOffset - usByteOffset * BITS_UCHAR;
 8011816:	eba1 01c4 	sub.w	r1, r1, r4, lsl #3
 801181a:	b292      	uxth	r2, r2
 801181c:	408a      	lsls	r2, r1

    /* copy bits into temporary storage. */
    usWordBuf = ucByteBuf[usByteOffset];
    usWordBuf |= ucByteBuf[usByteOffset + 1] << BITS_UCHAR;
 801181e:	ea46 2607 	orr.w	r6, r6, r7, lsl #8

    /* How many bits precede our bits to set. */
    usNPreBits = ( USHORT )( usBitOffset - usByteOffset * BITS_UCHAR );

    /* Move bit field into position over bits to set */
    usValue <<= usNPreBits;
 8011822:	b289      	uxth	r1, r1
 8011824:	408b      	lsls	r3, r1
    /* copy bits into temporary storage. */
    usWordBuf = ucByteBuf[usByteOffset];
    usWordBuf |= ucByteBuf[usByteOffset + 1] << BITS_UCHAR;

    /* Zero out bit field bits and then or value bits into them. */
    usWordBuf = ( USHORT )( ( usWordBuf & ( ~usMask ) ) | usValue );
 8011826:	ea26 0202 	bic.w	r2, r6, r2
 801182a:	431a      	orrs	r2, r3
 801182c:	b292      	uxth	r2, r2

    /* move bits back into storage */
    ucByteBuf[usByteOffset] = ( UCHAR )( usWordBuf & 0xFF );
    ucByteBuf[usByteOffset + 1] = ( UCHAR )( usWordBuf >> BITS_UCHAR );
 801182e:	0a13      	lsrs	r3, r2, #8

    /* Zero out bit field bits and then or value bits into them. */
    usWordBuf = ( USHORT )( ( usWordBuf & ( ~usMask ) ) | usValue );

    /* move bits back into storage */
    ucByteBuf[usByteOffset] = ( UCHAR )( usWordBuf & 0xFF );
 8011830:	5502      	strb	r2, [r0, r4]
    ucByteBuf[usByteOffset + 1] = ( UCHAR )( usWordBuf >> BITS_UCHAR );
 8011832:	5543      	strb	r3, [r0, r5]
 8011834:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    USHORT          usMask;
    USHORT          usByteOffset;
    USHORT          usNPreBits;
    USHORT          usValue = ucValue;

    assert( ucNBits <= 8 );
 8011836:	4803      	ldr	r0, [pc, #12]	; (8011844 <xMBUtilSetBits+0x44>)
 8011838:	4a03      	ldr	r2, [pc, #12]	; (8011848 <xMBUtilSetBits+0x48>)
 801183a:	4b04      	ldr	r3, [pc, #16]	; (801184c <xMBUtilSetBits+0x4c>)
 801183c:	2138      	movs	r1, #56	; 0x38
 801183e:	f001 ff7f 	bl	8013740 <__assert_func>
 8011842:	bf00      	nop
 8011844:	080191a0 	.word	0x080191a0
 8011848:	08019190 	.word	0x08019190
 801184c:	080191c8 	.word	0x080191c8

08011850 <prveMBError2Exception>:
    return ( UCHAR ) usWordBuf;
}

eMBException
prveMBError2Exception( eMBErrorCode eErrorCode )
{
 8011850:	2807      	cmp	r0, #7
 8011852:	bf9a      	itte	ls
 8011854:	4b01      	ldrls	r3, [pc, #4]	; (801185c <prveMBError2Exception+0xc>)
 8011856:	5c18      	ldrbls	r0, [r3, r0]
 8011858:	2004      	movhi	r0, #4
            eStatus = MB_EX_SLAVE_DEVICE_FAILURE;
            break;
    }

    return eStatus;
}
 801185a:	4770      	bx	lr
 801185c:	08019180 	.word	0x08019180

08011860 <usMBCRC16>:
    0x41, 0x81, 0x80, 0x40
};

USHORT
usMBCRC16( UCHAR * pucFrame, USHORT usLen )
{
 8011860:	b470      	push	{r4, r5, r6}
    UCHAR           ucCRCHi = 0xFF;
    UCHAR           ucCRCLo = 0xFF;
    int             iIndex;

    while( usLen-- )
 8011862:	1e4c      	subs	r4, r1, #1
 8011864:	b2a4      	uxth	r4, r4
 8011866:	b191      	cbz	r1, 801188e <usMBCRC16+0x2e>
 8011868:	22ff      	movs	r2, #255	; 0xff
 801186a:	4e0a      	ldr	r6, [pc, #40]	; (8011894 <usMBCRC16+0x34>)
 801186c:	4d0a      	ldr	r5, [pc, #40]	; (8011898 <usMBCRC16+0x38>)
 801186e:	4404      	add	r4, r0
 8011870:	1e41      	subs	r1, r0, #1
 8011872:	4610      	mov	r0, r2
    {
        iIndex = ucCRCLo ^ *( pucFrame++ );
 8011874:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 8011878:	4053      	eors	r3, r2
{
    UCHAR           ucCRCHi = 0xFF;
    UCHAR           ucCRCLo = 0xFF;
    int             iIndex;

    while( usLen-- )
 801187a:	42a1      	cmp	r1, r4
    {
        iIndex = ucCRCLo ^ *( pucFrame++ );
        ucCRCLo = ( UCHAR )( ucCRCHi ^ aucCRCHi[iIndex] );
 801187c:	5cf2      	ldrb	r2, [r6, r3]
 801187e:	ea82 0200 	eor.w	r2, r2, r0
        ucCRCHi = aucCRCLo[iIndex];
 8011882:	5ce8      	ldrb	r0, [r5, r3]
{
    UCHAR           ucCRCHi = 0xFF;
    UCHAR           ucCRCLo = 0xFF;
    int             iIndex;

    while( usLen-- )
 8011884:	d1f6      	bne.n	8011874 <usMBCRC16+0x14>
 8011886:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
        iIndex = ucCRCLo ^ *( pucFrame++ );
        ucCRCLo = ( UCHAR )( ucCRCHi ^ aucCRCHi[iIndex] );
        ucCRCHi = aucCRCLo[iIndex];
    }
    return ( USHORT )( ucCRCHi << 8 | ucCRCLo );
}
 801188a:	bc70      	pop	{r4, r5, r6}
 801188c:	4770      	bx	lr
{
    UCHAR           ucCRCHi = 0xFF;
    UCHAR           ucCRCLo = 0xFF;
    int             iIndex;

    while( usLen-- )
 801188e:	f64f 70ff 	movw	r0, #65535	; 0xffff
 8011892:	e7fa      	b.n	801188a <usMBCRC16+0x2a>
 8011894:	080192e0 	.word	0x080192e0
 8011898:	080191e0 	.word	0x080191e0
 801189c:	f3af 8000 	nop.w

080118a0 <eMBMasterRTUInit>:
static volatile eMBMasterTimerMode eMasterCurTimerMode;

/* ----------------------- Start implementation -----------------------------*/
eMBErrorCode
eMBMasterRTUInit(UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
{
 80118a0:	b570      	push	{r4, r5, r6, lr}
 80118a2:	4615      	mov	r5, r2
 80118a4:	4606      	mov	r6, r0
 80118a6:	460c      	mov	r4, r1
    eMBErrorCode    eStatus = MB_ENOERR;
    ULONG           usTimerT35_50us;

ENTER_CRITICAL_SECTION(  );
 80118a8:	f000 fdaa 	bl	8012400 <EnterCriticalSection>

    /* Modbus RTU uses 8 Databits. */
    if( xMBMasterPortSerialInit( ucPort, ulBaudRate, 8, eParity ) != TRUE )
 80118ac:	4630      	mov	r0, r6
 80118ae:	4621      	mov	r1, r4
 80118b0:	462b      	mov	r3, r5
 80118b2:	2208      	movs	r2, #8
 80118b4:	f000 fea4 	bl	8012600 <xMBMasterPortSerialInit>
 80118b8:	2801      	cmp	r0, #1
 80118ba:	d004      	beq.n	80118c6 <eMBMasterRTUInit+0x26>
    {
        eStatus = MB_EPORTERR;
 80118bc:	2403      	movs	r4, #3
        if( xMBMasterPortTimersInit( ( USHORT ) usTimerT35_50us ) != TRUE )
        {
            eStatus = MB_EPORTERR;
        }
    }
    EXIT_CRITICAL_SECTION(  );
 80118be:	f000 fda7 	bl	8012410 <ExitCriticalSection>

    return eStatus;
}
 80118c2:	4620      	mov	r0, r4
 80118c4:	bd70      	pop	{r4, r5, r6, pc}
    else
    {
        /* If baudrate > 19200 then we should use the fixed timer values
         * t35 = 1750us. Otherwise t35 must be 3.5 times the character time.
         */
        if( ulBaudRate > 19200 )
 80118c6:	f5b4 4f96 	cmp.w	r4, #19200	; 0x4b00
 80118ca:	d80e      	bhi.n	80118ea <eMBMasterRTUInit+0x4a>
             *             = 11 * Ticks_per_1s / Baudrate
             *             = 220000 / Baudrate
             * The reload for t3.5 is 1.5 times this value and similary
             * for t3.5.
             */
            usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate );
 80118cc:	4808      	ldr	r0, [pc, #32]	; (80118f0 <eMBMasterRTUInit+0x50>)
 80118ce:	0064      	lsls	r4, r4, #1
 80118d0:	fbb0 f4f4 	udiv	r4, r0, r4
 80118d4:	b2a0      	uxth	r0, r4
        }
        if( xMBMasterPortTimersInit( ( USHORT ) usTimerT35_50us ) != TRUE )
 80118d6:	f000 ff13 	bl	8012700 <xMBMasterPortTimersInit>
 80118da:	2801      	cmp	r0, #1
        {
            eStatus = MB_EPORTERR;
 80118dc:	bf0c      	ite	eq
 80118de:	2400      	moveq	r4, #0
 80118e0:	2403      	movne	r4, #3
        }
    }
    EXIT_CRITICAL_SECTION(  );
 80118e2:	f000 fd95 	bl	8012410 <ExitCriticalSection>

    return eStatus;
}
 80118e6:	4620      	mov	r0, r4
 80118e8:	bd70      	pop	{r4, r5, r6, pc}
 80118ea:	2023      	movs	r0, #35	; 0x23
 80118ec:	e7f3      	b.n	80118d6 <eMBMasterRTUInit+0x36>
 80118ee:	bf00      	nop
 80118f0:	00177fa0 	.word	0x00177fa0
 80118f4:	f3af 8000 	nop.w
 80118f8:	f3af 8000 	nop.w
 80118fc:	f3af 8000 	nop.w

08011900 <eMBMasterRTUStart>:

void
eMBMasterRTUStart( void )
{
 8011900:	b508      	push	{r3, lr}
    ENTER_CRITICAL_SECTION(  );
 8011902:	f000 fd7d 	bl	8012400 <EnterCriticalSection>
    /* Initially the receiver is in the state STATE_M_RX_INIT. we start
     * the timer and if no character is received within t3.5 we change
     * to STATE_M_RX_IDLE. This makes sure that we delay startup of the
     * modbus protocol stack until the bus is free.
     */
    eRcvState = STATE_M_RX_INIT;
 8011906:	2300      	movs	r3, #0
 8011908:	4a05      	ldr	r2, [pc, #20]	; (8011920 <eMBMasterRTUStart+0x20>)
    vMBMasterPortSerialEnable( TRUE, FALSE );
 801190a:	4619      	mov	r1, r3
 801190c:	2001      	movs	r0, #1
    /* Initially the receiver is in the state STATE_M_RX_INIT. we start
     * the timer and if no character is received within t3.5 we change
     * to STATE_M_RX_IDLE. This makes sure that we delay startup of the
     * modbus protocol stack until the bus is free.
     */
    eRcvState = STATE_M_RX_INIT;
 801190e:	7013      	strb	r3, [r2, #0]
    vMBMasterPortSerialEnable( TRUE, FALSE );
 8011910:	f000 fe8e 	bl	8012630 <vMBMasterPortSerialEnable>
    vMBMasterPortTimersT35Enable(  );
 8011914:	f000 ff04 	bl	8012720 <vMBMasterPortTimersT35Enable>

    EXIT_CRITICAL_SECTION(  );
}
 8011918:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     */
    eRcvState = STATE_M_RX_INIT;
    vMBMasterPortSerialEnable( TRUE, FALSE );
    vMBMasterPortTimersT35Enable(  );

    EXIT_CRITICAL_SECTION(  );
 801191c:	f000 bd78 	b.w	8012410 <ExitCriticalSection>
 8011920:	2000cd06 	.word	0x2000cd06
 8011924:	f3af 8000 	nop.w
 8011928:	f3af 8000 	nop.w
 801192c:	f3af 8000 	nop.w

08011930 <eMBMasterRTUStop>:
}

void
eMBMasterRTUStop( void )
{
 8011930:	b508      	push	{r3, lr}
    ENTER_CRITICAL_SECTION(  );
 8011932:	f000 fd65 	bl	8012400 <EnterCriticalSection>
    vMBMasterPortSerialEnable( FALSE, FALSE );
 8011936:	2000      	movs	r0, #0
 8011938:	4601      	mov	r1, r0
 801193a:	f000 fe79 	bl	8012630 <vMBMasterPortSerialEnable>
    vMBMasterPortTimersDisable(  );
 801193e:	f000 ff5f 	bl	8012800 <vMBMasterPortTimersDisable>
    EXIT_CRITICAL_SECTION(  );
}
 8011942:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
eMBMasterRTUStop( void )
{
    ENTER_CRITICAL_SECTION(  );
    vMBMasterPortSerialEnable( FALSE, FALSE );
    vMBMasterPortTimersDisable(  );
    EXIT_CRITICAL_SECTION(  );
 8011946:	f000 bd63 	b.w	8012410 <ExitCriticalSection>
 801194a:	bf00      	nop
 801194c:	f3af 8000 	nop.w

08011950 <eMBMasterRTUReceive>:
}

eMBErrorCode
eMBMasterRTUReceive( UCHAR * pucRcvAddress, UCHAR ** pucFrame, USHORT * pusLength )
{
 8011950:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    eMBErrorCode    eStatus = MB_ENOERR;

    ENTER_CRITICAL_SECTION(  );
    assert( usMasterRcvBufferPos < MB_SER_PDU_SIZE_MAX );
 8011954:	4c16      	ldr	r4, [pc, #88]	; (80119b0 <eMBMasterRTUReceive+0x60>)
    EXIT_CRITICAL_SECTION(  );
}

eMBErrorCode
eMBMasterRTUReceive( UCHAR * pucRcvAddress, UCHAR ** pucFrame, USHORT * pusLength )
{
 8011956:	4607      	mov	r7, r0
 8011958:	460d      	mov	r5, r1
 801195a:	4616      	mov	r6, r2
    eMBErrorCode    eStatus = MB_ENOERR;

    ENTER_CRITICAL_SECTION(  );
 801195c:	f000 fd50 	bl	8012400 <EnterCriticalSection>
    assert( usMasterRcvBufferPos < MB_SER_PDU_SIZE_MAX );
 8011960:	8823      	ldrh	r3, [r4, #0]
 8011962:	b29b      	uxth	r3, r3
 8011964:	2bff      	cmp	r3, #255	; 0xff
 8011966:	d81d      	bhi.n	80119a4 <eMBMasterRTUReceive+0x54>

    /* Length and CRC check */
    if( ( usMasterRcvBufferPos >= MB_SER_PDU_SIZE_MIN )
 8011968:	8823      	ldrh	r3, [r4, #0]
 801196a:	b29b      	uxth	r3, r3
 801196c:	2b03      	cmp	r3, #3
 801196e:	d806      	bhi.n	801197e <eMBMasterRTUReceive+0x2e>
        /* Return the start of the Modbus PDU to the caller. */
        *pucFrame = ( UCHAR * ) & ucMasterRTURcvBuf[MB_SER_PDU_PDU_OFF];
    }
    else
    {
        eStatus = MB_EIO;
 8011970:	f04f 0805 	mov.w	r8, #5
    }

    EXIT_CRITICAL_SECTION(  );
 8011974:	f000 fd4c 	bl	8012410 <ExitCriticalSection>
    return eStatus;
}
 8011978:	4640      	mov	r0, r8
 801197a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ENTER_CRITICAL_SECTION(  );
    assert( usMasterRcvBufferPos < MB_SER_PDU_SIZE_MAX );

    /* Length and CRC check */
    if( ( usMasterRcvBufferPos >= MB_SER_PDU_SIZE_MIN )
        && ( usMBCRC16( ( UCHAR * ) ucMasterRTURcvBuf, usMasterRcvBufferPos ) == 0 ) )
 801197e:	8821      	ldrh	r1, [r4, #0]
 8011980:	f8df 803c 	ldr.w	r8, [pc, #60]	; 80119c0 <eMBMasterRTUReceive+0x70>
 8011984:	b289      	uxth	r1, r1
 8011986:	4640      	mov	r0, r8
 8011988:	f7ff ff6a 	bl	8011860 <usMBCRC16>
 801198c:	2800      	cmp	r0, #0
 801198e:	d1ef      	bne.n	8011970 <eMBMasterRTUReceive+0x20>
    {
        /* Save the address field. All frames are passed to the upper layed
         * and the decision if a frame is used is done there.
         */
        *pucRcvAddress = ucMasterRTURcvBuf[MB_SER_PDU_ADDR_OFF];
 8011990:	4643      	mov	r3, r8
}

eMBErrorCode
eMBMasterRTUReceive( UCHAR * pucRcvAddress, UCHAR ** pucFrame, USHORT * pusLength )
{
    eMBErrorCode    eStatus = MB_ENOERR;
 8011992:	4680      	mov	r8, r0
        && ( usMBCRC16( ( UCHAR * ) ucMasterRTURcvBuf, usMasterRcvBufferPos ) == 0 ) )
    {
        /* Save the address field. All frames are passed to the upper layed
         * and the decision if a frame is used is done there.
         */
        *pucRcvAddress = ucMasterRTURcvBuf[MB_SER_PDU_ADDR_OFF];
 8011994:	f813 1b01 	ldrb.w	r1, [r3], #1

        /* Total length of Modbus-PDU is Modbus-Serial-Line-PDU minus
         * size of address field and CRC checksum.
         */
        *pusLength = ( USHORT )( usMasterRcvBufferPos - MB_SER_PDU_PDU_OFF - MB_SER_PDU_SIZE_CRC );
 8011998:	8822      	ldrh	r2, [r4, #0]
        && ( usMBCRC16( ( UCHAR * ) ucMasterRTURcvBuf, usMasterRcvBufferPos ) == 0 ) )
    {
        /* Save the address field. All frames are passed to the upper layed
         * and the decision if a frame is used is done there.
         */
        *pucRcvAddress = ucMasterRTURcvBuf[MB_SER_PDU_ADDR_OFF];
 801199a:	7039      	strb	r1, [r7, #0]

        /* Total length of Modbus-PDU is Modbus-Serial-Line-PDU minus
         * size of address field and CRC checksum.
         */
        *pusLength = ( USHORT )( usMasterRcvBufferPos - MB_SER_PDU_PDU_OFF - MB_SER_PDU_SIZE_CRC );
 801199c:	3a03      	subs	r2, #3
 801199e:	8032      	strh	r2, [r6, #0]

        /* Return the start of the Modbus PDU to the caller. */
        *pucFrame = ( UCHAR * ) & ucMasterRTURcvBuf[MB_SER_PDU_PDU_OFF];
 80119a0:	602b      	str	r3, [r5, #0]
 80119a2:	e7e7      	b.n	8011974 <eMBMasterRTUReceive+0x24>
eMBMasterRTUReceive( UCHAR * pucRcvAddress, UCHAR ** pucFrame, USHORT * pusLength )
{
    eMBErrorCode    eStatus = MB_ENOERR;

    ENTER_CRITICAL_SECTION(  );
    assert( usMasterRcvBufferPos < MB_SER_PDU_SIZE_MAX );
 80119a4:	4803      	ldr	r0, [pc, #12]	; (80119b4 <eMBMasterRTUReceive+0x64>)
 80119a6:	4a04      	ldr	r2, [pc, #16]	; (80119b8 <eMBMasterRTUReceive+0x68>)
 80119a8:	4b04      	ldr	r3, [pc, #16]	; (80119bc <eMBMasterRTUReceive+0x6c>)
 80119aa:	21a4      	movs	r1, #164	; 0xa4
 80119ac:	f001 fec8 	bl	8013740 <__assert_func>
 80119b0:	2000cd00 	.word	0x2000cd00
 80119b4:	08019420 	.word	0x08019420
 80119b8:	080195b0 	.word	0x080195b0
 80119bc:	08019440 	.word	0x08019440
 80119c0:	2000cbfc 	.word	0x2000cbfc
 80119c4:	f3af 8000 	nop.w
 80119c8:	f3af 8000 	nop.w
 80119cc:	f3af 8000 	nop.w

080119d0 <eMBMasterRTUSend>:
eMBMasterRTUSend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
{
    eMBErrorCode    eStatus = MB_ENOERR;
    USHORT          usCRC16;

    if ( ucSlaveAddress > MB_MASTER_TOTAL_SLAVE_NUM ) return MB_EINVAL;
 80119d0:	2810      	cmp	r0, #16
 80119d2:	d901      	bls.n	80119d8 <eMBMasterRTUSend+0x8>
 80119d4:	2002      	movs	r0, #2
 80119d6:	4770      	bx	lr
    return eStatus;
}

eMBErrorCode
eMBMasterRTUSend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
{
 80119d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80119da:	b085      	sub	sp, #20
 80119dc:	9203      	str	r2, [sp, #12]
 80119de:	9102      	str	r1, [sp, #8]
 80119e0:	9001      	str	r0, [sp, #4]
    eMBErrorCode    eStatus = MB_ENOERR;
    USHORT          usCRC16;

    if ( ucSlaveAddress > MB_MASTER_TOTAL_SLAVE_NUM ) return MB_EINVAL;

    ENTER_CRITICAL_SECTION(  );
 80119e2:	f000 fd0d 	bl	8012400 <EnterCriticalSection>

    /* Check if the receiver is still in idle state. If not we where to
     * slow with processing the received frame and the master sent another
     * frame on the network. We have to abort sending the frame.
     */
    if( eRcvState == STATE_M_RX_IDLE )
 80119e6:	4b1c      	ldr	r3, [pc, #112]	; (8011a58 <eMBMasterRTUSend+0x88>)
 80119e8:	781d      	ldrb	r5, [r3, #0]
 80119ea:	b2ed      	uxtb	r5, r5
 80119ec:	a801      	add	r0, sp, #4
 80119ee:	2d01      	cmp	r5, #1
 80119f0:	c807      	ldmia	r0, {r0, r1, r2}
 80119f2:	d005      	beq.n	8011a00 <eMBMasterRTUSend+0x30>
        eSndState = STATE_M_TX_XMIT;
        vMBMasterPortSerialEnable( FALSE, TRUE );
    }
    else
    {
        eStatus = MB_EIO;
 80119f4:	2405      	movs	r4, #5
    }
    EXIT_CRITICAL_SECTION(  );
 80119f6:	f000 fd0b 	bl	8012410 <ExitCriticalSection>
    return eStatus;
 80119fa:	4620      	mov	r0, r4
}
 80119fc:	b005      	add	sp, #20
 80119fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
     */
    if( eRcvState == STATE_M_RX_IDLE )
    {
        /* First byte before the Modbus-PDU is the slave address. */
        pucMasterSndBufferCur = ( UCHAR * ) pucFrame - 1;
        usMasterSndBufferCount = 1;
 8011a00:	4c16      	ldr	r4, [pc, #88]	; (8011a5c <eMBMasterRTUSend+0x8c>)
     * frame on the network. We have to abort sending the frame.
     */
    if( eRcvState == STATE_M_RX_IDLE )
    {
        /* First byte before the Modbus-PDU is the slave address. */
        pucMasterSndBufferCur = ( UCHAR * ) pucFrame - 1;
 8011a02:	4e17      	ldr	r6, [pc, #92]	; (8011a60 <eMBMasterRTUSend+0x90>)
        usMasterSndBufferCount = 1;
 8011a04:	8025      	strh	r5, [r4, #0]

        /* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */
        pucMasterSndBufferCur[MB_SER_PDU_ADDR_OFF] = ucSlaveAddress;
 8011a06:	f801 0c01 	strb.w	r0, [r1, #-1]
        usMasterSndBufferCount += usLength;
 8011a0a:	8823      	ldrh	r3, [r4, #0]

        /* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */
        usCRC16 = usMBCRC16( ( UCHAR * ) pucMasterSndBufferCur, usMasterSndBufferCount );
        ucMasterRTUSndBuf[usMasterSndBufferCount++] = ( UCHAR )( usCRC16 & 0xFF );
 8011a0c:	4f15      	ldr	r7, [pc, #84]	; (8011a64 <eMBMasterRTUSend+0x94>)
        pucMasterSndBufferCur = ( UCHAR * ) pucFrame - 1;
        usMasterSndBufferCount = 1;

        /* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */
        pucMasterSndBufferCur[MB_SER_PDU_ADDR_OFF] = ucSlaveAddress;
        usMasterSndBufferCount += usLength;
 8011a0e:	fa12 f283 	uxtah	r2, r2, r3
 8011a12:	b292      	uxth	r2, r2
 8011a14:	8022      	strh	r2, [r4, #0]

        /* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */
        usCRC16 = usMBCRC16( ( UCHAR * ) pucMasterSndBufferCur, usMasterSndBufferCount );
 8011a16:	8822      	ldrh	r2, [r4, #0]
     * frame on the network. We have to abort sending the frame.
     */
    if( eRcvState == STATE_M_RX_IDLE )
    {
        /* First byte before the Modbus-PDU is the slave address. */
        pucMasterSndBufferCur = ( UCHAR * ) pucFrame - 1;
 8011a18:	1e4b      	subs	r3, r1, #1
        /* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */
        pucMasterSndBufferCur[MB_SER_PDU_ADDR_OFF] = ucSlaveAddress;
        usMasterSndBufferCount += usLength;

        /* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */
        usCRC16 = usMBCRC16( ( UCHAR * ) pucMasterSndBufferCur, usMasterSndBufferCount );
 8011a1a:	4618      	mov	r0, r3
 8011a1c:	b291      	uxth	r1, r2
     * frame on the network. We have to abort sending the frame.
     */
    if( eRcvState == STATE_M_RX_IDLE )
    {
        /* First byte before the Modbus-PDU is the slave address. */
        pucMasterSndBufferCur = ( UCHAR * ) pucFrame - 1;
 8011a1e:	6033      	str	r3, [r6, #0]
        /* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */
        pucMasterSndBufferCur[MB_SER_PDU_ADDR_OFF] = ucSlaveAddress;
        usMasterSndBufferCount += usLength;

        /* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */
        usCRC16 = usMBCRC16( ( UCHAR * ) pucMasterSndBufferCur, usMasterSndBufferCount );
 8011a20:	f7ff ff1e 	bl	8011860 <usMBCRC16>
        ucMasterRTUSndBuf[usMasterSndBufferCount++] = ( UCHAR )( usCRC16 & 0xFF );
 8011a24:	8823      	ldrh	r3, [r4, #0]
        ucMasterRTUSndBuf[usMasterSndBufferCount++] = ( UCHAR )( usCRC16 >> 8 );

        /* Activate the transmitter. */
        eSndState = STATE_M_TX_XMIT;
 8011a26:	f8df e040 	ldr.w	lr, [pc, #64]	; 8011a68 <eMBMasterRTUSend+0x98>
        pucMasterSndBufferCur[MB_SER_PDU_ADDR_OFF] = ucSlaveAddress;
        usMasterSndBufferCount += usLength;

        /* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */
        usCRC16 = usMBCRC16( ( UCHAR * ) pucMasterSndBufferCur, usMasterSndBufferCount );
        ucMasterRTUSndBuf[usMasterSndBufferCount++] = ( UCHAR )( usCRC16 & 0xFF );
 8011a2a:	b29b      	uxth	r3, r3
 8011a2c:	1c5a      	adds	r2, r3, #1
 8011a2e:	b2c1      	uxtb	r1, r0
 8011a30:	b292      	uxth	r2, r2
 8011a32:	8022      	strh	r2, [r4, #0]
 8011a34:	54f9      	strb	r1, [r7, r3]
        ucMasterRTUSndBuf[usMasterSndBufferCount++] = ( UCHAR )( usCRC16 >> 8 );
 8011a36:	8823      	ldrh	r3, [r4, #0]
 8011a38:	b29b      	uxth	r3, r3
 8011a3a:	1c5e      	adds	r6, r3, #1
 8011a3c:	f3c0 2207 	ubfx	r2, r0, #8, #8
 8011a40:	b2b6      	uxth	r6, r6

        /* Activate the transmitter. */
        eSndState = STATE_M_TX_XMIT;
        vMBMasterPortSerialEnable( FALSE, TRUE );
 8011a42:	2000      	movs	r0, #0
 8011a44:	4629      	mov	r1, r5
        usMasterSndBufferCount += usLength;

        /* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */
        usCRC16 = usMBCRC16( ( UCHAR * ) pucMasterSndBufferCur, usMasterSndBufferCount );
        ucMasterRTUSndBuf[usMasterSndBufferCount++] = ( UCHAR )( usCRC16 & 0xFF );
        ucMasterRTUSndBuf[usMasterSndBufferCount++] = ( UCHAR )( usCRC16 >> 8 );
 8011a46:	8026      	strh	r6, [r4, #0]
 8011a48:	54fa      	strb	r2, [r7, r3]
}

eMBErrorCode
eMBMasterRTUSend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
{
    eMBErrorCode    eStatus = MB_ENOERR;
 8011a4a:	4604      	mov	r4, r0
        usCRC16 = usMBCRC16( ( UCHAR * ) pucMasterSndBufferCur, usMasterSndBufferCount );
        ucMasterRTUSndBuf[usMasterSndBufferCount++] = ( UCHAR )( usCRC16 & 0xFF );
        ucMasterRTUSndBuf[usMasterSndBufferCount++] = ( UCHAR )( usCRC16 >> 8 );

        /* Activate the transmitter. */
        eSndState = STATE_M_TX_XMIT;
 8011a4c:	f88e 5000 	strb.w	r5, [lr]
        vMBMasterPortSerialEnable( FALSE, TRUE );
 8011a50:	f000 fdee 	bl	8012630 <vMBMasterPortSerialEnable>
 8011a54:	e7cf      	b.n	80119f6 <eMBMasterRTUSend+0x26>
 8011a56:	bf00      	nop
 8011a58:	2000cd06 	.word	0x2000cd06
 8011a5c:	2000ccfe 	.word	0x2000ccfe
 8011a60:	2000cd08 	.word	0x2000cd08
 8011a64:	2000cd0c 	.word	0x2000cd0c
 8011a68:	2000cd05 	.word	0x2000cd05
 8011a6c:	f3af 8000 	nop.w

08011a70 <xMBMasterRTUReceiveFSM>:
    return eStatus;
}

BOOL
xMBMasterRTUReceiveFSM( void )
{
 8011a70:	b5f0      	push	{r4, r5, r6, r7, lr}
    BOOL            xTaskNeedSwitch = FALSE;
    UCHAR           ucByte;

    assert(( eSndState == STATE_M_TX_IDLE ) || ( eSndState == STATE_M_TX_XFWR ));
 8011a72:	4c22      	ldr	r4, [pc, #136]	; (8011afc <xMBMasterRTUReceiveFSM+0x8c>)
 8011a74:	7823      	ldrb	r3, [r4, #0]
    return eStatus;
}

BOOL
xMBMasterRTUReceiveFSM( void )
{
 8011a76:	b083      	sub	sp, #12
    BOOL            xTaskNeedSwitch = FALSE;
    UCHAR           ucByte;

    assert(( eSndState == STATE_M_TX_IDLE ) || ( eSndState == STATE_M_TX_XFWR ));
 8011a78:	b113      	cbz	r3, 8011a80 <xMBMasterRTUReceiveFSM+0x10>
 8011a7a:	7823      	ldrb	r3, [r4, #0]
 8011a7c:	2b02      	cmp	r3, #2
 8011a7e:	d137      	bne.n	8011af0 <xMBMasterRTUReceiveFSM+0x80>

    /* Always read the character. */
    ( void )xMBMasterPortSerialGetByte( ( CHAR * ) & ucByte );

    switch ( eRcvState )
 8011a80:	4d1f      	ldr	r5, [pc, #124]	; (8011b00 <xMBMasterRTUReceiveFSM+0x90>)
    UCHAR           ucByte;

    assert(( eSndState == STATE_M_TX_IDLE ) || ( eSndState == STATE_M_TX_XFWR ));

    /* Always read the character. */
    ( void )xMBMasterPortSerialGetByte( ( CHAR * ) & ucByte );
 8011a82:	f10d 0007 	add.w	r0, sp, #7
 8011a86:	f000 fe23 	bl	80126d0 <xMBMasterPortSerialGetByte>

    switch ( eRcvState )
 8011a8a:	782b      	ldrb	r3, [r5, #0]
 8011a8c:	2b03      	cmp	r3, #3
 8011a8e:	d813      	bhi.n	8011ab8 <xMBMasterRTUReceiveFSM+0x48>
 8011a90:	e8df f003 	tbb	[pc, r3]
 8011a94:	10021510 	.word	0x10021510
         * every character received. If more than the maximum possible
         * number of bytes in a modbus frame is received the frame is
         * ignored.
         */
    case STATE_M_RX_RCV:
        if( usMasterRcvBufferPos < MB_SER_PDU_SIZE_MAX )
 8011a98:	4a1a      	ldr	r2, [pc, #104]	; (8011b04 <xMBMasterRTUReceiveFSM+0x94>)
 8011a9a:	8813      	ldrh	r3, [r2, #0]
 8011a9c:	b29b      	uxth	r3, r3
 8011a9e:	2bff      	cmp	r3, #255	; 0xff
 8011aa0:	d823      	bhi.n	8011aea <xMBMasterRTUReceiveFSM+0x7a>
        {
            ucMasterRTURcvBuf[usMasterRcvBufferPos++] = ucByte;
 8011aa2:	8813      	ldrh	r3, [r2, #0]
 8011aa4:	4818      	ldr	r0, [pc, #96]	; (8011b08 <xMBMasterRTUReceiveFSM+0x98>)
 8011aa6:	f89d 4007 	ldrb.w	r4, [sp, #7]
 8011aaa:	b29b      	uxth	r3, r3
 8011aac:	1c59      	adds	r1, r3, #1
 8011aae:	b289      	uxth	r1, r1
 8011ab0:	8011      	strh	r1, [r2, #0]
 8011ab2:	54c4      	strb	r4, [r0, r3]
        }
        else
        {
            eRcvState = STATE_M_RX_ERROR;
        }
        vMBMasterPortTimersT35Enable();
 8011ab4:	f000 fe34 	bl	8012720 <vMBMasterPortTimersT35Enable>
        break;
    }
    return xTaskNeedSwitch;
}
 8011ab8:	2000      	movs	r0, #0
 8011aba:	b003      	add	sp, #12
 8011abc:	bdf0      	pop	{r4, r5, r6, r7, pc}
         */
    case STATE_M_RX_IDLE:
    	/* In time of respond timeout,the receiver receive a frame.
    	 * Disable timer of respond timeout and change the transmiter state to idle.
    	 */
    	vMBMasterPortTimersDisable( );
 8011abe:	f000 fe9f 	bl	8012800 <vMBMasterPortTimersDisable>
    	eSndState = STATE_M_TX_IDLE;

        usMasterRcvBufferPos = 0;
 8011ac2:	4a10      	ldr	r2, [pc, #64]	; (8011b04 <xMBMasterRTUReceiveFSM+0x94>)
        ucMasterRTURcvBuf[usMasterRcvBufferPos++] = ucByte;
 8011ac4:	4e10      	ldr	r6, [pc, #64]	; (8011b08 <xMBMasterRTUReceiveFSM+0x98>)
 8011ac6:	f89d 7007 	ldrb.w	r7, [sp, #7]
    case STATE_M_RX_IDLE:
    	/* In time of respond timeout,the receiver receive a frame.
    	 * Disable timer of respond timeout and change the transmiter state to idle.
    	 */
    	vMBMasterPortTimersDisable( );
    	eSndState = STATE_M_TX_IDLE;
 8011aca:	2300      	movs	r3, #0
 8011acc:	7023      	strb	r3, [r4, #0]

        usMasterRcvBufferPos = 0;
 8011ace:	8013      	strh	r3, [r2, #0]
        ucMasterRTURcvBuf[usMasterRcvBufferPos++] = ucByte;
 8011ad0:	8813      	ldrh	r3, [r2, #0]
 8011ad2:	b29b      	uxth	r3, r3
 8011ad4:	1c59      	adds	r1, r3, #1
 8011ad6:	b289      	uxth	r1, r1
        eRcvState = STATE_M_RX_RCV;
 8011ad8:	2002      	movs	r0, #2
    	 */
    	vMBMasterPortTimersDisable( );
    	eSndState = STATE_M_TX_IDLE;

        usMasterRcvBufferPos = 0;
        ucMasterRTURcvBuf[usMasterRcvBufferPos++] = ucByte;
 8011ada:	8011      	strh	r1, [r2, #0]
 8011adc:	54f7      	strb	r7, [r6, r3]
        eRcvState = STATE_M_RX_RCV;
 8011ade:	7028      	strb	r0, [r5, #0]
		//chprintf((BaseSequentialStream *)&itm_port, "%s\n", "First Byte Received");

        /* Enable t3.5 timers. */
        vMBMasterPortTimersT35Enable( );
 8011ae0:	f000 fe1e 	bl	8012720 <vMBMasterPortTimersT35Enable>
        }
        vMBMasterPortTimersT35Enable();
        break;
    }
    return xTaskNeedSwitch;
}
 8011ae4:	2000      	movs	r0, #0
 8011ae6:	b003      	add	sp, #12
 8011ae8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        {
            ucMasterRTURcvBuf[usMasterRcvBufferPos++] = ucByte;
        }
        else
        {
            eRcvState = STATE_M_RX_ERROR;
 8011aea:	2303      	movs	r3, #3
 8011aec:	702b      	strb	r3, [r5, #0]
 8011aee:	e7e1      	b.n	8011ab4 <xMBMasterRTUReceiveFSM+0x44>
xMBMasterRTUReceiveFSM( void )
{
    BOOL            xTaskNeedSwitch = FALSE;
    UCHAR           ucByte;

    assert(( eSndState == STATE_M_TX_IDLE ) || ( eSndState == STATE_M_TX_XFWR ));
 8011af0:	4806      	ldr	r0, [pc, #24]	; (8011b0c <xMBMasterRTUReceiveFSM+0x9c>)
 8011af2:	4a07      	ldr	r2, [pc, #28]	; (8011b10 <xMBMasterRTUReceiveFSM+0xa0>)
 8011af4:	4b07      	ldr	r3, [pc, #28]	; (8011b14 <xMBMasterRTUReceiveFSM+0xa4>)
 8011af6:	21ef      	movs	r1, #239	; 0xef
 8011af8:	f001 fe22 	bl	8013740 <__assert_func>
 8011afc:	2000cd05 	.word	0x2000cd05
 8011b00:	2000cd06 	.word	0x2000cd06
 8011b04:	2000cd00 	.word	0x2000cd00
 8011b08:	2000cbfc 	.word	0x2000cbfc
 8011b0c:	08019420 	.word	0x08019420
 8011b10:	080195d0 	.word	0x080195d0
 8011b14:	0801946c 	.word	0x0801946c
 8011b18:	f3af 8000 	nop.w
 8011b1c:	f3af 8000 	nop.w

08011b20 <xMBMasterRTUTransmitFSM>:
    return xTaskNeedSwitch;
}

BOOL
xMBMasterRTUTransmitFSM( void )
{
 8011b20:	b538      	push	{r3, r4, r5, lr}
    BOOL            xNeedPoll = FALSE;

    assert( eRcvState == STATE_M_RX_IDLE );
 8011b22:	4b20      	ldr	r3, [pc, #128]	; (8011ba4 <xMBMasterRTUTransmitFSM+0x84>)
 8011b24:	7818      	ldrb	r0, [r3, #0]
 8011b26:	b2c0      	uxtb	r0, r0
 8011b28:	2801      	cmp	r0, #1
 8011b2a:	d133      	bne.n	8011b94 <xMBMasterRTUTransmitFSM+0x74>

    switch ( eSndState )
 8011b2c:	4c1e      	ldr	r4, [pc, #120]	; (8011ba8 <xMBMasterRTUTransmitFSM+0x88>)
 8011b2e:	7823      	ldrb	r3, [r4, #0]
 8011b30:	f003 01ff 	and.w	r1, r3, #255	; 0xff
 8011b34:	b1cb      	cbz	r3, 8011b6a <xMBMasterRTUTransmitFSM+0x4a>
 8011b36:	2901      	cmp	r1, #1
 8011b38:	d115      	bne.n	8011b66 <xMBMasterRTUTransmitFSM+0x46>
        vMBMasterPortSerialEnable( TRUE, FALSE );
        break;

    case STATE_M_TX_XMIT:
        /* check if we are finished. */
        if( usMasterSndBufferCount != 0 )
 8011b3a:	4d1c      	ldr	r5, [pc, #112]	; (8011bac <xMBMasterRTUTransmitFSM+0x8c>)
 8011b3c:	882b      	ldrh	r3, [r5, #0]
 8011b3e:	b29b      	uxth	r3, r3
 8011b40:	b9bb      	cbnz	r3, 8011b72 <xMBMasterRTUTransmitFSM+0x52>
            pucMasterSndBufferCur++;  /* next byte in sendbuffer. */
            usMasterSndBufferCount--;
        }
        else
        {
            xFrameIsBroadcast = ( ucMasterRTUSndBuf[MB_SER_PDU_ADDR_OFF] == MB_ADDRESS_BROADCAST ) ? TRUE : FALSE;
 8011b42:	4a1b      	ldr	r2, [pc, #108]	; (8011bb0 <xMBMasterRTUTransmitFSM+0x90>)
 8011b44:	4d1b      	ldr	r5, [pc, #108]	; (8011bb4 <xMBMasterRTUTransmitFSM+0x94>)
 8011b46:	7812      	ldrb	r2, [r2, #0]
 8011b48:	fab2 f282 	clz	r2, r2
            /* Disable transmitter. This prevents another transmit buffer
             * empty interrupt. */
            vMBMasterPortSerialEnable( TRUE, FALSE );
 8011b4c:	4608      	mov	r0, r1
            pucMasterSndBufferCur++;  /* next byte in sendbuffer. */
            usMasterSndBufferCount--;
        }
        else
        {
            xFrameIsBroadcast = ( ucMasterRTUSndBuf[MB_SER_PDU_ADDR_OFF] == MB_ADDRESS_BROADCAST ) ? TRUE : FALSE;
 8011b4e:	0952      	lsrs	r2, r2, #5
            /* Disable transmitter. This prevents another transmit buffer
             * empty interrupt. */
            vMBMasterPortSerialEnable( TRUE, FALSE );
 8011b50:	4619      	mov	r1, r3
            pucMasterSndBufferCur++;  /* next byte in sendbuffer. */
            usMasterSndBufferCount--;
        }
        else
        {
            xFrameIsBroadcast = ( ucMasterRTUSndBuf[MB_SER_PDU_ADDR_OFF] == MB_ADDRESS_BROADCAST ) ? TRUE : FALSE;
 8011b52:	702a      	strb	r2, [r5, #0]
            /* Disable transmitter. This prevents another transmit buffer
             * empty interrupt. */
            vMBMasterPortSerialEnable( TRUE, FALSE );
 8011b54:	f000 fd6c 	bl	8012630 <vMBMasterPortSerialEnable>
            eSndState = STATE_M_TX_XFWR;
 8011b58:	2302      	movs	r3, #2
 8011b5a:	7023      	strb	r3, [r4, #0]
            /* If the frame is broadcast ,master will enable timer of convert delay,
             * else master will enable timer of respond timeout. */
            if ( xFrameIsBroadcast == TRUE )
 8011b5c:	782b      	ldrb	r3, [r5, #0]
 8011b5e:	2b01      	cmp	r3, #1
 8011b60:	d015      	beq.n	8011b8e <xMBMasterRTUTransmitFSM+0x6e>
            	vMBMasterPortTimersConvertDelayEnable( );
            }
            else
            {
				//chprintf((BaseSequentialStream *)&itm_port, "%s\n", "TimeOut Enable");
            	vMBMasterPortTimersRespondTimeoutEnable( );
 8011b62:	f000 fe2d 	bl	80127c0 <vMBMasterPortTimersRespondTimeoutEnable>
        }
        break;
    }

    return xNeedPoll;
}
 8011b66:	2000      	movs	r0, #0
 8011b68:	bd38      	pop	{r3, r4, r5, pc}
    {
        /* We should not get a transmitter event if the transmitter is in
         * idle state.  */
    case STATE_M_TX_IDLE:
        /* enable receiver/disable transmitter. */
        vMBMasterPortSerialEnable( TRUE, FALSE );
 8011b6a:	f000 fd61 	bl	8012630 <vMBMasterPortSerialEnable>
        }
        break;
    }

    return xNeedPoll;
}
 8011b6e:	2000      	movs	r0, #0
 8011b70:	bd38      	pop	{r3, r4, r5, pc}

    case STATE_M_TX_XMIT:
        /* check if we are finished. */
        if( usMasterSndBufferCount != 0 )
        {
            xMBMasterPortSerialPutByte( ( CHAR )*pucMasterSndBufferCur );
 8011b72:	4c11      	ldr	r4, [pc, #68]	; (8011bb8 <xMBMasterRTUTransmitFSM+0x98>)
 8011b74:	6823      	ldr	r3, [r4, #0]
 8011b76:	7818      	ldrb	r0, [r3, #0]
 8011b78:	f000 fda2 	bl	80126c0 <xMBMasterPortSerialPutByte>
            pucMasterSndBufferCur++;  /* next byte in sendbuffer. */
            usMasterSndBufferCount--;
 8011b7c:	882b      	ldrh	r3, [r5, #0]
    case STATE_M_TX_XMIT:
        /* check if we are finished. */
        if( usMasterSndBufferCount != 0 )
        {
            xMBMasterPortSerialPutByte( ( CHAR )*pucMasterSndBufferCur );
            pucMasterSndBufferCur++;  /* next byte in sendbuffer. */
 8011b7e:	6822      	ldr	r2, [r4, #0]
            usMasterSndBufferCount--;
 8011b80:	3b01      	subs	r3, #1
    case STATE_M_TX_XMIT:
        /* check if we are finished. */
        if( usMasterSndBufferCount != 0 )
        {
            xMBMasterPortSerialPutByte( ( CHAR )*pucMasterSndBufferCur );
            pucMasterSndBufferCur++;  /* next byte in sendbuffer. */
 8011b82:	3201      	adds	r2, #1
            usMasterSndBufferCount--;
 8011b84:	b29b      	uxth	r3, r3
    case STATE_M_TX_XMIT:
        /* check if we are finished. */
        if( usMasterSndBufferCount != 0 )
        {
            xMBMasterPortSerialPutByte( ( CHAR )*pucMasterSndBufferCur );
            pucMasterSndBufferCur++;  /* next byte in sendbuffer. */
 8011b86:	6022      	str	r2, [r4, #0]
            usMasterSndBufferCount--;
 8011b88:	802b      	strh	r3, [r5, #0]
        }
        break;
    }

    return xNeedPoll;
}
 8011b8a:	2000      	movs	r0, #0
 8011b8c:	bd38      	pop	{r3, r4, r5, pc}
            eSndState = STATE_M_TX_XFWR;
            /* If the frame is broadcast ,master will enable timer of convert delay,
             * else master will enable timer of respond timeout. */
            if ( xFrameIsBroadcast == TRUE )
            {
            	vMBMasterPortTimersConvertDelayEnable( );
 8011b8e:	f000 fdef 	bl	8012770 <vMBMasterPortTimersConvertDelayEnable>
 8011b92:	e7e8      	b.n	8011b66 <xMBMasterRTUTransmitFSM+0x46>
BOOL
xMBMasterRTUTransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;

    assert( eRcvState == STATE_M_RX_IDLE );
 8011b94:	4809      	ldr	r0, [pc, #36]	; (8011bbc <xMBMasterRTUTransmitFSM+0x9c>)
 8011b96:	4a0a      	ldr	r2, [pc, #40]	; (8011bc0 <xMBMasterRTUTransmitFSM+0xa0>)
 8011b98:	4b0a      	ldr	r3, [pc, #40]	; (8011bc4 <xMBMasterRTUTransmitFSM+0xa4>)
 8011b9a:	f240 1133 	movw	r1, #307	; 0x133
 8011b9e:	f001 fdcf 	bl	8013740 <__assert_func>
 8011ba2:	bf00      	nop
 8011ba4:	2000cd06 	.word	0x2000cd06
 8011ba8:	2000cd05 	.word	0x2000cd05
 8011bac:	2000ccfe 	.word	0x2000ccfe
 8011bb0:	2000cd0c 	.word	0x2000cd0c
 8011bb4:	2000ccfc 	.word	0x2000ccfc
 8011bb8:	2000cd08 	.word	0x2000cd08
 8011bbc:	08019420 	.word	0x08019420
 8011bc0:	080193e0 	.word	0x080193e0
 8011bc4:	080194b4 	.word	0x080194b4
 8011bc8:	f3af 8000 	nop.w
 8011bcc:	f3af 8000 	nop.w

08011bd0 <xMBMasterRTUTimerExpired>:

BOOL
xMBMasterRTUTimerExpired(void)
{
	BOOL xNeedPoll = FALSE;
	palClearPad(GPIOC, GPIOC_PIN9);
 8011bd0:	4b2d      	ldr	r3, [pc, #180]	; (8011c88 <xMBMasterRTUTimerExpired+0xb8>)
    return xNeedPoll;
}

BOOL
xMBMasterRTUTimerExpired(void)
{
 8011bd2:	b570      	push	{r4, r5, r6, lr}
	BOOL xNeedPoll = FALSE;
	palClearPad(GPIOC, GPIOC_PIN9);
 8011bd4:	f44f 7200 	mov.w	r2, #512	; 0x200
	//palClearPad(GPIOC, GPIOC_PIN10);
	switch (eRcvState)
 8011bd8:	4d2c      	ldr	r5, [pc, #176]	; (8011c8c <xMBMasterRTUTimerExpired+0xbc>)

BOOL
xMBMasterRTUTimerExpired(void)
{
	BOOL xNeedPoll = FALSE;
	palClearPad(GPIOC, GPIOC_PIN9);
 8011bda:	835a      	strh	r2, [r3, #26]
	//palClearPad(GPIOC, GPIOC_PIN10);
	switch (eRcvState)
 8011bdc:	7828      	ldrb	r0, [r5, #0]
 8011bde:	b2c0      	uxtb	r0, r0
 8011be0:	2802      	cmp	r0, #2
 8011be2:	d016      	beq.n	8011c12 <xMBMasterRTUTimerExpired+0x42>
 8011be4:	2803      	cmp	r0, #3
 8011be6:	d010      	beq.n	8011c0a <xMBMasterRTUTimerExpired+0x3a>
 8011be8:	2800      	cmp	r0, #0
 8011bea:	d035      	beq.n	8011c58 <xMBMasterRTUTimerExpired+0x88>
			xNeedPoll = xMBMasterPortEventPost( EV_MASTER_ERROR_PROCESS );
			break;

		/* Function called in an illegal state. */
		default:
			assert(
 8011bec:	782b      	ldrb	r3, [r5, #0]
 8011bee:	f003 06ff 	and.w	r6, r3, #255	; 0xff
 8011bf2:	b18b      	cbz	r3, 8011c18 <xMBMasterRTUTimerExpired+0x48>
 8011bf4:	782b      	ldrb	r3, [r5, #0]
 8011bf6:	2b02      	cmp	r3, #2
 8011bf8:	d005      	beq.n	8011c06 <xMBMasterRTUTimerExpired+0x36>
 8011bfa:	782b      	ldrb	r3, [r5, #0]
 8011bfc:	2b03      	cmp	r3, #3
 8011bfe:	d002      	beq.n	8011c06 <xMBMasterRTUTimerExpired+0x36>
 8011c00:	782b      	ldrb	r3, [r5, #0]
 8011c02:	2b01      	cmp	r3, #1
 8011c04:	d139      	bne.n	8011c7a <xMBMasterRTUTimerExpired+0xaa>
}

BOOL
xMBMasterRTUTimerExpired(void)
{
	BOOL xNeedPoll = FALSE;
 8011c06:	2600      	movs	r6, #0
 8011c08:	e006      	b.n	8011c18 <xMBMasterRTUTimerExpired+0x48>
			xNeedPoll = xMBMasterPortEventPost(EV_MASTER_FRAME_RECEIVED);
			break;

		/* An error occured while receiving the frame. */
		case STATE_M_RX_ERROR:
			vMBMasterSetErrorType(EV_ERROR_RECEIVE_DATA);
 8011c0a:	2002      	movs	r0, #2
 8011c0c:	f000 fa40 	bl	8012090 <vMBMasterSetErrorType>
			xNeedPoll = xMBMasterPortEventPost( EV_MASTER_ERROR_PROCESS );
 8011c10:	2010      	movs	r0, #16
 8011c12:	f000 fc0d 	bl	8012430 <xMBMasterPortEventPost>
 8011c16:	4606      	mov	r6, r0
			assert(
					( eRcvState == STATE_M_RX_INIT ) || ( eRcvState == STATE_M_RX_RCV ) ||
					( eRcvState == STATE_M_RX_ERROR ) || ( eRcvState == STATE_M_RX_IDLE ));
			break;
	}
	eRcvState = STATE_M_RX_IDLE;
 8011c18:	2001      	movs	r0, #1

	switch (eSndState)
 8011c1a:	4c1d      	ldr	r4, [pc, #116]	; (8011c90 <xMBMasterRTUTimerExpired+0xc0>)
			assert(
					( eRcvState == STATE_M_RX_INIT ) || ( eRcvState == STATE_M_RX_RCV ) ||
					( eRcvState == STATE_M_RX_ERROR ) || ( eRcvState == STATE_M_RX_IDLE ));
			break;
	}
	eRcvState = STATE_M_RX_IDLE;
 8011c1c:	7028      	strb	r0, [r5, #0]

	switch (eSndState)
 8011c1e:	7823      	ldrb	r3, [r4, #0]
 8011c20:	2b02      	cmp	r3, #2
 8011c22:	d10c      	bne.n	8011c3e <xMBMasterRTUTimerExpired+0x6e>
	{
		/* A frame was send finish and convert delay or respond timeout expired.
		 * If the frame is broadcast,The master will idle,and if the frame is not
		 * broadcast.Notify the listener process error.*/
		case STATE_M_TX_XFWR:
			if ( xFrameIsBroadcast == FALSE ) {
 8011c24:	4b1b      	ldr	r3, [pc, #108]	; (8011c94 <xMBMasterRTUTimerExpired+0xc4>)
 8011c26:	781b      	ldrb	r3, [r3, #0]
 8011c28:	b1db      	cbz	r3, 8011c62 <xMBMasterRTUTimerExpired+0x92>
		default:
			assert(
					( eSndState == STATE_M_TX_XFWR ) || ( eSndState == STATE_M_TX_IDLE ));
			break;
	}
	eSndState = STATE_M_TX_IDLE;
 8011c2a:	2300      	movs	r3, #0
 8011c2c:	7023      	strb	r3, [r4, #0]

	vMBMasterPortTimersDisable( );
 8011c2e:	f000 fde7 	bl	8012800 <vMBMasterPortTimersDisable>
	/* If timer mode is convert delay, the master event then turns EV_MASTER_EXECUTE status. */
	if (eMasterCurTimerMode == MB_TMODE_CONVERT_DELAY) {
 8011c32:	4b19      	ldr	r3, [pc, #100]	; (8011c98 <xMBMasterRTUTimerExpired+0xc8>)
 8011c34:	781b      	ldrb	r3, [r3, #0]
 8011c36:	2b02      	cmp	r3, #2
 8011c38:	d01a      	beq.n	8011c70 <xMBMasterRTUTimerExpired+0xa0>
		xNeedPoll = xMBMasterPortEventPost( EV_MASTER_EXECUTE );
	}

	return xNeedPoll;
}
 8011c3a:	4630      	mov	r0, r6
 8011c3c:	bd70      	pop	{r4, r5, r6, pc}
				xNeedPoll = xMBMasterPortEventPost(EV_MASTER_ERROR_PROCESS);
			}
			break;
		/* Function called in an illegal state. */
		default:
			assert(
 8011c3e:	7823      	ldrb	r3, [r4, #0]
 8011c40:	2b02      	cmp	r3, #2
 8011c42:	d0f2      	beq.n	8011c2a <xMBMasterRTUTimerExpired+0x5a>
 8011c44:	7823      	ldrb	r3, [r4, #0]
 8011c46:	2b00      	cmp	r3, #0
 8011c48:	d0ef      	beq.n	8011c2a <xMBMasterRTUTimerExpired+0x5a>
 8011c4a:	4814      	ldr	r0, [pc, #80]	; (8011c9c <xMBMasterRTUTimerExpired+0xcc>)
 8011c4c:	4a14      	ldr	r2, [pc, #80]	; (8011ca0 <xMBMasterRTUTimerExpired+0xd0>)
 8011c4e:	4b15      	ldr	r3, [pc, #84]	; (8011ca4 <xMBMasterRTUTimerExpired+0xd4>)
 8011c50:	f240 118f 	movw	r1, #399	; 0x18f
 8011c54:	f001 fd74 	bl	8013740 <__assert_func>
	//palClearPad(GPIOC, GPIOC_PIN10);
	switch (eRcvState)
	{
		/* Timer t35 expired. Startup phase is finished. */
		case STATE_M_RX_INIT:
			xNeedPoll = xMBMasterPortEventPost(EV_MASTER_READY);
 8011c58:	2001      	movs	r0, #1
 8011c5a:	f000 fbe9 	bl	8012430 <xMBMasterPortEventPost>
 8011c5e:	4606      	mov	r6, r0
			break;
 8011c60:	e7da      	b.n	8011c18 <xMBMasterRTUTimerExpired+0x48>
		/* A frame was send finish and convert delay or respond timeout expired.
		 * If the frame is broadcast,The master will idle,and if the frame is not
		 * broadcast.Notify the listener process error.*/
		case STATE_M_TX_XFWR:
			if ( xFrameIsBroadcast == FALSE ) {
				vMBMasterSetErrorType(EV_ERROR_RESPOND_TIMEOUT);
 8011c62:	f000 fa15 	bl	8012090 <vMBMasterSetErrorType>
				xNeedPoll = xMBMasterPortEventPost(EV_MASTER_ERROR_PROCESS);
 8011c66:	2010      	movs	r0, #16
 8011c68:	f000 fbe2 	bl	8012430 <xMBMasterPortEventPost>
 8011c6c:	4606      	mov	r6, r0
 8011c6e:	e7dc      	b.n	8011c2a <xMBMasterRTUTimerExpired+0x5a>
	eSndState = STATE_M_TX_IDLE;

	vMBMasterPortTimersDisable( );
	/* If timer mode is convert delay, the master event then turns EV_MASTER_EXECUTE status. */
	if (eMasterCurTimerMode == MB_TMODE_CONVERT_DELAY) {
		xNeedPoll = xMBMasterPortEventPost( EV_MASTER_EXECUTE );
 8011c70:	2004      	movs	r0, #4
	}

	return xNeedPoll;
}
 8011c72:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	eSndState = STATE_M_TX_IDLE;

	vMBMasterPortTimersDisable( );
	/* If timer mode is convert delay, the master event then turns EV_MASTER_EXECUTE status. */
	if (eMasterCurTimerMode == MB_TMODE_CONVERT_DELAY) {
		xNeedPoll = xMBMasterPortEventPost( EV_MASTER_EXECUTE );
 8011c76:	f000 bbdb 	b.w	8012430 <xMBMasterPortEventPost>
			xNeedPoll = xMBMasterPortEventPost( EV_MASTER_ERROR_PROCESS );
			break;

		/* Function called in an illegal state. */
		default:
			assert(
 8011c7a:	4808      	ldr	r0, [pc, #32]	; (8011c9c <xMBMasterRTUTimerExpired+0xcc>)
 8011c7c:	4a08      	ldr	r2, [pc, #32]	; (8011ca0 <xMBMasterRTUTimerExpired+0xd0>)
 8011c7e:	4b0a      	ldr	r3, [pc, #40]	; (8011ca8 <xMBMasterRTUTimerExpired+0xd8>)
 8011c80:	f44f 71be 	mov.w	r1, #380	; 0x17c
 8011c84:	f001 fd5c 	bl	8013740 <__assert_func>
 8011c88:	40020800 	.word	0x40020800
 8011c8c:	2000cd06 	.word	0x2000cd06
 8011c90:	2000cd05 	.word	0x2000cd05
 8011c94:	2000ccfc 	.word	0x2000ccfc
 8011c98:	2000cd04 	.word	0x2000cd04
 8011c9c:	08019420 	.word	0x08019420
 8011ca0:	08019400 	.word	0x08019400
 8011ca4:	08019564 	.word	0x08019564
 8011ca8:	080194d4 	.word	0x080194d4
 8011cac:	f3af 8000 	nop.w

08011cb0 <vMBMasterGetPDUSndBuf>:

/* Get Modbus Master send PDU's buffer address pointer.*/
void 
vMBMasterGetPDUSndBuf( UCHAR ** pucFrame )
{
	*pucFrame = ( UCHAR * ) &ucMasterRTUSndBuf[MB_SER_PDU_PDU_OFF];
 8011cb0:	4b01      	ldr	r3, [pc, #4]	; (8011cb8 <vMBMasterGetPDUSndBuf+0x8>)
 8011cb2:	6003      	str	r3, [r0, #0]
 8011cb4:	4770      	bx	lr
 8011cb6:	bf00      	nop
 8011cb8:	2000cd0d 	.word	0x2000cd0d
 8011cbc:	f3af 8000 	nop.w

08011cc0 <vMBMasterSetPDUSndLength>:

/* Set Modbus Master send PDU's buffer length.*/
void 
vMBMasterSetPDUSndLength( USHORT SendPDULength )
{
	usMasterSendPDULength = SendPDULength;
 8011cc0:	4b01      	ldr	r3, [pc, #4]	; (8011cc8 <vMBMasterSetPDUSndLength+0x8>)
 8011cc2:	8018      	strh	r0, [r3, #0]
 8011cc4:	4770      	bx	lr
 8011cc6:	bf00      	nop
 8011cc8:	2000cd02 	.word	0x2000cd02
 8011ccc:	f3af 8000 	nop.w

08011cd0 <usMBMasterGetPDUSndLength>:

/* Get Modbus Master send PDU's buffer length.*/
USHORT 
usMBMasterGetPDUSndLength( void )
{
	return usMasterSendPDULength;
 8011cd0:	4b01      	ldr	r3, [pc, #4]	; (8011cd8 <usMBMasterGetPDUSndLength+0x8>)
 8011cd2:	8818      	ldrh	r0, [r3, #0]
}
 8011cd4:	b280      	uxth	r0, r0
 8011cd6:	4770      	bx	lr
 8011cd8:	2000cd02 	.word	0x2000cd02
 8011cdc:	f3af 8000 	nop.w

08011ce0 <vMBMasterSetCurTimerMode>:

/* Set Modbus Master current timer mode.*/
void 
vMBMasterSetCurTimerMode( eMBMasterTimerMode eMBTimerMode )
{
	eMasterCurTimerMode = eMBTimerMode;
 8011ce0:	4b01      	ldr	r3, [pc, #4]	; (8011ce8 <vMBMasterSetCurTimerMode+0x8>)
 8011ce2:	7018      	strb	r0, [r3, #0]
 8011ce4:	4770      	bx	lr
 8011ce6:	bf00      	nop
 8011ce8:	2000cd04 	.word	0x2000cd04
 8011cec:	f3af 8000 	nop.w

08011cf0 <xMBMasterRequestIsBroadcast>:
}

/* The master request is broadcast? */
BOOL 
xMBMasterRequestIsBroadcast( void ){
	return xFrameIsBroadcast;
 8011cf0:	4b01      	ldr	r3, [pc, #4]	; (8011cf8 <xMBMasterRequestIsBroadcast+0x8>)
 8011cf2:	7818      	ldrb	r0, [r3, #0]
}
 8011cf4:	4770      	bx	lr
 8011cf6:	bf00      	nop
 8011cf8:	2000ccfc 	.word	0x2000ccfc
 8011cfc:	f3af 8000 	nop.w

08011d00 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8011d00:	b40e      	push	{r1, r2, r3}
 8011d02:	b500      	push	{lr}
 8011d04:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8011d06:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 8011d08:	461a      	mov	r2, r3
 8011d0a:	4905      	ldr	r1, [pc, #20]	; (8011d20 <chprintf.constprop.0+0x20>)
 8011d0c:	4805      	ldr	r0, [pc, #20]	; (8011d24 <chprintf.constprop.0+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8011d0e:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8011d10:	f7fe fff6 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8011d14:	b002      	add	sp, #8
 8011d16:	f85d eb04 	ldr.w	lr, [sp], #4
 8011d1a:	b003      	add	sp, #12
 8011d1c:	4770      	bx	lr
 8011d1e:	bf00      	nop
 8011d20:	08017004 	.word	0x08017004
 8011d24:	200180c8 	.word	0x200180c8
 8011d28:	f3af 8000 	nop.w
 8011d2c:	f3af 8000 	nop.w

08011d30 <eMBMasterInit>:
};

/* ----------------------- Start implementation -----------------------------*/
eMBErrorCode
eMBMasterInit( eMBMode eMode, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
{
 8011d30:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    eMBErrorCode    eStatus = MB_ENOERR;

	switch (eMode)
 8011d34:	b118      	cbz	r0, 8011d3e <eMBMasterInit+0xe>

		eStatus = eMBMasterASCIIInit(ucPort, ulBaudRate, eParity );
		break;
#endif
	default:
		eStatus = MB_EINVAL;
 8011d36:	2402      	movs	r4, #2
		}
		/* initialize the OS resource for modbus master. */
		vMBMasterOsResInit();
	}
	return eStatus;
}
 8011d38:	4620      	mov	r0, r4
 8011d3a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8011d3e:	4604      	mov	r4, r0
 8011d40:	4608      	mov	r0, r1

	switch (eMode)
	{
#if MB_MASTER_RTU_ENABLED > 0
	case MB_RTU:
		pvMBMasterFrameStartCur = eMBMasterRTUStart;
 8011d42:	491e      	ldr	r1, [pc, #120]	; (8011dbc <eMBMasterInit+0x8c>)
		pvMBMasterFrameStopCur = eMBMasterRTUStop;
 8011d44:	f8df 908c 	ldr.w	r9, [pc, #140]	; 8011dd4 <eMBMasterInit+0xa4>
		peMBMasterFrameSendCur = eMBMasterRTUSend;
 8011d48:	f8df 808c 	ldr.w	r8, [pc, #140]	; 8011dd8 <eMBMasterInit+0xa8>

	switch (eMode)
	{
#if MB_MASTER_RTU_ENABLED > 0
	case MB_RTU:
		pvMBMasterFrameStartCur = eMBMasterRTUStart;
 8011d4c:	f8df b08c 	ldr.w	fp, [pc, #140]	; 8011ddc <eMBMasterInit+0xac>
 8011d50:	f8c1 b000 	str.w	fp, [r1]
		pvMBMasterFrameStopCur = eMBMasterRTUStop;
		peMBMasterFrameSendCur = eMBMasterRTUSend;
		peMBMasterFrameReceiveCur = eMBMasterRTUReceive;
 8011d54:	f8df c088 	ldr.w	ip, [pc, #136]	; 8011de0 <eMBMasterInit+0xb0>
		pvMBMasterFrameCloseCur = MB_PORT_HAS_CLOSE ? vMBMasterPortClose : NULL;
 8011d58:	f8df e088 	ldr.w	lr, [pc, #136]	; 8011de4 <eMBMasterInit+0xb4>
	switch (eMode)
	{
#if MB_MASTER_RTU_ENABLED > 0
	case MB_RTU:
		pvMBMasterFrameStartCur = eMBMasterRTUStart;
		pvMBMasterFrameStopCur = eMBMasterRTUStop;
 8011d5c:	f8df a088 	ldr.w	sl, [pc, #136]	; 8011de8 <eMBMasterInit+0xb8>
		peMBMasterFrameSendCur = eMBMasterRTUSend;
		peMBMasterFrameReceiveCur = eMBMasterRTUReceive;
		pvMBMasterFrameCloseCur = MB_PORT_HAS_CLOSE ? vMBMasterPortClose : NULL;
		pxMBMasterFrameCBByteReceived = xMBMasterRTUReceiveFSM;
 8011d60:	4f17      	ldr	r7, [pc, #92]	; (8011dc0 <eMBMasterInit+0x90>)
		pxMBMasterFrameCBTransmitterEmpty = xMBMasterRTUTransmitFSM;
 8011d62:	4e18      	ldr	r6, [pc, #96]	; (8011dc4 <eMBMasterInit+0x94>)
		pxMBMasterPortCBTimerExpired = xMBMasterRTUTimerExpired;
 8011d64:	4d18      	ldr	r5, [pc, #96]	; (8011dc8 <eMBMasterInit+0x98>)
	{
#if MB_MASTER_RTU_ENABLED > 0
	case MB_RTU:
		pvMBMasterFrameStartCur = eMBMasterRTUStart;
		pvMBMasterFrameStopCur = eMBMasterRTUStop;
		peMBMasterFrameSendCur = eMBMasterRTUSend;
 8011d66:	f8df b084 	ldr.w	fp, [pc, #132]	; 8011dec <eMBMasterInit+0xbc>
	switch (eMode)
	{
#if MB_MASTER_RTU_ENABLED > 0
	case MB_RTU:
		pvMBMasterFrameStartCur = eMBMasterRTUStart;
		pvMBMasterFrameStopCur = eMBMasterRTUStop;
 8011d6a:	f8c9 a000 	str.w	sl, [r9]
		pvMBMasterFrameCloseCur = MB_PORT_HAS_CLOSE ? vMBMasterPortClose : NULL;
		pxMBMasterFrameCBByteReceived = xMBMasterRTUReceiveFSM;
		pxMBMasterFrameCBTransmitterEmpty = xMBMasterRTUTransmitFSM;
		pxMBMasterPortCBTimerExpired = xMBMasterRTUTimerExpired;

		eStatus = eMBMasterRTUInit(ucPort, ulBaudRate, eParity);
 8011d6e:	4611      	mov	r1, r2
	{
#if MB_MASTER_RTU_ENABLED > 0
	case MB_RTU:
		pvMBMasterFrameStartCur = eMBMasterRTUStart;
		pvMBMasterFrameStopCur = eMBMasterRTUStop;
		peMBMasterFrameSendCur = eMBMasterRTUSend;
 8011d70:	f8c8 b000 	str.w	fp, [r8]
		pvMBMasterFrameCloseCur = MB_PORT_HAS_CLOSE ? vMBMasterPortClose : NULL;
		pxMBMasterFrameCBByteReceived = xMBMasterRTUReceiveFSM;
		pxMBMasterFrameCBTransmitterEmpty = xMBMasterRTUTransmitFSM;
		pxMBMasterPortCBTimerExpired = xMBMasterRTUTimerExpired;

		eStatus = eMBMasterRTUInit(ucPort, ulBaudRate, eParity);
 8011d74:	461a      	mov	r2, r3
		pvMBMasterFrameStartCur = eMBMasterRTUStart;
		pvMBMasterFrameStopCur = eMBMasterRTUStop;
		peMBMasterFrameSendCur = eMBMasterRTUSend;
		peMBMasterFrameReceiveCur = eMBMasterRTUReceive;
		pvMBMasterFrameCloseCur = MB_PORT_HAS_CLOSE ? vMBMasterPortClose : NULL;
		pxMBMasterFrameCBByteReceived = xMBMasterRTUReceiveFSM;
 8011d76:	f8df a078 	ldr.w	sl, [pc, #120]	; 8011df0 <eMBMasterInit+0xc0>
#if MB_MASTER_RTU_ENABLED > 0
	case MB_RTU:
		pvMBMasterFrameStartCur = eMBMasterRTUStart;
		pvMBMasterFrameStopCur = eMBMasterRTUStop;
		peMBMasterFrameSendCur = eMBMasterRTUSend;
		peMBMasterFrameReceiveCur = eMBMasterRTUReceive;
 8011d7a:	4b14      	ldr	r3, [pc, #80]	; (8011dcc <eMBMasterInit+0x9c>)
		pvMBMasterFrameCloseCur = MB_PORT_HAS_CLOSE ? vMBMasterPortClose : NULL;
		pxMBMasterFrameCBByteReceived = xMBMasterRTUReceiveFSM;
		pxMBMasterFrameCBTransmitterEmpty = xMBMasterRTUTransmitFSM;
 8011d7c:	f8df 9074 	ldr.w	r9, [pc, #116]	; 8011df4 <eMBMasterInit+0xc4>
		pxMBMasterPortCBTimerExpired = xMBMasterRTUTimerExpired;
 8011d80:	f8df 8074 	ldr.w	r8, [pc, #116]	; 8011df8 <eMBMasterInit+0xc8>
	case MB_RTU:
		pvMBMasterFrameStartCur = eMBMasterRTUStart;
		pvMBMasterFrameStopCur = eMBMasterRTUStop;
		peMBMasterFrameSendCur = eMBMasterRTUSend;
		peMBMasterFrameReceiveCur = eMBMasterRTUReceive;
		pvMBMasterFrameCloseCur = MB_PORT_HAS_CLOSE ? vMBMasterPortClose : NULL;
 8011d84:	f8ce 4000 	str.w	r4, [lr]
#if MB_MASTER_RTU_ENABLED > 0
	case MB_RTU:
		pvMBMasterFrameStartCur = eMBMasterRTUStart;
		pvMBMasterFrameStopCur = eMBMasterRTUStop;
		peMBMasterFrameSendCur = eMBMasterRTUSend;
		peMBMasterFrameReceiveCur = eMBMasterRTUReceive;
 8011d88:	f8cc 3000 	str.w	r3, [ip]
		pvMBMasterFrameCloseCur = MB_PORT_HAS_CLOSE ? vMBMasterPortClose : NULL;
		pxMBMasterFrameCBByteReceived = xMBMasterRTUReceiveFSM;
 8011d8c:	f8c7 a000 	str.w	sl, [r7]
		pxMBMasterFrameCBTransmitterEmpty = xMBMasterRTUTransmitFSM;
 8011d90:	f8c6 9000 	str.w	r9, [r6]
		pxMBMasterPortCBTimerExpired = xMBMasterRTUTimerExpired;
 8011d94:	f8c5 8000 	str.w	r8, [r5]

		eStatus = eMBMasterRTUInit(ucPort, ulBaudRate, eParity);
 8011d98:	f7ff fd82 	bl	80118a0 <eMBMasterRTUInit>
	default:
		eStatus = MB_EINVAL;
		break;
	}

	if (eStatus == MB_ENOERR)
 8011d9c:	4604      	mov	r4, r0
 8011d9e:	2800      	cmp	r0, #0
 8011da0:	d1ca      	bne.n	8011d38 <eMBMasterInit+0x8>
	{
		if (!xMBMasterPortEventInit())
 8011da2:	f000 fb3d 	bl	8012420 <xMBMasterPortEventInit>
 8011da6:	b138      	cbz	r0, 8011db8 <eMBMasterInit+0x88>
			/* port dependent event module initalization failed. */
			eStatus = MB_EPORTERR;
		}
		else
		{
			eMBState = STATE_DISABLED;
 8011da8:	4b09      	ldr	r3, [pc, #36]	; (8011dd0 <eMBMasterInit+0xa0>)
 8011daa:	2201      	movs	r2, #1
 8011dac:	701a      	strb	r2, [r3, #0]
		}
		/* initialize the OS resource for modbus master. */
		vMBMasterOsResInit();
 8011dae:	f000 fb5f 	bl	8012470 <vMBMasterOsResInit>
	}
	return eStatus;
}
 8011db2:	4620      	mov	r0, r4
 8011db4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (eStatus == MB_ENOERR)
	{
		if (!xMBMasterPortEventInit())
		{
			/* port dependent event module initalization failed. */
			eStatus = MB_EPORTERR;
 8011db8:	2403      	movs	r4, #3
 8011dba:	e7f8      	b.n	8011dae <eMBMasterInit+0x7e>
 8011dbc:	2000ce1c 	.word	0x2000ce1c
 8011dc0:	2000ce18 	.word	0x2000ce18
 8011dc4:	2000ce30 	.word	0x2000ce30
 8011dc8:	2000ce2c 	.word	0x2000ce2c
 8011dcc:	08011951 	.word	0x08011951
 8011dd0:	200008c2 	.word	0x200008c2
 8011dd4:	2000ce10 	.word	0x2000ce10
 8011dd8:	2000ce3c 	.word	0x2000ce3c
 8011ddc:	08011901 	.word	0x08011901
 8011de0:	2000ce34 	.word	0x2000ce34
 8011de4:	2000ce0c 	.word	0x2000ce0c
 8011de8:	08011931 	.word	0x08011931
 8011dec:	080119d1 	.word	0x080119d1
 8011df0:	08011a71 	.word	0x08011a71
 8011df4:	08011b21 	.word	0x08011b21
 8011df8:	08011bd1 	.word	0x08011bd1
 8011dfc:	f3af 8000 	nop.w

08011e00 <eMBMasterEnable>:
    return eStatus;
}

eMBErrorCode
eMBMasterEnable( void )
{
 8011e00:	b510      	push	{r4, lr}
    eMBErrorCode    eStatus = MB_ENOERR;

    if( eMBState == STATE_DISABLED )
 8011e02:	4c06      	ldr	r4, [pc, #24]	; (8011e1c <eMBMasterEnable+0x1c>)
 8011e04:	7823      	ldrb	r3, [r4, #0]
 8011e06:	2b01      	cmp	r3, #1
 8011e08:	d001      	beq.n	8011e0e <eMBMasterEnable+0xe>
        pvMBMasterFrameStartCur(  );
        eMBState = STATE_ENABLED;
    }
    else
    {
        eStatus = MB_EILLSTATE;
 8011e0a:	2006      	movs	r0, #6
    }
    return eStatus;
}
 8011e0c:	bd10      	pop	{r4, pc}
    eMBErrorCode    eStatus = MB_ENOERR;

    if( eMBState == STATE_DISABLED )
    {
        /* Activate the protocol stack. */
        pvMBMasterFrameStartCur(  );
 8011e0e:	4b04      	ldr	r3, [pc, #16]	; (8011e20 <eMBMasterEnable+0x20>)
 8011e10:	681b      	ldr	r3, [r3, #0]
 8011e12:	4798      	blx	r3
        eMBState = STATE_ENABLED;
 8011e14:	2000      	movs	r0, #0
 8011e16:	7020      	strb	r0, [r4, #0]
 8011e18:	bd10      	pop	{r4, pc}
 8011e1a:	bf00      	nop
 8011e1c:	200008c2 	.word	0x200008c2
 8011e20:	2000ce1c 	.word	0x2000ce1c
 8011e24:	f3af 8000 	nop.w
 8011e28:	f3af 8000 	nop.w
 8011e2c:	f3af 8000 	nop.w

08011e30 <eMBMasterPoll>:
    return eStatus;
}

eMBErrorCode
eMBMasterPoll( void )
{
 8011e30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    eMBErrorCode    eStatus = MB_ENOERR;
    eMBMasterEventType    eEvent;
    eMBMasterErrorEventType errorType;

    /* Check if the protocol stack is ready. */
    if( eMBState != STATE_ENABLED )
 8011e34:	4b77      	ldr	r3, [pc, #476]	; (8012014 <eMBMasterPoll+0x1e4>)
 8011e36:	781c      	ldrb	r4, [r3, #0]
    return eStatus;
}

eMBErrorCode
eMBMasterPoll( void )
{
 8011e38:	b083      	sub	sp, #12
    eMBErrorCode    eStatus = MB_ENOERR;
    eMBMasterEventType    eEvent;
    eMBMasterErrorEventType errorType;

    /* Check if the protocol stack is ready. */
    if( eMBState != STATE_ENABLED )
 8011e3a:	b11c      	cbz	r4, 8011e44 <eMBMasterPoll+0x14>
    {
        return MB_EILLSTATE;
 8011e3c:	2006      	movs	r0, #6
			vMBMasterRunResRelease();
        	break;
        }
    }
    return MB_ENOERR;
}
 8011e3e:	b003      	add	sp, #12
 8011e40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return MB_EILLSTATE;
    }

    /* Check if there is a event available. If not return control to caller.
     * Otherwise we will handle the event. */
    if( xMBMasterPortEventGet( &eEvent ) == TRUE )
 8011e44:	f10d 0006 	add.w	r0, sp, #6
 8011e48:	f000 fb02 	bl	8012450 <xMBMasterPortEventGet>
 8011e4c:	2801      	cmp	r0, #1
 8011e4e:	d003      	beq.n	8011e58 <eMBMasterPoll+0x28>
			}
			vMBMasterRunResRelease();
        	break;
        }
    }
    return MB_ENOERR;
 8011e50:	2000      	movs	r0, #0
}
 8011e52:	b003      	add	sp, #12
 8011e54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

    /* Check if there is a event available. If not return control to caller.
     * Otherwise we will handle the event. */
    if( xMBMasterPortEventGet( &eEvent ) == TRUE )
    {
        switch ( eEvent )
 8011e58:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8011e5c:	3b02      	subs	r3, #2
 8011e5e:	2b0e      	cmp	r3, #14
 8011e60:	d8f6      	bhi.n	8011e50 <eMBMasterPoll+0x20>
 8011e62:	a201      	add	r2, pc, #4	; (adr r2, 8011e68 <eMBMasterPoll+0x38>)
 8011e64:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8011e68:	08011f0b 	.word	0x08011f0b
 8011e6c:	08011e51 	.word	0x08011e51
 8011e70:	08011ecf 	.word	0x08011ecf
 8011e74:	08011e51 	.word	0x08011e51
 8011e78:	08011e51 	.word	0x08011e51
 8011e7c:	08011e51 	.word	0x08011e51
 8011e80:	08011ea5 	.word	0x08011ea5
 8011e84:	08011e51 	.word	0x08011e51
 8011e88:	08011e51 	.word	0x08011e51
 8011e8c:	08011e51 	.word	0x08011e51
 8011e90:	08011e51 	.word	0x08011e51
 8011e94:	08011e51 	.word	0x08011e51
 8011e98:	08011e51 	.word	0x08011e51
 8011e9c:	08011e51 	.word	0x08011e51
 8011ea0:	08011f37 	.word	0x08011f37
            break;

        case EV_MASTER_FRAME_SENT:
        	/* Master is busy now. */
			chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Master is sending");
        	vMBMasterGetPDUSndBuf( &ucMBFrame );
 8011ea4:	4c5c      	ldr	r4, [pc, #368]	; (8012018 <eMBMasterPoll+0x1e8>)
            }
            break;

        case EV_MASTER_FRAME_SENT:
        	/* Master is busy now. */
			chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Master is sending");
 8011ea6:	495d      	ldr	r1, [pc, #372]	; (801201c <eMBMasterPoll+0x1ec>)
 8011ea8:	4a5d      	ldr	r2, [pc, #372]	; (8012020 <eMBMasterPoll+0x1f0>)
 8011eaa:	485e      	ldr	r0, [pc, #376]	; (8012024 <eMBMasterPoll+0x1f4>)
 8011eac:	f7ff ff28 	bl	8011d00 <chprintf.constprop.0>
        	vMBMasterGetPDUSndBuf( &ucMBFrame );
 8011eb0:	4620      	mov	r0, r4
 8011eb2:	f7ff fefd 	bl	8011cb0 <vMBMasterGetPDUSndBuf>
	xMBRunInMasterMode = IsMasterMode;
}
/* Get Modbus Master send destination address. */
UCHAR ucMBMasterGetDestAddress( void )
{
	return ucMBMasterDestAddress;
 8011eb6:	4a5c      	ldr	r2, [pc, #368]	; (8012028 <eMBMasterPoll+0x1f8>)

        case EV_MASTER_FRAME_SENT:
        	/* Master is busy now. */
			chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Master is sending");
        	vMBMasterGetPDUSndBuf( &ucMBFrame );
			eStatus = peMBMasterFrameSendCur( ucMBMasterGetDestAddress(), ucMBFrame, usMBMasterGetPDUSndLength() );
 8011eb8:	4b5c      	ldr	r3, [pc, #368]	; (801202c <eMBMasterPoll+0x1fc>)
 8011eba:	6825      	ldr	r5, [r4, #0]
	xMBRunInMasterMode = IsMasterMode;
}
/* Get Modbus Master send destination address. */
UCHAR ucMBMasterGetDestAddress( void )
{
	return ucMBMasterDestAddress;
 8011ebc:	7816      	ldrb	r6, [r2, #0]

        case EV_MASTER_FRAME_SENT:
        	/* Master is busy now. */
			chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Master is sending");
        	vMBMasterGetPDUSndBuf( &ucMBFrame );
			eStatus = peMBMasterFrameSendCur( ucMBMasterGetDestAddress(), ucMBFrame, usMBMasterGetPDUSndLength() );
 8011ebe:	681c      	ldr	r4, [r3, #0]
 8011ec0:	f7ff ff06 	bl	8011cd0 <usMBMasterGetPDUSndLength>
 8011ec4:	4629      	mov	r1, r5
 8011ec6:	4602      	mov	r2, r0
 8011ec8:	4630      	mov	r0, r6
 8011eca:	47a0      	blx	r4
 8011ecc:	e7c0      	b.n	8011e50 <eMBMasterPoll+0x20>
				( void ) xMBMasterPortEventPost( EV_MASTER_ERROR_PROCESS );
			}
			break;

        case EV_MASTER_EXECUTE:
            ucFunctionCode = ucMBFrame[MB_PDU_FUNC_OFF];
 8011ece:	4e52      	ldr	r6, [pc, #328]	; (8012018 <eMBMasterPoll+0x1e8>)
 8011ed0:	4a57      	ldr	r2, [pc, #348]	; (8012030 <eMBMasterPoll+0x200>)
 8011ed2:	6833      	ldr	r3, [r6, #0]
            eException = MB_EX_ILLEGAL_FUNCTION;
 8011ed4:	4d57      	ldr	r5, [pc, #348]	; (8012034 <eMBMasterPoll+0x204>)
				( void ) xMBMasterPortEventPost( EV_MASTER_ERROR_PROCESS );
			}
			break;

        case EV_MASTER_EXECUTE:
            ucFunctionCode = ucMBFrame[MB_PDU_FUNC_OFF];
 8011ed6:	7819      	ldrb	r1, [r3, #0]
 8011ed8:	7011      	strb	r1, [r2, #0]
            eException = MB_EX_ILLEGAL_FUNCTION;
 8011eda:	2201      	movs	r2, #1
 8011edc:	702a      	strb	r2, [r5, #0]
            /* If receive frame has exception .The receive function code highest bit is 1.*/
            if(ucFunctionCode >> 7) {
 8011ede:	060a      	lsls	r2, r1, #24
 8011ee0:	d443      	bmi.n	8011f6a <eMBMasterPoll+0x13a>
 8011ee2:	4855      	ldr	r0, [pc, #340]	; (8012038 <eMBMasterPoll+0x208>)
 8011ee4:	2300      	movs	r3, #0
			else
			{
				for (i = 0; i < MB_FUNC_HANDLERS_MAX; i++)
				{
					/* No more function handlers registered. Abort. */
					if (xMasterFuncHandlers[i].ucFunctionCode == 0)	{
 8011ee6:	f810 2033 	ldrb.w	r2, [r0, r3, lsl #3]
 8011eea:	4f53      	ldr	r7, [pc, #332]	; (8012038 <eMBMasterPoll+0x208>)
 8011eec:	00dc      	lsls	r4, r3, #3
            if(ucFunctionCode >> 7) {
            	eException = (eMBException)ucMBFrame[MB_PDU_DATA_OFF];
            }
			else
			{
				for (i = 0; i < MB_FUNC_HANDLERS_MAX; i++)
 8011eee:	3301      	adds	r3, #1
				{
					/* No more function handlers registered. Abort. */
					if (xMasterFuncHandlers[i].ucFunctionCode == 0)	{
 8011ef0:	b11a      	cbz	r2, 8011efa <eMBMasterPoll+0xca>
						break;
					}
					else if (xMasterFuncHandlers[i].ucFunctionCode == ucFunctionCode) {
 8011ef2:	4291      	cmp	r1, r2
 8011ef4:	d05f      	beq.n	8011fb6 <eMBMasterPoll+0x186>
            if(ucFunctionCode >> 7) {
            	eException = (eMBException)ucMBFrame[MB_PDU_DATA_OFF];
            }
			else
			{
				for (i = 0; i < MB_FUNC_HANDLERS_MAX; i++)
 8011ef6:	2b10      	cmp	r3, #16
 8011ef8:	d1f5      	bne.n	8011ee6 <eMBMasterPoll+0xb6>
	return eMBMasterCurErrorType;
}
/* Set Modbus Master current error event type. */
void vMBMasterSetErrorType( eMBMasterErrorEventType errorType )
{
	eMBMasterCurErrorType = errorType;
 8011efa:	4b50      	ldr	r3, [pc, #320]	; (801203c <eMBMasterPoll+0x20c>)
 8011efc:	2204      	movs	r2, #4
				}
			}
            /* If master has exception ,Master will send error process.Otherwise the Master is idle.*/
            if (eException != MB_EX_NONE) {
            	vMBMasterSetErrorType(EV_ERROR_EXECUTE_FUNCTION);
            	( void ) xMBMasterPortEventPost( EV_MASTER_ERROR_PROCESS );
 8011efe:	2010      	movs	r0, #16
	return eMBMasterCurErrorType;
}
/* Set Modbus Master current error event type. */
void vMBMasterSetErrorType( eMBMasterErrorEventType errorType )
{
	eMBMasterCurErrorType = errorType;
 8011f00:	701a      	strb	r2, [r3, #0]
				}
			}
            /* If master has exception ,Master will send error process.Otherwise the Master is idle.*/
            if (eException != MB_EX_NONE) {
            	vMBMasterSetErrorType(EV_ERROR_EXECUTE_FUNCTION);
            	( void ) xMBMasterPortEventPost( EV_MASTER_ERROR_PROCESS );
 8011f02:	f000 fa95 	bl	8012430 <xMBMasterPortEventPost>
			}
			vMBMasterRunResRelease();
        	break;
        }
    }
    return MB_ENOERR;
 8011f06:	2000      	movs	r0, #0
 8011f08:	e799      	b.n	8011e3e <eMBMasterPoll+0xe>
        {
        case EV_MASTER_READY:
            break;

        case EV_MASTER_FRAME_RECEIVED:
			eStatus = peMBMasterFrameReceiveCur( &ucRcvAddress, &ucMBFrame, &usLength );
 8011f0a:	4b4d      	ldr	r3, [pc, #308]	; (8012040 <eMBMasterPoll+0x210>)
 8011f0c:	4d4d      	ldr	r5, [pc, #308]	; (8012044 <eMBMasterPoll+0x214>)
 8011f0e:	681b      	ldr	r3, [r3, #0]
 8011f10:	4941      	ldr	r1, [pc, #260]	; (8012018 <eMBMasterPoll+0x1e8>)
 8011f12:	4a4d      	ldr	r2, [pc, #308]	; (8012048 <eMBMasterPoll+0x218>)
 8011f14:	4628      	mov	r0, r5
 8011f16:	4798      	blx	r3
			/* Check if the frame is for us. If not ,send an error process event. */
			if ( ( eStatus == MB_ENOERR ) && ( ucRcvAddress == ucMBMasterGetDestAddress() ) )
 8011f18:	4604      	mov	r4, r0
 8011f1a:	b920      	cbnz	r0, 8011f26 <eMBMasterPoll+0xf6>
	xMBRunInMasterMode = IsMasterMode;
}
/* Get Modbus Master send destination address. */
UCHAR ucMBMasterGetDestAddress( void )
{
	return ucMBMasterDestAddress;
 8011f1c:	4b42      	ldr	r3, [pc, #264]	; (8012028 <eMBMasterPoll+0x1f8>)
            break;

        case EV_MASTER_FRAME_RECEIVED:
			eStatus = peMBMasterFrameReceiveCur( &ucRcvAddress, &ucMBFrame, &usLength );
			/* Check if the frame is for us. If not ,send an error process event. */
			if ( ( eStatus == MB_ENOERR ) && ( ucRcvAddress == ucMBMasterGetDestAddress() ) )
 8011f1e:	782a      	ldrb	r2, [r5, #0]
 8011f20:	781b      	ldrb	r3, [r3, #0]
 8011f22:	429a      	cmp	r2, r3
 8011f24:	d068      	beq.n	8011ff8 <eMBMasterPoll+0x1c8>
	return eMBMasterCurErrorType;
}
/* Set Modbus Master current error event type. */
void vMBMasterSetErrorType( eMBMasterErrorEventType errorType )
{
	eMBMasterCurErrorType = errorType;
 8011f26:	4b45      	ldr	r3, [pc, #276]	; (801203c <eMBMasterPoll+0x20c>)
 8011f28:	2202      	movs	r2, #2
				( void ) xMBMasterPortEventPost( EV_MASTER_EXECUTE );
			}
			else
			{
				vMBMasterSetErrorType(EV_ERROR_RECEIVE_DATA);
				( void ) xMBMasterPortEventPost( EV_MASTER_ERROR_PROCESS );
 8011f2a:	2010      	movs	r0, #16
	return eMBMasterCurErrorType;
}
/* Set Modbus Master current error event type. */
void vMBMasterSetErrorType( eMBMasterErrorEventType errorType )
{
	eMBMasterCurErrorType = errorType;
 8011f2c:	701a      	strb	r2, [r3, #0]
				( void ) xMBMasterPortEventPost( EV_MASTER_EXECUTE );
			}
			else
			{
				vMBMasterSetErrorType(EV_ERROR_RECEIVE_DATA);
				( void ) xMBMasterPortEventPost( EV_MASTER_ERROR_PROCESS );
 8011f2e:	f000 fa7f 	bl	8012430 <xMBMasterPortEventPost>
			}
			vMBMasterRunResRelease();
        	break;
        }
    }
    return MB_ENOERR;
 8011f32:	2000      	movs	r0, #0
 8011f34:	e783      	b.n	8011e3e <eMBMasterPoll+0xe>
	ucMBMasterDestAddress = Address;
}
/* Get Modbus Master current error event type. */
eMBMasterErrorEventType eMBMasterGetErrorType( void )
{
	return eMBMasterCurErrorType;
 8011f36:	4b41      	ldr	r3, [pc, #260]	; (801203c <eMBMasterPoll+0x20c>)
            break;

        case EV_MASTER_ERROR_PROCESS:
        	/* Execute specified error process callback function. */
			errorType = eMBMasterGetErrorType();
			vMBMasterGetPDUSndBuf( &ucMBFrame );
 8011f38:	4d37      	ldr	r5, [pc, #220]	; (8012018 <eMBMasterPoll+0x1e8>)
	ucMBMasterDestAddress = Address;
}
/* Get Modbus Master current error event type. */
eMBMasterErrorEventType eMBMasterGetErrorType( void )
{
	return eMBMasterCurErrorType;
 8011f3a:	781c      	ldrb	r4, [r3, #0]
            break;

        case EV_MASTER_ERROR_PROCESS:
        	/* Execute specified error process callback function. */
			errorType = eMBMasterGetErrorType();
			vMBMasterGetPDUSndBuf( &ucMBFrame );
 8011f3c:	4628      	mov	r0, r5
 8011f3e:	f7ff feb7 	bl	8011cb0 <vMBMasterGetPDUSndBuf>
			switch (errorType) {
 8011f42:	2c02      	cmp	r4, #2
 8011f44:	d02c      	beq.n	8011fa0 <eMBMasterPoll+0x170>
 8011f46:	2c04      	cmp	r4, #4
 8011f48:	d01f      	beq.n	8011f8a <eMBMasterPoll+0x15a>
 8011f4a:	2c01      	cmp	r4, #1
 8011f4c:	d109      	bne.n	8011f62 <eMBMasterPoll+0x132>
	xMBRunInMasterMode = IsMasterMode;
}
/* Get Modbus Master send destination address. */
UCHAR ucMBMasterGetDestAddress( void )
{
	return ucMBMasterDestAddress;
 8011f4e:	4b36      	ldr	r3, [pc, #216]	; (8012028 <eMBMasterPoll+0x1f8>)
        	/* Execute specified error process callback function. */
			errorType = eMBMasterGetErrorType();
			vMBMasterGetPDUSndBuf( &ucMBFrame );
			switch (errorType) {
			case EV_ERROR_RESPOND_TIMEOUT:
				vMBMasterErrorCBRespondTimeout(ucMBMasterGetDestAddress(),
 8011f50:	682c      	ldr	r4, [r5, #0]
	xMBRunInMasterMode = IsMasterMode;
}
/* Get Modbus Master send destination address. */
UCHAR ucMBMasterGetDestAddress( void )
{
	return ucMBMasterDestAddress;
 8011f52:	781d      	ldrb	r5, [r3, #0]
        	/* Execute specified error process callback function. */
			errorType = eMBMasterGetErrorType();
			vMBMasterGetPDUSndBuf( &ucMBFrame );
			switch (errorType) {
			case EV_ERROR_RESPOND_TIMEOUT:
				vMBMasterErrorCBRespondTimeout(ucMBMasterGetDestAddress(),
 8011f54:	f7ff febc 	bl	8011cd0 <usMBMasterGetPDUSndLength>
 8011f58:	4621      	mov	r1, r4
 8011f5a:	4602      	mov	r2, r0
 8011f5c:	4628      	mov	r0, r5
 8011f5e:	f000 faa7 	bl	80124b0 <vMBMasterErrorCBRespondTimeout>
			case EV_ERROR_EXECUTE_FUNCTION:
				vMBMasterErrorCBExecuteFunction(ucMBMasterGetDestAddress(),
						ucMBFrame, usMBMasterGetPDUSndLength());
				break;
			}
			vMBMasterRunResRelease();
 8011f62:	f000 fa9d 	bl	80124a0 <vMBMasterRunResRelease>
        	break;
        }
    }
    return MB_ENOERR;
 8011f66:	2000      	movs	r0, #0
				vMBMasterErrorCBExecuteFunction(ucMBMasterGetDestAddress(),
						ucMBFrame, usMBMasterGetPDUSndLength());
				break;
			}
			vMBMasterRunResRelease();
        	break;
 8011f68:	e769      	b.n	8011e3e <eMBMasterPoll+0xe>
        case EV_MASTER_EXECUTE:
            ucFunctionCode = ucMBFrame[MB_PDU_FUNC_OFF];
            eException = MB_EX_ILLEGAL_FUNCTION;
            /* If receive frame has exception .The receive function code highest bit is 1.*/
            if(ucFunctionCode >> 7) {
            	eException = (eMBException)ucMBFrame[MB_PDU_DATA_OFF];
 8011f6a:	7858      	ldrb	r0, [r3, #1]
 8011f6c:	7028      	strb	r0, [r5, #0]
 8011f6e:	4604      	mov	r4, r0
						break;
					}
				}
			}
            /* If master has exception ,Master will send error process.Otherwise the Master is idle.*/
            if (eException != MB_EX_NONE) {
 8011f70:	2c00      	cmp	r4, #0
 8011f72:	d1c2      	bne.n	8011efa <eMBMasterPoll+0xca>
            	vMBMasterSetErrorType(EV_ERROR_EXECUTE_FUNCTION);
            	( void ) xMBMasterPortEventPost( EV_MASTER_ERROR_PROCESS );
            }
            else {
				chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Release Resource");
 8011f74:	4929      	ldr	r1, [pc, #164]	; (801201c <eMBMasterPoll+0x1ec>)
 8011f76:	4a35      	ldr	r2, [pc, #212]	; (801204c <eMBMasterPoll+0x21c>)
 8011f78:	482a      	ldr	r0, [pc, #168]	; (8012024 <eMBMasterPoll+0x1f4>)
 8011f7a:	f7ff fec1 	bl	8011d00 <chprintf.constprop.0>
            	vMBMasterCBRequestScuuess( );
 8011f7e:	f000 fac7 	bl	8012510 <vMBMasterCBRequestScuuess>
            	vMBMasterRunResRelease( );
 8011f82:	f000 fa8d 	bl	80124a0 <vMBMasterRunResRelease>
			}
			vMBMasterRunResRelease();
        	break;
        }
    }
    return MB_ENOERR;
 8011f86:	4620      	mov	r0, r4
 8011f88:	e759      	b.n	8011e3e <eMBMasterPoll+0xe>
	xMBRunInMasterMode = IsMasterMode;
}
/* Get Modbus Master send destination address. */
UCHAR ucMBMasterGetDestAddress( void )
{
	return ucMBMasterDestAddress;
 8011f8a:	4b27      	ldr	r3, [pc, #156]	; (8012028 <eMBMasterPoll+0x1f8>)
			case EV_ERROR_RECEIVE_DATA:
				vMBMasterErrorCBReceiveData(ucMBMasterGetDestAddress(),
						ucMBFrame, usMBMasterGetPDUSndLength());
				break;
			case EV_ERROR_EXECUTE_FUNCTION:
				vMBMasterErrorCBExecuteFunction(ucMBMasterGetDestAddress(),
 8011f8c:	682c      	ldr	r4, [r5, #0]
	xMBRunInMasterMode = IsMasterMode;
}
/* Get Modbus Master send destination address. */
UCHAR ucMBMasterGetDestAddress( void )
{
	return ucMBMasterDestAddress;
 8011f8e:	781d      	ldrb	r5, [r3, #0]
			case EV_ERROR_RECEIVE_DATA:
				vMBMasterErrorCBReceiveData(ucMBMasterGetDestAddress(),
						ucMBFrame, usMBMasterGetPDUSndLength());
				break;
			case EV_ERROR_EXECUTE_FUNCTION:
				vMBMasterErrorCBExecuteFunction(ucMBMasterGetDestAddress(),
 8011f90:	f7ff fe9e 	bl	8011cd0 <usMBMasterGetPDUSndLength>
 8011f94:	4621      	mov	r1, r4
 8011f96:	4602      	mov	r2, r0
 8011f98:	4628      	mov	r0, r5
 8011f9a:	f000 faa9 	bl	80124f0 <vMBMasterErrorCBExecuteFunction>
						ucMBFrame, usMBMasterGetPDUSndLength());
				break;
 8011f9e:	e7e0      	b.n	8011f62 <eMBMasterPoll+0x132>
	xMBRunInMasterMode = IsMasterMode;
}
/* Get Modbus Master send destination address. */
UCHAR ucMBMasterGetDestAddress( void )
{
	return ucMBMasterDestAddress;
 8011fa0:	4b21      	ldr	r3, [pc, #132]	; (8012028 <eMBMasterPoll+0x1f8>)
			case EV_ERROR_RESPOND_TIMEOUT:
				vMBMasterErrorCBRespondTimeout(ucMBMasterGetDestAddress(),
						ucMBFrame, usMBMasterGetPDUSndLength());
				break;
			case EV_ERROR_RECEIVE_DATA:
				vMBMasterErrorCBReceiveData(ucMBMasterGetDestAddress(),
 8011fa2:	682c      	ldr	r4, [r5, #0]
	xMBRunInMasterMode = IsMasterMode;
}
/* Get Modbus Master send destination address. */
UCHAR ucMBMasterGetDestAddress( void )
{
	return ucMBMasterDestAddress;
 8011fa4:	781d      	ldrb	r5, [r3, #0]
			case EV_ERROR_RESPOND_TIMEOUT:
				vMBMasterErrorCBRespondTimeout(ucMBMasterGetDestAddress(),
						ucMBFrame, usMBMasterGetPDUSndLength());
				break;
			case EV_ERROR_RECEIVE_DATA:
				vMBMasterErrorCBReceiveData(ucMBMasterGetDestAddress(),
 8011fa6:	f7ff fe93 	bl	8011cd0 <usMBMasterGetPDUSndLength>
 8011faa:	4621      	mov	r1, r4
 8011fac:	4602      	mov	r2, r0
 8011fae:	4628      	mov	r0, r5
 8011fb0:	f000 fa8e 	bl	80124d0 <vMBMasterErrorCBReceiveData>
						ucMBFrame, usMBMasterGetPDUSndLength());
				break;
 8011fb4:	e7d5      	b.n	8011f62 <eMBMasterPoll+0x132>
	return xMBRunInMasterMode;
}
/* Set whether the Modbus Master is run in master mode.*/
void vMBMasterSetCBRunInMasterMode( BOOL IsMasterMode )
{
	xMBRunInMasterMode = IsMasterMode;
 8011fb6:	f8df 8098 	ldr.w	r8, [pc, #152]	; 8012050 <eMBMasterPoll+0x220>
 8011fba:	f04f 0901 	mov.w	r9, #1
 8011fbe:	f888 9000 	strb.w	r9, [r8]
					else if (xMasterFuncHandlers[i].ucFunctionCode == ucFunctionCode) {
						vMBMasterSetCBRunInMasterMode(TRUE);
						/* If master request is broadcast,
						 * the master need execute function for all slave.
						 */
						if ( xMBMasterRequestIsBroadcast() ) {
 8011fc2:	f7ff fe95 	bl	8011cf0 <xMBMasterRequestIsBroadcast>
 8011fc6:	b1e0      	cbz	r0, 8012002 <eMBMasterPoll+0x1d2>
							usLength = usMBMasterGetPDUSndLength();
 8011fc8:	f7ff fe82 	bl	8011cd0 <usMBMasterGetPDUSndLength>
 8011fcc:	443c      	add	r4, r7
 8011fce:	4b1e      	ldr	r3, [pc, #120]	; (8012048 <eMBMasterPoll+0x218>)
 8011fd0:	f8d4 b004 	ldr.w	fp, [r4, #4]
 8011fd4:	f8df a050 	ldr.w	sl, [pc, #80]	; 8012028 <eMBMasterPoll+0x1f8>
 8011fd8:	8018      	strh	r0, [r3, #0]
							for(j = 1; j <= MB_MASTER_TOTAL_SLAVE_NUM; j++){
 8011fda:	464f      	mov	r7, r9
								vMBMasterSetDestAddress(j);
 8011fdc:	f88a 7000 	strb.w	r7, [sl]
								eException = xMasterFuncHandlers[i].pxHandler(ucMBFrame, &usLength);
 8011fe0:	6830      	ldr	r0, [r6, #0]
 8011fe2:	4919      	ldr	r1, [pc, #100]	; (8012048 <eMBMasterPoll+0x218>)
 8011fe4:	47d8      	blx	fp
						/* If master request is broadcast,
						 * the master need execute function for all slave.
						 */
						if ( xMBMasterRequestIsBroadcast() ) {
							usLength = usMBMasterGetPDUSndLength();
							for(j = 1; j <= MB_MASTER_TOTAL_SLAVE_NUM; j++){
 8011fe6:	3701      	adds	r7, #1
 8011fe8:	2f11      	cmp	r7, #17
								vMBMasterSetDestAddress(j);
								eException = xMasterFuncHandlers[i].pxHandler(ucMBFrame, &usLength);
 8011fea:	4604      	mov	r4, r0
 8011fec:	7028      	strb	r0, [r5, #0]
						/* If master request is broadcast,
						 * the master need execute function for all slave.
						 */
						if ( xMBMasterRequestIsBroadcast() ) {
							usLength = usMBMasterGetPDUSndLength();
							for(j = 1; j <= MB_MASTER_TOTAL_SLAVE_NUM; j++){
 8011fee:	d1f5      	bne.n	8011fdc <eMBMasterPoll+0x1ac>
	return xMBRunInMasterMode;
}
/* Set whether the Modbus Master is run in master mode.*/
void vMBMasterSetCBRunInMasterMode( BOOL IsMasterMode )
{
	xMBRunInMasterMode = IsMasterMode;
 8011ff0:	2300      	movs	r3, #0
 8011ff2:	f888 3000 	strb.w	r3, [r8]
 8011ff6:	e7bb      	b.n	8011f70 <eMBMasterPoll+0x140>
        case EV_MASTER_FRAME_RECEIVED:
			eStatus = peMBMasterFrameReceiveCur( &ucRcvAddress, &ucMBFrame, &usLength );
			/* Check if the frame is for us. If not ,send an error process event. */
			if ( ( eStatus == MB_ENOERR ) && ( ucRcvAddress == ucMBMasterGetDestAddress() ) )
			{
				( void ) xMBMasterPortEventPost( EV_MASTER_EXECUTE );
 8011ff8:	2004      	movs	r0, #4
 8011ffa:	f000 fa19 	bl	8012430 <xMBMasterPortEventPost>
			}
			vMBMasterRunResRelease();
        	break;
        }
    }
    return MB_ENOERR;
 8011ffe:	4620      	mov	r0, r4
        case EV_MASTER_FRAME_RECEIVED:
			eStatus = peMBMasterFrameReceiveCur( &ucRcvAddress, &ucMBFrame, &usLength );
			/* Check if the frame is for us. If not ,send an error process event. */
			if ( ( eStatus == MB_ENOERR ) && ( ucRcvAddress == ucMBMasterGetDestAddress() ) )
			{
				( void ) xMBMasterPortEventPost( EV_MASTER_EXECUTE );
 8012000:	e71d      	b.n	8011e3e <eMBMasterPoll+0xe>
								vMBMasterSetDestAddress(j);
								eException = xMasterFuncHandlers[i].pxHandler(ucMBFrame, &usLength);
							}
						}
						else {
							eException = xMasterFuncHandlers[i].pxHandler(ucMBFrame, &usLength);
 8012002:	443c      	add	r4, r7
 8012004:	6830      	ldr	r0, [r6, #0]
 8012006:	6863      	ldr	r3, [r4, #4]
 8012008:	490f      	ldr	r1, [pc, #60]	; (8012048 <eMBMasterPoll+0x218>)
 801200a:	4798      	blx	r3
 801200c:	4604      	mov	r4, r0
 801200e:	7028      	strb	r0, [r5, #0]
 8012010:	e7ee      	b.n	8011ff0 <eMBMasterPoll+0x1c0>
 8012012:	bf00      	nop
 8012014:	200008c2 	.word	0x200008c2
 8012018:	2000ce24 	.word	0x2000ce24
 801201c:	08017004 	.word	0x08017004
 8012020:	08019604 	.word	0x08019604
 8012024:	200180c8 	.word	0x200180c8
 8012028:	2000ce14 	.word	0x2000ce14
 801202c:	2000ce3c 	.word	0x2000ce3c
 8012030:	2000ce17 	.word	0x2000ce17
 8012034:	2000ce38 	.word	0x2000ce38
 8012038:	08019620 	.word	0x08019620
 801203c:	2000ce28 	.word	0x2000ce28
 8012040:	2000ce34 	.word	0x2000ce34
 8012044:	2000ce16 	.word	0x2000ce16
 8012048:	2000ce20 	.word	0x2000ce20
 801204c:	080195f0 	.word	0x080195f0
 8012050:	2000ce15 	.word	0x2000ce15
 8012054:	f3af 8000 	nop.w
 8012058:	f3af 8000 	nop.w
 801205c:	f3af 8000 	nop.w

08012060 <ucMBMasterGetDestAddress>:
	xMBRunInMasterMode = IsMasterMode;
}
/* Get Modbus Master send destination address. */
UCHAR ucMBMasterGetDestAddress( void )
{
	return ucMBMasterDestAddress;
 8012060:	4b01      	ldr	r3, [pc, #4]	; (8012068 <ucMBMasterGetDestAddress+0x8>)
}
 8012062:	7818      	ldrb	r0, [r3, #0]
 8012064:	4770      	bx	lr
 8012066:	bf00      	nop
 8012068:	2000ce14 	.word	0x2000ce14
 801206c:	f3af 8000 	nop.w

08012070 <vMBMasterSetDestAddress>:
/* Set Modbus Master send destination address. */
void vMBMasterSetDestAddress( UCHAR Address )
{
	ucMBMasterDestAddress = Address;
 8012070:	4b01      	ldr	r3, [pc, #4]	; (8012078 <vMBMasterSetDestAddress+0x8>)
 8012072:	7018      	strb	r0, [r3, #0]
 8012074:	4770      	bx	lr
 8012076:	bf00      	nop
 8012078:	2000ce14 	.word	0x2000ce14
 801207c:	f3af 8000 	nop.w

08012080 <eMBMasterGetErrorType>:
}
/* Get Modbus Master current error event type. */
eMBMasterErrorEventType eMBMasterGetErrorType( void )
{
	return eMBMasterCurErrorType;
 8012080:	4b01      	ldr	r3, [pc, #4]	; (8012088 <eMBMasterGetErrorType+0x8>)
}
 8012082:	7818      	ldrb	r0, [r3, #0]
 8012084:	4770      	bx	lr
 8012086:	bf00      	nop
 8012088:	2000ce28 	.word	0x2000ce28
 801208c:	f3af 8000 	nop.w

08012090 <vMBMasterSetErrorType>:
/* Set Modbus Master current error event type. */
void vMBMasterSetErrorType( eMBMasterErrorEventType errorType )
{
	eMBMasterCurErrorType = errorType;
 8012090:	4b01      	ldr	r3, [pc, #4]	; (8012098 <vMBMasterSetErrorType+0x8>)
 8012092:	7018      	strb	r0, [r3, #0]
 8012094:	4770      	bx	lr
 8012096:	bf00      	nop
 8012098:	2000ce28 	.word	0x2000ce28
 801209c:	f3af 8000 	nop.w

080120a0 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80120a0:	b40e      	push	{r1, r2, r3}
 80120a2:	b500      	push	{lr}
 80120a4:	b082      	sub	sp, #8
 80120a6:	aa03      	add	r2, sp, #12
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
 80120a8:	4805      	ldr	r0, [pc, #20]	; (80120c0 <chprintf.constprop.0+0x20>)
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80120aa:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80120ae:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80120b0:	f7fe fe26 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 80120b4:	b002      	add	sp, #8
 80120b6:	f85d eb04 	ldr.w	lr, [sp], #4
 80120ba:	b003      	add	sp, #12
 80120bc:	4770      	bx	lr
 80120be:	bf00      	nop
 80120c0:	200180c8 	.word	0x200180c8
 80120c4:	f3af 8000 	nop.w
 80120c8:	f3af 8000 	nop.w
 80120cc:	f3af 8000 	nop.w

080120d0 <display_holding>:
static uint16_t	xtholdingNRegs;
static uint16_t	xtholdingRegIndex;
static USHORT   usMRegHoldStart                            = M_REG_HOLDING_START;
static USHORT   usMRegHoldBuf[MB_MASTER_TOTAL_SLAVE_NUM][M_REG_HOLDING_NREGS];

void display_holding(void){
 80120d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80120d4:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 8012198 <display_holding+0xc8>
 80120d8:	4f24      	ldr	r7, [pc, #144]	; (801216c <display_holding+0x9c>)
 80120da:	4e25      	ldr	r6, [pc, #148]	; (8012170 <display_holding+0xa0>)
	uint16_t			i;
	
	for(i = 0; i <= xtholdingNRegs; i++){
 80120dc:	2400      	movs	r4, #0
		chprintf((BaseSequentialStream *)&itm_port, "usMRegHoldBuf[%d]: %d\n", xtholdingRegIndex + i, usMRegHoldBuf[ucMBMasterGetDestAddress() - 1][xtholdingRegIndex + i]);
 80120de:	f44f 7516 	mov.w	r5, #600	; 0x258
 80120e2:	f7ff ffbd 	bl	8012060 <ucMBMasterGetDestAddress>
 80120e6:	f8b8 2000 	ldrh.w	r2, [r8]
 80120ea:	4922      	ldr	r1, [pc, #136]	; (8012174 <display_holding+0xa4>)
 80120ec:	4422      	add	r2, r4
 80120ee:	3801      	subs	r0, #1
 80120f0:	fb05 2000 	mla	r0, r5, r0, r2
static USHORT   usMRegHoldBuf[MB_MASTER_TOTAL_SLAVE_NUM][M_REG_HOLDING_NREGS];

void display_holding(void){
	uint16_t			i;
	
	for(i = 0; i <= xtholdingNRegs; i++){
 80120f4:	3401      	adds	r4, #1
		chprintf((BaseSequentialStream *)&itm_port, "usMRegHoldBuf[%d]: %d\n", xtholdingRegIndex + i, usMRegHoldBuf[ucMBMasterGetDestAddress() - 1][xtholdingRegIndex + i]);
 80120f6:	f837 3010 	ldrh.w	r3, [r7, r0, lsl #1]
 80120fa:	481f      	ldr	r0, [pc, #124]	; (8012178 <display_holding+0xa8>)
 80120fc:	f7ff ffd0 	bl	80120a0 <chprintf.constprop.0>
static USHORT   usMRegHoldBuf[MB_MASTER_TOTAL_SLAVE_NUM][M_REG_HOLDING_NREGS];

void display_holding(void){
	uint16_t			i;
	
	for(i = 0; i <= xtholdingNRegs; i++){
 8012100:	8833      	ldrh	r3, [r6, #0]
 8012102:	b2a4      	uxth	r4, r4
 8012104:	42a3      	cmp	r3, r4
 8012106:	d2ec      	bcs.n	80120e2 <display_holding+0x12>
 8012108:	f8df 8090 	ldr.w	r8, [pc, #144]	; 801219c <display_holding+0xcc>
 801210c:	4f1b      	ldr	r7, [pc, #108]	; (801217c <display_holding+0xac>)
 801210e:	4e1c      	ldr	r6, [pc, #112]	; (8012180 <display_holding+0xb0>)
 8012110:	2400      	movs	r4, #0
		chprintf((BaseSequentialStream *)&itm_port, "usMRegHoldBuf[%d]: %d\n", xtholdingRegIndex + i, usMRegHoldBuf[ucMBMasterGetDestAddress() - 1][xtholdingRegIndex + i]);
	}
	for(i = 0; i <= xtinputNRegs; i++){
		chprintf((BaseSequentialStream *)&itm_port, "usMRegInBuf[%d]: %d\n", xtinputRegIndex + i, usMRegInBuf[ucMBMasterGetDestAddress() - 1][xtinputRegIndex + i]);
 8012112:	f44f 7516 	mov.w	r5, #600	; 0x258
 8012116:	f7ff ffa3 	bl	8012060 <ucMBMasterGetDestAddress>
 801211a:	f8b8 2000 	ldrh.w	r2, [r8]
 801211e:	4919      	ldr	r1, [pc, #100]	; (8012184 <display_holding+0xb4>)
 8012120:	4422      	add	r2, r4
 8012122:	3801      	subs	r0, #1
 8012124:	fb05 2000 	mla	r0, r5, r0, r2
	uint16_t			i;
	
	for(i = 0; i <= xtholdingNRegs; i++){
		chprintf((BaseSequentialStream *)&itm_port, "usMRegHoldBuf[%d]: %d\n", xtholdingRegIndex + i, usMRegHoldBuf[ucMBMasterGetDestAddress() - 1][xtholdingRegIndex + i]);
	}
	for(i = 0; i <= xtinputNRegs; i++){
 8012128:	3401      	adds	r4, #1
		chprintf((BaseSequentialStream *)&itm_port, "usMRegInBuf[%d]: %d\n", xtinputRegIndex + i, usMRegInBuf[ucMBMasterGetDestAddress() - 1][xtinputRegIndex + i]);
 801212a:	f837 3010 	ldrh.w	r3, [r7, r0, lsl #1]
 801212e:	4812      	ldr	r0, [pc, #72]	; (8012178 <display_holding+0xa8>)
 8012130:	f7ff ffb6 	bl	80120a0 <chprintf.constprop.0>
	uint16_t			i;
	
	for(i = 0; i <= xtholdingNRegs; i++){
		chprintf((BaseSequentialStream *)&itm_port, "usMRegHoldBuf[%d]: %d\n", xtholdingRegIndex + i, usMRegHoldBuf[ucMBMasterGetDestAddress() - 1][xtholdingRegIndex + i]);
	}
	for(i = 0; i <= xtinputNRegs; i++){
 8012134:	8833      	ldrh	r3, [r6, #0]
 8012136:	b2a4      	uxth	r4, r4
 8012138:	42a3      	cmp	r3, r4
 801213a:	d2ec      	bcs.n	8012116 <display_holding+0x46>
 801213c:	4f12      	ldr	r7, [pc, #72]	; (8012188 <display_holding+0xb8>)
 801213e:	4e13      	ldr	r6, [pc, #76]	; (801218c <display_holding+0xbc>)
 8012140:	4d13      	ldr	r5, [pc, #76]	; (8012190 <display_holding+0xc0>)
 8012142:	2400      	movs	r4, #0
		chprintf((BaseSequentialStream *)&itm_port, "usMRegInBuf[%d]: %d\n", xtinputRegIndex + i, usMRegInBuf[ucMBMasterGetDestAddress() - 1][xtinputRegIndex + i]);
	}
	for(i = 0; i <= xtCoilNRegs; i++){
		chprintf((BaseSequentialStream *)&itm_port, "ucMCoilBuf[%d]: %d\n", xtCoilRegIndex + i, ucMCoilBuf[ucMBMasterGetDestAddress() - 1][xtCoilRegIndex + i]);
 8012144:	f7ff ff8c 	bl	8012060 <ucMBMasterGetDestAddress>
 8012148:	883a      	ldrh	r2, [r7, #0]
 801214a:	4912      	ldr	r1, [pc, #72]	; (8012194 <display_holding+0xc4>)
 801214c:	3801      	subs	r0, #1
 801214e:	4422      	add	r2, r4
 8012150:	ebc0 1080 	rsb	r0, r0, r0, lsl #6
 8012154:	4410      	add	r0, r2
		chprintf((BaseSequentialStream *)&itm_port, "usMRegHoldBuf[%d]: %d\n", xtholdingRegIndex + i, usMRegHoldBuf[ucMBMasterGetDestAddress() - 1][xtholdingRegIndex + i]);
	}
	for(i = 0; i <= xtinputNRegs; i++){
		chprintf((BaseSequentialStream *)&itm_port, "usMRegInBuf[%d]: %d\n", xtinputRegIndex + i, usMRegInBuf[ucMBMasterGetDestAddress() - 1][xtinputRegIndex + i]);
	}
	for(i = 0; i <= xtCoilNRegs; i++){
 8012156:	3401      	adds	r4, #1
		chprintf((BaseSequentialStream *)&itm_port, "ucMCoilBuf[%d]: %d\n", xtCoilRegIndex + i, ucMCoilBuf[ucMBMasterGetDestAddress() - 1][xtCoilRegIndex + i]);
 8012158:	5c33      	ldrb	r3, [r6, r0]
 801215a:	4807      	ldr	r0, [pc, #28]	; (8012178 <display_holding+0xa8>)
 801215c:	f7ff ffa0 	bl	80120a0 <chprintf.constprop.0>
		chprintf((BaseSequentialStream *)&itm_port, "usMRegHoldBuf[%d]: %d\n", xtholdingRegIndex + i, usMRegHoldBuf[ucMBMasterGetDestAddress() - 1][xtholdingRegIndex + i]);
	}
	for(i = 0; i <= xtinputNRegs; i++){
		chprintf((BaseSequentialStream *)&itm_port, "usMRegInBuf[%d]: %d\n", xtinputRegIndex + i, usMRegInBuf[ucMBMasterGetDestAddress() - 1][xtinputRegIndex + i]);
	}
	for(i = 0; i <= xtCoilNRegs; i++){
 8012160:	882b      	ldrh	r3, [r5, #0]
 8012162:	b2a4      	uxth	r4, r4
 8012164:	42a3      	cmp	r3, r4
 8012166:	d2ed      	bcs.n	8012144 <display_holding+0x74>
		chprintf((BaseSequentialStream *)&itm_port, "ucMCoilBuf[%d]: %d\n", xtCoilRegIndex + i, ucMCoilBuf[ucMBMasterGetDestAddress() - 1][xtCoilRegIndex + i]);
	}
}
 8012168:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801216c:	20011d40 	.word	0x20011d40
 8012170:	20011944 	.word	0x20011944
 8012174:	080196a0 	.word	0x080196a0
 8012178:	200180c8 	.word	0x200180c8
 801217c:	2000ce44 	.word	0x2000ce44
 8012180:	20011d3a 	.word	0x20011d3a
 8012184:	080196b8 	.word	0x080196b8
 8012188:	2000ce40 	.word	0x2000ce40
 801218c:	20016844 	.word	0x20016844
 8012190:	20011d38 	.word	0x20011d38
 8012194:	080196d0 	.word	0x080196d0
 8012198:	20011d3e 	.word	0x20011d3e
 801219c:	20011d3c 	.word	0x20011d3c

080121a0 <eMBMasterRegInputCB>:
 * @param usNRegs input register number
 *
 * @return result
 */
eMBErrorCode eMBMasterRegInputCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs )
{
 80121a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    USHORT *        pusRegInputBuf;
    USHORT          REG_INPUT_START;
    USHORT          REG_INPUT_NREGS;
    USHORT          usRegInStart;

    xtinputNRegs = usNRegs;
 80121a2:	4b16      	ldr	r3, [pc, #88]	; (80121fc <eMBMasterRegInputCB+0x5c>)
 * @param usNRegs input register number
 *
 * @return result
 */
eMBErrorCode eMBMasterRegInputCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs )
{
 80121a4:	460c      	mov	r4, r1
 80121a6:	4617      	mov	r7, r2
 80121a8:	4605      	mov	r5, r0
    USHORT *        pusRegInputBuf;
    USHORT          REG_INPUT_START;
    USHORT          REG_INPUT_NREGS;
    USHORT          usRegInStart;

    xtinputNRegs = usNRegs;
 80121aa:	801a      	strh	r2, [r3, #0]

    pusRegInputBuf = usMRegInBuf[ucMBMasterGetDestAddress() - 1];
 80121ac:	f7ff ff58 	bl	8012060 <ucMBMasterGetDestAddress>
    REG_INPUT_START = M_REG_INPUT_START;
    REG_INPUT_NREGS = M_REG_INPUT_NREGS;
    usRegInStart = usMRegInStart;

    /* it already plus one in modbus function method. */
    usAddress--;
 80121b0:	1e61      	subs	r1, r4, #1
 80121b2:	b289      	uxth	r1, r1

    if ((usAddress >= REG_INPUT_START)
            && (usAddress + usNRegs <= REG_INPUT_START + REG_INPUT_NREGS))
 80121b4:	19ce      	adds	r6, r1, r7
 80121b6:	f5b6 7f16 	cmp.w	r6, #600	; 0x258
 80121ba:	dc1c      	bgt.n	80121f6 <eMBMasterRegInputCB+0x56>
    {
        iRegIndex = usAddress - usRegInStart;
		xtinputRegIndex = iRegIndex;
 80121bc:	4b10      	ldr	r3, [pc, #64]	; (8012200 <eMBMasterRegInputCB+0x60>)
 80121be:	8019      	strh	r1, [r3, #0]
        while (usNRegs > 0)
 80121c0:	b1bf      	cbz	r7, 80121f2 <eMBMasterRegInputCB+0x52>
 80121c2:	4b10      	ldr	r3, [pc, #64]	; (8012204 <eMBMasterRegInputCB+0x64>)
 80121c4:	3801      	subs	r0, #1
    USHORT          REG_INPUT_NREGS;
    USHORT          usRegInStart;

    xtinputNRegs = usNRegs;

    pusRegInputBuf = usMRegInBuf[ucMBMasterGetDestAddress() - 1];
 80121c6:	f44f 6496 	mov.w	r4, #1200	; 0x4b0
 80121ca:	1caa      	adds	r2, r5, #2
 80121cc:	b2b6      	uxth	r6, r6
 80121ce:	fb04 3000 	mla	r0, r4, r0, r3
    {
        iRegIndex = usAddress - usRegInStart;
		xtinputRegIndex = iRegIndex;
        while (usNRegs > 0)
        {
            pusRegInputBuf[iRegIndex] = *pucRegBuffer++ << 8;
 80121d2:	f812 3c02 	ldrb.w	r3, [r2, #-2]
 80121d6:	021b      	lsls	r3, r3, #8
 80121d8:	f820 3011 	strh.w	r3, [r0, r1, lsl #1]
            pusRegInputBuf[iRegIndex] |= *pucRegBuffer++;
 80121dc:	f812 4c01 	ldrb.w	r4, [r2, #-1]
            iRegIndex++;
 80121e0:	1c4d      	adds	r5, r1, #1
        iRegIndex = usAddress - usRegInStart;
		xtinputRegIndex = iRegIndex;
        while (usNRegs > 0)
        {
            pusRegInputBuf[iRegIndex] = *pucRegBuffer++ << 8;
            pusRegInputBuf[iRegIndex] |= *pucRegBuffer++;
 80121e2:	4323      	orrs	r3, r4
 80121e4:	f820 3011 	strh.w	r3, [r0, r1, lsl #1]
            iRegIndex++;
 80121e8:	b2a9      	uxth	r1, r5
    if ((usAddress >= REG_INPUT_START)
            && (usAddress + usNRegs <= REG_INPUT_START + REG_INPUT_NREGS))
    {
        iRegIndex = usAddress - usRegInStart;
		xtinputRegIndex = iRegIndex;
        while (usNRegs > 0)
 80121ea:	42b1      	cmp	r1, r6
 80121ec:	f102 0202 	add.w	r2, r2, #2
 80121f0:	d1ef      	bne.n	80121d2 <eMBMasterRegInputCB+0x32>
 *
 * @return result
 */
eMBErrorCode eMBMasterRegInputCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs )
{
    eMBErrorCode    eStatus = MB_ENOERR;
 80121f2:	2000      	movs	r0, #0
 80121f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            usNRegs--;
        }
    }
    else
    {
        eStatus = MB_ENOREG;
 80121f6:	2001      	movs	r0, #1
    }

    return eStatus;
}
 80121f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80121fa:	bf00      	nop
 80121fc:	20011d3a 	.word	0x20011d3a
 8012200:	20011d3c 	.word	0x20011d3c
 8012204:	2000ce44 	.word	0x2000ce44
 8012208:	f3af 8000 	nop.w
 801220c:	f3af 8000 	nop.w

08012210 <eMBMasterRegHoldingCB>:
 *
 * @return result
 */
eMBErrorCode
eMBMasterRegHoldingCB(uint8_t* pucRegBuffer, uint16_t usAddress, uint16_t usNRegs, eMBRegisterMode eMode)
{
 8012210:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint16_t *        pusRegHoldingBuf;
    uint16_t          REG_HOLDING_START;
    uint16_t          REG_HOLDING_NREGS;
    uint16_t          usRegHoldStart;
	
	xtholdingNRegs = usNRegs;
 8012212:	4b16      	ldr	r3, [pc, #88]	; (801226c <eMBMasterRegHoldingCB+0x5c>)
 *
 * @return result
 */
eMBErrorCode
eMBMasterRegHoldingCB(uint8_t* pucRegBuffer, uint16_t usAddress, uint16_t usNRegs, eMBRegisterMode eMode)
{
 8012214:	460c      	mov	r4, r1
 8012216:	4617      	mov	r7, r2
 8012218:	4605      	mov	r5, r0
    uint16_t *        pusRegHoldingBuf;
    uint16_t          REG_HOLDING_START;
    uint16_t          REG_HOLDING_NREGS;
    uint16_t          usRegHoldStart;
	
	xtholdingNRegs = usNRegs;
 801221a:	801a      	strh	r2, [r3, #0]

    pusRegHoldingBuf = usMRegHoldBuf[ucMBMasterGetDestAddress() - 1];
 801221c:	f7ff ff20 	bl	8012060 <ucMBMasterGetDestAddress>
    usRegHoldStart = usMRegHoldStart;
    /* if mode is read, the master will write the received date to buffer. */
    eMode = MB_REG_WRITE;

    /* it already plus one in modbus function method. */
    usAddress--;
 8012220:	1e61      	subs	r1, r4, #1
 8012222:	b289      	uxth	r1, r1
	//chprintf((BaseSequentialStream *)&itm_port,"usAddress: %d\n", usAddress);

    if ((usAddress >= REG_HOLDING_START)
            && (usAddress + usNRegs <= REG_HOLDING_START + REG_HOLDING_NREGS))
 8012224:	19ce      	adds	r6, r1, r7
 8012226:	f5b6 7f16 	cmp.w	r6, #600	; 0x258
 801222a:	dc1c      	bgt.n	8012266 <eMBMasterRegHoldingCB+0x56>
    {
        iRegIndex = usAddress - usRegHoldStart;
		xtholdingRegIndex = iRegIndex;
 801222c:	4b10      	ldr	r3, [pc, #64]	; (8012270 <eMBMasterRegHoldingCB+0x60>)
 801222e:	8019      	strh	r1, [r3, #0]
                usNRegs--;
            }
            break;
        /* write current register values with new values from the protocol stack. */
        case MB_REG_WRITE:
            while (usNRegs > 0)
 8012230:	b1bf      	cbz	r7, 8012262 <eMBMasterRegHoldingCB+0x52>
 8012232:	4b10      	ldr	r3, [pc, #64]	; (8012274 <eMBMasterRegHoldingCB+0x64>)
 8012234:	3801      	subs	r0, #1
    uint16_t          REG_HOLDING_NREGS;
    uint16_t          usRegHoldStart;
	
	xtholdingNRegs = usNRegs;

    pusRegHoldingBuf = usMRegHoldBuf[ucMBMasterGetDestAddress() - 1];
 8012236:	f44f 6496 	mov.w	r4, #1200	; 0x4b0
 801223a:	1caa      	adds	r2, r5, #2
 801223c:	b2b6      	uxth	r6, r6
 801223e:	fb04 3000 	mla	r0, r4, r0, r3
            break;
        /* write current register values with new values from the protocol stack. */
        case MB_REG_WRITE:
            while (usNRegs > 0)
            {
                pusRegHoldingBuf[iRegIndex] = *pucRegBuffer++ << 8;
 8012242:	f812 3c02 	ldrb.w	r3, [r2, #-2]
 8012246:	021b      	lsls	r3, r3, #8
 8012248:	f820 3011 	strh.w	r3, [r0, r1, lsl #1]
                pusRegHoldingBuf[iRegIndex] |= *pucRegBuffer++;
 801224c:	f812 4c01 	ldrb.w	r4, [r2, #-1]
                iRegIndex++;
 8012250:	1c4d      	adds	r5, r1, #1
        /* write current register values with new values from the protocol stack. */
        case MB_REG_WRITE:
            while (usNRegs > 0)
            {
                pusRegHoldingBuf[iRegIndex] = *pucRegBuffer++ << 8;
                pusRegHoldingBuf[iRegIndex] |= *pucRegBuffer++;
 8012252:	4323      	orrs	r3, r4
 8012254:	f820 3011 	strh.w	r3, [r0, r1, lsl #1]
                iRegIndex++;
 8012258:	b2a9      	uxth	r1, r5
                usNRegs--;
            }
            break;
        /* write current register values with new values from the protocol stack. */
        case MB_REG_WRITE:
            while (usNRegs > 0)
 801225a:	42b1      	cmp	r1, r6
 801225c:	f102 0202 	add.w	r2, r2, #2
 8012260:	d1ef      	bne.n	8012242 <eMBMasterRegHoldingCB+0x32>
 * @return result
 */
eMBErrorCode
eMBMasterRegHoldingCB(uint8_t* pucRegBuffer, uint16_t usAddress, uint16_t usNRegs, eMBRegisterMode eMode)
{
    eMBErrorCode    eStatus = MB_ENOERR;
 8012262:	2000      	movs	r0, #0
 8012264:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            break;
        }
    }
    else
    {
        eStatus = MB_ENOREG;
 8012266:	2001      	movs	r0, #1
    }
    return eStatus;
}
 8012268:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801226a:	bf00      	nop
 801226c:	20011944 	.word	0x20011944
 8012270:	20011d3e 	.word	0x20011d3e
 8012274:	20011d40 	.word	0x20011d40
 8012278:	f3af 8000 	nop.w
 801227c:	f3af 8000 	nop.w

08012280 <eMBMasterRegCoilsCB>:
 *
 * @return result
 */
eMBErrorCode eMBMasterRegCoilsCB(UCHAR * pucRegBuffer, USHORT usAddress,
        USHORT usNCoils, eMBRegisterMode eMode)
{
 8012280:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012284:	b083      	sub	sp, #12
    USHORT          iRegIndex , iRegBitIndex , iNReg;
    UCHAR *         pucCoilBuf;
    USHORT          COIL_START;
    USHORT          COIL_NCOILS;
    USHORT          usCoilStart;
    iNReg =  		usNCoils / 8 + 1;
 8012286:	08d3      	lsrs	r3, r2, #3
 *
 * @return result
 */
eMBErrorCode eMBMasterRegCoilsCB(UCHAR * pucRegBuffer, USHORT usAddress,
        USHORT usNCoils, eMBRegisterMode eMode)
{
 8012288:	460d      	mov	r5, r1
    USHORT          iRegIndex , iRegBitIndex , iNReg;
    UCHAR *         pucCoilBuf;
    USHORT          COIL_START;
    USHORT          COIL_NCOILS;
    USHORT          usCoilStart;
    iNReg =  		usNCoils / 8 + 1;
 801228a:	1c5c      	adds	r4, r3, #1
 801228c:	9300      	str	r3, [sp, #0]

    /* if mode is read,the master will write the received date to buffer. */
    eMode = MB_REG_WRITE;

    /* it already plus one in modbus function method. */
    usAddress--;
 801228e:	3d01      	subs	r5, #1
    USHORT          COIL_START;
    USHORT          COIL_NCOILS;
    USHORT          usCoilStart;
    iNReg =  		usNCoils / 8 + 1;

    xtCoilNRegs = iNReg;
 8012290:	4b28      	ldr	r3, [pc, #160]	; (8012334 <eMBMasterRegCoilsCB+0xb4>)
	
	chprintf( (BaseSequentialStream *)&itm_port, "xtCoilNRegs[%d]: %d\n", xtCoilNRegs );
 8012292:	4929      	ldr	r1, [pc, #164]	; (8012338 <eMBMasterRegCoilsCB+0xb8>)
    USHORT          COIL_START;
    USHORT          COIL_NCOILS;
    USHORT          usCoilStart;
    iNReg =  		usNCoils / 8 + 1;

    xtCoilNRegs = iNReg;
 8012294:	801c      	strh	r4, [r3, #0]
 *
 * @return result
 */
eMBErrorCode eMBMasterRegCoilsCB(UCHAR * pucRegBuffer, USHORT usAddress,
        USHORT usNCoils, eMBRegisterMode eMode)
{
 8012296:	4617      	mov	r7, r2
 8012298:	4682      	mov	sl, r0
    USHORT          usCoilStart;
    iNReg =  		usNCoils / 8 + 1;

    xtCoilNRegs = iNReg;
	
	chprintf( (BaseSequentialStream *)&itm_port, "xtCoilNRegs[%d]: %d\n", xtCoilNRegs );
 801229a:	4622      	mov	r2, r4
 801229c:	4827      	ldr	r0, [pc, #156]	; (801233c <eMBMasterRegCoilsCB+0xbc>)

    /* if mode is read,the master will write the received date to buffer. */
    eMode = MB_REG_WRITE;

    /* it already plus one in modbus function method. */
    usAddress--;
 801229e:	b2ad      	uxth	r5, r5
    USHORT          usCoilStart;
    iNReg =  		usNCoils / 8 + 1;

    xtCoilNRegs = iNReg;
	
	chprintf( (BaseSequentialStream *)&itm_port, "xtCoilNRegs[%d]: %d\n", xtCoilNRegs );
 80122a0:	f7ff fefe 	bl	80120a0 <chprintf.constprop.0>

    pucCoilBuf = ucMCoilBuf[ucMBMasterGetDestAddress() - 1];
 80122a4:	f7ff fedc 	bl	8012060 <ucMBMasterGetDestAddress>

    /* it already plus one in modbus function method. */
    usAddress--;

    if ((usAddress >= COIL_START)
            && (usAddress + usNCoils <= COIL_START + COIL_NCOILS))
 80122a8:	19eb      	adds	r3, r5, r7
 80122aa:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 80122ae:	dc3c      	bgt.n	801232a <eMBMasterRegCoilsCB+0xaa>

    xtCoilNRegs = iNReg;
	
	chprintf( (BaseSequentialStream *)&itm_port, "xtCoilNRegs[%d]: %d\n", xtCoilNRegs );

    pucCoilBuf = ucMCoilBuf[ucMBMasterGetDestAddress() - 1];
 80122b0:	3801      	subs	r0, #1
 80122b2:	4e23      	ldr	r6, [pc, #140]	; (8012340 <eMBMasterRegCoilsCB+0xc0>)

    if ((usAddress >= COIL_START)
            && (usAddress + usNCoils <= COIL_START + COIL_NCOILS))
    {
        iRegIndex = (uint16_t) (usAddress - usCoilStart) / 8;
		xtCoilRegIndex = iRegIndex;
 80122b4:	4b23      	ldr	r3, [pc, #140]	; (8012344 <eMBMasterRegCoilsCB+0xc4>)
    usAddress--;

    if ((usAddress >= COIL_START)
            && (usAddress + usNCoils <= COIL_START + COIL_NCOILS))
    {
        iRegIndex = (uint16_t) (usAddress - usCoilStart) / 8;
 80122b6:	ea4f 0bd5 	mov.w	fp, r5, lsr #3

    xtCoilNRegs = iNReg;
	
	chprintf( (BaseSequentialStream *)&itm_port, "xtCoilNRegs[%d]: %d\n", xtCoilNRegs );

    pucCoilBuf = ucMCoilBuf[ucMBMasterGetDestAddress() - 1];
 80122ba:	ebc0 1080 	rsb	r0, r0, r0, lsl #6
            *pucRegBuffer = *pucRegBuffer >> (8 - usNCoils);
            break;

        /* write current coil values with new values from the protocol stack. */
        case MB_REG_WRITE:
            while (iNReg > 1)
 80122be:	2c01      	cmp	r4, #1

    xtCoilNRegs = iNReg;
	
	chprintf( (BaseSequentialStream *)&itm_port, "xtCoilNRegs[%d]: %d\n", xtCoilNRegs );

    pucCoilBuf = ucMCoilBuf[ucMBMasterGetDestAddress() - 1];
 80122c0:	4406      	add	r6, r0

    if ((usAddress >= COIL_START)
            && (usAddress + usNCoils <= COIL_START + COIL_NCOILS))
    {
        iRegIndex = (uint16_t) (usAddress - usCoilStart) / 8;
		xtCoilRegIndex = iRegIndex;
 80122c2:	f8a3 b000 	strh.w	fp, [r3]
        iRegBitIndex = (uint16_t) (usAddress - usCoilStart) % 8;
 80122c6:	f005 0507 	and.w	r5, r5, #7
            *pucRegBuffer = *pucRegBuffer >> (8 - usNCoils);
            break;

        /* write current coil values with new values from the protocol stack. */
        case MB_REG_WRITE:
            while (iNReg > 1)
 80122ca:	d01c      	beq.n	8012306 <eMBMasterRegCoilsCB+0x86>
 80122cc:	9b00      	ldr	r3, [sp, #0]
 80122ce:	3b01      	subs	r3, #1
 80122d0:	b29b      	uxth	r3, r3
 80122d2:	9301      	str	r3, [sp, #4]
 80122d4:	eb0a 0803 	add.w	r8, sl, r3
 80122d8:	f10a 39ff 	add.w	r9, sl, #4294967295
 80122dc:	4658      	mov	r0, fp
            {
                xMBUtilSetBits(&pucCoilBuf[iRegIndex++], iRegBitIndex, 8,
 80122de:	f819 3f01 	ldrb.w	r3, [r9, #1]!
 80122e2:	1c44      	adds	r4, r0, #1
 80122e4:	4629      	mov	r1, r5
 80122e6:	4430      	add	r0, r6
 80122e8:	2208      	movs	r2, #8
 80122ea:	f7ff fa89 	bl	8011800 <xMBUtilSetBits>
 80122ee:	b2a4      	uxth	r4, r4
            *pucRegBuffer = *pucRegBuffer >> (8 - usNCoils);
            break;

        /* write current coil values with new values from the protocol stack. */
        case MB_REG_WRITE:
            while (iNReg > 1)
 80122f0:	45c1      	cmp	r9, r8
            {
                xMBUtilSetBits(&pucCoilBuf[iRegIndex++], iRegBitIndex, 8,
 80122f2:	4620      	mov	r0, r4
            *pucRegBuffer = *pucRegBuffer >> (8 - usNCoils);
            break;

        /* write current coil values with new values from the protocol stack. */
        case MB_REG_WRITE:
            while (iNReg > 1)
 80122f4:	d1f3      	bne.n	80122de <eMBMasterRegCoilsCB+0x5e>
 80122f6:	9b00      	ldr	r3, [sp, #0]
 80122f8:	445b      	add	r3, fp
 80122fa:	469b      	mov	fp, r3
 80122fc:	9b01      	ldr	r3, [sp, #4]
 80122fe:	3301      	adds	r3, #1
 8012300:	fa1f fb8b 	uxth.w	fp, fp
 8012304:	449a      	add	sl, r3
                iNReg--;
            }
            /* last coils */
            usNCoils = usNCoils % 8;
            /* xMBUtilSetBits has bug when ucNBits is zero */
            if (usNCoils != 0)
 8012306:	f017 0207 	ands.w	r2, r7, #7
 801230a:	d103      	bne.n	8012314 <eMBMasterRegCoilsCB+0x94>
 * @return result
 */
eMBErrorCode eMBMasterRegCoilsCB(UCHAR * pucRegBuffer, USHORT usAddress,
        USHORT usNCoils, eMBRegisterMode eMode)
{
    eMBErrorCode    eStatus = MB_ENOERR;
 801230c:	4610      	mov	r0, r2
    else
    {
        eStatus = MB_ENOREG;
    }
    return eStatus;
}
 801230e:	b003      	add	sp, #12
 8012310:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            /* last coils */
            usNCoils = usNCoils % 8;
            /* xMBUtilSetBits has bug when ucNBits is zero */
            if (usNCoils != 0)
            {
                xMBUtilSetBits(&pucCoilBuf[iRegIndex++], iRegBitIndex, usNCoils,
 8012314:	eb06 000b 	add.w	r0, r6, fp
 8012318:	4629      	mov	r1, r5
 801231a:	f89a 3000 	ldrb.w	r3, [sl]
 801231e:	f7ff fa6f 	bl	8011800 <xMBUtilSetBits>
 * @return result
 */
eMBErrorCode eMBMasterRegCoilsCB(UCHAR * pucRegBuffer, USHORT usAddress,
        USHORT usNCoils, eMBRegisterMode eMode)
{
    eMBErrorCode    eStatus = MB_ENOERR;
 8012322:	2000      	movs	r0, #0
    else
    {
        eStatus = MB_ENOREG;
    }
    return eStatus;
}
 8012324:	b003      	add	sp, #12
 8012326:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            break;
        }
    }
    else
    {
        eStatus = MB_ENOREG;
 801232a:	2001      	movs	r0, #1
    }
    return eStatus;
}
 801232c:	b003      	add	sp, #12
 801232e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8012332:	bf00      	nop
 8012334:	20011d38 	.word	0x20011d38
 8012338:	080196e4 	.word	0x080196e4
 801233c:	200180c8 	.word	0x200180c8
 8012340:	20016844 	.word	0x20016844
 8012344:	2000ce40 	.word	0x2000ce40
 8012348:	f3af 8000 	nop.w
 801234c:	f3af 8000 	nop.w

08012350 <eMBMasterRegDiscreteCB>:
 * @param usNDiscrete discrete number
 *
 * @return result
 */
eMBErrorCode eMBMasterRegDiscreteCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNDiscrete )
{
 8012350:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012354:	460c      	mov	r4, r1
 8012356:	b083      	sub	sp, #12
 8012358:	4617      	mov	r7, r2
 801235a:	4681      	mov	r9, r0
    USHORT          DISCRETE_INPUT_START;
    USHORT          DISCRETE_INPUT_NDISCRETES;
    USHORT          usDiscreteInputStart;
    iNReg =  usNDiscrete / 8 + 1;

    pucDiscreteInputBuf = ucMDiscInBuf[ucMBMasterGetDestAddress() - 1];
 801235c:	f7ff fe80 	bl	8012060 <ucMBMasterGetDestAddress>
    DISCRETE_INPUT_START = M_DISCRETE_INPUT_START;
    DISCRETE_INPUT_NDISCRETES = M_DISCRETE_INPUT_NDISCRETES;
    usDiscreteInputStart = usMDiscInStart;

    /* it already plus one in modbus function method. */
    usAddress--;
 8012360:	1e61      	subs	r1, r4, #1
 8012362:	b289      	uxth	r1, r1
    iNReg =  usNDiscrete / 8 + 1;

    pucDiscreteInputBuf = ucMDiscInBuf[ucMBMasterGetDestAddress() - 1];
    DISCRETE_INPUT_START = M_DISCRETE_INPUT_START;
    DISCRETE_INPUT_NDISCRETES = M_DISCRETE_INPUT_NDISCRETES;
    usDiscreteInputStart = usMDiscInStart;
 8012364:	4a22      	ldr	r2, [pc, #136]	; (80123f0 <eMBMasterRegDiscreteCB+0xa0>)

    /* it already plus one in modbus function method. */
    usAddress--;

    if ((usAddress >= DISCRETE_INPUT_START)
            && (usAddress + usNDiscrete    <= DISCRETE_INPUT_START + DISCRETE_INPUT_NDISCRETES))
 8012366:	19cb      	adds	r3, r1, r7
 8012368:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
    iNReg =  usNDiscrete / 8 + 1;

    pucDiscreteInputBuf = ucMDiscInBuf[ucMBMasterGetDestAddress() - 1];
    DISCRETE_INPUT_START = M_DISCRETE_INPUT_START;
    DISCRETE_INPUT_NDISCRETES = M_DISCRETE_INPUT_NDISCRETES;
    usDiscreteInputStart = usMDiscInStart;
 801236c:	8815      	ldrh	r5, [r2, #0]

    /* it already plus one in modbus function method. */
    usAddress--;

    if ((usAddress >= DISCRETE_INPUT_START)
            && (usAddress + usNDiscrete    <= DISCRETE_INPUT_START + DISCRETE_INPUT_NDISCRETES))
 801236e:	dc3a      	bgt.n	80123e6 <eMBMasterRegDiscreteCB+0x96>
    USHORT          DISCRETE_INPUT_START;
    USHORT          DISCRETE_INPUT_NDISCRETES;
    USHORT          usDiscreteInputStart;
    iNReg =  usNDiscrete / 8 + 1;

    pucDiscreteInputBuf = ucMDiscInBuf[ucMBMasterGetDestAddress() - 1];
 8012370:	3801      	subs	r0, #1
    usAddress--;

    if ((usAddress >= DISCRETE_INPUT_START)
            && (usAddress + usNDiscrete    <= DISCRETE_INPUT_START + DISCRETE_INPUT_NDISCRETES))
    {
        iRegIndex = (USHORT) (usAddress - usDiscreteInputStart) / 8;
 8012372:	1b4d      	subs	r5, r1, r5
    USHORT          DISCRETE_INPUT_START;
    USHORT          DISCRETE_INPUT_NDISCRETES;
    USHORT          usDiscreteInputStart;
    iNReg =  usNDiscrete / 8 + 1;

    pucDiscreteInputBuf = ucMDiscInBuf[ucMBMasterGetDestAddress() - 1];
 8012374:	4e1f      	ldr	r6, [pc, #124]	; (80123f4 <eMBMasterRegDiscreteCB+0xa4>)
    usAddress--;

    if ((usAddress >= DISCRETE_INPUT_START)
            && (usAddress + usNDiscrete    <= DISCRETE_INPUT_START + DISCRETE_INPUT_NDISCRETES))
    {
        iRegIndex = (USHORT) (usAddress - usDiscreteInputStart) / 8;
 8012376:	b2ad      	uxth	r5, r5
    USHORT          DISCRETE_INPUT_START;
    USHORT          DISCRETE_INPUT_NDISCRETES;
    USHORT          usDiscreteInputStart;
    iNReg =  usNDiscrete / 8 + 1;

    pucDiscreteInputBuf = ucMDiscInBuf[ucMBMasterGetDestAddress() - 1];
 8012378:	ebc0 1080 	rsb	r0, r0, r0, lsl #6
    {
        iRegIndex = (USHORT) (usAddress - usDiscreteInputStart) / 8;
        iRegBitIndex = (USHORT) (usAddress - usDiscreteInputStart) % 8;

        /* write current discrete values with new values from the protocol stack. */
        while (iNReg > 1)
 801237c:	08fb      	lsrs	r3, r7, #3
    usAddress--;

    if ((usAddress >= DISCRETE_INPUT_START)
            && (usAddress + usNDiscrete    <= DISCRETE_INPUT_START + DISCRETE_INPUT_NDISCRETES))
    {
        iRegIndex = (USHORT) (usAddress - usDiscreteInputStart) / 8;
 801237e:	ea4f 0bd5 	mov.w	fp, r5, lsr #3
    USHORT          DISCRETE_INPUT_START;
    USHORT          DISCRETE_INPUT_NDISCRETES;
    USHORT          usDiscreteInputStart;
    iNReg =  usNDiscrete / 8 + 1;

    pucDiscreteInputBuf = ucMDiscInBuf[ucMBMasterGetDestAddress() - 1];
 8012382:	4406      	add	r6, r0

    if ((usAddress >= DISCRETE_INPUT_START)
            && (usAddress + usNDiscrete    <= DISCRETE_INPUT_START + DISCRETE_INPUT_NDISCRETES))
    {
        iRegIndex = (USHORT) (usAddress - usDiscreteInputStart) / 8;
        iRegBitIndex = (USHORT) (usAddress - usDiscreteInputStart) % 8;
 8012384:	f005 0507 	and.w	r5, r5, #7

        /* write current discrete values with new values from the protocol stack. */
        while (iNReg > 1)
 8012388:	9300      	str	r3, [sp, #0]
 801238a:	d01a      	beq.n	80123c2 <eMBMasterRegDiscreteCB+0x72>
 801238c:	3b01      	subs	r3, #1
 801238e:	b29b      	uxth	r3, r3
 8012390:	9301      	str	r3, [sp, #4]
 8012392:	eb09 0803 	add.w	r8, r9, r3
 8012396:	f109 3aff 	add.w	sl, r9, #4294967295
 801239a:	4658      	mov	r0, fp
        {
            xMBUtilSetBits(&pucDiscreteInputBuf[iRegIndex++], iRegBitIndex, 8,
 801239c:	f81a 3f01 	ldrb.w	r3, [sl, #1]!
 80123a0:	1c44      	adds	r4, r0, #1
 80123a2:	4629      	mov	r1, r5
 80123a4:	4430      	add	r0, r6
 80123a6:	2208      	movs	r2, #8
 80123a8:	f7ff fa2a 	bl	8011800 <xMBUtilSetBits>
 80123ac:	b2a4      	uxth	r4, r4
    {
        iRegIndex = (USHORT) (usAddress - usDiscreteInputStart) / 8;
        iRegBitIndex = (USHORT) (usAddress - usDiscreteInputStart) % 8;

        /* write current discrete values with new values from the protocol stack. */
        while (iNReg > 1)
 80123ae:	45c2      	cmp	sl, r8
        {
            xMBUtilSetBits(&pucDiscreteInputBuf[iRegIndex++], iRegBitIndex, 8,
 80123b0:	4620      	mov	r0, r4
    {
        iRegIndex = (USHORT) (usAddress - usDiscreteInputStart) / 8;
        iRegBitIndex = (USHORT) (usAddress - usDiscreteInputStart) % 8;

        /* write current discrete values with new values from the protocol stack. */
        while (iNReg > 1)
 80123b2:	d1f3      	bne.n	801239c <eMBMasterRegDiscreteCB+0x4c>
 80123b4:	9b00      	ldr	r3, [sp, #0]
 80123b6:	449b      	add	fp, r3
 80123b8:	9b01      	ldr	r3, [sp, #4]
 80123ba:	3301      	adds	r3, #1
 80123bc:	fa1f fb8b 	uxth.w	fp, fp
 80123c0:	4499      	add	r9, r3
            iNReg--;
        }
        /* last discrete */
        usNDiscrete = usNDiscrete % 8;
        /* xMBUtilSetBits has bug when ucNBits is zero */
        if (usNDiscrete != 0)
 80123c2:	f017 0207 	ands.w	r2, r7, #7
 80123c6:	d103      	bne.n	80123d0 <eMBMasterRegDiscreteCB+0x80>
 *
 * @return result
 */
eMBErrorCode eMBMasterRegDiscreteCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNDiscrete )
{
    eMBErrorCode    eStatus = MB_ENOERR;
 80123c8:	4610      	mov	r0, r2
    {
        eStatus = MB_ENOREG;
    }

    return eStatus;
}
 80123ca:	b003      	add	sp, #12
 80123cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        /* last discrete */
        usNDiscrete = usNDiscrete % 8;
        /* xMBUtilSetBits has bug when ucNBits is zero */
        if (usNDiscrete != 0)
        {
            xMBUtilSetBits(&pucDiscreteInputBuf[iRegIndex++], iRegBitIndex,
 80123d0:	eb06 000b 	add.w	r0, r6, fp
 80123d4:	4629      	mov	r1, r5
 80123d6:	f899 3000 	ldrb.w	r3, [r9]
 80123da:	f7ff fa11 	bl	8011800 <xMBUtilSetBits>
 *
 * @return result
 */
eMBErrorCode eMBMasterRegDiscreteCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNDiscrete )
{
    eMBErrorCode    eStatus = MB_ENOERR;
 80123de:	2000      	movs	r0, #0
    {
        eStatus = MB_ENOREG;
    }

    return eStatus;
}
 80123e0:	b003      	add	sp, #12
 80123e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    usNDiscrete, *pucRegBuffer++);
        }
    }
    else
    {
        eStatus = MB_ENOREG;
 80123e6:	2001      	movs	r0, #1
    }

    return eStatus;
}
 80123e8:	b003      	add	sp, #12
 80123ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80123ee:	bf00      	nop
 80123f0:	20016840 	.word	0x20016840
 80123f4:	20011948 	.word	0x20011948
 80123f8:	f3af 8000 	nop.w
 80123fc:	f3af 8000 	nop.w

08012400 <EnterCriticalSection>:
#include "port.h"
/* ----------------------- Variables ----------------------------------------*/
//static rt_base_t level;
/* ----------------------- Start implementation -----------------------------*/
void EnterCriticalSection(void)
{
 8012400:	4770      	bx	lr
 8012402:	bf00      	nop
 8012404:	f3af 8000 	nop.w
 8012408:	f3af 8000 	nop.w
 801240c:	f3af 8000 	nop.w

08012410 <ExitCriticalSection>:
    //level = rt_hw_interrupt_disable();
}

void ExitCriticalSection(void)
{
 8012410:	4770      	bx	lr
 8012412:	bf00      	nop
 8012414:	f3af 8000 	nop.w
 8012418:	f3af 8000 	nop.w
 801241c:	f3af 8000 	nop.w

08012420 <xMBMasterPortEventInit>:
static bool		xtNeedPoll;
/* ----------------------- Start implementation -----------------------------*/
BOOL
xMBMasterPortEventInit( void )
{
    xEventInQueue = FALSE;
 8012420:	4b02      	ldr	r3, [pc, #8]	; (801242c <xMBMasterPortEventInit+0xc>)
 8012422:	2200      	movs	r2, #0
 8012424:	701a      	strb	r2, [r3, #0]
    return TRUE;
}
 8012426:	2001      	movs	r0, #1
 8012428:	4770      	bx	lr
 801242a:	bf00      	nop
 801242c:	20016c34 	.word	0x20016c34

08012430 <xMBMasterPortEventPost>:

BOOL
xMBMasterPortEventPost( eMBMasterEventType eEvent )
{
    xEventInQueue = TRUE;
    eQueuedEvent = eEvent;
 8012430:	4a02      	ldr	r2, [pc, #8]	; (801243c <xMBMasterPortEventPost+0xc>)
}

BOOL
xMBMasterPortEventPost( eMBMasterEventType eEvent )
{
    xEventInQueue = TRUE;
 8012432:	4b03      	ldr	r3, [pc, #12]	; (8012440 <xMBMasterPortEventPost+0x10>)
    eQueuedEvent = eEvent;
 8012434:	7010      	strb	r0, [r2, #0]
}

BOOL
xMBMasterPortEventPost( eMBMasterEventType eEvent )
{
    xEventInQueue = TRUE;
 8012436:	2001      	movs	r0, #1
 8012438:	7018      	strb	r0, [r3, #0]
    eQueuedEvent = eEvent;
    return TRUE;
}
 801243a:	4770      	bx	lr
 801243c:	20016c36 	.word	0x20016c36
 8012440:	20016c34 	.word	0x20016c34
 8012444:	f3af 8000 	nop.w
 8012448:	f3af 8000 	nop.w
 801244c:	f3af 8000 	nop.w

08012450 <xMBMasterPortEventGet>:
BOOL
xMBMasterPortEventGet( eMBMasterEventType * eEvent )
{
    BOOL            xEventHappened = FALSE;

    if( xEventInQueue )
 8012450:	4a05      	ldr	r2, [pc, #20]	; (8012468 <xMBMasterPortEventGet+0x18>)
 8012452:	7813      	ldrb	r3, [r2, #0]
 8012454:	b133      	cbz	r3, 8012464 <xMBMasterPortEventGet+0x14>
    {
        *eEvent = eQueuedEvent;
 8012456:	4905      	ldr	r1, [pc, #20]	; (801246c <xMBMasterPortEventGet+0x1c>)
        xEventInQueue = FALSE;
 8012458:	2300      	movs	r3, #0
{
    BOOL            xEventHappened = FALSE;

    if( xEventInQueue )
    {
        *eEvent = eQueuedEvent;
 801245a:	7809      	ldrb	r1, [r1, #0]
 801245c:	8001      	strh	r1, [r0, #0]
        xEventInQueue = FALSE;
 801245e:	7013      	strb	r3, [r2, #0]
        xEventHappened = TRUE;
 8012460:	2001      	movs	r0, #1
 8012462:	4770      	bx	lr
}

BOOL
xMBMasterPortEventGet( eMBMasterEventType * eEvent )
{
    BOOL            xEventHappened = FALSE;
 8012464:	4618      	mov	r0, r3
        *eEvent = eQueuedEvent;
        xEventInQueue = FALSE;
        xEventHappened = TRUE;
    }
    return xEventHappened;
}
 8012466:	4770      	bx	lr
 8012468:	20016c34 	.word	0x20016c34
 801246c:	20016c36 	.word	0x20016c36

08012470 <vMBMasterOsResInit>:
 * Note:The resource is define by OS.If you not use OS this function can be empty.
 *
 */
void vMBMasterOsResInit( void )
{
	xtNeedPoll = true;
 8012470:	4b01      	ldr	r3, [pc, #4]	; (8012478 <vMBMasterOsResInit+0x8>)
 8012472:	2201      	movs	r2, #1
 8012474:	701a      	strb	r2, [r3, #0]
 8012476:	4770      	bx	lr
 8012478:	20016c35 	.word	0x20016c35
 801247c:	f3af 8000 	nop.w

08012480 <xMBMasterRunResTake>:
 */
BOOL xMBMasterRunResTake( LONG lTimeOut )
{
    (void)lTimeOut;
	
	return xtNeedPoll;
 8012480:	4b01      	ldr	r3, [pc, #4]	; (8012488 <xMBMasterRunResTake+0x8>)
}
 8012482:	7818      	ldrb	r0, [r3, #0]
 8012484:	4770      	bx	lr
 8012486:	bf00      	nop
 8012488:	20016c35 	.word	0x20016c35
 801248c:	f3af 8000 	nop.w

08012490 <xMBMasterRunResLock>:

void xMBMasterRunResLock(void){
	
	xtNeedPoll = false;
 8012490:	4b01      	ldr	r3, [pc, #4]	; (8012498 <xMBMasterRunResLock+0x8>)
 8012492:	2200      	movs	r2, #0
 8012494:	701a      	strb	r2, [r3, #0]
 8012496:	4770      	bx	lr
 8012498:	20016c35 	.word	0x20016c35
 801249c:	f3af 8000 	nop.w

080124a0 <vMBMasterRunResRelease>:
 *
 */
void vMBMasterRunResRelease( void )
{
    /* release resource */
    xtNeedPoll = true;
 80124a0:	4b01      	ldr	r3, [pc, #4]	; (80124a8 <vMBMasterRunResRelease+0x8>)
 80124a2:	2201      	movs	r2, #1
 80124a4:	701a      	strb	r2, [r3, #0]
 80124a6:	4770      	bx	lr
 80124a8:	20016c35 	.word	0x20016c35
 80124ac:	f3af 8000 	nop.w

080124b0 <vMBMasterErrorCBRespondTimeout>:
}

BOOL
xMBMasterPortEventPost( eMBMasterEventType eEvent )
{
    xEventInQueue = TRUE;
 80124b0:	4903      	ldr	r1, [pc, #12]	; (80124c0 <vMBMasterErrorCBRespondTimeout+0x10>)
    eQueuedEvent = eEvent;
 80124b2:	4b04      	ldr	r3, [pc, #16]	; (80124c4 <vMBMasterErrorCBRespondTimeout+0x14>)
}

BOOL
xMBMasterPortEventPost( eMBMasterEventType eEvent )
{
    xEventInQueue = TRUE;
 80124b4:	2001      	movs	r0, #1
    eQueuedEvent = eEvent;
 80124b6:	2240      	movs	r2, #64	; 0x40
}

BOOL
xMBMasterPortEventPost( eMBMasterEventType eEvent )
{
    xEventInQueue = TRUE;
 80124b8:	7008      	strb	r0, [r1, #0]
    eQueuedEvent = eEvent;
 80124ba:	701a      	strb	r2, [r3, #0]
 80124bc:	4770      	bx	lr
 80124be:	bf00      	nop
 80124c0:	20016c34 	.word	0x20016c34
 80124c4:	20016c36 	.word	0x20016c36
 80124c8:	f3af 8000 	nop.w
 80124cc:	f3af 8000 	nop.w

080124d0 <vMBMasterErrorCBReceiveData>:
}

BOOL
xMBMasterPortEventPost( eMBMasterEventType eEvent )
{
    xEventInQueue = TRUE;
 80124d0:	4903      	ldr	r1, [pc, #12]	; (80124e0 <vMBMasterErrorCBReceiveData+0x10>)
    eQueuedEvent = eEvent;
 80124d2:	4b04      	ldr	r3, [pc, #16]	; (80124e4 <vMBMasterErrorCBReceiveData+0x14>)
}

BOOL
xMBMasterPortEventPost( eMBMasterEventType eEvent )
{
    xEventInQueue = TRUE;
 80124d4:	2001      	movs	r0, #1
    eQueuedEvent = eEvent;
 80124d6:	2280      	movs	r2, #128	; 0x80
}

BOOL
xMBMasterPortEventPost( eMBMasterEventType eEvent )
{
    xEventInQueue = TRUE;
 80124d8:	7008      	strb	r0, [r1, #0]
    eQueuedEvent = eEvent;
 80124da:	701a      	strb	r2, [r3, #0]
 80124dc:	4770      	bx	lr
 80124de:	bf00      	nop
 80124e0:	20016c34 	.word	0x20016c34
 80124e4:	20016c36 	.word	0x20016c36
 80124e8:	f3af 8000 	nop.w
 80124ec:	f3af 8000 	nop.w

080124f0 <vMBMasterErrorCBExecuteFunction>:
}

BOOL
xMBMasterPortEventPost( eMBMasterEventType eEvent )
{
    xEventInQueue = TRUE;
 80124f0:	4903      	ldr	r1, [pc, #12]	; (8012500 <vMBMasterErrorCBExecuteFunction+0x10>)
    eQueuedEvent = eEvent;
 80124f2:	4b04      	ldr	r3, [pc, #16]	; (8012504 <vMBMasterErrorCBExecuteFunction+0x14>)
}

BOOL
xMBMasterPortEventPost( eMBMasterEventType eEvent )
{
    xEventInQueue = TRUE;
 80124f4:	2001      	movs	r0, #1
    eQueuedEvent = eEvent;
 80124f6:	2200      	movs	r2, #0
}

BOOL
xMBMasterPortEventPost( eMBMasterEventType eEvent )
{
    xEventInQueue = TRUE;
 80124f8:	7008      	strb	r0, [r1, #0]
    eQueuedEvent = eEvent;
 80124fa:	701a      	strb	r2, [r3, #0]
 80124fc:	4770      	bx	lr
 80124fe:	bf00      	nop
 8012500:	20016c34 	.word	0x20016c34
 8012504:	20016c36 	.word	0x20016c36
 8012508:	f3af 8000 	nop.w
 801250c:	f3af 8000 	nop.w

08012510 <vMBMasterCBRequestScuuess>:
}

BOOL
xMBMasterPortEventPost( eMBMasterEventType eEvent )
{
    xEventInQueue = TRUE;
 8012510:	4903      	ldr	r1, [pc, #12]	; (8012520 <vMBMasterCBRequestScuuess+0x10>)
    eQueuedEvent = eEvent;
 8012512:	4b04      	ldr	r3, [pc, #16]	; (8012524 <vMBMasterCBRequestScuuess+0x14>)
}

BOOL
xMBMasterPortEventPost( eMBMasterEventType eEvent )
{
    xEventInQueue = TRUE;
 8012514:	2001      	movs	r0, #1
    eQueuedEvent = eEvent;
 8012516:	2220      	movs	r2, #32
}

BOOL
xMBMasterPortEventPost( eMBMasterEventType eEvent )
{
    xEventInQueue = TRUE;
 8012518:	7008      	strb	r0, [r1, #0]
    eQueuedEvent = eEvent;
 801251a:	701a      	strb	r2, [r3, #0]
 801251c:	4770      	bx	lr
 801251e:	bf00      	nop
 8012520:	20016c34 	.word	0x20016c34
 8012524:	20016c36 	.word	0x20016c36
 8012528:	f3af 8000 	nop.w
 801252c:	f3af 8000 	nop.w

08012530 <txend1>:
static void txend1(UARTDriver *uartp){
	(void)uartp;
	
	//chprintf((BaseSequentialStream *)&itm_port, "%s\n", "TxEmpty...");
	//chSysLockFromISR();
	pxMBMasterFrameCBTransmitterEmpty();
 8012530:	4b01      	ldr	r3, [pc, #4]	; (8012538 <txend1+0x8>)
 8012532:	681b      	ldr	r3, [r3, #0]
 8012534:	4718      	bx	r3
 8012536:	bf00      	nop
 8012538:	2000ce30 	.word	0x2000ce30
 801253c:	f3af 8000 	nop.w

08012540 <rxchar>:
	(void)uartp;
	(void)c;
	
	//chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Rx Not Empty...");
	//chSysLockFromISR();
	pxMBMasterFrameCBByteReceived();
 8012540:	4b01      	ldr	r3, [pc, #4]	; (8012548 <rxchar+0x8>)
 8012542:	681b      	ldr	r3, [r3, #0]
 8012544:	4718      	bx	r3
 8012546:	bf00      	nop
 8012548:	2000ce18 	.word	0x2000ce18
 801254c:	f3af 8000 	nop.w

08012550 <chprintf.constprop.1>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8012550:	b40e      	push	{r1, r2, r3}
 8012552:	b500      	push	{lr}
 8012554:	b082      	sub	sp, #8
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8012556:	ab04      	add	r3, sp, #16
  formatted_bytes = chvprintf(chp, fmt, ap);
 8012558:	461a      	mov	r2, r3
 801255a:	4905      	ldr	r1, [pc, #20]	; (8012570 <chprintf.constprop.1+0x20>)
 801255c:	4805      	ldr	r0, [pc, #20]	; (8012574 <chprintf.constprop.1+0x24>)
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 801255e:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8012560:	f7fe fbce 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8012564:	b002      	add	sp, #8
 8012566:	f85d eb04 	ldr.w	lr, [sp], #4
 801256a:	b003      	add	sp, #12
 801256c:	4770      	bx	lr
 801256e:	bf00      	nop
 8012570:	08017004 	.word	0x08017004
 8012574:	200180c8 	.word	0x200180c8
 8012578:	f3af 8000 	nop.w
 801257c:	f3af 8000 	nop.w

08012580 <rxerr>:
static void rxerr(UARTDriver *uartp, uartflags_t e){
	(void)uartp;
	(void)e;
	
	//chSysLockFromISR(); 
	if (e & USART_SR_PE) {
 8012580:	07cb      	lsls	r3, r1, #31

/*
 * This callback is invoked on a receive error, the errors mask is passed
 * as parameter.
 */
static void rxerr(UARTDriver *uartp, uartflags_t e){
 8012582:	b510      	push	{r4, lr}
 8012584:	460c      	mov	r4, r1
	(void)uartp;
	(void)e;
	
	//chSysLockFromISR(); 
	if (e & USART_SR_PE) {
 8012586:	d41f      	bmi.n	80125c8 <rxerr+0x48>
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "parity err");
	} else if (e & USART_SR_FE) {
 8012588:	0788      	lsls	r0, r1, #30
 801258a:	d423      	bmi.n	80125d4 <rxerr+0x54>
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "framing err");
	} if (e & USART_SR_NE) {
 801258c:	0761      	lsls	r1, r4, #29
 801258e:	d415      	bmi.n	80125bc <rxerr+0x3c>
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "noise err");
	} if (e & USART_SR_ORE) {
 8012590:	0722      	lsls	r2, r4, #28
 8012592:	d40d      	bmi.n	80125b0 <rxerr+0x30>
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "overrun err");
	} if (e & USART_SR_IDLE) {
 8012594:	06e3      	lsls	r3, r4, #27
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "idle line err");
 8012596:	4812      	ldr	r0, [pc, #72]	; (80125e0 <rxerr+0x60>)
 8012598:	4912      	ldr	r1, [pc, #72]	; (80125e4 <rxerr+0x64>)
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "framing err");
	} if (e & USART_SR_NE) {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "noise err");
	} if (e & USART_SR_ORE) {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "overrun err");
	} if (e & USART_SR_IDLE) {
 801259a:	d404      	bmi.n	80125a6 <rxerr+0x26>
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "idle line err");
	} else {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "uart rx err");
 801259c:	4a12      	ldr	r2, [pc, #72]	; (80125e8 <rxerr+0x68>)
	}
	//chSysUnlockFromISR();

}
 801259e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	} if (e & USART_SR_ORE) {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "overrun err");
	} if (e & USART_SR_IDLE) {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "idle line err");
	} else {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "uart rx err");
 80125a2:	f7ff bfd5 	b.w	8012550 <chprintf.constprop.1>
	} if (e & USART_SR_NE) {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "noise err");
	} if (e & USART_SR_ORE) {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "overrun err");
	} if (e & USART_SR_IDLE) {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "idle line err");
 80125a6:	4a11      	ldr	r2, [pc, #68]	; (80125ec <rxerr+0x6c>)
	} else {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "uart rx err");
	}
	//chSysUnlockFromISR();

}
 80125a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	} if (e & USART_SR_NE) {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "noise err");
	} if (e & USART_SR_ORE) {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "overrun err");
	} if (e & USART_SR_IDLE) {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "idle line err");
 80125ac:	f7ff bfd0 	b.w	8012550 <chprintf.constprop.1>
	} else if (e & USART_SR_FE) {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "framing err");
	} if (e & USART_SR_NE) {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "noise err");
	} if (e & USART_SR_ORE) {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "overrun err");
 80125b0:	490c      	ldr	r1, [pc, #48]	; (80125e4 <rxerr+0x64>)
 80125b2:	4a0f      	ldr	r2, [pc, #60]	; (80125f0 <rxerr+0x70>)
 80125b4:	480a      	ldr	r0, [pc, #40]	; (80125e0 <rxerr+0x60>)
 80125b6:	f7ff ffcb 	bl	8012550 <chprintf.constprop.1>
 80125ba:	e7eb      	b.n	8012594 <rxerr+0x14>
	if (e & USART_SR_PE) {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "parity err");
	} else if (e & USART_SR_FE) {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "framing err");
	} if (e & USART_SR_NE) {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "noise err");
 80125bc:	4909      	ldr	r1, [pc, #36]	; (80125e4 <rxerr+0x64>)
 80125be:	4a0d      	ldr	r2, [pc, #52]	; (80125f4 <rxerr+0x74>)
 80125c0:	4807      	ldr	r0, [pc, #28]	; (80125e0 <rxerr+0x60>)
 80125c2:	f7ff ffc5 	bl	8012550 <chprintf.constprop.1>
 80125c6:	e7e3      	b.n	8012590 <rxerr+0x10>
	(void)uartp;
	(void)e;
	
	//chSysLockFromISR(); 
	if (e & USART_SR_PE) {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "parity err");
 80125c8:	4906      	ldr	r1, [pc, #24]	; (80125e4 <rxerr+0x64>)
 80125ca:	4a0b      	ldr	r2, [pc, #44]	; (80125f8 <rxerr+0x78>)
 80125cc:	4804      	ldr	r0, [pc, #16]	; (80125e0 <rxerr+0x60>)
 80125ce:	f7ff ffbf 	bl	8012550 <chprintf.constprop.1>
 80125d2:	e7db      	b.n	801258c <rxerr+0xc>
	} else if (e & USART_SR_FE) {
	  chprintf((BaseSequentialStream *)&itm_port, "%s\n", "framing err");
 80125d4:	4903      	ldr	r1, [pc, #12]	; (80125e4 <rxerr+0x64>)
 80125d6:	4a09      	ldr	r2, [pc, #36]	; (80125fc <rxerr+0x7c>)
 80125d8:	4801      	ldr	r0, [pc, #4]	; (80125e0 <rxerr+0x60>)
 80125da:	f7ff ffb9 	bl	8012550 <chprintf.constprop.1>
 80125de:	e7d5      	b.n	801258c <rxerr+0xc>
 80125e0:	200180c8 	.word	0x200180c8
 80125e4:	08017004 	.word	0x08017004
 80125e8:	08019740 	.word	0x08019740
 80125ec:	08019730 	.word	0x08019730
 80125f0:	08019724 	.word	0x08019724
 80125f4:	08019718 	.word	0x08019718
 80125f8:	08019700 	.word	0x08019700
 80125fc:	0801970c 	.word	0x0801970c

08012600 <xMBMasterPortSerialInit>:
static void rxchar(UARTDriver *uartp, uint16_t c);

/* ----------------------- Start implementation -----------------------------*/
BOOL xMBMasterPortSerialInit(UCHAR ucPORT, ULONG ulBaudRate, UCHAR ucDataBits,
        eMBParity eParity)
{
 8012600:	b510      	push	{r4, lr}
		0,
		0,
		0
	};
	
    uartCfg.speed = ulBaudRate;
 8012602:	4a05      	ldr	r2, [pc, #20]	; (8012618 <xMBMasterPortSerialInit+0x18>)
	serial = &UARTD3;
 8012604:	4b05      	ldr	r3, [pc, #20]	; (801261c <xMBMasterPortSerialInit+0x1c>)
 8012606:	4c06      	ldr	r4, [pc, #24]	; (8012620 <xMBMasterPortSerialInit+0x20>)
		0,
		0,
		0
	};
	
    uartCfg.speed = ulBaudRate;
 8012608:	6151      	str	r1, [r2, #20]
	serial = &UARTD3;

	/* set serial configure */
	uartStart(serial, &uartCfg);
 801260a:	4618      	mov	r0, r3
 801260c:	4611      	mov	r1, r2
		0,
		0
	};
	
    uartCfg.speed = ulBaudRate;
	serial = &UARTD3;
 801260e:	6023      	str	r3, [r4, #0]

	/* set serial configure */
	uartStart(serial, &uartCfg);
 8012610:	f7f3 ffee 	bl	80065f0 <uartStart>

    return TRUE;
}
 8012614:	2001      	movs	r0, #1
 8012616:	bd10      	pop	{r4, pc}
 8012618:	200008c4 	.word	0x200008c4
 801261c:	20004334 	.word	0x20004334
 8012620:	20016c38 	.word	0x20016c38
 8012624:	f3af 8000 	nop.w
 8012628:	f3af 8000 	nop.w
 801262c:	f3af 8000 	nop.w

08012630 <vMBMasterPortSerialEnable>:

void vMBMasterPortSerialEnable(BOOL xRxEnable, BOOL xTxEnable)
{
 8012630:	b538      	push	{r3, r4, r5, lr}
	USART_TypeDef *ureg = serial->usart;
 8012632:	4b1b      	ldr	r3, [pc, #108]	; (80126a0 <vMBMasterPortSerialEnable+0x70>)
 8012634:	681b      	ldr	r3, [r3, #0]
 8012636:	689c      	ldr	r4, [r3, #8]

    return TRUE;
}

void vMBMasterPortSerialEnable(BOOL xRxEnable, BOOL xTxEnable)
{
 8012638:	460d      	mov	r5, r1
    if (xRxEnable)
    {
		/* switch 485 to receive mode */
		
        /* enable RX interrupt */
		ureg->CR1 |= USART_CR1_RXNEIE;
 801263a:	68e3      	ldr	r3, [r4, #12]

void vMBMasterPortSerialEnable(BOOL xRxEnable, BOOL xTxEnable)
{
	USART_TypeDef *ureg = serial->usart;
	
    if (xRxEnable)
 801263c:	b1b8      	cbz	r0, 801266e <vMBMasterPortSerialEnable+0x3e>
    {
		/* switch 485 to receive mode */
		
        /* enable RX interrupt */
		ureg->CR1 |= USART_CR1_RXNEIE;
 801263e:	f043 0320 	orr.w	r3, r3, #32
		chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Receive Enable");
 8012642:	4818      	ldr	r0, [pc, #96]	; (80126a4 <vMBMasterPortSerialEnable+0x74>)
 8012644:	4918      	ldr	r1, [pc, #96]	; (80126a8 <vMBMasterPortSerialEnable+0x78>)
 8012646:	4a19      	ldr	r2, [pc, #100]	; (80126ac <vMBMasterPortSerialEnable+0x7c>)
    if (xRxEnable)
    {
		/* switch 485 to receive mode */
		
        /* enable RX interrupt */
		ureg->CR1 |= USART_CR1_RXNEIE;
 8012648:	60e3      	str	r3, [r4, #12]
		chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Receive Enable");
 801264a:	f7ff ff81 	bl	8012550 <chprintf.constprop.1>
    {
        /* disable RX interrupt */
		ureg->CR1 &= ~USART_CR1_RXNEIE;
		chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Receive Disable");
    }
    if (xTxEnable)
 801264e:	b9c5      	cbnz	r5, 8012682 <vMBMasterPortSerialEnable+0x52>
		chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Transmit Enable");
    }
    else
    {
        /* stop serial transmit */
		ureg->CR1 &= ~USART_CR1_TXEIE;
 8012650:	68e3      	ldr	r3, [r4, #12]
		ureg->CR1 |= USART_CR1_TCIE;
		chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Transmit Disable");
 8012652:	4814      	ldr	r0, [pc, #80]	; (80126a4 <vMBMasterPortSerialEnable+0x74>)
 8012654:	4914      	ldr	r1, [pc, #80]	; (80126a8 <vMBMasterPortSerialEnable+0x78>)
 8012656:	4a16      	ldr	r2, [pc, #88]	; (80126b0 <vMBMasterPortSerialEnable+0x80>)
		chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Transmit Enable");
    }
    else
    {
        /* stop serial transmit */
		ureg->CR1 &= ~USART_CR1_TXEIE;
 8012658:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 801265c:	60e3      	str	r3, [r4, #12]
		ureg->CR1 |= USART_CR1_TCIE;
 801265e:	68e3      	ldr	r3, [r4, #12]
 8012660:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8012664:	60e3      	str	r3, [r4, #12]
		chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Transmit Disable");
    }
}
 8012666:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    else
    {
        /* stop serial transmit */
		ureg->CR1 &= ~USART_CR1_TXEIE;
		ureg->CR1 |= USART_CR1_TCIE;
		chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Transmit Disable");
 801266a:	f7ff bf71 	b.w	8012550 <chprintf.constprop.1>
		chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Receive Enable");
    }
    else
    {
        /* disable RX interrupt */
		ureg->CR1 &= ~USART_CR1_RXNEIE;
 801266e:	f023 0320 	bic.w	r3, r3, #32
		chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Receive Disable");
 8012672:	480c      	ldr	r0, [pc, #48]	; (80126a4 <vMBMasterPortSerialEnable+0x74>)
 8012674:	490c      	ldr	r1, [pc, #48]	; (80126a8 <vMBMasterPortSerialEnable+0x78>)
 8012676:	4a0f      	ldr	r2, [pc, #60]	; (80126b4 <vMBMasterPortSerialEnable+0x84>)
		chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Receive Enable");
    }
    else
    {
        /* disable RX interrupt */
		ureg->CR1 &= ~USART_CR1_RXNEIE;
 8012678:	60e3      	str	r3, [r4, #12]
		chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Receive Disable");
 801267a:	f7ff ff69 	bl	8012550 <chprintf.constprop.1>
    }
    if (xTxEnable)
 801267e:	2d00      	cmp	r5, #0
 8012680:	d0e6      	beq.n	8012650 <vMBMasterPortSerialEnable+0x20>
    {
		/* switch 485 to transmit mode */
		palSetPad(GPIOG, GPIOG_PIN8);
 8012682:	4b0d      	ldr	r3, [pc, #52]	; (80126b8 <vMBMasterPortSerialEnable+0x88>)
		
		/* start serial transmit */
		ureg->CR1 |= USART_CR1_TXEIE;
		chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Transmit Enable");
 8012684:	4807      	ldr	r0, [pc, #28]	; (80126a4 <vMBMasterPortSerialEnable+0x74>)
 8012686:	4908      	ldr	r1, [pc, #32]	; (80126a8 <vMBMasterPortSerialEnable+0x78>)
 8012688:	4a0c      	ldr	r2, [pc, #48]	; (80126bc <vMBMasterPortSerialEnable+0x8c>)
		chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Receive Disable");
    }
    if (xTxEnable)
    {
		/* switch 485 to transmit mode */
		palSetPad(GPIOG, GPIOG_PIN8);
 801268a:	f44f 7580 	mov.w	r5, #256	; 0x100
 801268e:	831d      	strh	r5, [r3, #24]
		
		/* start serial transmit */
		ureg->CR1 |= USART_CR1_TXEIE;
 8012690:	68e3      	ldr	r3, [r4, #12]
 8012692:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8012696:	60e3      	str	r3, [r4, #12]
        /* stop serial transmit */
		ureg->CR1 &= ~USART_CR1_TXEIE;
		ureg->CR1 |= USART_CR1_TCIE;
		chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Transmit Disable");
    }
}
 8012698:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		/* switch 485 to transmit mode */
		palSetPad(GPIOG, GPIOG_PIN8);
		
		/* start serial transmit */
		ureg->CR1 |= USART_CR1_TXEIE;
		chprintf((BaseSequentialStream *)&itm_port, "%s\n", "Transmit Enable");
 801269c:	f7ff bf58 	b.w	8012550 <chprintf.constprop.1>
 80126a0:	20016c38 	.word	0x20016c38
 80126a4:	200180c8 	.word	0x200180c8
 80126a8:	08017004 	.word	0x08017004
 80126ac:	0801974c 	.word	0x0801974c
 80126b0:	0801977c 	.word	0x0801977c
 80126b4:	0801975c 	.word	0x0801975c
 80126b8:	40021800 	.word	0x40021800
 80126bc:	0801976c 	.word	0x0801976c

080126c0 <xMBMasterPortSerialPutByte>:
    uartStop(serial);
}

BOOL xMBMasterPortSerialPutByte(CHAR ucByte)
{
	USART_TypeDef *ureg = serial->usart;
 80126c0:	4b02      	ldr	r3, [pc, #8]	; (80126cc <xMBMasterPortSerialPutByte+0xc>)
 80126c2:	681b      	ldr	r3, [r3, #0]
 80126c4:	689b      	ldr	r3, [r3, #8]
	
	//chprintf((BaseSequentialStream *)&itm_port, "ucByte: %d\n", ucByte);
	
	(ureg->DR) = (uint8_t)ucByte;
 80126c6:	6058      	str	r0, [r3, #4]
	
    return TRUE;
}
 80126c8:	2001      	movs	r0, #1
 80126ca:	4770      	bx	lr
 80126cc:	20016c38 	.word	0x20016c38

080126d0 <xMBMasterPortSerialGetByte>:

BOOL xMBMasterPortSerialGetByte(CHAR * pucByte)
{	
	USART_TypeDef *ureg = serial->usart;
 80126d0:	4b03      	ldr	r3, [pc, #12]	; (80126e0 <xMBMasterPortSerialGetByte+0x10>)
 80126d2:	681b      	ldr	r3, [r3, #0]
 80126d4:	689b      	ldr	r3, [r3, #8]
	
    *pucByte = (uint8_t)(ureg->DR);
 80126d6:	685b      	ldr	r3, [r3, #4]
 80126d8:	7003      	strb	r3, [r0, #0]
	
	//chprintf((BaseSequentialStream *)&itm_port, "*pucByte: %d\n", *pucByte);
	
    return TRUE;
}
 80126da:	2001      	movs	r0, #1
 80126dc:	4770      	bx	lr
 80126de:	bf00      	nop
 80126e0:	20016c38 	.word	0x20016c38
 80126e4:	f3af 8000 	nop.w
 80126e8:	f3af 8000 	nop.w
 80126ec:	f3af 8000 	nop.w

080126f0 <timer_timeout_ind>:
	chSysUnlockFromISR();
}

void prvvTIMERExpiredISR(void)
{
    (void) pxMBMasterPortCBTimerExpired();
 80126f0:	4b01      	ldr	r3, [pc, #4]	; (80126f8 <timer_timeout_ind+0x8>)
 80126f2:	681b      	ldr	r3, [r3, #0]
 80126f4:	4718      	bx	r3
 80126f6:	bf00      	nop
 80126f8:	2000ce2c 	.word	0x2000ce2c
 80126fc:	f3af 8000 	nop.w

08012700 <xMBMasterPortTimersInit>:

/* ----------------------- Start implementation -----------------------------*/
BOOL xMBMasterPortTimersInit(USHORT usTimeOut50us)
{
    /* backup T35 ticks */
    usT35TimeOut50us = usTimeOut50us;
 8012700:	4a03      	ldr	r2, [pc, #12]	; (8012710 <xMBMasterPortTimersInit+0x10>)
	palClearPad(GPIOC, GPIOC_PIN9);
 8012702:	4b04      	ldr	r3, [pc, #16]	; (8012714 <xMBMasterPortTimersInit+0x14>)

/* ----------------------- Start implementation -----------------------------*/
BOOL xMBMasterPortTimersInit(USHORT usTimeOut50us)
{
    /* backup T35 ticks */
    usT35TimeOut50us = usTimeOut50us;
 8012704:	8010      	strh	r0, [r2, #0]
	palClearPad(GPIOC, GPIOC_PIN9);
 8012706:	f44f 7200 	mov.w	r2, #512	; 0x200
 801270a:	835a      	strh	r2, [r3, #26]

    return TRUE;
}
 801270c:	2001      	movs	r0, #1
 801270e:	4770      	bx	lr
 8012710:	20016c78 	.word	0x20016c78
 8012714:	40020800 	.word	0x40020800
 8012718:	f3af 8000 	nop.w
 801271c:	f3af 8000 	nop.w

08012720 <vMBMasterPortTimersT35Enable>:

void vMBMasterPortTimersT35Enable()
{
 8012720:	b510      	push	{r4, lr}
	//chprintf((BaseSequentialStream *)&itm_port, "%s\n", "T35 Enable");
    /* Set current timer mode, don't change it.*/
    vMBMasterSetCurTimerMode(MB_TMODE_T35);
 8012722:	2000      	movs	r0, #0
 8012724:	f7ff fadc 	bl	8011ce0 <vMBMasterSetCurTimerMode>
	palSetPad(GPIOC, GPIOC_PIN9);
 8012728:	4b0d      	ldr	r3, [pc, #52]	; (8012760 <vMBMasterPortTimersT35Enable+0x40>)
 801272a:	f44f 7200 	mov.w	r2, #512	; 0x200
 801272e:	831a      	strh	r2, [r3, #24]
 8012730:	2320      	movs	r3, #32
 8012732:	f383 8811 	msr	BASEPRI, r3
 8012736:	4c0b      	ldr	r4, [pc, #44]	; (8012764 <vMBMasterPortTimersT35Enable+0x44>)
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8012738:	68e3      	ldr	r3, [r4, #12]
 801273a:	b13b      	cbz	r3, 801274c <vMBMasterPortTimersT35Enable+0x2c>
    chVTDoResetI(vtp);
 801273c:	4620      	mov	r0, r4
 801273e:	f7ee fe57 	bl	80013f0 <chVTDoResetI>
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8012742:	68e3      	ldr	r3, [r4, #12]
 8012744:	b113      	cbz	r3, 801274c <vMBMasterPortTimersT35Enable+0x2c>
    chVTDoResetI(vtp);
 8012746:	4620      	mov	r0, r4
 8012748:	f7ee fe52 	bl	80013f0 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 801274c:	4805      	ldr	r0, [pc, #20]	; (8012764 <vMBMasterPortTimersT35Enable+0x44>)
 801274e:	4a06      	ldr	r2, [pc, #24]	; (8012768 <vMBMasterPortTimersT35Enable+0x48>)
 8012750:	2114      	movs	r1, #20
 8012752:	2300      	movs	r3, #0
 8012754:	f7ee fe14 	bl	8001380 <chVTDoSetI>
 8012758:	2300      	movs	r3, #0
 801275a:	f383 8811 	msr	BASEPRI, r3
 801275e:	bd10      	pop	{r4, pc}
 8012760:	40020800 	.word	0x40020800
 8012764:	20016c3c 	.word	0x20016c3c
 8012768:	080126f1 	.word	0x080126f1
 801276c:	f3af 8000 	nop.w

08012770 <vMBMasterPortTimersConvertDelayEnable>:
	chVTSetI(&vt35, US2ST((uint32_t)2000), timer_timeout_ind, NULL);
	chSysUnlockFromISR();
}

void vMBMasterPortTimersConvertDelayEnable()
{
 8012770:	b510      	push	{r4, lr}
    /* Set current timer mode, don't change it.*/
    vMBMasterSetCurTimerMode(MB_TMODE_CONVERT_DELAY);
 8012772:	2002      	movs	r0, #2
 8012774:	f7ff fab4 	bl	8011ce0 <vMBMasterSetCurTimerMode>
 8012778:	2320      	movs	r3, #32
 801277a:	f383 8811 	msr	BASEPRI, r3
 801277e:	4c0b      	ldr	r4, [pc, #44]	; (80127ac <vMBMasterPortTimersConvertDelayEnable+0x3c>)
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8012780:	68e3      	ldr	r3, [r4, #12]
 8012782:	b13b      	cbz	r3, 8012794 <vMBMasterPortTimersConvertDelayEnable+0x24>
    chVTDoResetI(vtp);
 8012784:	4620      	mov	r0, r4
 8012786:	f7ee fe33 	bl	80013f0 <chVTDoResetI>
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 801278a:	68e3      	ldr	r3, [r4, #12]
 801278c:	b113      	cbz	r3, 8012794 <vMBMasterPortTimersConvertDelayEnable+0x24>
    chVTDoResetI(vtp);
 801278e:	4620      	mov	r0, r4
 8012790:	f7ee fe2e 	bl	80013f0 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8012794:	4805      	ldr	r0, [pc, #20]	; (80127ac <vMBMasterPortTimersConvertDelayEnable+0x3c>)
 8012796:	4a06      	ldr	r2, [pc, #24]	; (80127b0 <vMBMasterPortTimersConvertDelayEnable+0x40>)
 8012798:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 801279c:	2300      	movs	r3, #0
 801279e:	f7ee fdef 	bl	8001380 <chVTDoSetI>
 80127a2:	2300      	movs	r3, #0
 80127a4:	f383 8811 	msr	BASEPRI, r3
 80127a8:	bd10      	pop	{r4, pc}
 80127aa:	bf00      	nop
 80127ac:	20016c64 	.word	0x20016c64
 80127b0:	080126f1 	.word	0x080126f1
 80127b4:	f3af 8000 	nop.w
 80127b8:	f3af 8000 	nop.w
 80127bc:	f3af 8000 	nop.w

080127c0 <vMBMasterPortTimersRespondTimeoutEnable>:
	chVTSetI(&vtdelay, MS2ST((uint32_t)MB_MASTER_DELAY_MS_CONVERT), timer_timeout_ind, NULL);
	chSysUnlockFromISR();
}

void vMBMasterPortTimersRespondTimeoutEnable()
{
 80127c0:	b510      	push	{r4, lr}
 80127c2:	2320      	movs	r3, #32
 80127c4:	f383 8811 	msr	BASEPRI, r3
 80127c8:	4c0a      	ldr	r4, [pc, #40]	; (80127f4 <vMBMasterPortTimersRespondTimeoutEnable+0x34>)
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 80127ca:	68e3      	ldr	r3, [r4, #12]
 80127cc:	b13b      	cbz	r3, 80127de <vMBMasterPortTimersRespondTimeoutEnable+0x1e>
    chVTDoResetI(vtp);
 80127ce:	4620      	mov	r0, r4
 80127d0:	f7ee fe0e 	bl	80013f0 <chVTDoResetI>
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 80127d4:	68e3      	ldr	r3, [r4, #12]
 80127d6:	b113      	cbz	r3, 80127de <vMBMasterPortTimersRespondTimeoutEnable+0x1e>
    chVTDoResetI(vtp);
 80127d8:	4620      	mov	r0, r4
 80127da:	f7ee fe09 	bl	80013f0 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 80127de:	4805      	ldr	r0, [pc, #20]	; (80127f4 <vMBMasterPortTimersRespondTimeoutEnable+0x34>)
 80127e0:	4a05      	ldr	r2, [pc, #20]	; (80127f8 <vMBMasterPortTimersRespondTimeoutEnable+0x38>)
 80127e2:	f241 3188 	movw	r1, #5000	; 0x1388
 80127e6:	2300      	movs	r3, #0
 80127e8:	f7ee fdca 	bl	8001380 <chVTDoSetI>
 80127ec:	2300      	movs	r3, #0
 80127ee:	f383 8811 	msr	BASEPRI, r3
 80127f2:	bd10      	pop	{r4, pc}
 80127f4:	20016c50 	.word	0x20016c50
 80127f8:	080126f1 	.word	0x080126f1
 80127fc:	f3af 8000 	nop.w

08012800 <vMBMasterPortTimersDisable>:
	chVTSetI(&vtout, MS2ST((uint32_t)MB_MASTER_TIMEOUT_MS_RESPOND), timer_timeout_ind, NULL);
	chSysUnlockFromISR();
}

void vMBMasterPortTimersDisable()
{
 8012800:	b508      	push	{r3, lr}
	palClearPad(GPIOC, GPIOC_PIN9);
 8012802:	4b0d      	ldr	r3, [pc, #52]	; (8012838 <vMBMasterPortTimersDisable+0x38>)
 8012804:	f44f 7200 	mov.w	r2, #512	; 0x200
 8012808:	835a      	strh	r2, [r3, #26]
 801280a:	2320      	movs	r3, #32
 801280c:	f383 8811 	msr	BASEPRI, r3
 8012810:	480a      	ldr	r0, [pc, #40]	; (801283c <vMBMasterPortTimersDisable+0x3c>)
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8012812:	68c3      	ldr	r3, [r0, #12]
 8012814:	b10b      	cbz	r3, 801281a <vMBMasterPortTimersDisable+0x1a>
    chVTDoResetI(vtp);
 8012816:	f7ee fdeb 	bl	80013f0 <chVTDoResetI>
 801281a:	4809      	ldr	r0, [pc, #36]	; (8012840 <vMBMasterPortTimersDisable+0x40>)
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 801281c:	68c3      	ldr	r3, [r0, #12]
 801281e:	b10b      	cbz	r3, 8012824 <vMBMasterPortTimersDisable+0x24>
    chVTDoResetI(vtp);
 8012820:	f7ee fde6 	bl	80013f0 <chVTDoResetI>
 8012824:	4807      	ldr	r0, [pc, #28]	; (8012844 <vMBMasterPortTimersDisable+0x44>)
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8012826:	68c3      	ldr	r3, [r0, #12]
 8012828:	b10b      	cbz	r3, 801282e <vMBMasterPortTimersDisable+0x2e>
    chVTDoResetI(vtp);
 801282a:	f7ee fde1 	bl	80013f0 <chVTDoResetI>
 801282e:	2300      	movs	r3, #0
 8012830:	f383 8811 	msr	BASEPRI, r3
 8012834:	bd08      	pop	{r3, pc}
 8012836:	bf00      	nop
 8012838:	40020800 	.word	0x40020800
 801283c:	20016c3c 	.word	0x20016c3c
 8012840:	20016c64 	.word	0x20016c64
 8012844:	20016c50 	.word	0x20016c50
 8012848:	f3af 8000 	nop.w
 801284c:	f3af 8000 	nop.w

08012850 <_exit>:
#include "stubs.h"

extern ITMStream itm_port;


void _exit(int status){
 8012850:	b508      	push	{r3, lr}
	(void) status;
	chSysHalt("exit");
 8012852:	4802      	ldr	r0, [pc, #8]	; (801285c <_exit+0xc>)
 8012854:	f7ee fb8c 	bl	8000f70 <chSysHalt>

	while(TRUE){}
 8012858:	e7fe      	b.n	8012858 <_exit+0x8>
 801285a:	bf00      	nop
 801285c:	08019790 	.word	0x08019790

08012860 <_getpid>:
}

pid_t _getpid(void){
	return 1;
}
 8012860:	2001      	movs	r0, #1
 8012862:	4770      	bx	lr
 8012864:	f3af 8000 	nop.w
 8012868:	f3af 8000 	nop.w
 801286c:	f3af 8000 	nop.w

08012870 <_kill>:

void _kill(pid_t id){
 8012870:	4770      	bx	lr
 8012872:	bf00      	nop
 8012874:	f3af 8000 	nop.w
 8012878:	f3af 8000 	nop.w
 801287c:	f3af 8000 	nop.w

08012880 <get>:
static msg_t get(void *ip) {

  (void)ip;

  return 4;
}
 8012880:	2004      	movs	r0, #4
 8012882:	4770      	bx	lr
 8012884:	f3af 8000 	nop.w
 8012888:	f3af 8000 	nop.w
 801288c:	f3af 8000 	nop.w

08012890 <reads>:
  (void)ip;
  (void)bp;
  (void)n;

  return 0;
}
 8012890:	2000      	movs	r0, #0
 8012892:	4770      	bx	lr
 8012894:	f3af 8000 	nop.w
 8012898:	f3af 8000 	nop.w
 801289c:	f3af 8000 	nop.w

080128a0 <put>:
extern void Debug_ITMDebugOutputChar(char ch);

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/
static msg_t put(void *ip, uint8_t b) {
 80128a0:	b508      	push	{r3, lr}

  (void)ip;
  
  Debug_ITMDebugOutputChar(b);
 80128a2:	4608      	mov	r0, r1
 80128a4:	f000 ff34 	bl	8013710 <Debug_ITMDebugOutputChar>

  return 1;
}
 80128a8:	2001      	movs	r0, #1
 80128aa:	bd08      	pop	{r3, pc}
 80128ac:	f3af 8000 	nop.w

080128b0 <writes>:
  (void)ip;

  return 4;
}

static size_t writes(void *ip, const uint8_t *bp, size_t n) {
 80128b0:	b570      	push	{r4, r5, r6, lr}
  size_t cnt = n;

  while (cnt > 0) {
 80128b2:	4616      	mov	r6, r2
 80128b4:	b13a      	cbz	r2, 80128c6 <writes+0x16>
 80128b6:	460d      	mov	r5, r1
 80128b8:	4614      	mov	r4, r2
/*===========================================================================*/
static msg_t put(void *ip, uint8_t b) {

  (void)ip;
  
  Debug_ITMDebugOutputChar(b);
 80128ba:	f815 0b01 	ldrb.w	r0, [r5], #1
 80128be:	f000 ff27 	bl	8013710 <Debug_ITMDebugOutputChar>
}

static size_t writes(void *ip, const uint8_t *bp, size_t n) {
  size_t cnt = n;

  while (cnt > 0) {
 80128c2:	3c01      	subs	r4, #1
 80128c4:	d1f9      	bne.n	80128ba <writes+0xa>
    bp++;
    cnt--;
  }

  return n;
}
 80128c6:	4630      	mov	r0, r6
 80128c8:	bd70      	pop	{r4, r5, r6, pc}
 80128ca:	bf00      	nop
 80128cc:	f3af 8000 	nop.w

080128d0 <itmObjectInit>:
 * @brief   ITM stream object initialization.
 *
 * @param[out] pitm      pointer to the @p ITMStream object to be initialized
 */
void itmObjectInit(ITMStream *pitm) {
   pitm->vmt = &vmt;
 80128d0:	4b01      	ldr	r3, [pc, #4]	; (80128d8 <itmObjectInit+0x8>)
 80128d2:	6003      	str	r3, [r0, #0]
 80128d4:	4770      	bx	lr
 80128d6:	bf00      	nop
 80128d8:	080197b0 	.word	0x080197b0
 80128dc:	f3af 8000 	nop.w

080128e0 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80128e0:	b40e      	push	{r1, r2, r3}
 80128e2:	b500      	push	{lr}
 80128e4:	b082      	sub	sp, #8
 80128e6:	aa03      	add	r2, sp, #12
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
 80128e8:	4805      	ldr	r0, [pc, #20]	; (8012900 <chprintf.constprop.0+0x20>)
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80128ea:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80128ee:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80128f0:	f7fe fa06 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 80128f4:	b002      	add	sp, #8
 80128f6:	f85d eb04 	ldr.w	lr, [sp], #4
 80128fa:	b003      	add	sp, #12
 80128fc:	4770      	bx	lr
 80128fe:	bf00      	nop
 8012900:	200180c8 	.word	0x200180c8
 8012904:	f3af 8000 	nop.w
 8012908:	f3af 8000 	nop.w
 801290c:	f3af 8000 	nop.w

08012910 <itoa>:

#if LWIP_NETCONN

 /* itoa: */
void itoa(int n, char s[])
{
 8012910:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8012912:	ea80 73e0 	eor.w	r3, r0, r0, asr #31

    if ((sign = n) < 0)  /* */
        n = -n;          /* */
    i = 0;
    do {       /* */
        s[i++] = n % 10 + '0';   /* */
 8012916:	4f19      	ldr	r7, [pc, #100]	; (801297c <itoa+0x6c>)

#if LWIP_NETCONN

 /* itoa: */
void itoa(int n, char s[])
{
 8012918:	460c      	mov	r4, r1
 801291a:	1e4d      	subs	r5, r1, #1
 801291c:	eba3 73e0 	sub.w	r3, r3, r0, asr #31
 8012920:	2100      	movs	r1, #0

    if ((sign = n) < 0)  /* */
        n = -n;          /* */
    i = 0;
    do {       /* */
        s[i++] = n % 10 + '0';   /* */
 8012922:	fb87 2603 	smull	r2, r6, r7, r3
 8012926:	17da      	asrs	r2, r3, #31
 8012928:	ebc2 02a6 	rsb	r2, r2, r6, asr #2
 801292c:	eb02 0682 	add.w	r6, r2, r2, lsl #2
 8012930:	eba3 0346 	sub.w	r3, r3, r6, lsl #1
 8012934:	3330      	adds	r3, #48	; 0x30
 8012936:	f805 3f01 	strb.w	r3, [r5, #1]!
 801293a:	3101      	adds	r1, #1
    } while ((n /= 10) > 0);     /* */
 801293c:	4613      	mov	r3, r2
 801293e:	2a00      	cmp	r2, #0
 8012940:	d1ef      	bne.n	8012922 <itoa+0x12>
    if (sign < 0)
 8012942:	2800      	cmp	r0, #0
 8012944:	da02      	bge.n	801294c <itoa+0x3c>
        s[i++] = '-';
 8012946:	222d      	movs	r2, #45	; 0x2d
 8012948:	5462      	strb	r2, [r4, r1]
 801294a:	3101      	adds	r1, #1
    s[i] = '\0';
 801294c:	2500      	movs	r5, #0
 801294e:	5465      	strb	r5, [r4, r1]
	void reverse(char s[])
	{
	    int i, j;
	    char c;

	    for (i = 0, j = strlen(s)-1; i<j; i++, j--)
 8012950:	4620      	mov	r0, r4
 8012952:	f001 fcbd 	bl	80142d0 <strlen>
 8012956:	1e42      	subs	r2, r0, #1
 8012958:	42aa      	cmp	r2, r5
 801295a:	dd0d      	ble.n	8012978 <itoa+0x68>
 801295c:	4621      	mov	r1, r4
 801295e:	4420      	add	r0, r4
 8012960:	462b      	mov	r3, r5
 8012962:	3301      	adds	r3, #1
 8012964:	3a01      	subs	r2, #1
	    {
	        c = s[i];
 8012966:	780c      	ldrb	r4, [r1, #0]
	        s[i] = s[j];
 8012968:	f810 5c01 	ldrb.w	r5, [r0, #-1]
 801296c:	f801 5b01 	strb.w	r5, [r1], #1
	void reverse(char s[])
	{
	    int i, j;
	    char c;

	    for (i = 0, j = strlen(s)-1; i<j; i++, j--)
 8012970:	4293      	cmp	r3, r2
	    {
	        c = s[i];
	        s[i] = s[j];
	        s[j] = c;
 8012972:	f800 4d01 	strb.w	r4, [r0, #-1]!
	void reverse(char s[])
	{
	    int i, j;
	    char c;

	    for (i = 0, j = strlen(s)-1; i<j; i++, j--)
 8012976:	dbf4      	blt.n	8012962 <itoa+0x52>
 8012978:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801297a:	bf00      	nop
 801297c:	66666667 	.word	0x66666667

08012980 <DynWebPage>:
  *         running tasks and the number of page hits.
  * @param  conn pointer on connection structure
  * @retval None
  */
void DynWebPage(struct netconn *conn)
{
 8012980:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012984:	f2ad 4ddc 	subw	sp, sp, #1244	; 0x4dc
  char PAGE_BODY[1024];
  char pagehits[10] = {0};
 8012988:	2500      	movs	r5, #0
  memset(PAGE_BODY, 0,1024);
 801298a:	ac36      	add	r4, sp, #216	; 0xd8
 801298c:	4629      	mov	r1, r5
  *         running tasks and the number of page hits.
  * @param  conn pointer on connection structure
  * @retval None
  */
void DynWebPage(struct netconn *conn)
{
 801298e:	9003      	str	r0, [sp, #12]
  char PAGE_BODY[1024];
  char pagehits[10] = {0};
  memset(PAGE_BODY, 0,1024);
 8012990:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8012994:	4620      	mov	r0, r4
  * @retval None
  */
void DynWebPage(struct netconn *conn)
{
  char PAGE_BODY[1024];
  char pagehits[10] = {0};
 8012996:	9506      	str	r5, [sp, #24]
 8012998:	f8ad 501c 	strh.w	r5, [sp, #28]
 801299c:	9505      	str	r5, [sp, #20]
  memset(PAGE_BODY, 0,1024);
 801299e:	f001 fa17 	bl	8013dd0 <memset>

  char TABLE_HEAD[130];
  memset(TABLE_HEAD, 0,130);
 80129a2:	4629      	mov	r1, r5
 80129a4:	2282      	movs	r2, #130	; 0x82
 80129a6:	a815      	add	r0, sp, #84	; 0x54
 80129a8:	f001 fa12 	bl	8013dd0 <memset>

  /* Update the hit count */
  nPageHits++;
 80129ac:	4a5f      	ldr	r2, [pc, #380]	; (8012b2c <DynWebPage+0x1ac>)
 80129ae:	4e60      	ldr	r6, [pc, #384]	; (8012b30 <DynWebPage+0x1b0>)
 80129b0:	6813      	ldr	r3, [r2, #0]
 80129b2:	f8df 8194 	ldr.w	r8, [pc, #404]	; 8012b48 <DynWebPage+0x1c8>
 80129b6:	3301      	adds	r3, #1

  itoa(nPageHits, pagehits);
 80129b8:	4618      	mov	r0, r3
 80129ba:	a905      	add	r1, sp, #20

  char TABLE_HEAD[130];
  memset(TABLE_HEAD, 0,130);

  /* Update the hit count */
  nPageHits++;
 80129bc:	6013      	str	r3, [r2, #0]

  itoa(nPageHits, pagehits);
 80129be:	f7ff ffa7 	bl	8012910 <itoa>
 80129c2:	a815      	add	r0, sp, #84	; 0x54
 80129c4:	f001 fc84 	bl	80142d0 <strlen>
  strcat(TABLE_HEAD, pagehits);
 80129c8:	ab15      	add	r3, sp, #84	; 0x54
 80129ca:	a905      	add	r1, sp, #20
 80129cc:	4418      	add	r0, r3
 80129ce:	f001 fc57 	bl	8014280 <stpcpy>
  strcat(TABLE_HEAD, "<br><br>");
 80129d2:	4b58      	ldr	r3, [pc, #352]	; (8012b34 <DynWebPage+0x1b4>)

  /* Update the hit count */
  nPageHits++;

  itoa(nPageHits, pagehits);
  strcat(TABLE_HEAD, pagehits);
 80129d4:	4605      	mov	r5, r0
  strcat(TABLE_HEAD, "<br><br>");
 80129d6:	cb03      	ldmia	r3!, {r0, r1}

  strcat((char *)TABLE_HEAD,
 80129d8:	2273      	movs	r2, #115	; 0x73
  /* Update the hit count */
  nPageHits++;

  itoa(nPageHits, pagehits);
  strcat(TABLE_HEAD, pagehits);
  strcat(TABLE_HEAD, "<br><br>");
 80129da:	6028      	str	r0, [r5, #0]
 80129dc:	6069      	str	r1, [r5, #4]

  strcat((char *)TABLE_HEAD,
 80129de:	f105 0008 	add.w	r0, r5, #8
 80129e2:	4955      	ldr	r1, [pc, #340]	; (8012b38 <DynWebPage+0x1b8>)
 80129e4:	f7ed ff6c 	bl	80008c0 <memcpy>
  char mes[50];
  const char * tr = "<tr>";
  const char * td = "<td>";
  const char * trc = "</tr>";
  
  tp = chRegFirstThread();
 80129e8:	f7ee ff3a 	bl	8001860 <chRegFirstThread>
 80129ec:	4b53      	ldr	r3, [pc, #332]	; (8012b3c <DynWebPage+0x1bc>)
  do{
	  strcat((char *)PAGE_BODY, tr);

	  strcat((char *)PAGE_BODY, td);
 80129ee:	f8d6 b000 	ldr.w	fp, [r6]
  const char * td = "<td>";
  const char * trc = "</tr>";
  
  tp = chRegFirstThread();
  do{
	  strcat((char *)PAGE_BODY, tr);
 80129f2:	f8d3 a000 	ldr.w	sl, [r3]

	  strcat((char *)PAGE_BODY, td);
 80129f6:	7937      	ldrb	r7, [r6, #4]
  char mes[50];
  const char * tr = "<tr>";
  const char * td = "<td>";
  const char * trc = "</tr>";
  
  tp = chRegFirstThread();
 80129f8:	4605      	mov	r5, r0
 80129fa:	f1c4 0904 	rsb	r9, r4, #4
  do{
	  strcat((char *)PAGE_BODY, tr);
 80129fe:	4620      	mov	r0, r4
 8012a00:	f001 fc66 	bl	80142d0 <strlen>

	  strcat((char *)PAGE_BODY, td);
 8012a04:	1d03      	adds	r3, r0, #4
 8012a06:	18e2      	adds	r2, r4, r3
  const char * td = "<td>";
  const char * trc = "</tr>";
  
  tp = chRegFirstThread();
  do{
	  strcat((char *)PAGE_BODY, tr);
 8012a08:	f844 a000 	str.w	sl, [r4, r0]

	  strcat((char *)PAGE_BODY, td);
 8012a0c:	f844 b003 	str.w	fp, [r4, r3]
 8012a10:	3008      	adds	r0, #8
 8012a12:	7117      	strb	r7, [r2, #4]
	  strcat((char *)PAGE_BODY, tp->p_name);
 8012a14:	69a9      	ldr	r1, [r5, #24]
 8012a16:	4420      	add	r0, r4
 8012a18:	f001 fc32 	bl	8014280 <stpcpy>
 8012a1c:	4603      	mov	r3, r0

	  strcat((char *)PAGE_BODY, td);
 8012a1e:	6830      	ldr	r0, [r6, #0]
 8012a20:	6018      	str	r0, [r3, #0]
 8012a22:	711f      	strb	r7, [r3, #4]
	  itoa((uint32_t)tp, mes);
 8012a24:	a908      	add	r1, sp, #32
 8012a26:	4628      	mov	r0, r5
 8012a28:	f7ff ff72 	bl	8012910 <itoa>
 8012a2c:	4620      	mov	r0, r4
 8012a2e:	f001 fc4f 	bl	80142d0 <strlen>
	  strcat((char *)PAGE_BODY, mes);
 8012a32:	a908      	add	r1, sp, #32
 8012a34:	4420      	add	r0, r4
 8012a36:	f001 fc23 	bl	8014280 <stpcpy>
 8012a3a:	4603      	mov	r3, r0

	  strcat((char *)PAGE_BODY, td);
 8012a3c:	6830      	ldr	r0, [r6, #0]
 8012a3e:	711f      	strb	r7, [r3, #4]
 8012a40:	6018      	str	r0, [r3, #0]
	  itoa((uint32_t)(uint32_t)tp->p_ctx.r13, mes);
 8012a42:	68e8      	ldr	r0, [r5, #12]
 8012a44:	a908      	add	r1, sp, #32
 8012a46:	f7ff ff63 	bl	8012910 <itoa>
 8012a4a:	4620      	mov	r0, r4
 8012a4c:	f001 fc40 	bl	80142d0 <strlen>
	  strcat((char *)PAGE_BODY, mes);
 8012a50:	a908      	add	r1, sp, #32
 8012a52:	4420      	add	r0, r4
 8012a54:	f001 fc14 	bl	8014280 <stpcpy>
 8012a58:	4603      	mov	r3, r0

	  strcat((char *)PAGE_BODY, td);
 8012a5a:	6830      	ldr	r0, [r6, #0]
 8012a5c:	711f      	strb	r7, [r3, #4]
 8012a5e:	6018      	str	r0, [r3, #0]
	  itoa((uint32_t)tp->p_prio, mes);
 8012a60:	68a8      	ldr	r0, [r5, #8]
 8012a62:	a908      	add	r1, sp, #32
 8012a64:	f7ff ff54 	bl	8012910 <itoa>
 8012a68:	4620      	mov	r0, r4
 8012a6a:	f001 fc31 	bl	80142d0 <strlen>
	  strcat((char *)PAGE_BODY, mes);
 8012a6e:	a908      	add	r1, sp, #32
 8012a70:	4420      	add	r0, r4
 8012a72:	f001 fc05 	bl	8014280 <stpcpy>
 8012a76:	4603      	mov	r3, r0

	  strcat((char *)PAGE_BODY, td);
 8012a78:	6830      	ldr	r0, [r6, #0]
 8012a7a:	711f      	strb	r7, [r3, #4]
 8012a7c:	6018      	str	r0, [r3, #0]
	  itoa((uint32_t)(tp->p_refs - 1), mes);
 8012a7e:	7fa8      	ldrb	r0, [r5, #30]
 8012a80:	a908      	add	r1, sp, #32
 8012a82:	3801      	subs	r0, #1
 8012a84:	f7ff ff44 	bl	8012910 <itoa>
 8012a88:	4620      	mov	r0, r4
 8012a8a:	f001 fc21 	bl	80142d0 <strlen>
	  strcat((char *)PAGE_BODY, mes);
 8012a8e:	a908      	add	r1, sp, #32
 8012a90:	4420      	add	r0, r4
 8012a92:	f001 fbf5 	bl	8014280 <stpcpy>
 8012a96:	4602      	mov	r2, r0

	  strcat((char *)PAGE_BODY, td);
	  //strcat((char *)PAGE_BODY,states[tp->p_state]);
	  strcat((char *)PAGE_BODY, " ");
 8012a98:	eb00 0309 	add.w	r3, r0, r9

	  strcat((char *)PAGE_BODY, td);
	  itoa((uint32_t)(tp->p_refs - 1), mes);
	  strcat((char *)PAGE_BODY, mes);

	  strcat((char *)PAGE_BODY, td);
 8012a9c:	6830      	ldr	r0, [r6, #0]
 8012a9e:	6010      	str	r0, [r2, #0]
	  //strcat((char *)PAGE_BODY,states[tp->p_state]);
	  strcat((char *)PAGE_BODY, " ");

	  strcat((char *)PAGE_BODY, td);
 8012aa0:	1c59      	adds	r1, r3, #1
	  itoa((uint32_t)(tp->p_refs - 1), mes);
	  strcat((char *)PAGE_BODY, mes);

	  strcat((char *)PAGE_BODY, td);
	  //strcat((char *)PAGE_BODY,states[tp->p_state]);
	  strcat((char *)PAGE_BODY, " ");
 8012aa2:	2220      	movs	r2, #32
 8012aa4:	54e2      	strb	r2, [r4, r3]

	  strcat((char *)PAGE_BODY, td);
 8012aa6:	3305      	adds	r3, #5
 8012aa8:	5060      	str	r0, [r4, r1]
	  //itoa((uint32_t)tp->p_time, mes);
	  strcat((char *)PAGE_BODY, mes);
 8012aaa:	eb0d 0102 	add.w	r1, sp, r2
 8012aae:	18e0      	adds	r0, r4, r3
 8012ab0:	f001 fbe6 	bl	8014280 <stpcpy>
 8012ab4:	4602      	mov	r2, r0

	  strcat((char *)PAGE_BODY, trc);
 8012ab6:	f8b8 3004 	ldrh.w	r3, [r8, #4]
 8012aba:	f8d8 0000 	ldr.w	r0, [r8]
 8012abe:	6010      	str	r0, [r2, #0]
 8012ac0:	8093      	strh	r3, [r2, #4]
	  
	  tp = chRegNextThread(tp);
 8012ac2:	4628      	mov	r0, r5
 8012ac4:	f7ee fedc 	bl	8001880 <chRegNextThread>
  }
  while(tp != NULL);
 8012ac8:	4605      	mov	r5, r0
 8012aca:	2800      	cmp	r0, #0
 8012acc:	d197      	bne.n	80129fe <DynWebPage+0x7e>
  strcat((char *)PAGE_BODY, "</table>" );
 8012ace:	4620      	mov	r0, r4
 8012ad0:	f001 fbfe 	bl	80142d0 <strlen>
 8012ad4:	4b1a      	ldr	r3, [pc, #104]	; (8012b40 <DynWebPage+0x1c0>)
 8012ad6:	4606      	mov	r6, r0
 8012ad8:	cb03      	ldmia	r3!, {r0, r1}
 8012ada:	19a2      	adds	r2, r4, r6
 8012adc:	781b      	ldrb	r3, [r3, #0]
 8012ade:	51a0      	str	r0, [r4, r6]
 8012ae0:	7213      	strb	r3, [r2, #8]
 8012ae2:	6051      	str	r1, [r2, #4]

  // Send the dynamically generated page
  netconn_write(conn, PAGE_START, strlen((char*)PAGE_START), NETCONN_COPY);
 8012ae4:	4817      	ldr	r0, [pc, #92]	; (8012b44 <DynWebPage+0x1c4>)
 8012ae6:	f001 fbf3 	bl	80142d0 <strlen>
 8012aea:	9e03      	ldr	r6, [sp, #12]
 8012aec:	4915      	ldr	r1, [pc, #84]	; (8012b44 <DynWebPage+0x1c4>)
 8012aee:	9500      	str	r5, [sp, #0]
 8012af0:	4602      	mov	r2, r0
 8012af2:	2301      	movs	r3, #1
 8012af4:	4630      	mov	r0, r6
 8012af6:	f7fc fd83 	bl	800f600 <netconn_write_partly>
  netconn_write(conn, TABLE_HEAD, strlen((char*)TABLE_HEAD), NETCONN_COPY);
 8012afa:	a815      	add	r0, sp, #84	; 0x54
 8012afc:	f001 fbe8 	bl	80142d0 <strlen>
 8012b00:	a915      	add	r1, sp, #84	; 0x54
 8012b02:	4602      	mov	r2, r0
 8012b04:	2301      	movs	r3, #1
 8012b06:	9500      	str	r5, [sp, #0]
 8012b08:	4630      	mov	r0, r6
 8012b0a:	f7fc fd79 	bl	800f600 <netconn_write_partly>
  netconn_write(conn, PAGE_BODY,  strlen(PAGE_BODY), 		 NETCONN_COPY);
 8012b0e:	4620      	mov	r0, r4
 8012b10:	f001 fbde 	bl	80142d0 <strlen>
 8012b14:	9500      	str	r5, [sp, #0]
 8012b16:	4602      	mov	r2, r0
 8012b18:	4621      	mov	r1, r4
 8012b1a:	4630      	mov	r0, r6
 8012b1c:	2301      	movs	r3, #1
 8012b1e:	f7fc fd6f 	bl	800f600 <netconn_write_partly>
}
 8012b22:	f20d 4ddc 	addw	sp, sp, #1244	; 0x4dc
 8012b26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8012b2a:	bf00      	nop
 8012b2c:	20016c7c 	.word	0x20016c7c
 8012b30:	08019d58 	.word	0x08019d58
 8012b34:	08019cd0 	.word	0x08019cd0
 8012b38:	08019cdc 	.word	0x08019cdc
 8012b3c:	08019d50 	.word	0x08019d50
 8012b40:	08019d68 	.word	0x08019d68
 8012b44:	080197d0 	.word	0x080197d0
 8012b48:	08019d60 	.word	0x08019d60
 8012b4c:	f3af 8000 	nop.w

08012b50 <DynWebPage_ModbusStat>:
  *         running modbus slaves.
  * @param  conn pointer on connection structure
  * @retval None
  */
void DynWebPage_ModbusStat(struct netconn *conn)
{
 8012b50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012b54:	f2ad 5d54 	subw	sp, sp, #1364	; 0x554
  DeviceElement* e;
  uint8_t index = 0;

  char PAGE_BODY[1024];
  char pagehits[10] = {0};
 8012b58:	2700      	movs	r7, #0
  memset(PAGE_BODY, 0,1024);
 8012b5a:	ac54      	add	r4, sp, #336	; 0x150
  *         running modbus slaves.
  * @param  conn pointer on connection structure
  * @retval None
  */
void DynWebPage_ModbusStat(struct netconn *conn)
{
 8012b5c:	9003      	str	r0, [sp, #12]
  DeviceElement* e;
  uint8_t index = 0;

  char PAGE_BODY[1024];
  char pagehits[10] = {0};
  memset(PAGE_BODY, 0,1024);
 8012b5e:	4639      	mov	r1, r7
 8012b60:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8012b64:	4620      	mov	r0, r4
{
  DeviceElement* e;
  uint8_t index = 0;

  char PAGE_BODY[1024];
  char pagehits[10] = {0};
 8012b66:	9705      	str	r7, [sp, #20]
 8012b68:	f8ad 7018 	strh.w	r7, [sp, #24]
 8012b6c:	9704      	str	r7, [sp, #16]
  memset(PAGE_BODY, 0,1024);
 8012b6e:	f001 f92f 	bl	8013dd0 <memset>

  char TABLE_HEAD[256];
  memset(TABLE_HEAD, 0,256);
 8012b72:	4639      	mov	r1, r7
 8012b74:	f44f 7280 	mov.w	r2, #256	; 0x100
 8012b78:	a814      	add	r0, sp, #80	; 0x50
 8012b7a:	f001 f929 	bl	8013dd0 <memset>

  /* Update the hit count */
  nPageHits++;
 8012b7e:	4ab8      	ldr	r2, [pc, #736]	; (8012e60 <DynWebPage_ModbusStat+0x310>)
 8012b80:	4eb8      	ldr	r6, [pc, #736]	; (8012e64 <DynWebPage_ModbusStat+0x314>)
 8012b82:	6813      	ldr	r3, [r2, #0]
 8012b84:	4db8      	ldr	r5, [pc, #736]	; (8012e68 <DynWebPage_ModbusStat+0x318>)
 8012b86:	3301      	adds	r3, #1

  itoa(nPageHits, pagehits);
 8012b88:	4618      	mov	r0, r3
 8012b8a:	a904      	add	r1, sp, #16

  char TABLE_HEAD[256];
  memset(TABLE_HEAD, 0,256);

  /* Update the hit count */
  nPageHits++;
 8012b8c:	6013      	str	r3, [r2, #0]

  itoa(nPageHits, pagehits);
 8012b8e:	f7ff febf 	bl	8012910 <itoa>
 8012b92:	a814      	add	r0, sp, #80	; 0x50
 8012b94:	f001 fb9c 	bl	80142d0 <strlen>
  strcat(TABLE_HEAD, pagehits);
 8012b98:	ab14      	add	r3, sp, #80	; 0x50
 8012b9a:	a904      	add	r1, sp, #16
 8012b9c:	4418      	add	r0, r3
 8012b9e:	f001 fb6f 	bl	8014280 <stpcpy>
  strcat(TABLE_HEAD, "<br><br>");
 8012ba2:	4bb2      	ldr	r3, [pc, #712]	; (8012e6c <DynWebPage_ModbusStat+0x31c>)

  /* Update the hit count */
  nPageHits++;

  itoa(nPageHits, pagehits);
  strcat(TABLE_HEAD, pagehits);
 8012ba4:	4686      	mov	lr, r0
  strcat(TABLE_HEAD, "<br><br>");
 8012ba6:	cb03      	ldmia	r3!, {r0, r1}

  strcat((char *)TABLE_HEAD,
 8012ba8:	2288      	movs	r2, #136	; 0x88
  /* Update the hit count */
  nPageHits++;

  itoa(nPageHits, pagehits);
  strcat(TABLE_HEAD, pagehits);
  strcat(TABLE_HEAD, "<br><br>");
 8012baa:	f8ce 0000 	str.w	r0, [lr]
 8012bae:	f8ce 1004 	str.w	r1, [lr, #4]

  strcat((char *)TABLE_HEAD,
 8012bb2:	f10e 0008 	add.w	r0, lr, #8
 8012bb6:	49ae      	ldr	r1, [pc, #696]	; (8012e70 <DynWebPage_ModbusStat+0x320>)
 8012bb8:	f7ed fe82 	bl	80008c0 <memcpy>
  * @retval None
  */
void DynWebPage_ModbusStat(struct netconn *conn)
{
  DeviceElement* e;
  uint8_t index = 0;
 8012bbc:	46bb      	mov	fp, r7
 8012bbe:	f1c4 0905 	rsb	r9, r4, #5
 8012bc2:	e0c1      	b.n	8012d48 <DynWebPage_ModbusStat+0x1f8>
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
	  if(e->state == 0)
	  {
		strcat((char *)PAGE_BODY, "CONNECTED");
 8012bc4:	4aab      	ldr	r2, [pc, #684]	; (8012e74 <DynWebPage_ModbusStat+0x324>)
 8012bc6:	ca03      	ldmia	r2!, {r0, r1}
 8012bc8:	3304      	adds	r3, #4
 8012bca:	18e7      	adds	r7, r4, r3
 8012bcc:	8812      	ldrh	r2, [r2, #0]
 8012bce:	50e0      	str	r0, [r4, r3]
 8012bd0:	813a      	strh	r2, [r7, #8]
 8012bd2:	6079      	str	r1, [r7, #4]
	  }else{
		strcat((char *)PAGE_BODY, "CONNECTIONLESS");
	  }
	  strcat((char *)PAGE_BODY, "</td>");
 8012bd4:	4620      	mov	r0, r4
 8012bd6:	f001 fb7b 	bl	80142d0 <strlen>
 8012bda:	4603      	mov	r3, r0
 8012bdc:	1822      	adds	r2, r4, r0
 8012bde:	6828      	ldr	r0, [r5, #0]
 8012be0:	792f      	ldrb	r7, [r5, #4]
 8012be2:	50e0      	str	r0, [r4, r3]
	  
	  strcat((char *)PAGE_BODY, td);
 8012be4:	3305      	adds	r3, #5
	  {
		strcat((char *)PAGE_BODY, "CONNECTED");
	  }else{
		strcat((char *)PAGE_BODY, "CONNECTIONLESS");
	  }
	  strcat((char *)PAGE_BODY, "</td>");
 8012be6:	7117      	strb	r7, [r2, #4]
	  
	  strcat((char *)PAGE_BODY, td);
 8012be8:	6830      	ldr	r0, [r6, #0]
 8012bea:	f896 a004 	ldrb.w	sl, [r6, #4]
 8012bee:	50e0      	str	r0, [r4, r3]
 8012bf0:	18e2      	adds	r2, r4, r3
	  itoa((e->TimeOut_request), mes);
 8012bf2:	a907      	add	r1, sp, #28
	  }else{
		strcat((char *)PAGE_BODY, "CONNECTIONLESS");
	  }
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
 8012bf4:	f882 a004 	strb.w	sl, [r2, #4]
	  itoa((e->TimeOut_request), mes);
 8012bf8:	f8b8 000a 	ldrh.w	r0, [r8, #10]
 8012bfc:	f7ff fe88 	bl	8012910 <itoa>
 8012c00:	4620      	mov	r0, r4
 8012c02:	f001 fb65 	bl	80142d0 <strlen>
	  strcat((char *)PAGE_BODY, mes);
 8012c06:	a907      	add	r1, sp, #28
 8012c08:	4420      	add	r0, r4
 8012c0a:	f001 fb39 	bl	8014280 <stpcpy>
 8012c0e:	4603      	mov	r3, r0
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
 8012c10:	eb03 0209 	add.w	r2, r3, r9
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->TimeOut_request), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
 8012c14:	6828      	ldr	r0, [r5, #0]
 8012c16:	6018      	str	r0, [r3, #0]
 8012c18:	711f      	strb	r7, [r3, #4]
	  
	  strcat((char *)PAGE_BODY, td);
 8012c1a:	6830      	ldr	r0, [r6, #0]
 8012c1c:	50a0      	str	r0, [r4, r2]
 8012c1e:	18a3      	adds	r3, r4, r2
	  itoa((e->requests), mes);
 8012c20:	a907      	add	r1, sp, #28
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->TimeOut_request), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
 8012c22:	f883 a004 	strb.w	sl, [r3, #4]
	  itoa((e->requests), mes);
 8012c26:	f8b8 000c 	ldrh.w	r0, [r8, #12]
 8012c2a:	f7ff fe71 	bl	8012910 <itoa>
 8012c2e:	4620      	mov	r0, r4
 8012c30:	f001 fb4e 	bl	80142d0 <strlen>
	  strcat((char *)PAGE_BODY, mes);
 8012c34:	a907      	add	r1, sp, #28
 8012c36:	4420      	add	r0, r4
 8012c38:	f001 fb22 	bl	8014280 <stpcpy>
 8012c3c:	4603      	mov	r3, r0
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
 8012c3e:	eb03 0209 	add.w	r2, r3, r9
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->requests), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
 8012c42:	6828      	ldr	r0, [r5, #0]
 8012c44:	6018      	str	r0, [r3, #0]
 8012c46:	711f      	strb	r7, [r3, #4]
	  
	  strcat((char *)PAGE_BODY, td);
 8012c48:	6830      	ldr	r0, [r6, #0]
 8012c4a:	50a0      	str	r0, [r4, r2]
 8012c4c:	18a3      	adds	r3, r4, r2
	  itoa((e->function), mes);
 8012c4e:	a907      	add	r1, sp, #28
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->requests), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
 8012c50:	f883 a004 	strb.w	sl, [r3, #4]
	  itoa((e->function), mes);
 8012c54:	f898 000e 	ldrb.w	r0, [r8, #14]
 8012c58:	f7ff fe5a 	bl	8012910 <itoa>
 8012c5c:	4620      	mov	r0, r4
 8012c5e:	f001 fb37 	bl	80142d0 <strlen>
	  strcat((char *)PAGE_BODY, mes);
 8012c62:	a907      	add	r1, sp, #28
 8012c64:	4420      	add	r0, r4
 8012c66:	f001 fb0b 	bl	8014280 <stpcpy>
 8012c6a:	4603      	mov	r3, r0
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
 8012c6c:	eb03 0209 	add.w	r2, r3, r9
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->function), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
 8012c70:	6828      	ldr	r0, [r5, #0]
 8012c72:	6018      	str	r0, [r3, #0]
 8012c74:	711f      	strb	r7, [r3, #4]
	  
	  strcat((char *)PAGE_BODY, td);
 8012c76:	6830      	ldr	r0, [r6, #0]
 8012c78:	50a0      	str	r0, [r4, r2]
 8012c7a:	18a3      	adds	r3, r4, r2
	  itoa((e->regStart), mes);
 8012c7c:	a907      	add	r1, sp, #28
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->function), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
 8012c7e:	f883 a004 	strb.w	sl, [r3, #4]
	  itoa((e->regStart), mes);
 8012c82:	f8b8 0010 	ldrh.w	r0, [r8, #16]
 8012c86:	f7ff fe43 	bl	8012910 <itoa>
 8012c8a:	4620      	mov	r0, r4
 8012c8c:	f001 fb20 	bl	80142d0 <strlen>
	  strcat((char *)PAGE_BODY, mes);
 8012c90:	a907      	add	r1, sp, #28
 8012c92:	4420      	add	r0, r4
 8012c94:	f001 faf4 	bl	8014280 <stpcpy>
 8012c98:	4603      	mov	r3, r0
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
 8012c9a:	eb03 0209 	add.w	r2, r3, r9
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->regStart), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
 8012c9e:	6828      	ldr	r0, [r5, #0]
 8012ca0:	6018      	str	r0, [r3, #0]
 8012ca2:	711f      	strb	r7, [r3, #4]
	  
	  strcat((char *)PAGE_BODY, td);
 8012ca4:	6830      	ldr	r0, [r6, #0]
 8012ca6:	50a0      	str	r0, [r4, r2]
 8012ca8:	18a3      	adds	r3, r4, r2
	  itoa((e->regCount), mes);
 8012caa:	a907      	add	r1, sp, #28
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->regStart), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
 8012cac:	f883 a004 	strb.w	sl, [r3, #4]
	  itoa((e->regCount), mes);
 8012cb0:	f8b8 0012 	ldrh.w	r0, [r8, #18]
 8012cb4:	f7ff fe2c 	bl	8012910 <itoa>
 8012cb8:	4620      	mov	r0, r4
 8012cba:	f001 fb09 	bl	80142d0 <strlen>
	  strcat((char *)PAGE_BODY, mes);
 8012cbe:	a907      	add	r1, sp, #28
 8012cc0:	4420      	add	r0, r4
 8012cc2:	f001 fadd 	bl	8014280 <stpcpy>
 8012cc6:	4603      	mov	r3, r0
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
 8012cc8:	eb03 0209 	add.w	r2, r3, r9
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->regCount), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
 8012ccc:	6828      	ldr	r0, [r5, #0]
 8012cce:	6018      	str	r0, [r3, #0]
 8012cd0:	711f      	strb	r7, [r3, #4]
	  
	  strcat((char *)PAGE_BODY, td);
 8012cd2:	6830      	ldr	r0, [r6, #0]
 8012cd4:	50a0      	str	r0, [r4, r2]
 8012cd6:	18a3      	adds	r3, r4, r2
	  itoa((e->AHU_address), mes);
 8012cd8:	a907      	add	r1, sp, #28
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->regCount), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
 8012cda:	f883 a004 	strb.w	sl, [r3, #4]
	  itoa((e->AHU_address), mes);
 8012cde:	f898 0014 	ldrb.w	r0, [r8, #20]
 8012ce2:	f7ff fe15 	bl	8012910 <itoa>
 8012ce6:	4620      	mov	r0, r4
 8012ce8:	f001 faf2 	bl	80142d0 <strlen>
	  strcat((char *)PAGE_BODY, mes);
 8012cec:	a907      	add	r1, sp, #28
 8012cee:	4420      	add	r0, r4
 8012cf0:	f001 fac6 	bl	8014280 <stpcpy>
 8012cf4:	4603      	mov	r3, r0
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
 8012cf6:	eb03 0209 	add.w	r2, r3, r9
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->AHU_address), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
 8012cfa:	6828      	ldr	r0, [r5, #0]
 8012cfc:	6018      	str	r0, [r3, #0]
 8012cfe:	711f      	strb	r7, [r3, #4]
	  
	  strcat((char *)PAGE_BODY, td);
 8012d00:	6830      	ldr	r0, [r6, #0]
 8012d02:	50a0      	str	r0, [r4, r2]
 8012d04:	18a3      	adds	r3, r4, r2
	  itoa((e->HRU_address), mes);
 8012d06:	a907      	add	r1, sp, #28
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->AHU_address), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
 8012d08:	f883 a004 	strb.w	sl, [r3, #4]
	  itoa((e->HRU_address), mes);
 8012d0c:	f898 0015 	ldrb.w	r0, [r8, #21]
 8012d10:	f7ff fdfe 	bl	8012910 <itoa>
 8012d14:	4620      	mov	r0, r4
 8012d16:	f001 fadb 	bl	80142d0 <strlen>
	  strcat((char *)PAGE_BODY, mes);
 8012d1a:	a907      	add	r1, sp, #28
 8012d1c:	4420      	add	r0, r4
 8012d1e:	f001 faaf 	bl	8014280 <stpcpy>
	  strcat((char *)PAGE_BODY, "</td>");

	  strcat((char *)PAGE_BODY, trc);
    }
    while(index <= list_RTC.current);
 8012d22:	4a55      	ldr	r2, [pc, #340]	; (8012e78 <DynWebPage_ModbusStat+0x328>)
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->HRU_address), mes);
	  strcat((char *)PAGE_BODY, mes);
 8012d24:	4603      	mov	r3, r0
	  strcat((char *)PAGE_BODY, "</td>");

	  strcat((char *)PAGE_BODY, trc);
 8012d26:	eb00 0e09 	add.w	lr, r0, r9
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->HRU_address), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
 8012d2a:	6828      	ldr	r0, [r5, #0]
 8012d2c:	6018      	str	r0, [r3, #0]
 8012d2e:	711f      	strb	r7, [r3, #4]

	  strcat((char *)PAGE_BODY, trc);
    }
    while(index <= list_RTC.current);
 8012d30:	6812      	ldr	r2, [r2, #0]
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->HRU_address), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");

	  strcat((char *)PAGE_BODY, trc);
 8012d32:	4852      	ldr	r0, [pc, #328]	; (8012e7c <DynWebPage_ModbusStat+0x32c>)
 8012d34:	4b51      	ldr	r3, [pc, #324]	; (8012e7c <DynWebPage_ModbusStat+0x32c>)
 8012d36:	6800      	ldr	r0, [r0, #0]
 8012d38:	889b      	ldrh	r3, [r3, #4]
 8012d3a:	f844 000e 	str.w	r0, [r4, lr]
 8012d3e:	eb04 010e 	add.w	r1, r4, lr
    }
    while(index <= list_RTC.current);
 8012d42:	4593      	cmp	fp, r2
	  strcat((char *)PAGE_BODY, td);
	  itoa((e->HRU_address), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");

	  strcat((char *)PAGE_BODY, trc);
 8012d44:	808b      	strh	r3, [r1, #4]
    }
    while(index <= list_RTC.current);
 8012d46:	dc5c      	bgt.n	8012e02 <DynWebPage_ModbusStat+0x2b2>
  const char * tr = "<tr>";
  const char * td = "<td>";
  const char * trc = "</tr>";
  
  do{
	  chprintf((BaseSequentialStream *)&itm_port, "index: %d\n", index);
 8012d48:	465a      	mov	r2, fp
 8012d4a:	494d      	ldr	r1, [pc, #308]	; (8012e80 <DynWebPage_ModbusStat+0x330>)
 8012d4c:	484d      	ldr	r0, [pc, #308]	; (8012e84 <DynWebPage_ModbusStat+0x334>)
 8012d4e:	f7ff fdc7 	bl	80128e0 <chprintf.constprop.0>
	  e = get(&list_RTC, index++);
 8012d52:	4659      	mov	r1, fp
 8012d54:	4848      	ldr	r0, [pc, #288]	; (8012e78 <DynWebPage_ModbusStat+0x328>)
 8012d56:	f000 fb6b 	bl	8013430 <get>
 8012d5a:	4680      	mov	r8, r0
	  
	  strcat((char *)PAGE_BODY, tr);
 8012d5c:	4620      	mov	r0, r4
 8012d5e:	f001 fab7 	bl	80142d0 <strlen>
 8012d62:	4949      	ldr	r1, [pc, #292]	; (8012e88 <DynWebPage_ModbusStat+0x338>)

	  strcat((char *)PAGE_BODY, td);
 8012d64:	f896 a004 	ldrb.w	sl, [r6, #4]
  
  do{
	  chprintf((BaseSequentialStream *)&itm_port, "index: %d\n", index);
	  e = get(&list_RTC, index++);
	  
	  strcat((char *)PAGE_BODY, tr);
 8012d68:	4603      	mov	r3, r0

	  strcat((char *)PAGE_BODY, td);
 8012d6a:	1d02      	adds	r2, r0, #4
  
  do{
	  chprintf((BaseSequentialStream *)&itm_port, "index: %d\n", index);
	  e = get(&list_RTC, index++);
	  
	  strcat((char *)PAGE_BODY, tr);
 8012d6c:	6808      	ldr	r0, [r1, #0]
 8012d6e:	50e0      	str	r0, [r4, r3]

	  strcat((char *)PAGE_BODY, td);
 8012d70:	18a1      	adds	r1, r4, r2
 8012d72:	6830      	ldr	r0, [r6, #0]
 8012d74:	50a0      	str	r0, [r4, r2]
 8012d76:	f103 0008 	add.w	r0, r3, #8
 8012d7a:	f881 a004 	strb.w	sl, [r1, #4]
	  strcat((char *)PAGE_BODY, (e->name));
 8012d7e:	f8d8 1004 	ldr.w	r1, [r8, #4]
 8012d82:	4420      	add	r0, r4
 8012d84:	f001 fa7c 	bl	8014280 <stpcpy>
 8012d88:	4603      	mov	r3, r0
	  strcat((char *)PAGE_BODY, "</td>");

	  strcat((char *)PAGE_BODY, td);
 8012d8a:	eb00 0209 	add.w	r2, r0, r9
	  
	  strcat((char *)PAGE_BODY, tr);

	  strcat((char *)PAGE_BODY, td);
	  strcat((char *)PAGE_BODY, (e->name));
	  strcat((char *)PAGE_BODY, "</td>");
 8012d8e:	792f      	ldrb	r7, [r5, #4]
 8012d90:	6828      	ldr	r0, [r5, #0]
 8012d92:	6018      	str	r0, [r3, #0]
 8012d94:	711f      	strb	r7, [r3, #4]

	  strcat((char *)PAGE_BODY, td);
 8012d96:	6830      	ldr	r0, [r6, #0]
 8012d98:	50a0      	str	r0, [r4, r2]
 8012d9a:	18a3      	adds	r3, r4, r2
	  itoa((e->address), mes);
 8012d9c:	a907      	add	r1, sp, #28

	  strcat((char *)PAGE_BODY, td);
	  strcat((char *)PAGE_BODY, (e->name));
	  strcat((char *)PAGE_BODY, "</td>");

	  strcat((char *)PAGE_BODY, td);
 8012d9e:	f883 a004 	strb.w	sl, [r3, #4]
	  itoa((e->address), mes);
 8012da2:	f898 0000 	ldrb.w	r0, [r8]
 8012da6:	f7ff fdb3 	bl	8012910 <itoa>
 8012daa:	4620      	mov	r0, r4
 8012dac:	f001 fa90 	bl	80142d0 <strlen>
	  strcat((char *)PAGE_BODY, mes);
 8012db0:	a907      	add	r1, sp, #28
 8012db2:	4420      	add	r0, r4
 8012db4:	f001 fa64 	bl	8014280 <stpcpy>
 8012db8:	4602      	mov	r2, r0
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
 8012dba:	eb00 0309 	add.w	r3, r0, r9
	  strcat((char *)PAGE_BODY, "</td>");

	  strcat((char *)PAGE_BODY, td);
	  itoa((e->address), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
 8012dbe:	6828      	ldr	r0, [r5, #0]
 8012dc0:	6010      	str	r0, [r2, #0]
	  
	  strcat((char *)PAGE_BODY, td);
 8012dc2:	18e1      	adds	r1, r4, r3
 8012dc4:	6830      	ldr	r0, [r6, #0]
	  strcat((char *)PAGE_BODY, "</td>");

	  strcat((char *)PAGE_BODY, td);
	  itoa((e->address), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
 8012dc6:	7117      	strb	r7, [r2, #4]
	  
	  strcat((char *)PAGE_BODY, td);
 8012dc8:	50e0      	str	r0, [r4, r3]
 8012dca:	f881 a004 	strb.w	sl, [r1, #4]
	  if(e->state == 0)
 8012dce:	f898 2008 	ldrb.w	r2, [r8, #8]
  const char * td = "<td>";
  const char * trc = "</tr>";
  
  do{
	  chprintf((BaseSequentialStream *)&itm_port, "index: %d\n", index);
	  e = get(&list_RTC, index++);
 8012dd2:	f10b 0b01 	add.w	fp, fp, #1
 8012dd6:	fa5f fb8b 	uxtb.w	fp, fp
	  itoa((e->address), mes);
	  strcat((char *)PAGE_BODY, mes);
	  strcat((char *)PAGE_BODY, "</td>");
	  
	  strcat((char *)PAGE_BODY, td);
	  if(e->state == 0)
 8012dda:	2a00      	cmp	r2, #0
 8012ddc:	f43f aef2 	beq.w	8012bc4 <DynWebPage_ModbusStat+0x74>
	  {
		strcat((char *)PAGE_BODY, "CONNECTED");
	  }else{
		strcat((char *)PAGE_BODY, "CONNECTIONLESS");
 8012de0:	4f2a      	ldr	r7, [pc, #168]	; (8012e8c <DynWebPage_ModbusStat+0x33c>)
 8012de2:	cf07      	ldmia	r7!, {r0, r1, r2}
 8012de4:	3304      	adds	r3, #4
 8012de6:	eb04 0e03 	add.w	lr, r4, r3
 8012dea:	50e0      	str	r0, [r4, r3]
 8012dec:	8838      	ldrh	r0, [r7, #0]
 8012dee:	78bb      	ldrb	r3, [r7, #2]
 8012df0:	f8ce 1004 	str.w	r1, [lr, #4]
 8012df4:	f8ce 2008 	str.w	r2, [lr, #8]
 8012df8:	f8ae 000c 	strh.w	r0, [lr, #12]
 8012dfc:	f88e 300e 	strb.w	r3, [lr, #14]
 8012e00:	e6e8      	b.n	8012bd4 <DynWebPage_ModbusStat+0x84>

	  strcat((char *)PAGE_BODY, trc);
    }
    while(index <= list_RTC.current);
  
  strcat((char *)PAGE_BODY, "</table>" );
 8012e02:	4b23      	ldr	r3, [pc, #140]	; (8012e90 <DynWebPage_ModbusStat+0x340>)
 8012e04:	cb03      	ldmia	r3!, {r0, r1}
 8012e06:	f10e 0e05 	add.w	lr, lr, #5
 8012e0a:	eb04 020e 	add.w	r2, r4, lr
 8012e0e:	781b      	ldrb	r3, [r3, #0]
 8012e10:	f844 000e 	str.w	r0, [r4, lr]
 8012e14:	7213      	strb	r3, [r2, #8]
 8012e16:	6051      	str	r1, [r2, #4]
  
  //chprintf((BaseSequentialStream *)&itm_port, "PAGE_BODY: %s\n", PAGE_BODY);

  // Send the dynamically generated page
  netconn_write(conn, PAGE_START, strlen((char*)PAGE_START), NETCONN_COPY);
 8012e18:	481e      	ldr	r0, [pc, #120]	; (8012e94 <DynWebPage_ModbusStat+0x344>)
 8012e1a:	f001 fa59 	bl	80142d0 <strlen>
 8012e1e:	9e03      	ldr	r6, [sp, #12]
 8012e20:	491c      	ldr	r1, [pc, #112]	; (8012e94 <DynWebPage_ModbusStat+0x344>)
 8012e22:	2500      	movs	r5, #0
 8012e24:	4602      	mov	r2, r0
 8012e26:	2301      	movs	r3, #1
 8012e28:	9500      	str	r5, [sp, #0]
 8012e2a:	4630      	mov	r0, r6
 8012e2c:	f7fc fbe8 	bl	800f600 <netconn_write_partly>
  netconn_write(conn, TABLE_HEAD, strlen((char*)TABLE_HEAD), NETCONN_COPY);
 8012e30:	a814      	add	r0, sp, #80	; 0x50
 8012e32:	f001 fa4d 	bl	80142d0 <strlen>
 8012e36:	a914      	add	r1, sp, #80	; 0x50
 8012e38:	4602      	mov	r2, r0
 8012e3a:	2301      	movs	r3, #1
 8012e3c:	9500      	str	r5, [sp, #0]
 8012e3e:	4630      	mov	r0, r6
 8012e40:	f7fc fbde 	bl	800f600 <netconn_write_partly>
  netconn_write(conn, PAGE_BODY,  strlen(PAGE_BODY), 		 NETCONN_COPY);
 8012e44:	4620      	mov	r0, r4
 8012e46:	f001 fa43 	bl	80142d0 <strlen>
 8012e4a:	9500      	str	r5, [sp, #0]
 8012e4c:	4602      	mov	r2, r0
 8012e4e:	4621      	mov	r1, r4
 8012e50:	4630      	mov	r0, r6
 8012e52:	2301      	movs	r3, #1
 8012e54:	f7fc fbd4 	bl	800f600 <netconn_write_partly>
}
 8012e58:	f20d 5d54 	addw	sp, sp, #1364	; 0x554
 8012e5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8012e60:	20016c7c 	.word	0x20016c7c
 8012e64:	08019d58 	.word	0x08019d58
 8012e68:	08019e08 	.word	0x08019e08
 8012e6c:	08019cd0 	.word	0x08019cd0
 8012e70:	08019d74 	.word	0x08019d74
 8012e74:	08019e10 	.word	0x08019e10
 8012e78:	20018420 	.word	0x20018420
 8012e7c:	08019d60 	.word	0x08019d60
 8012e80:	08019dfc 	.word	0x08019dfc
 8012e84:	200180c8 	.word	0x200180c8
 8012e88:	08019d50 	.word	0x08019d50
 8012e8c:	08019e1c 	.word	0x08019e1c
 8012e90:	08019d68 	.word	0x08019d68
 8012e94:	080197d0 	.word	0x080197d0
 8012e98:	f3af 8000 	nop.w
 8012e9c:	f3af 8000 	nop.w

08012ea0 <http_server_serve>:
  * @brief serve tcp connection
  * @param conn: pointer on connection structure
  * @retval None
  */
void http_server_serve(struct netconn *conn)
{
 8012ea0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8012ea4:	b092      	sub	sp, #72	; 0x48
  uint32_t			FilenameOffset;
  int32_t 			i = 0;
  err_t 			err;
  // Read the data from the port, blocking if nothing yet there.
  // We assume the request (the part we care about) is in one netbuf
  err = netconn_recv(conn, &inbuf);
 8012ea6:	a903      	add	r1, sp, #12
  * @brief serve tcp connection
  * @param conn: pointer on connection structure
  * @retval None
  */
void http_server_serve(struct netconn *conn)
{
 8012ea8:	4607      	mov	r7, r0
  uint32_t			FilenameOffset;
  int32_t 			i = 0;
  err_t 			err;
  // Read the data from the port, blocking if nothing yet there.
  // We assume the request (the part we care about) is in one netbuf
  err = netconn_recv(conn, &inbuf);
 8012eaa:	f7fc fb21 	bl	800f4f0 <netconn_recv>

  if (inbuf != NULL)
 8012eae:	9b03      	ldr	r3, [sp, #12]
 8012eb0:	b103      	cbz	r3, 8012eb4 <http_server_serve+0x14>
  {
    if (err == ERR_OK)
 8012eb2:	b140      	cbz	r0, 8012ec6 <http_server_serve+0x26>
		}
	  }
    }
  }
  /* Close the connection (server closes in HTTP) */
  netconn_close(conn);
 8012eb4:	4638      	mov	r0, r7
 8012eb6:	f7fc fc13 	bl	800f6e0 <netconn_close>

  /* Delete the buffer (netconn_recv gives us ownership,
   so we have to make sure to deallocate the buffer) */
  netbuf_delete(inbuf);
 8012eba:	9803      	ldr	r0, [sp, #12]
 8012ebc:	f7fd fc90 	bl	80107e0 <netbuf_delete>
}
 8012ec0:	b012      	add	sp, #72	; 0x48
 8012ec2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

  if (inbuf != NULL)
  {
    if (err == ERR_OK)
    {
      netbuf_data(inbuf, (void**)&buf, &buflen);
 8012ec6:	4618      	mov	r0, r3
 8012ec8:	a904      	add	r1, sp, #16
 8012eca:	f10d 020a 	add.w	r2, sp, #10
 8012ece:	f7fd fc9f 	bl	8010810 <netbuf_data>
	  chprintf((BaseSequentialStream *)&itm_port, "buflen: %i\n buf: %s\n", buflen, buf);
 8012ed2:	9b04      	ldr	r3, [sp, #16]
 8012ed4:	48b5      	ldr	r0, [pc, #724]	; (80131ac <http_server_serve+0x30c>)
 8012ed6:	49b6      	ldr	r1, [pc, #728]	; (80131b0 <http_server_serve+0x310>)
 8012ed8:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 8012edc:	f7ff fd00 	bl	80128e0 <chprintf.constprop.0>

      /* Is this an HTTP GET command? (only check the first 5 chars, since
      there are other formats for GET, and we're keeping it very simple )*/
      if ((buflen >=5) && (strncmp(buf, "GET /", 5) == 0))
 8012ee0:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 8012ee4:	9c04      	ldr	r4, [sp, #16]
 8012ee6:	2b04      	cmp	r3, #4
 8012ee8:	d945      	bls.n	8012f76 <http_server_serve+0xd6>
 8012eea:	49b2      	ldr	r1, [pc, #712]	; (80131b4 <http_server_serve+0x314>)
 8012eec:	4620      	mov	r0, r4
 8012eee:	2205      	movs	r2, #5
 8012ef0:	f001 fa1e 	bl	8014330 <strncmp>
 8012ef4:	2800      	cmp	r0, #0
 8012ef6:	d13e      	bne.n	8012f76 <http_server_serve+0xd6>
      {
        /* Check if request to get climate-control.jpg */
        if (strncmp((char const *)buf,"GET /assets/splash_screen.jpg",25)==0)
 8012ef8:	4620      	mov	r0, r4
 8012efa:	49af      	ldr	r1, [pc, #700]	; (80131b8 <http_server_serve+0x318>)
 8012efc:	2219      	movs	r2, #25
 8012efe:	f001 fa17 	bl	8014330 <strncmp>
 8012f02:	4605      	mov	r5, r0
 8012f04:	2800      	cmp	r0, #0
 8012f06:	f000 810c 	beq.w	8013122 <http_server_serve+0x282>
          file = fs_open("/img/splash_screen.jpg");
          netconn_write(conn, (const unsigned char*)(file->data), (size_t)file->len, NETCONN_NOCOPY);
          fs_close(file);
        }
		/* Load dynamic page */
        else if(strncmp(buf, "GET /STM32F4x7TASKS.html", 24) == 0)
 8012f0a:	4620      	mov	r0, r4
 8012f0c:	49ab      	ldr	r1, [pc, #684]	; (80131bc <http_server_serve+0x31c>)
 8012f0e:	2218      	movs	r2, #24
 8012f10:	f001 fa0e 	bl	8014330 <strncmp>
 8012f14:	2800      	cmp	r0, #0
 8012f16:	f000 80db 	beq.w	80130d0 <http_server_serve+0x230>
        {
           DynWebPage(conn);
        }
		else if(strncmp(buf, "GET /MODBUSTASKS.html", 21) == 0)
 8012f1a:	4620      	mov	r0, r4
 8012f1c:	49a8      	ldr	r1, [pc, #672]	; (80131c0 <http_server_serve+0x320>)
 8012f1e:	2215      	movs	r2, #21
 8012f20:	f001 fa06 	bl	8014330 <strncmp>
 8012f24:	2800      	cmp	r0, #0
 8012f26:	f000 8127 	beq.w	8013178 <http_server_serve+0x2d8>
        {
           DynWebPage_ModbusStat(conn);
        }
		else if(strncmp(buf, "GET /uploadconfig.html", 22) == 0)
 8012f2a:	4620      	mov	r0, r4
 8012f2c:	49a5      	ldr	r1, [pc, #660]	; (80131c4 <http_server_serve+0x324>)
 8012f2e:	2216      	movs	r2, #22
 8012f30:	f001 f9fe 	bl	8014330 <strncmp>
 8012f34:	4605      	mov	r5, r0
 8012f36:	2800      	cmp	r0, #0
 8012f38:	f000 812e 	beq.w	8013198 <http_server_serve+0x2f8>
		   file = fs_open("/uploadconfig.html");
           netconn_write(conn, (const unsigned char*)(file->data), (size_t)file->len, NETCONN_NOCOPY);
           fs_close(file);
        }
		/* Load index page */
        else if((strncmp(buf, "GET /Verventa_Master.html", 15) == 0)||(strncmp(buf, "GET / ", 6) == 0))
 8012f3c:	4620      	mov	r0, r4
 8012f3e:	49a2      	ldr	r1, [pc, #648]	; (80131c8 <http_server_serve+0x328>)
 8012f40:	220f      	movs	r2, #15
 8012f42:	f001 f9f5 	bl	8014330 <strncmp>
 8012f46:	b138      	cbz	r0, 8012f58 <http_server_serve+0xb8>
 8012f48:	4620      	mov	r0, r4
 8012f4a:	49a0      	ldr	r1, [pc, #640]	; (80131cc <http_server_serve+0x32c>)
 8012f4c:	2206      	movs	r2, #6
 8012f4e:	f001 f9ef 	bl	8014330 <strncmp>
 8012f52:	2800      	cmp	r0, #0
 8012f54:	f040 8122 	bne.w	801319c <http_server_serve+0x2fc>
        {
          file = fs_open("/Verventa_Master.html");
 8012f58:	489d      	ldr	r0, [pc, #628]	; (80131d0 <http_server_serve+0x330>)
        }
		/* Load Error page */
        else
        {
          chprintf((BaseSequentialStream *)&itm_port, "%s\n", "/404.html");
          file = fs_open("/404.html");
 8012f5a:	f000 f9a9 	bl	80132b0 <fs_open>
          netconn_write(conn, (const unsigned char*)(file->data), (size_t)file->len, NETCONN_NOCOPY);
 8012f5e:	2300      	movs	r3, #0
 8012f60:	e890 0006 	ldmia.w	r0, {r1, r2}
        }
		/* Load Error page */
        else
        {
          chprintf((BaseSequentialStream *)&itm_port, "%s\n", "/404.html");
          file = fs_open("/404.html");
 8012f64:	4604      	mov	r4, r0
          netconn_write(conn, (const unsigned char*)(file->data), (size_t)file->len, NETCONN_NOCOPY);
 8012f66:	9300      	str	r3, [sp, #0]
 8012f68:	4638      	mov	r0, r7
 8012f6a:	f7fc fb49 	bl	800f600 <netconn_write_partly>
          fs_close(file);
 8012f6e:	4620      	mov	r0, r4
 8012f70:	f000 f9ee 	bl	8013350 <fs_close>
 8012f74:	e79e      	b.n	8012eb4 <http_server_serve+0x14>
        }
      }
	  else{
		/* process POST request for file upload and incoming data packets after POST request*/
		if((strncmp(buf, "POST /upload.cgi", 16) == 0) || (DataFlag >= 1))
 8012f76:	4997      	ldr	r1, [pc, #604]	; (80131d4 <http_server_serve+0x334>)
 8012f78:	f8df 826c 	ldr.w	r8, [pc, #620]	; 80131e8 <http_server_serve+0x348>
 8012f7c:	4620      	mov	r0, r4
 8012f7e:	2210      	movs	r2, #16
 8012f80:	f001 f9d6 	bl	8014330 <strncmp>
 8012f84:	b118      	cbz	r0, 8012f8e <http_server_serve+0xee>
 8012f86:	f8d8 3000 	ldr.w	r3, [r8]
 8012f8a:	2b00      	cmp	r3, #0
 8012f8c:	d092      	beq.n	8012eb4 <http_server_serve+0x14>
		{
			chprintf((BaseSequentialStream *)&itm_port, "%s\n", "start upload file...");
 8012f8e:	4887      	ldr	r0, [pc, #540]	; (80131ac <http_server_serve+0x30c>)
 8012f90:	4991      	ldr	r1, [pc, #580]	; (80131d8 <http_server_serve+0x338>)
 8012f92:	4a92      	ldr	r2, [pc, #584]	; (80131dc <http_server_serve+0x33c>)
 8012f94:	f7ff fca4 	bl	80128e0 <chprintf.constprop.0>
			DataOffset = 0;
        
			/* POST Packet received */
			if(DataFlag == 0)
 8012f98:	f8d8 4000 	ldr.w	r4, [r8]
 8012f9c:	b9bc      	cbnz	r4, 8012fce <http_server_serve+0x12e>
			{
				BrowserFlag = 0;
 8012f9e:	f8df 924c 	ldr.w	r9, [pc, #588]	; 80131ec <http_server_serve+0x34c>
				TotalReceived = 0;
 8012fa2:	4b8f      	ldr	r3, [pc, #572]	; (80131e0 <http_server_serve+0x340>)
          
				/* parse packet for Content-length field */
				//size = Parse_Content_Length(buf, (uint32_t)(buflen));
           
				/* parse packet for the octet-stream field */
				for(i = 0; i < buflen; i++)
 8012fa4:	f8bd 500a 	ldrh.w	r5, [sp, #10]
			DataOffset = 0;
        
			/* POST Packet received */
			if(DataFlag == 0)
			{
				BrowserFlag = 0;
 8012fa8:	f8c9 4000 	str.w	r4, [r9]
				TotalReceived = 0;
 8012fac:	601c      	str	r4, [r3, #0]
          
				/* parse packet for Content-length field */
				//size = Parse_Content_Length(buf, (uint32_t)(buflen));
           
				/* parse packet for the octet-stream field */
				for(i = 0; i < buflen; i++)
 8012fae:	2d00      	cmp	r5, #0
 8012fb0:	d04e      	beq.n	8013050 <http_server_serve+0x1b0>
 8012fb2:	9e04      	ldr	r6, [sp, #16]
 8012fb4:	e002      	b.n	8012fbc <http_server_serve+0x11c>
 8012fb6:	3401      	adds	r4, #1
 8012fb8:	42ac      	cmp	r4, r5
 8012fba:	d049      	beq.n	8013050 <http_server_serve+0x1b0>
				{
					if(strncmp((char*)(buf + i), octet_stream, 13) == 0)
 8012fbc:	1930      	adds	r0, r6, r4
 8012fbe:	4989      	ldr	r1, [pc, #548]	; (80131e4 <http_server_serve+0x344>)
 8012fc0:	220d      	movs	r2, #13
 8012fc2:	f001 f9b5 	bl	8014330 <strncmp>
 8012fc6:	2800      	cmp	r0, #0
 8012fc8:	d1f5      	bne.n	8012fb6 <http_server_serve+0x116>
					{
						DataOffset = i + 16;
 8012fca:	3410      	adds	r4, #16
 8012fcc:	e002      	b.n	8012fd4 <http_server_serve+0x134>
 8012fce:	f8bd 500a 	ldrh.w	r5, [sp, #10]
	  else{
		/* process POST request for file upload and incoming data packets after POST request*/
		if((strncmp(buf, "POST /upload.cgi", 16) == 0) || (DataFlag >= 1))
		{
			chprintf((BaseSequentialStream *)&itm_port, "%s\n", "start upload file...");
			DataOffset = 0;
 8012fd2:	2400      	movs	r4, #0
				{
					//TotalReceived = buflen - (ContentLengthOffset + 4);
				}
			}
			/* For MSIE8 and Mozilla Firefox */
			if(((DataFlag == 1) && (BrowserFlag == 1)) || ((DataFlag == 0) && (BrowserFlag == 0)))
 8012fd4:	f8d8 3000 	ldr.w	r3, [r8]
 8012fd8:	4a83      	ldr	r2, [pc, #524]	; (80131e8 <http_server_serve+0x348>)
 8012fda:	2b01      	cmp	r3, #1
 8012fdc:	d07c      	beq.n	80130d8 <http_server_serve+0x238>
 8012fde:	f8d8 3000 	ldr.w	r3, [r8]
 8012fe2:	4a81      	ldr	r2, [pc, #516]	; (80131e8 <http_server_serve+0x348>)
 8012fe4:	b91b      	cbnz	r3, 8012fee <http_server_serve+0x14e>
 8012fe6:	4b81      	ldr	r3, [pc, #516]	; (80131ec <http_server_serve+0x34c>)
 8012fe8:	681b      	ldr	r3, [r3, #0]
 8012fea:	2b00      	cmp	r3, #0
 8012fec:	d039      	beq.n	8013062 <http_server_serve+0x1c2>
				}
			}
			/* DataFlag > 1 => the packet is data only  */
			else 
			{
				TotalReceived += buflen;
 8012fee:	4a7c      	ldr	r2, [pc, #496]	; (80131e0 <http_server_serve+0x340>)
 8012ff0:	6813      	ldr	r3, [r2, #0]
 8012ff2:	442b      	add	r3, r5
 8012ff4:	6013      	str	r3, [r2, #0]
        
			ptr = (char*)(buf + DataOffset);
			buflen -= DataOffset;
        
			/* update Total data received counter */
			TotalData += buflen;
 8012ff6:	f8df a218 	ldr.w	sl, [pc, #536]	; 8013210 <http_server_serve+0x370>
        
			/* check if last data packet */
			if(TotalReceived == size)
 8012ffa:	497d      	ldr	r1, [pc, #500]	; (80131f0 <http_server_serve+0x350>)
        
			ptr = (char*)(buf + DataOffset);
			buflen -= DataOffset;
        
			/* update Total data received counter */
			TotalData += buflen;
 8012ffc:	f8da 2000 	ldr.w	r2, [sl]
			{
				TotalReceived += buflen;
			}
        
			ptr = (char*)(buf + DataOffset);
			buflen -= DataOffset;
 8013000:	1b2c      	subs	r4, r5, r4
 8013002:	b2a4      	uxth	r4, r4
        
			/* update Total data received counter */
			TotalData += buflen;
 8013004:	4422      	add	r2, r4
 8013006:	f8ca 2000 	str.w	r2, [sl]
        
			/* check if last data packet */
			if(TotalReceived == size)
 801300a:	680a      	ldr	r2, [r1, #0]
			{
				TotalReceived += buflen;
			}
        
			ptr = (char*)(buf + DataOffset);
			buflen -= DataOffset;
 801300c:	f8ad 400a 	strh.w	r4, [sp, #10]
        
			/* update Total data received counter */
			TotalData += buflen;
        
			/* check if last data packet */
			if(TotalReceived == size)
 8013010:	429a      	cmp	r2, r3
 8013012:	d117      	bne.n	8013044 <http_server_serve+0x1a4>
 8013014:	9d04      	ldr	r5, [sp, #16]
 8013016:	2604      	movs	r6, #4
 8013018:	e000      	b.n	801301c <http_server_serve+0x17c>
				/* if last packet need to remove the http boundary tag */
				/* parse packet for "\r\n--" starting from end of data */
				i = 4;
				while(strncmp((char*)(buf + buflen - i), http_crnl_2 , 4))
				{
					i++;
 801301a:	3601      	adds	r6, #1
 801301c:	ebc6 0904 	rsb	r9, r6, r4
			if(TotalReceived == size)
			{
				/* if last packet need to remove the http boundary tag */
				/* parse packet for "\r\n--" starting from end of data */
				i = 4;
				while(strncmp((char*)(buf + buflen - i), http_crnl_2 , 4))
 8013020:	eb05 0009 	add.w	r0, r5, r9
 8013024:	4973      	ldr	r1, [pc, #460]	; (80131f4 <http_server_serve+0x354>)
 8013026:	2204      	movs	r2, #4
 8013028:	f001 f982 	bl	8014330 <strncmp>
 801302c:	2800      	cmp	r0, #0
 801302e:	d1f4      	bne.n	801301a <http_server_serve+0x17a>
				{
					i++;
				}
		   
				buflen -= i;
				TotalData -= i;
 8013030:	f8da 3000 	ldr.w	r3, [sl]
				while(strncmp((char*)(buf + buflen - i), http_crnl_2 , 4))
				{
					i++;
				}
		   
				buflen -= i;
 8013034:	f8ad 900a 	strh.w	r9, [sp, #10]
				TotalData -= i;
 8013038:	1b9e      	subs	r6, r3, r6
 801303a:	f8ca 6000 	str.w	r6, [sl]
				
				DataFlag = 0;
 801303e:	f8c8 0000 	str.w	r0, [r8]
 8013042:	e737      	b.n	8012eb4 <http_server_serve+0x14>
				//tcp_sent(pcb, http_sent);  
			}
			/* not last data packet */
			else
			{
				chprintf((BaseSequentialStream *)&itm_port, "%s\n", "not last data package...\n");
 8013044:	4964      	ldr	r1, [pc, #400]	; (80131d8 <http_server_serve+0x338>)
 8013046:	4a6c      	ldr	r2, [pc, #432]	; (80131f8 <http_server_serve+0x358>)
 8013048:	4858      	ldr	r0, [pc, #352]	; (80131ac <http_server_serve+0x30c>)
 801304a:	f7ff fc49 	bl	80128e0 <chprintf.constprop.0>
 801304e:	e731      	b.n	8012eb4 <http_server_serve+0x14>
					}
				}
				/* case of MSIE8 : we do not receive data in the POST packet*/ 
				if(DataOffset == 0)
				{
					DataFlag++;
 8013050:	f8d8 3000 	ldr.w	r3, [r8]
					BrowserFlag = 1;
 8013054:	2201      	movs	r2, #1
					}
				}
				/* case of MSIE8 : we do not receive data in the POST packet*/ 
				if(DataOffset == 0)
				{
					DataFlag++;
 8013056:	4413      	add	r3, r2
 8013058:	f8c8 3000 	str.w	r3, [r8]
					BrowserFlag = 1;
 801305c:	f8c9 2000 	str.w	r2, [r9]
				 
					return ERR_OK;
 8013060:	e72e      	b.n	8012ec0 <http_server_serve+0x20>
				}
			}
			/* For MSIE8 and Mozilla Firefox */
			if(((DataFlag == 1) && (BrowserFlag == 1)) || ((DataFlag == 0) && (BrowserFlag == 0)))
			{
				if((DataFlag == 0) && (BrowserFlag == 0))
 8013062:	6813      	ldr	r3, [r2, #0]
 8013064:	2b00      	cmp	r3, #0
 8013066:	f040 8085 	bne.w	8013174 <http_server_serve+0x2d4>
				{
					DataFlag++;
 801306a:	6813      	ldr	r3, [r2, #0]
 801306c:	3301      	adds	r3, #1
 801306e:	6013      	str	r3, [r2, #0]
					DataFlag++;
				}  
                
				/* parse packet for the filename field */
				FilenameOffset = 0;
				for(i = 0; i < buflen; i++)
 8013070:	2d00      	cmp	r5, #0
 8013072:	d06d      	beq.n	8013150 <http_server_serve+0x2b0>
 8013074:	f8dd 9010 	ldr.w	r9, [sp, #16]
 8013078:	2600      	movs	r6, #0
 801307a:	e002      	b.n	8013082 <http_server_serve+0x1e2>
 801307c:	3601      	adds	r6, #1
 801307e:	42ae      	cmp	r6, r5
 8013080:	d066      	beq.n	8013150 <http_server_serve+0x2b0>
 8013082:	eb09 0a06 	add.w	sl, r9, r6
				{
					if(strncmp((char*)(buf + i), "filename=", 9) == 0)
 8013086:	4650      	mov	r0, sl
 8013088:	495c      	ldr	r1, [pc, #368]	; (80131fc <http_server_serve+0x35c>)
 801308a:	2209      	movs	r2, #9
 801308c:	f001 f950 	bl	8014330 <strncmp>
 8013090:	2800      	cmp	r0, #0
 8013092:	d1f3      	bne.n	801307c <http_server_serve+0x1dc>
				
				i = 0;
				
				if(FilenameOffset)
				{
					while((*(buf + FilenameOffset + i) != 0x22 ) && (i < 13))
 8013094:	f89a 200a 	ldrb.w	r2, [sl, #10]
 8013098:	2a22      	cmp	r2, #34	; 0x22
 801309a:	d051      	beq.n	8013140 <http_server_serve+0x2a0>
 801309c:	360a      	adds	r6, #10
 801309e:	444e      	add	r6, r9
 80130a0:	4603      	mov	r3, r0
 80130a2:	a905      	add	r1, sp, #20
					{
						filename[i] = *(buf + FilenameOffset + i);
 80130a4:	f841 2b04 	str.w	r2, [r1], #4
				
				i = 0;
				
				if(FilenameOffset)
				{
					while((*(buf + FilenameOffset + i) != 0x22 ) && (i < 13))
 80130a8:	f816 2f01 	ldrb.w	r2, [r6, #1]!
 80130ac:	2a22      	cmp	r2, #34	; 0x22
					{
						filename[i] = *(buf + FilenameOffset + i);
						i++;
 80130ae:	f103 0301 	add.w	r3, r3, #1
				
				i = 0;
				
				if(FilenameOffset)
				{
					while((*(buf + FilenameOffset + i) != 0x22 ) && (i < 13))
 80130b2:	d065      	beq.n	8013180 <http_server_serve+0x2e0>
 80130b4:	2b0d      	cmp	r3, #13
 80130b6:	d1f5      	bne.n	80130a4 <http_server_serve+0x204>
					{
						filename[i] = *(buf + FilenameOffset + i);
						i++;
					}
					filename[i] = 0x0;
 80130b8:	2500      	movs	r5, #0
					
					chprintf((BaseSequentialStream *)&itm_port, "filename: %s with length: %d\n", filename, i);
 80130ba:	aa05      	add	r2, sp, #20
 80130bc:	483b      	ldr	r0, [pc, #236]	; (80131ac <http_server_serve+0x30c>)
 80130be:	4950      	ldr	r1, [pc, #320]	; (8013200 <http_server_serve+0x360>)
					while((*(buf + FilenameOffset + i) != 0x22 ) && (i < 13))
					{
						filename[i] = *(buf + FilenameOffset + i);
						i++;
					}
					filename[i] = 0x0;
 80130c0:	9512      	str	r5, [sp, #72]	; 0x48
					
					chprintf((BaseSequentialStream *)&itm_port, "filename: %s with length: %d\n", filename, i);
 80130c2:	f7ff fc0d 	bl	80128e0 <chprintf.constprop.0>
 80130c6:	4b46      	ldr	r3, [pc, #280]	; (80131e0 <http_server_serve+0x340>)
 80130c8:	f8bd 500a 	ldrh.w	r5, [sp, #10]
 80130cc:	681b      	ldr	r3, [r3, #0]
 80130ce:	e792      	b.n	8012ff6 <http_server_serve+0x156>
          fs_close(file);
        }
		/* Load dynamic page */
        else if(strncmp(buf, "GET /STM32F4x7TASKS.html", 24) == 0)
        {
           DynWebPage(conn);
 80130d0:	4638      	mov	r0, r7
 80130d2:	f7ff fc55 	bl	8012980 <DynWebPage>
 80130d6:	e6ed      	b.n	8012eb4 <http_server_serve+0x14>
				{
					//TotalReceived = buflen - (ContentLengthOffset + 4);
				}
			}
			/* For MSIE8 and Mozilla Firefox */
			if(((DataFlag == 1) && (BrowserFlag == 1)) || ((DataFlag == 0) && (BrowserFlag == 0)))
 80130d8:	4b44      	ldr	r3, [pc, #272]	; (80131ec <http_server_serve+0x34c>)
 80130da:	681b      	ldr	r3, [r3, #0]
 80130dc:	2b01      	cmp	r3, #1
 80130de:	f47f af7e 	bne.w	8012fde <http_server_serve+0x13e>
			{
				if((DataFlag == 0) && (BrowserFlag == 0))
 80130e2:	6813      	ldr	r3, [r2, #0]
				{
					DataFlag++;
				}
				else if((DataFlag == 1) && (BrowserFlag == 1))
 80130e4:	6813      	ldr	r3, [r2, #0]
 80130e6:	2b01      	cmp	r3, #1
 80130e8:	d1c2      	bne.n	8013070 <http_server_serve+0x1d0>
				{
					/* parse packet for the octet-stream field */
					for (i = 0; i < buflen; i++)
 80130ea:	b185      	cbz	r5, 801310e <http_server_serve+0x26e>
 80130ec:	f8dd 9010 	ldr.w	r9, [sp, #16]
 80130f0:	2600      	movs	r6, #0
 80130f2:	e002      	b.n	80130fa <http_server_serve+0x25a>
 80130f4:	3601      	adds	r6, #1
 80130f6:	42ae      	cmp	r6, r5
 80130f8:	d009      	beq.n	801310e <http_server_serve+0x26e>
					{
						if(strncmp((char*)(buf + i), octet_stream, 13) == 0)
 80130fa:	eb09 0006 	add.w	r0, r9, r6
 80130fe:	4939      	ldr	r1, [pc, #228]	; (80131e4 <http_server_serve+0x344>)
 8013100:	220d      	movs	r2, #13
 8013102:	f001 f915 	bl	8014330 <strncmp>
 8013106:	2800      	cmp	r0, #0
 8013108:	d1f4      	bne.n	80130f4 <http_server_serve+0x254>
						{
							DataOffset = i + 16;
 801310a:	f106 0410 	add.w	r4, r6, #16
							break;
						}
					}
					TotalReceived += buflen;
 801310e:	4934      	ldr	r1, [pc, #208]	; (80131e0 <http_server_serve+0x340>)
					DataFlag++;
 8013110:	f8d8 3000 	ldr.w	r3, [r8]
						{
							DataOffset = i + 16;
							break;
						}
					}
					TotalReceived += buflen;
 8013114:	680a      	ldr	r2, [r1, #0]
					DataFlag++;
 8013116:	3301      	adds	r3, #1
						{
							DataOffset = i + 16;
							break;
						}
					}
					TotalReceived += buflen;
 8013118:	442a      	add	r2, r5
 801311a:	600a      	str	r2, [r1, #0]
					DataFlag++;
 801311c:	f8c8 3000 	str.w	r3, [r8]
 8013120:	e7a6      	b.n	8013070 <http_server_serve+0x1d0>
      if ((buflen >=5) && (strncmp(buf, "GET /", 5) == 0))
      {
        /* Check if request to get climate-control.jpg */
        if (strncmp((char const *)buf,"GET /assets/splash_screen.jpg",25)==0)
        {
          file = fs_open("/img/splash_screen.jpg");
 8013122:	4838      	ldr	r0, [pc, #224]	; (8013204 <http_server_serve+0x364>)
        {
           DynWebPage_ModbusStat(conn);
        }
		else if(strncmp(buf, "GET /uploadconfig.html", 22) == 0)
        {
		   file = fs_open("/uploadconfig.html");
 8013124:	f000 f8c4 	bl	80132b0 <fs_open>
           netconn_write(conn, (const unsigned char*)(file->data), (size_t)file->len, NETCONN_NOCOPY);
 8013128:	462b      	mov	r3, r5
 801312a:	e890 0006 	ldmia.w	r0, {r1, r2}
        {
           DynWebPage_ModbusStat(conn);
        }
		else if(strncmp(buf, "GET /uploadconfig.html", 22) == 0)
        {
		   file = fs_open("/uploadconfig.html");
 801312e:	4604      	mov	r4, r0
           netconn_write(conn, (const unsigned char*)(file->data), (size_t)file->len, NETCONN_NOCOPY);
 8013130:	9500      	str	r5, [sp, #0]
 8013132:	4638      	mov	r0, r7
 8013134:	f7fc fa64 	bl	800f600 <netconn_write_partly>
           fs_close(file);
 8013138:	4620      	mov	r0, r4
 801313a:	f000 f909 	bl	8013350 <fs_close>
 801313e:	e6b9      	b.n	8012eb4 <http_server_serve+0x14>
					while((*(buf + FilenameOffset + i) != 0x22 ) && (i < 13))
					{
						filename[i] = *(buf + FilenameOffset + i);
						i++;
					}
					filename[i] = 0x0;
 8013140:	aa12      	add	r2, sp, #72	; 0x48
					
					chprintf((BaseSequentialStream *)&itm_port, "filename: %s with length: %d\n", filename, i);
 8013142:	4603      	mov	r3, r0
					while((*(buf + FilenameOffset + i) != 0x22 ) && (i < 13))
					{
						filename[i] = *(buf + FilenameOffset + i);
						i++;
					}
					filename[i] = 0x0;
 8013144:	f842 0d34 	str.w	r0, [r2, #-52]!
					
					chprintf((BaseSequentialStream *)&itm_port, "filename: %s with length: %d\n", filename, i);
 8013148:	492d      	ldr	r1, [pc, #180]	; (8013200 <http_server_serve+0x360>)
 801314a:	4818      	ldr	r0, [pc, #96]	; (80131ac <http_server_serve+0x30c>)
 801314c:	f7ff fbc8 	bl	80128e0 <chprintf.constprop.0>
				}
           
				if(i == 0)
				{
					/* no filename, in this case reload upload page */
					file = fs_open("/uploadconfig.html");
 8013150:	482d      	ldr	r0, [pc, #180]	; (8013208 <http_server_serve+0x368>)
 8013152:	f000 f8ad 	bl	80132b0 <fs_open>
					netconn_write(conn, (const unsigned char*)(file->data), (size_t)file->len, NETCONN_NOCOPY);
 8013156:	2400      	movs	r4, #0
 8013158:	e890 0006 	ldmia.w	r0, {r1, r2}
				}
           
				if(i == 0)
				{
					/* no filename, in this case reload upload page */
					file = fs_open("/uploadconfig.html");
 801315c:	4605      	mov	r5, r0
					netconn_write(conn, (const unsigned char*)(file->data), (size_t)file->len, NETCONN_NOCOPY);
 801315e:	4623      	mov	r3, r4
 8013160:	9400      	str	r4, [sp, #0]
 8013162:	4638      	mov	r0, r7
 8013164:	f7fc fa4c 	bl	800f600 <netconn_write_partly>
					fs_close(file);
 8013168:	4628      	mov	r0, r5
 801316a:	f000 f8f1 	bl	8013350 <fs_close>
          
					/* Tell TCP that we wish be to informed of data that has been
					successfully sent by a call to the http_sent() function. */
					//tcp_sent(pcb, http_sent); 
					DataFlag = 0;
 801316e:	f8c8 4000 	str.w	r4, [r8]
					
					return ERR_OK;
 8013172:	e6a5      	b.n	8012ec0 <http_server_serve+0x20>
			{
				if((DataFlag == 0) && (BrowserFlag == 0))
				{
					DataFlag++;
				}
				else if((DataFlag == 1) && (BrowserFlag == 1))
 8013174:	6813      	ldr	r3, [r2, #0]
 8013176:	e77b      	b.n	8013070 <http_server_serve+0x1d0>
        {
           DynWebPage(conn);
        }
		else if(strncmp(buf, "GET /MODBUSTASKS.html", 21) == 0)
        {
           DynWebPage_ModbusStat(conn);
 8013178:	4638      	mov	r0, r7
 801317a:	f7ff fce9 	bl	8012b50 <DynWebPage_ModbusStat>
 801317e:	e699      	b.n	8012eb4 <http_server_serve+0x14>
					while((*(buf + FilenameOffset + i) != 0x22 ) && (i < 13))
					{
						filename[i] = *(buf + FilenameOffset + i);
						i++;
					}
					filename[i] = 0x0;
 8013180:	aa12      	add	r2, sp, #72	; 0x48
 8013182:	eb02 0583 	add.w	r5, r2, r3, lsl #2
 8013186:	2600      	movs	r6, #0
					
					chprintf((BaseSequentialStream *)&itm_port, "filename: %s with length: %d\n", filename, i);
 8013188:	aa05      	add	r2, sp, #20
 801318a:	491d      	ldr	r1, [pc, #116]	; (8013200 <http_server_serve+0x360>)
 801318c:	4807      	ldr	r0, [pc, #28]	; (80131ac <http_server_serve+0x30c>)
					while((*(buf + FilenameOffset + i) != 0x22 ) && (i < 13))
					{
						filename[i] = *(buf + FilenameOffset + i);
						i++;
					}
					filename[i] = 0x0;
 801318e:	f845 6c34 	str.w	r6, [r5, #-52]
					
					chprintf((BaseSequentialStream *)&itm_port, "filename: %s with length: %d\n", filename, i);
 8013192:	f7ff fba5 	bl	80128e0 <chprintf.constprop.0>
 8013196:	e796      	b.n	80130c6 <http_server_serve+0x226>
        {
           DynWebPage_ModbusStat(conn);
        }
		else if(strncmp(buf, "GET /uploadconfig.html", 22) == 0)
        {
		   file = fs_open("/uploadconfig.html");
 8013198:	481b      	ldr	r0, [pc, #108]	; (8013208 <http_server_serve+0x368>)
 801319a:	e7c3      	b.n	8013124 <http_server_serve+0x284>
          fs_close(file);
        }
		/* Load Error page */
        else
        {
          chprintf((BaseSequentialStream *)&itm_port, "%s\n", "/404.html");
 801319c:	4803      	ldr	r0, [pc, #12]	; (80131ac <http_server_serve+0x30c>)
 801319e:	490e      	ldr	r1, [pc, #56]	; (80131d8 <http_server_serve+0x338>)
 80131a0:	4a1a      	ldr	r2, [pc, #104]	; (801320c <http_server_serve+0x36c>)
 80131a2:	f7ff fb9d 	bl	80128e0 <chprintf.constprop.0>
          file = fs_open("/404.html");
 80131a6:	4819      	ldr	r0, [pc, #100]	; (801320c <http_server_serve+0x36c>)
 80131a8:	e6d7      	b.n	8012f5a <http_server_serve+0xba>
 80131aa:	bf00      	nop
 80131ac:	200180c8 	.word	0x200180c8
 80131b0:	08019e2c 	.word	0x08019e2c
 80131b4:	08019e44 	.word	0x08019e44
 80131b8:	08019e4c 	.word	0x08019e4c
 80131bc:	08019e84 	.word	0x08019e84
 80131c0:	08019ea0 	.word	0x08019ea0
 80131c4:	08019eb8 	.word	0x08019eb8
 80131c8:	08019ed0 	.word	0x08019ed0
 80131cc:	08019eec 	.word	0x08019eec
 80131d0:	08019ed4 	.word	0x08019ed4
 80131d4:	08019f00 	.word	0x08019f00
 80131d8:	08017004 	.word	0x08017004
 80131dc:	08019f14 	.word	0x08019f14
 80131e0:	20016c90 	.word	0x20016c90
 80131e4:	08019fb0 	.word	0x08019fb0
 80131e8:	20016c84 	.word	0x20016c84
 80131ec:	20016c8c 	.word	0x20016c8c
 80131f0:	20016c88 	.word	0x20016c88
 80131f4:	080197c0 	.word	0x080197c0
 80131f8:	08019f58 	.word	0x08019f58
 80131fc:	08019f2c 	.word	0x08019f2c
 8013200:	08019f38 	.word	0x08019f38
 8013204:	08019e6c 	.word	0x08019e6c
 8013208:	08019ebc 	.word	0x08019ebc
 801320c:	08019ef4 	.word	0x08019ef4
 8013210:	20016c80 	.word	0x20016c80
 8013214:	f3af 8000 	nop.w
 8013218:	f3af 8000 	nop.w
 801321c:	f3af 8000 	nop.w

08013220 <http_server>:

/**
 * HTTP server thread.
 */
msg_t http_server(void *p)
{
 8013220:	b510      	push	{r4, lr}
  struct netconn *conn, *newconn;
  err_t err;

  (void)p;
  
  chRegSetThreadName("httpserver");
 8013222:	4b1a      	ldr	r3, [pc, #104]	; (801328c <http_server+0x6c>)
 8013224:	4a1a      	ldr	r2, [pc, #104]	; (8013290 <http_server+0x70>)
 8013226:	699b      	ldr	r3, [r3, #24]

  /* Create a new TCP connection handle */
  conn = netconn_new(NETCONN_TCP);
 8013228:	2100      	movs	r1, #0

/**
 * HTTP server thread.
 */
msg_t http_server(void *p)
{
 801322a:	b084      	sub	sp, #16
  struct netconn *conn, *newconn;
  err_t err;

  (void)p;
  
  chRegSetThreadName("httpserver");
 801322c:	619a      	str	r2, [r3, #24]

  /* Create a new TCP connection handle */
  conn = netconn_new(NETCONN_TCP);
 801322e:	2010      	movs	r0, #16
 8013230:	460a      	mov	r2, r1
 8013232:	f7fc f805 	bl	800f240 <netconn_new_with_proto_and_callback>
  LWIP_ERROR("http_server: invalid conn", (conn != NULL), return MSG_RESET;);
 8013236:	b1c0      	cbz	r0, 801326a <http_server+0x4a>
 8013238:	4604      	mov	r4, r0

  /* Bind to port 80 (HTTP) with default IP address */
  netconn_bind(conn, NULL, WEB_THREAD_PORT);
 801323a:	2100      	movs	r1, #0
 801323c:	2250      	movs	r2, #80	; 0x50
 801323e:	f7fc f88f 	bl	800f360 <netconn_bind>

  /* Put the connection into LISTEN state */
  netconn_listen(conn);
 8013242:	4620      	mov	r0, r4
 8013244:	21ff      	movs	r1, #255	; 0xff
 8013246:	f7fc f8bb 	bl	800f3c0 <netconn_listen_with_backlog>

  /* Goes to the final priority after initialization.*/
  chThdSetPriority(WEB_THREAD_PRIORITY);
 801324a:	2004      	movs	r0, #4
 801324c:	f7ee f9a0 	bl	8001590 <chThdSetPriority>

  while(1) {
    err = netconn_accept(conn, &newconn);
 8013250:	4620      	mov	r0, r4
 8013252:	a903      	add	r1, sp, #12
 8013254:	f7fc f8e4 	bl	800f420 <netconn_accept>
    if (err != ERR_OK)
 8013258:	2800      	cmp	r0, #0
 801325a:	d1f9      	bne.n	8013250 <http_server+0x30>
      continue;
    http_server_serve(newconn);
 801325c:	9803      	ldr	r0, [sp, #12]
 801325e:	f7ff fe1f 	bl	8012ea0 <http_server_serve>
    netconn_delete(newconn);
 8013262:	9803      	ldr	r0, [sp, #12]
 8013264:	f7fc f864 	bl	800f330 <netconn_delete>
 8013268:	e7f2      	b.n	8013250 <http_server+0x30>
  
  chRegSetThreadName("httpserver");

  /* Create a new TCP connection handle */
  conn = netconn_new(NETCONN_TCP);
  LWIP_ERROR("http_server: invalid conn", (conn != NULL), return MSG_RESET;);
 801326a:	4b0a      	ldr	r3, [pc, #40]	; (8013294 <http_server+0x74>)
 801326c:	9300      	str	r3, [sp, #0]
 801326e:	490a      	ldr	r1, [pc, #40]	; (8013298 <http_server+0x78>)
 8013270:	4a0a      	ldr	r2, [pc, #40]	; (801329c <http_server+0x7c>)
 8013272:	480b      	ldr	r0, [pc, #44]	; (80132a0 <http_server+0x80>)
 8013274:	f44f 732f 	mov.w	r3, #700	; 0x2bc
 8013278:	f7ff fb32 	bl	80128e0 <chprintf.constprop.0>
 801327c:	4807      	ldr	r0, [pc, #28]	; (801329c <http_server+0x7c>)
 801327e:	f7ed fe77 	bl	8000f70 <chSysHalt>
      continue;
    http_server_serve(newconn);
    netconn_delete(newconn);
  }
  return MSG_OK;
}
 8013282:	f06f 0001 	mvn.w	r0, #1
 8013286:	b004      	add	sp, #16
 8013288:	bd10      	pop	{r4, pc}
 801328a:	bf00      	nop
 801328c:	20001150 	.word	0x20001150
 8013290:	08019f74 	.word	0x08019f74
 8013294:	08019f9c 	.word	0x08019f9c
 8013298:	08016fe0 	.word	0x08016fe0
 801329c:	08019f80 	.word	0x08019f80
 80132a0:	200180c8 	.word	0x200180c8
 80132a4:	f3af 8000 	nop.w
 80132a8:	f3af 8000 	nop.w
 80132ac:	f3af 8000 	nop.w

080132b0 <fs_open>:
}

/*-----------------------------------------------------------------------------------*/
struct fs_file *
fs_open(const char *name)
{
 80132b0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80132b4:	4e23      	ldr	r6, [pc, #140]	; (8013344 <fs_open+0x94>)
/*-----------------------------------------------------------------------------------*/
static struct fs_file *
fs_malloc(void)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 80132b6:	2500      	movs	r5, #0
}

/*-----------------------------------------------------------------------------------*/
struct fs_file *
fs_open(const char *name)
{
 80132b8:	4637      	mov	r7, r6
 80132ba:	4633      	mov	r3, r6
static struct fs_file *
fs_malloc(void)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
    if(fs_memory[i].inuse == 0) {
 80132bc:	7d1a      	ldrb	r2, [r3, #20]
 80132be:	3318      	adds	r3, #24
 80132c0:	b13a      	cbz	r2, 80132d2 <fs_open+0x22>
/*-----------------------------------------------------------------------------------*/
static struct fs_file *
fs_malloc(void)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 80132c2:	3501      	adds	r5, #1
 80132c4:	2d0a      	cmp	r5, #10
 80132c6:	d1f9      	bne.n	80132bc <fs_open+0xc>
  struct fs_file *file;
  const struct fsdata_file *f;

  file = fs_malloc();
  if(file == NULL) {
    return NULL;
 80132c8:	f04f 0800 	mov.w	r8, #0
      return file;
    }
  }
  fs_free(file);
  return NULL;
}
 80132cc:	4640      	mov	r0, r8
 80132ce:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
fs_malloc(void)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
    if(fs_memory[i].inuse == 0) {
      fs_memory[i].inuse = 1;
 80132d2:	ea4f 0b45 	mov.w	fp, r5, lsl #1
 80132d6:	eb0b 0a05 	add.w	sl, fp, r5
 80132da:	eb07 0aca 	add.w	sl, r7, sl, lsl #3
 80132de:	2301      	movs	r3, #1
      return(&fs_memory[i].file);
 80132e0:	4c19      	ldr	r4, [pc, #100]	; (8013348 <fs_open+0x98>)
fs_malloc(void)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
    if(fs_memory[i].inuse == 0) {
      fs_memory[i].inuse = 1;
 80132e2:	f88a 3014 	strb.w	r3, [sl, #20]
 80132e6:	4681      	mov	r9, r0
      return(&fs_memory[i].file);
 80132e8:	46d0      	mov	r8, sl
  }
  file->is_custom_file = 0;
#endif /* LWIP_HTTPD_CUSTOM_FILES */

  for(f = FS_ROOT; f != NULL; f = f->next) {
    if (!strcmp(name, (char *)f->name)) {
 80132ea:	4648      	mov	r0, r9
 80132ec:	6861      	ldr	r1, [r4, #4]
 80132ee:	f7ed fb8b 	bl	8000a08 <strcmp>
 80132f2:	b1c0      	cbz	r0, 8013326 <fs_open+0x76>
    return file;
  }
  file->is_custom_file = 0;
#endif /* LWIP_HTTPD_CUSTOM_FILES */

  for(f = FS_ROOT; f != NULL; f = f->next) {
 80132f4:	6824      	ldr	r4, [r4, #0]
 80132f6:	2c00      	cmp	r4, #0
 80132f8:	d1f7      	bne.n	80132ea <fs_open+0x3a>
static void
fs_free(struct fs_file *file)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
    if(&fs_memory[i].file == file) {
 80132fa:	45b2      	cmp	sl, r6
 80132fc:	f106 0618 	add.w	r6, r6, #24
 8013300:	d006      	beq.n	8013310 <fs_open+0x60>
/*-----------------------------------------------------------------------------------*/
static void
fs_free(struct fs_file *file)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 8013302:	3401      	adds	r4, #1
 8013304:	2c0a      	cmp	r4, #10
 8013306:	d0df      	beq.n	80132c8 <fs_open+0x18>
    if(&fs_memory[i].file == file) {
 8013308:	45b2      	cmp	sl, r6
 801330a:	f106 0618 	add.w	r6, r6, #24
 801330e:	d1f8      	bne.n	8013302 <fs_open+0x52>
      fs_memory[i].inuse = 0;
 8013310:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8013314:	eb07 03c4 	add.w	r3, r7, r4, lsl #3
 8013318:	f04f 0800 	mov.w	r8, #0
 801331c:	f883 8014 	strb.w	r8, [r3, #20]
      return file;
    }
  }
  fs_free(file);
  return NULL;
}
 8013320:	4640      	mov	r0, r8
 8013322:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  file->is_custom_file = 0;
#endif /* LWIP_HTTPD_CUSTOM_FILES */

  for(f = FS_ROOT; f != NULL; f = f->next) {
    if (!strcmp(name, (char *)f->name)) {
      file->data = (const char *)f->data;
 8013326:	eb0b 0305 	add.w	r3, fp, r5
 801332a:	00db      	lsls	r3, r3, #3
 801332c:	68a2      	ldr	r2, [r4, #8]
 801332e:	50fa      	str	r2, [r7, r3]
 8013330:	443b      	add	r3, r7
      file->len = f->len;
 8013332:	68e2      	ldr	r2, [r4, #12]
 8013334:	605a      	str	r2, [r3, #4]
      file->index = f->len;
      file->pextension = NULL;
 8013336:	60d8      	str	r0, [r3, #12]

  for(f = FS_ROOT; f != NULL; f = f->next) {
    if (!strcmp(name, (char *)f->name)) {
      file->data = (const char *)f->data;
      file->len = f->len;
      file->index = f->len;
 8013338:	609a      	str	r2, [r3, #8]
      file->pextension = NULL;
      file->http_header_included = f->http_header_included;
 801333a:	7c22      	ldrb	r2, [r4, #16]
 801333c:	741a      	strb	r2, [r3, #16]
      return file;
    }
  }
  fs_free(file);
  return NULL;
}
 801333e:	4640      	mov	r0, r8
 8013340:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013344:	20017de8 	.word	0x20017de8
 8013348:	0801a540 	.word	0x0801a540
 801334c:	f3af 8000 	nop.w

08013350 <fs_close>:

/*-----------------------------------------------------------------------------------*/
void
fs_close(struct fs_file *file)
{
 8013350:	4908      	ldr	r1, [pc, #32]	; (8013374 <fs_close+0x24>)
/*-----------------------------------------------------------------------------------*/
static void
fs_free(struct fs_file *file)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 8013352:	2300      	movs	r3, #0
 8013354:	460a      	mov	r2, r1
    if(&fs_memory[i].file == file) {
 8013356:	4290      	cmp	r0, r2
 8013358:	f102 0218 	add.w	r2, r2, #24
 801335c:	d003      	beq.n	8013366 <fs_close+0x16>
/*-----------------------------------------------------------------------------------*/
static void
fs_free(struct fs_file *file)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 801335e:	3301      	adds	r3, #1
 8013360:	2b0a      	cmp	r3, #10
 8013362:	d1f8      	bne.n	8013356 <fs_close+0x6>
 8013364:	4770      	bx	lr
    if(&fs_memory[i].file == file) {
      fs_memory[i].inuse = 0;
 8013366:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801336a:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 801336e:	2200      	movs	r2, #0
 8013370:	751a      	strb	r2, [r3, #20]
 8013372:	4770      	bx	lr
 8013374:	20017de8 	.word	0x20017de8
 8013378:	f3af 8000 	nop.w
 801337c:	f3af 8000 	nop.w

08013380 <arrayCopy>:
#include <stdlib.h>

#include "ArrayUtil.h"

void arrayCopy(void *dest, int dIndex, const void* src, int sIndex, int len, int destLen, size_t size)
{
 8013380:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8013384:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8013386:	9d08      	ldr	r5, [sp, #32]
 8013388:	f8dd e024 	ldr.w	lr, [sp, #36]	; 0x24
	dIndex	*= size;
	sIndex	*= size;
	len		*= size;
	destLen	*= size;
	
	if(src != dest)
 801338c:	4282      	cmp	r2, r0
#include <stdlib.h>

#include "ArrayUtil.h"

void arrayCopy(void *dest, int dIndex, const void* src, int sIndex, int len, int destLen, size_t size)
{
 801338e:	4616      	mov	r6, r2
	uint8_t *udest 	= (uint8_t*) dest;
	uint8_t *usrc	= (uint8_t*) src;
	dIndex	*= size;
	sIndex	*= size;
	len		*= size;
 8013390:	fb05 f504 	mul.w	r5, r5, r4

void arrayCopy(void *dest, int dIndex, const void* src, int sIndex, int len, int destLen, size_t size)
{
	uint8_t *udest 	= (uint8_t*) dest;
	uint8_t *usrc	= (uint8_t*) src;
	dIndex	*= size;
 8013394:	fb04 f701 	mul.w	r7, r4, r1
	sIndex	*= size;
 8013398:	fb04 f803 	mul.w	r8, r4, r3
	len		*= size;
	destLen	*= size;
	
	if(src != dest)
 801339c:	d007      	beq.n	80133ae <arrayCopy+0x2e>
	{
		memcpy(&udest[dIndex], &usrc[sIndex], len);
 801339e:	eb02 0108 	add.w	r1, r2, r8
 80133a2:	4438      	add	r0, r7
 80133a4:	462a      	mov	r2, r5
		{
			memcpy(&udest[dIndex], &usrc[sIndex], (destLen - sIndex) + 1);
		}else
			return;
	}
 80133a6:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	len		*= size;
	destLen	*= size;
	
	if(src != dest)
	{
		memcpy(&udest[dIndex], &usrc[sIndex], len);
 80133aa:	f7ed ba89 	b.w	80008c0 <memcpy>
	}else
	{
		if(dIndex > sIndex)
 80133ae:	4547      	cmp	r7, r8
	uint8_t *udest 	= (uint8_t*) dest;
	uint8_t *usrc	= (uint8_t*) src;
	dIndex	*= size;
	sIndex	*= size;
	len		*= size;
	destLen	*= size;
 80133b0:	fb0e f004 	mul.w	r0, lr, r4
	if(src != dest)
	{
		memcpy(&udest[dIndex], &usrc[sIndex], len);
	}else
	{
		if(dIndex > sIndex)
 80133b4:	dc0c      	bgt.n	80133d0 <arrayCopy+0x50>
			uint8_t *tmp = (uint8_t*) calloc(destLen, size);
			memcpy(tmp, &udest[dIndex], (destLen - dIndex));
			memcpy(&udest[dIndex], &usrc[sIndex], len);
			memcpy(&udest[dIndex + len], tmp, (destLen - dIndex));
			free(tmp);
		}else if(sIndex > dIndex)
 80133b6:	db01      	blt.n	80133bc <arrayCopy+0x3c>
 80133b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		{
			memcpy(&udest[dIndex], &usrc[sIndex], (destLen - sIndex) + 1);
 80133bc:	ebc8 0200 	rsb	r2, r8, r0
 80133c0:	eb06 0108 	add.w	r1, r6, r8
 80133c4:	19f0      	adds	r0, r6, r7
 80133c6:	3201      	adds	r2, #1
		}else
			return;
	}
 80133c8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			memcpy(&udest[dIndex], &usrc[sIndex], len);
			memcpy(&udest[dIndex + len], tmp, (destLen - dIndex));
			free(tmp);
		}else if(sIndex > dIndex)
		{
			memcpy(&udest[dIndex], &usrc[sIndex], (destLen - sIndex) + 1);
 80133cc:	f7ed ba78 	b.w	80008c0 <memcpy>
		memcpy(&udest[dIndex], &usrc[sIndex], len);
	}else
	{
		if(dIndex > sIndex)
		{
			uint8_t *tmp = (uint8_t*) calloc(destLen, size);
 80133d0:	4621      	mov	r1, r4
			memcpy(tmp, &udest[dIndex], (destLen - dIndex));
 80133d2:	eb02 0a07 	add.w	sl, r2, r7
 80133d6:	ebc7 0900 	rsb	r9, r7, r0
		memcpy(&udest[dIndex], &usrc[sIndex], len);
	}else
	{
		if(dIndex > sIndex)
		{
			uint8_t *tmp = (uint8_t*) calloc(destLen, size);
 80133da:	f000 f9d1 	bl	8013780 <calloc>
			memcpy(tmp, &udest[dIndex], (destLen - dIndex));
 80133de:	464a      	mov	r2, r9
 80133e0:	4651      	mov	r1, sl
		memcpy(&udest[dIndex], &usrc[sIndex], len);
	}else
	{
		if(dIndex > sIndex)
		{
			uint8_t *tmp = (uint8_t*) calloc(destLen, size);
 80133e2:	4604      	mov	r4, r0
			memcpy(tmp, &udest[dIndex], (destLen - dIndex));
 80133e4:	f7ed fa6c 	bl	80008c0 <memcpy>
			memcpy(&udest[dIndex], &usrc[sIndex], len);
 80133e8:	eb06 0108 	add.w	r1, r6, r8
 80133ec:	462a      	mov	r2, r5
 80133ee:	4650      	mov	r0, sl
 80133f0:	f7ed fa66 	bl	80008c0 <memcpy>
			memcpy(&udest[dIndex + len], tmp, (destLen - dIndex));
 80133f4:	1978      	adds	r0, r7, r5
 80133f6:	464a      	mov	r2, r9
 80133f8:	4430      	add	r0, r6
 80133fa:	4621      	mov	r1, r4
 80133fc:	f7ed fa60 	bl	80008c0 <memcpy>
			free(tmp);
 8013400:	4620      	mov	r0, r4
		{
			memcpy(&udest[dIndex], &usrc[sIndex], (destLen - sIndex) + 1);
		}else
			return;
	}
 8013402:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		{
			uint8_t *tmp = (uint8_t*) calloc(destLen, size);
			memcpy(tmp, &udest[dIndex], (destLen - dIndex));
			memcpy(&udest[dIndex], &usrc[sIndex], len);
			memcpy(&udest[dIndex + len], tmp, (destLen - dIndex));
			free(tmp);
 8013406:	f000 ba13 	b.w	8013830 <free>
 801340a:	bf00      	nop
 801340c:	f3af 8000 	nop.w

08013410 <init>:
static void printElement(const DeviceElement* const);
static void shift(DeviceList* const list, int index, int rooms, Shift dir);
static void wide(DeviceList* const);

void init(DeviceList* const list)
{
 8013410:	b510      	push	{r4, lr}
}

void initWithSizeAndIncRate(DeviceList* const list, int size, int rate)
{
	list->size = size;
	list->increment_rate = rate;
 8013412:	2301      	movs	r3, #1
	initWithSizeAndIncRate(list, size, 1);
}

void initWithSizeAndIncRate(DeviceList* const list, int size, int rate)
{
	list->size = size;
 8013414:	2210      	movs	r2, #16
static void printElement(const DeviceElement* const);
static void shift(DeviceList* const list, int index, int rooms, Shift dir);
static void wide(DeviceList* const);

void init(DeviceList* const list)
{
 8013416:	4604      	mov	r4, r0
}

void initWithSizeAndIncRate(DeviceList* const list, int size, int rate)
{
	list->size = size;
	list->increment_rate = rate;
 8013418:	6083      	str	r3, [r0, #8]
	initWithSizeAndIncRate(list, size, 1);
}

void initWithSizeAndIncRate(DeviceList* const list, int size, int rate)
{
	list->size = size;
 801341a:	6042      	str	r2, [r0, #4]
	list->increment_rate = rate;
	list->elements = (DeviceElement*) chHeapAlloc( NULL, list->size * sizeof(DeviceElement));
 801341c:	f44f 71c0 	mov.w	r1, #384	; 0x180
 8013420:	2000      	movs	r0, #0
 8013422:	f7ef fa05 	bl	8002830 <chHeapAlloc>
	list->current = -1;
 8013426:	f04f 33ff 	mov.w	r3, #4294967295

void initWithSizeAndIncRate(DeviceList* const list, int size, int rate)
{
	list->size = size;
	list->increment_rate = rate;
	list->elements = (DeviceElement*) chHeapAlloc( NULL, list->size * sizeof(DeviceElement));
 801342a:	60e0      	str	r0, [r4, #12]
	list->current = -1;
 801342c:	6023      	str	r3, [r4, #0]
 801342e:	bd10      	pop	{r4, pc}

08013430 <get>:
	return 0;
}

DeviceElement* get(DeviceList* const list, int index)
{
	if(index <= list->current)
 8013430:	6803      	ldr	r3, [r0, #0]
 8013432:	428b      	cmp	r3, r1
	{
		DeviceElement *e = &list->elements[index];
 8013434:	bfa3      	ittte	ge
 8013436:	68c0      	ldrge	r0, [r0, #12]
 8013438:	eb01 0141 	addge.w	r1, r1, r1, lsl #1
 801343c:	eb00 00c1 	addge.w	r0, r0, r1, lsl #3
		return e;
	}
	return NULL;
 8013440:	2000      	movlt	r0, #0
}
 8013442:	4770      	bx	lr
 8013444:	f3af 8000 	nop.w
 8013448:	f3af 8000 	nop.w
 801344c:	f3af 8000 	nop.w

08013450 <add>:
	}
	return -1;
}

int add(DeviceList* const list, DeviceElement e)
{
 8013450:	b084      	sub	sp, #16
 8013452:	b5f0      	push	{r4, r5, r6, r7, lr}
 8013454:	b085      	sub	sp, #20
 8013456:	ad0b      	add	r5, sp, #44	; 0x2c
 8013458:	e885 000e 	stmia.w	r5, {r1, r2, r3}
	uint8_t i;
	
	for(i = 0; i <= list->current; i++)
 801345c:	6801      	ldr	r1, [r0, #0]
 801345e:	2900      	cmp	r1, #0
	}
	return -1;
}

int add(DeviceList* const list, DeviceElement e)
{
 8013460:	4606      	mov	r6, r0
 8013462:	f89d 002c 	ldrb.w	r0, [sp, #44]	; 0x2c
	uint8_t i;
	
	for(i = 0; i <= list->current; i++)
 8013466:	db0f      	blt.n	8013488 <add+0x38>
	{
		if(list->elements[i].address == e.address)
 8013468:	68f4      	ldr	r4, [r6, #12]
 801346a:	7823      	ldrb	r3, [r4, #0]
 801346c:	4283      	cmp	r3, r0
 801346e:	d01c      	beq.n	80134aa <add+0x5a>
 8013470:	2300      	movs	r3, #0
 8013472:	e003      	b.n	801347c <add+0x2c>
 8013474:	f814 2032 	ldrb.w	r2, [r4, r2, lsl #3]
 8013478:	4282      	cmp	r2, r0
 801347a:	d016      	beq.n	80134aa <add+0x5a>

int add(DeviceList* const list, DeviceElement e)
{
	uint8_t i;
	
	for(i = 0; i <= list->current; i++)
 801347c:	3301      	adds	r3, #1
 801347e:	b2db      	uxtb	r3, r3
 8013480:	428b      	cmp	r3, r1
	{
		if(list->elements[i].address == e.address)
 8013482:	eb03 0243 	add.w	r2, r3, r3, lsl #1

int add(DeviceList* const list, DeviceElement e)
{
	uint8_t i;
	
	for(i = 0; i <= list->current; i++)
 8013486:	ddf5      	ble.n	8013474 <add+0x24>
	{
		if(list->elements[i].address == e.address)
			return;
	}
	if(++list->current < list->size)
 8013488:	6873      	ldr	r3, [r6, #4]
 801348a:	1c4c      	adds	r4, r1, #1
 801348c:	429c      	cmp	r4, r3
 801348e:	6034      	str	r4, [r6, #0]
 8013490:	da10      	bge.n	80134b4 <add+0x64>
	{
		list->elements[list->current] = e;
 8013492:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8013494:	68f6      	ldr	r6, [r6, #12]
 8013496:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 801349a:	eb06 04c4 	add.w	r4, r6, r4, lsl #3
 801349e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80134a0:	e895 0003 	ldmia.w	r5, {r0, r1}
 80134a4:	e884 0003 	stmia.w	r4, {r0, r1}
 80134a8:	2001      	movs	r0, #1
		wide(list);
		list->elements[list->current] = e;
		return 1;
	}
	return 0;
}
 80134aa:	b005      	add	sp, #20
 80134ac:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 80134b0:	b004      	add	sp, #16
 80134b2:	4770      	bx	lr

static void wide(DeviceList* const list)
{
	list->size += list->increment_rate;
 80134b4:	68b2      	ldr	r2, [r6, #8]
 80134b6:	4413      	add	r3, r2
	DeviceElement *newArr = (DeviceElement*) chHeapAlloc( NULL, list->size * sizeof(DeviceElement));
 80134b8:	eb03 0143 	add.w	r1, r3, r3, lsl #1
	return 0;
}

static void wide(DeviceList* const list)
{
	list->size += list->increment_rate;
 80134bc:	6073      	str	r3, [r6, #4]
	DeviceElement *newArr = (DeviceElement*) chHeapAlloc( NULL, list->size * sizeof(DeviceElement));
 80134be:	00c9      	lsls	r1, r1, #3
 80134c0:	2000      	movs	r0, #0
 80134c2:	f7ef f9b5 	bl	8002830 <chHeapAlloc>
	arrayCopy(newArr, 0, list->elements, 0, list->current, list->size, sizeof(DeviceElement));
 80134c6:	e896 0018 	ldmia.w	r6, {r3, r4}
 80134ca:	68f2      	ldr	r2, [r6, #12]
 80134cc:	9300      	str	r3, [sp, #0]
 80134ce:	2100      	movs	r1, #0
 80134d0:	2318      	movs	r3, #24
 80134d2:	9401      	str	r4, [sp, #4]
 80134d4:	9302      	str	r3, [sp, #8]
 80134d6:	460b      	mov	r3, r1
}

static void wide(DeviceList* const list)
{
	list->size += list->increment_rate;
	DeviceElement *newArr = (DeviceElement*) chHeapAlloc( NULL, list->size * sizeof(DeviceElement));
 80134d8:	4607      	mov	r7, r0
	arrayCopy(newArr, 0, list->elements, 0, list->current, list->size, sizeof(DeviceElement));
 80134da:	f7ff ff51 	bl	8013380 <arrayCopy>
	free(list->elements);
 80134de:	68f0      	ldr	r0, [r6, #12]
 80134e0:	f000 f9a6 	bl	8013830 <free>
		list->elements[list->current] = e;
		return 1;
	}else
	{
		wide(list);
		list->elements[list->current] = e;
 80134e4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80134e6:	6834      	ldr	r4, [r6, #0]
{
	list->size += list->increment_rate;
	DeviceElement *newArr = (DeviceElement*) chHeapAlloc( NULL, list->size * sizeof(DeviceElement));
	arrayCopy(newArr, 0, list->elements, 0, list->current, list->size, sizeof(DeviceElement));
	free(list->elements);
	list->elements = newArr;
 80134e8:	60f7      	str	r7, [r6, #12]
		list->elements[list->current] = e;
		return 1;
	}else
	{
		wide(list);
		list->elements[list->current] = e;
 80134ea:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 80134ee:	eb07 04c4 	add.w	r4, r7, r4, lsl #3
 80134f2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80134f4:	e895 0003 	ldmia.w	r5, {r0, r1}
 80134f8:	e884 0003 	stmia.w	r4, {r0, r1}
		return 1;
 80134fc:	e7d4      	b.n	80134a8 <add+0x58>
 80134fe:	bf00      	nop

08013500 <populate>:
	}
	return 0;
}

int populate(DeviceList* const list, DeviceElement e)
{
 8013500:	b084      	sub	sp, #16
 8013502:	b5f0      	push	{r4, r5, r6, r7, lr}
 8013504:	b08b      	sub	sp, #44	; 0x2c
 8013506:	af11      	add	r7, sp, #68	; 0x44
 8013508:	e887 000e 	stmia.w	r7, {r1, r2, r3}
}

int get_Index(DeviceList* const list, int8_t address)
{
	int index = 0;
	while(index <= list->current)
 801350c:	6806      	ldr	r6, [r0, #0]
 801350e:	f89d e044 	ldrb.w	lr, [sp, #68]	; 0x44
 8013512:	2e00      	cmp	r6, #0
{
	int index = 0;
	
	if(isEmpty(list) == -1) return -1;
	
	index = get_Index(list, e.address);
 8013514:	fa5f f58e 	uxtb.w	r5, lr
}

int get_Index(DeviceList* const list, int8_t address)
{
	int index = 0;
	while(index <= list->current)
 8013518:	db11      	blt.n	801353e <populate+0x3e>
	{
		if((list->elements[index].address) == address) return index;
 801351a:	68c4      	ldr	r4, [r0, #12]
 801351c:	7823      	ldrb	r3, [r4, #0]
 801351e:	b26d      	sxtb	r5, r5
 8013520:	42ab      	cmp	r3, r5
 8013522:	d01c      	beq.n	801355e <populate+0x5e>
 8013524:	f104 0218 	add.w	r2, r4, #24
 8013528:	2300      	movs	r3, #0
 801352a:	e002      	b.n	8013532 <populate+0x32>
 801352c:	7821      	ldrb	r1, [r4, #0]
 801352e:	42a9      	cmp	r1, r5
 8013530:	d015      	beq.n	801355e <populate+0x5e>
		index++;
 8013532:	3301      	adds	r3, #1
}

int get_Index(DeviceList* const list, int8_t address)
{
	int index = 0;
	while(index <= list->current)
 8013534:	42b3      	cmp	r3, r6
	{
		if((list->elements[index].address) == address) return index;
 8013536:	4614      	mov	r4, r2
 8013538:	f102 0218 	add.w	r2, r2, #24
}

int get_Index(DeviceList* const list, int8_t address)
{
	int index = 0;
	while(index <= list->current)
 801353c:	ddf6      	ble.n	801352c <populate+0x2c>
	
	if(isEmpty(list) == -1) return -1;
	
	index = get_Index(list, e.address);
	if(index == -1){
		add(list, e);
 801353e:	aa14      	add	r2, sp, #80	; 0x50
 8013540:	4603      	mov	r3, r0
 8013542:	ca07      	ldmia	r2, {r0, r1, r2}
 8013544:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 8013548:	4618      	mov	r0, r3
 801354a:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 801354e:	f7ff ff7f 	bl	8013450 <add>
	}else
	{
		set(list, e, index);
	}
	return 0;
}
 8013552:	2000      	movs	r0, #0
 8013554:	b00b      	add	sp, #44	; 0x2c
 8013556:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 801355a:	b004      	add	sp, #16
 801355c:	4770      	bx	lr
 801355e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8013560:	ad04      	add	r5, sp, #16
 8013562:	c50f      	stmia	r5!, {r0, r1, r2, r3}

int set(DeviceList* const list, DeviceElement e, int index)
{
	if(index <= list->current)
	{
		list->elements[index] = e;
 8013564:	ae0a      	add	r6, sp, #40	; 0x28
 8013566:	e897 0003 	ldmia.w	r7, {r0, r1}
 801356a:	f806 ed18 	strb.w	lr, [r6, #-24]!
 801356e:	e885 0003 	stmia.w	r5, {r0, r1}
 8013572:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8013574:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8013576:	e895 0003 	ldmia.w	r5, {r0, r1}
 801357a:	e884 0003 	stmia.w	r4, {r0, r1}
 801357e:	e7e8      	b.n	8013552 <populate+0x52>

08013580 <modbusreq_thread>:
  eMBMasterReqErrCode	errorCode = MB_MRE_NO_ERR;
  //uint16_t			i;
  uint16_t 			counter = 1;

  (void)arg;
  chRegSetThreadName("modbus_request");
 8013580:	4b14      	ldr	r3, [pc, #80]	; (80135d4 <modbusreq_thread+0x54>)
 8013582:	4a15      	ldr	r2, [pc, #84]	; (80135d8 <modbusreq_thread+0x58>)
 8013584:	699b      	ldr	r3, [r3, #24]
	chThdSleepMilliseconds(100);
  }
}

static THD_WORKING_AREA(wa_modbusreq_thread, 512);
static THD_FUNCTION(modbusreq_thread, arg) {
 8013586:	b510      	push	{r4, lr}
  eMBMasterReqErrCode	errorCode = MB_MRE_NO_ERR;
  //uint16_t			i;
  uint16_t 			counter = 1;
 8013588:	2401      	movs	r4, #1

  (void)arg;
  chRegSetThreadName("modbus_request");
 801358a:	619a      	str	r2, [r3, #24]
 801358c:	e008      	b.n	80135a0 <modbusreq_thread+0x20>
				
			break;
		case 1:
			//errorCode = eMBMasterReqReadHoldingRegister(10, 147, 6, -1);
			//errorCode = eMBMasterReqReadInputRegister(10, 497, 15, -1);
			errorCode = eMBMasterReqReadCoils(11, 79, 25, -1);
 801358e:	200b      	movs	r0, #11
 8013590:	f7fd fd56 	bl	8011040 <eMBMasterReqReadCoils>
			break;
		default:
			break;
	}
	
	display_holding();
 8013594:	f7fe fd9c 	bl	80120d0 <display_holding>
	
	chThdSleepMilliseconds(520);
 8013598:	f241 4050 	movw	r0, #5200	; 0x1450
 801359c:	f7ee f820 	bl	80015e0 <chThdSleep>

  (void)arg;
  chRegSetThreadName("modbus_request");

  while (TRUE) {
    chThdSleepMilliseconds(720);
 80135a0:	f44f 50e1 	mov.w	r0, #7200	; 0x1c20
    chSemWait(&mbPoll);
	counter++;
 80135a4:	3401      	adds	r4, #1

  (void)arg;
  chRegSetThreadName("modbus_request");

  while (TRUE) {
    chThdSleepMilliseconds(720);
 80135a6:	f7ee f81b 	bl	80015e0 <chThdSleep>
    chSemWait(&mbPoll);
	counter++;
 80135aa:	b2a4      	uxth	r4, r4
  (void)arg;
  chRegSetThreadName("modbus_request");

  while (TRUE) {
    chThdSleepMilliseconds(720);
    chSemWait(&mbPoll);
 80135ac:	480b      	ldr	r0, [pc, #44]	; (80135dc <modbusreq_thread+0x5c>)
 80135ae:	f7ee f9af 	bl	8001910 <chSemWait>
	counter++;
	switch(counter % 2){
 80135b2:	f014 0f01 	tst.w	r4, #1
				
			break;
		case 1:
			//errorCode = eMBMasterReqReadHoldingRegister(10, 147, 6, -1);
			//errorCode = eMBMasterReqReadInputRegister(10, 497, 15, -1);
			errorCode = eMBMasterReqReadCoils(11, 79, 25, -1);
 80135b6:	f04f 014f 	mov.w	r1, #79	; 0x4f
 80135ba:	f04f 0219 	mov.w	r2, #25
 80135be:	f04f 33ff 	mov.w	r3, #4294967295
    chSemWait(&mbPoll);
	counter++;
	switch(counter % 2){
		case 0:
			//errorCode = eMBMasterReqReadInputRegister(10, 497, 6, -1);
			errorCode = eMBMasterReqReadHoldingRegister(10, 147, 20, -1);
 80135c2:	f04f 000a 	mov.w	r0, #10

  while (TRUE) {
    chThdSleepMilliseconds(720);
    chSemWait(&mbPoll);
	counter++;
	switch(counter % 2){
 80135c6:	d1e2      	bne.n	801358e <modbusreq_thread+0xe>
		case 0:
			//errorCode = eMBMasterReqReadInputRegister(10, 497, 6, -1);
			errorCode = eMBMasterReqReadHoldingRegister(10, 147, 20, -1);
 80135c8:	2193      	movs	r1, #147	; 0x93
 80135ca:	2214      	movs	r2, #20
 80135cc:	f7fd ff38 	bl	8011440 <eMBMasterReqReadHoldingRegister>
				
			break;
 80135d0:	e7e0      	b.n	8013594 <modbusreq_thread+0x14>
 80135d2:	bf00      	nop
 80135d4:	20001150 	.word	0x20001150
 80135d8:	0801cd10 	.word	0x0801cd10
 80135dc:	200180a8 	.word	0x200180a8

080135e0 <chprintf.constprop.3>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80135e0:	b40e      	push	{r1, r2, r3}
 80135e2:	b500      	push	{lr}
 80135e4:	b082      	sub	sp, #8
 80135e6:	aa03      	add	r2, sp, #12
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
 80135e8:	4805      	ldr	r0, [pc, #20]	; (8013600 <chprintf.constprop.3+0x20>)
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80135ea:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80135ee:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80135f0:	f7fd fb86 	bl	8010d00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 80135f4:	b002      	add	sp, #8
 80135f6:	f85d eb04 	ldr.w	lr, [sp], #4
 80135fa:	b003      	add	sp, #12
 80135fc:	4770      	bx	lr
 80135fe:	bf00      	nop
 8013600:	200180c8 	.word	0x200180c8
 8013604:	f3af 8000 	nop.w
 8013608:	f3af 8000 	nop.w
 801360c:	f3af 8000 	nop.w

08013610 <modbus_thread>:
    chThdSleepMilliseconds(500);
  }
}

static THD_WORKING_AREA(wa_freemodbus_thread, 512);
static THD_FUNCTION(modbus_thread, arg) {
 8013610:	b538      	push	{r3, r4, r5, lr}
  eMBErrorCode			eStatus;
  eMBMasterReqErrCode	errorCode = MB_MRE_NO_ERR;

  (void)arg;
  chRegSetThreadName("modbus_poll");
 8013612:	4b14      	ldr	r3, [pc, #80]	; (8013664 <modbus_thread+0x54>)
 8013614:	4a14      	ldr	r2, [pc, #80]	; (8013668 <modbus_thread+0x58>)
 8013616:	699b      	ldr	r3, [r3, #24]
  
  /*	Init modbus	Master -----------------------------------------------*/
  eStatus = eMBMasterInit(MB_RTU, 3, 19200, MB_PAR_NONE);
  chprintf((BaseSequentialStream *)&itm_port, "eStatus: %s\n", eStatus ? "error": "no'error");
 8013618:	4c14      	ldr	r4, [pc, #80]	; (801366c <modbus_thread+0x5c>)
static THD_FUNCTION(modbus_thread, arg) {
  eMBErrorCode			eStatus;
  eMBMasterReqErrCode	errorCode = MB_MRE_NO_ERR;

  (void)arg;
  chRegSetThreadName("modbus_poll");
 801361a:	619a      	str	r2, [r3, #24]
  
  /*	Init modbus	Master -----------------------------------------------*/
  eStatus = eMBMasterInit(MB_RTU, 3, 19200, MB_PAR_NONE);
 801361c:	2000      	movs	r0, #0
 801361e:	4603      	mov	r3, r0
 8013620:	2103      	movs	r1, #3
 8013622:	f44f 4296 	mov.w	r2, #19200	; 0x4b00
 8013626:	f7fe fb83 	bl	8011d30 <eMBMasterInit>
  chprintf((BaseSequentialStream *)&itm_port, "eStatus: %s\n", eStatus ? "error": "no'error");
 801362a:	4d11      	ldr	r5, [pc, #68]	; (8013670 <modbus_thread+0x60>)
 801362c:	4911      	ldr	r1, [pc, #68]	; (8013674 <modbus_thread+0x64>)
 801362e:	2800      	cmp	r0, #0
 8013630:	bf14      	ite	ne
 8013632:	4622      	movne	r2, r4
 8013634:	462a      	moveq	r2, r5
 8013636:	4810      	ldr	r0, [pc, #64]	; (8013678 <modbus_thread+0x68>)
 8013638:	f7ff ffd2 	bl	80135e0 <chprintf.constprop.3>
  /************************************************************************/
	
  /*	Enable the Modbus Protocol Stack ---------------------------------*/
  eStatus = eMBMasterEnable();
 801363c:	f7fe fbe0 	bl	8011e00 <eMBMasterEnable>
  chprintf((BaseSequentialStream *)&itm_port, "eStatus: %s\n", eStatus ? "error": "no'error");
 8013640:	490c      	ldr	r1, [pc, #48]	; (8013674 <modbus_thread+0x64>)
 8013642:	2800      	cmp	r0, #0
 8013644:	bf14      	ite	ne
 8013646:	4622      	movne	r2, r4
 8013648:	462a      	moveq	r2, r5
 801364a:	480b      	ldr	r0, [pc, #44]	; (8013678 <modbus_thread+0x68>)
 801364c:	f7ff ffc8 	bl	80135e0 <chprintf.constprop.3>
  /************************************************************************/
  
  while (TRUE) {
	eMBMasterPoll();
 8013650:	f7fe fbee 	bl	8011e30 <eMBMasterPoll>
	
	chSemSignal(&mbPoll);
 8013654:	4809      	ldr	r0, [pc, #36]	; (801367c <modbus_thread+0x6c>)
 8013656:	f7ee f9b3 	bl	80019c0 <chSemSignal>
	chThdSleepMilliseconds(100);
 801365a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 801365e:	f7ed ffbf 	bl	80015e0 <chThdSleep>
  }
 8013662:	e7f5      	b.n	8013650 <modbus_thread+0x40>
 8013664:	20001150 	.word	0x20001150
 8013668:	0801cd34 	.word	0x0801cd34
 801366c:	0801cd20 	.word	0x0801cd20
 8013670:	0801cd28 	.word	0x0801cd28
 8013674:	0801cd40 	.word	0x0801cd40
 8013678:	200180c8 	.word	0x200180c8
 801367c:	200180a8 	.word	0x200180a8

08013680 <Thread1>:

/*
 * LED blinker thread, times are in milliseconds.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg){
 8013680:	b508      	push	{r3, lr}
	
  (void)arg;
  chRegSetThreadName("blinker");
 8013682:	4b0b      	ldr	r3, [pc, #44]	; (80136b0 <Thread1+0x30>)
 8013684:	4a0b      	ldr	r2, [pc, #44]	; (80136b4 <Thread1+0x34>)
 8013686:	699b      	ldr	r3, [r3, #24]
 8013688:	619a      	str	r2, [r3, #24]
  while (TRUE)
  {
	chprintf((BaseSequentialStream *)&itm_port, "%s", "Thread blinker.\n");
    palClearPad(GPIOG, GPIOG_PIN6);
 801368a:	4c0b      	ldr	r4, [pc, #44]	; (80136b8 <Thread1+0x38>)
	
  (void)arg;
  chRegSetThreadName("blinker");
  while (TRUE)
  {
	chprintf((BaseSequentialStream *)&itm_port, "%s", "Thread blinker.\n");
 801368c:	490b      	ldr	r1, [pc, #44]	; (80136bc <Thread1+0x3c>)
 801368e:	4a0c      	ldr	r2, [pc, #48]	; (80136c0 <Thread1+0x40>)
 8013690:	480c      	ldr	r0, [pc, #48]	; (80136c4 <Thread1+0x44>)
    palClearPad(GPIOG, GPIOG_PIN6);
 8013692:	2540      	movs	r5, #64	; 0x40
	
  (void)arg;
  chRegSetThreadName("blinker");
  while (TRUE)
  {
	chprintf((BaseSequentialStream *)&itm_port, "%s", "Thread blinker.\n");
 8013694:	f7ff ffa4 	bl	80135e0 <chprintf.constprop.3>
    palClearPad(GPIOG, GPIOG_PIN6);
 8013698:	8365      	strh	r5, [r4, #26]
    chThdSleepMilliseconds(500);
 801369a:	f241 3088 	movw	r0, #5000	; 0x1388
 801369e:	f7ed ff9f 	bl	80015e0 <chThdSleep>
    palSetPad(GPIOG, GPIOG_PIN6);
 80136a2:	8325      	strh	r5, [r4, #24]
    chThdSleepMilliseconds(500);
 80136a4:	f241 3088 	movw	r0, #5000	; 0x1388
 80136a8:	f7ed ff9a 	bl	80015e0 <chThdSleep>
  }
 80136ac:	e7ed      	b.n	801368a <Thread1+0xa>
 80136ae:	bf00      	nop
 80136b0:	20001150 	.word	0x20001150
 80136b4:	0801cd50 	.word	0x0801cd50
 80136b8:	40021800 	.word	0x40021800
 80136bc:	0801cd58 	.word	0x0801cd58
 80136c0:	0801cd5c 	.word	0x0801cd5c
 80136c4:	200180c8 	.word	0x200180c8
 80136c8:	f3af 8000 	nop.w
 80136cc:	f3af 8000 	nop.w

080136d0 <Debug_ITMDebugEnable>:
void Debug_ITMDebugEnable(void){
	volatile unsigned int *ITM_TER      = (volatile unsigned int *)0xE0000E00;
	volatile unsigned int *SCB_DHCSR 		= (volatile unsigned int *)0xE000EDF0;
	volatile unsigned int *DBGMCU_CR 		= (volatile unsigned int *)0xE0042004;

	*DBGMCU_CR |= 0x27; // DBGMCU_CR
 80136d0:	4a08      	ldr	r2, [pc, #32]	; (80136f4 <Debug_ITMDebugEnable+0x24>)

if ((*SCB_DHCSR & 1) && (*ITM_TER & 1)) // Enabled?
 80136d2:	4909      	ldr	r1, [pc, #36]	; (80136f8 <Debug_ITMDebugEnable+0x28>)
void Debug_ITMDebugEnable(void){
	volatile unsigned int *ITM_TER      = (volatile unsigned int *)0xE0000E00;
	volatile unsigned int *SCB_DHCSR 		= (volatile unsigned int *)0xE000EDF0;
	volatile unsigned int *DBGMCU_CR 		= (volatile unsigned int *)0xE0042004;

	*DBGMCU_CR |= 0x27; // DBGMCU_CR
 80136d4:	6813      	ldr	r3, [r2, #0]
 80136d6:	f043 0327 	orr.w	r3, r3, #39	; 0x27
 80136da:	6013      	str	r3, [r2, #0]

if ((*SCB_DHCSR & 1) && (*ITM_TER & 1)) // Enabled?
 80136dc:	680b      	ldr	r3, [r1, #0]
 80136de:	07da      	lsls	r2, r3, #31
 80136e0:	d506      	bpl.n	80136f0 <Debug_ITMDebugEnable+0x20>
 80136e2:	4b06      	ldr	r3, [pc, #24]	; (80136fc <Debug_ITMDebugEnable+0x2c>)
 80136e4:	681b      	ldr	r3, [r3, #0]
 80136e6:	07db      	lsls	r3, r3, #31
 80136e8:	d502      	bpl.n	80136f0 <Debug_ITMDebugEnable+0x20>
    Debug_ITMDebug = 1;
 80136ea:	4b05      	ldr	r3, [pc, #20]	; (8013700 <Debug_ITMDebugEnable+0x30>)
 80136ec:	2201      	movs	r2, #1
 80136ee:	601a      	str	r2, [r3, #0]
 80136f0:	4770      	bx	lr
 80136f2:	bf00      	nop
 80136f4:	e0042004 	.word	0xe0042004
 80136f8:	e000edf0 	.word	0xe000edf0
 80136fc:	e0000e00 	.word	0xe0000e00
 8013700:	200180b4 	.word	0x200180b4
 8013704:	f3af 8000 	nop.w
 8013708:	f3af 8000 	nop.w
 801370c:	f3af 8000 	nop.w

08013710 <Debug_ITMDebugOutputChar>:

void Debug_ITMDebugOutputChar(char ch){
	static volatile unsigned int *ITM_STIM0 = (volatile unsigned int *)0xE0000000; // ITM Port 0
	static volatile unsigned int *SCB_DEMCR = (volatile unsigned int *)0xE000EDFC;

	if (Debug_ITMDebug && (*SCB_DEMCR & 0x01000000))
 8013710:	4b07      	ldr	r3, [pc, #28]	; (8013730 <Debug_ITMDebugOutputChar+0x20>)
 8013712:	681b      	ldr	r3, [r3, #0]
 8013714:	b15b      	cbz	r3, 801372e <Debug_ITMDebugOutputChar+0x1e>
 8013716:	4b07      	ldr	r3, [pc, #28]	; (8013734 <Debug_ITMDebugOutputChar+0x24>)
 8013718:	681b      	ldr	r3, [r3, #0]
 801371a:	01db      	lsls	r3, r3, #7
 801371c:	d507      	bpl.n	801372e <Debug_ITMDebugOutputChar+0x1e>
	{
		while(*ITM_STIM0 == 0);
 801371e:	f04f 4160 	mov.w	r1, #3758096384	; 0xe0000000
 8013722:	680b      	ldr	r3, [r1, #0]
 8013724:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 8013728:	2b00      	cmp	r3, #0
 801372a:	d0fa      	beq.n	8013722 <Debug_ITMDebugOutputChar+0x12>
  	*((volatile char *)ITM_STIM0) = ch;
 801372c:	7010      	strb	r0, [r2, #0]
 801372e:	4770      	bx	lr
 8013730:	200180b4 	.word	0x200180b4
 8013734:	e000edfc 	.word	0xe000edfc
 8013738:	f3af 8000 	nop.w
 801373c:	f3af 8000 	nop.w

08013740 <__assert_func>:
 8013740:	b500      	push	{lr}
 8013742:	4c0a      	ldr	r4, [pc, #40]	; (801376c <__assert_func+0x2c>)
 8013744:	6824      	ldr	r4, [r4, #0]
 8013746:	4605      	mov	r5, r0
 8013748:	b085      	sub	sp, #20
 801374a:	68e0      	ldr	r0, [r4, #12]
 801374c:	b152      	cbz	r2, 8013764 <__assert_func+0x24>
 801374e:	4c08      	ldr	r4, [pc, #32]	; (8013770 <__assert_func+0x30>)
 8013750:	9202      	str	r2, [sp, #8]
 8013752:	e88d 0012 	stmia.w	sp, {r1, r4}
 8013756:	461a      	mov	r2, r3
 8013758:	4906      	ldr	r1, [pc, #24]	; (8013774 <__assert_func+0x34>)
 801375a:	462b      	mov	r3, r5
 801375c:	f000 f850 	bl	8013800 <fiprintf>
 8013760:	f001 fd26 	bl	80151b0 <abort>
 8013764:	4c04      	ldr	r4, [pc, #16]	; (8013778 <__assert_func+0x38>)
 8013766:	4622      	mov	r2, r4
 8013768:	e7f2      	b.n	8013750 <__assert_func+0x10>
 801376a:	bf00      	nop
 801376c:	20000d10 	.word	0x20000d10
 8013770:	0801cdb0 	.word	0x0801cdb0
 8013774:	0801cdc0 	.word	0x0801cdc0
 8013778:	0801cd6c 	.word	0x0801cd6c
 801377c:	00000000 	.word	0x00000000

08013780 <calloc>:
 8013780:	4b02      	ldr	r3, [pc, #8]	; (801378c <calloc+0xc>)
 8013782:	460a      	mov	r2, r1
 8013784:	4601      	mov	r1, r0
 8013786:	6818      	ldr	r0, [r3, #0]
 8013788:	f000 b802 	b.w	8013790 <_calloc_r>
 801378c:	20000d10 	.word	0x20000d10

08013790 <_calloc_r>:
 8013790:	b510      	push	{r4, lr}
 8013792:	fb02 f101 	mul.w	r1, r2, r1
 8013796:	f000 f853 	bl	8013840 <_malloc_r>
 801379a:	4604      	mov	r4, r0
 801379c:	b168      	cbz	r0, 80137ba <_calloc_r+0x2a>
 801379e:	f850 2c04 	ldr.w	r2, [r0, #-4]
 80137a2:	f022 0203 	bic.w	r2, r2, #3
 80137a6:	3a04      	subs	r2, #4
 80137a8:	2a24      	cmp	r2, #36	; 0x24
 80137aa:	d818      	bhi.n	80137de <_calloc_r+0x4e>
 80137ac:	2a13      	cmp	r2, #19
 80137ae:	d806      	bhi.n	80137be <_calloc_r+0x2e>
 80137b0:	4603      	mov	r3, r0
 80137b2:	2200      	movs	r2, #0
 80137b4:	601a      	str	r2, [r3, #0]
 80137b6:	605a      	str	r2, [r3, #4]
 80137b8:	609a      	str	r2, [r3, #8]
 80137ba:	4620      	mov	r0, r4
 80137bc:	bd10      	pop	{r4, pc}
 80137be:	2300      	movs	r3, #0
 80137c0:	2a1b      	cmp	r2, #27
 80137c2:	6003      	str	r3, [r0, #0]
 80137c4:	6043      	str	r3, [r0, #4]
 80137c6:	d90f      	bls.n	80137e8 <_calloc_r+0x58>
 80137c8:	2a24      	cmp	r2, #36	; 0x24
 80137ca:	6083      	str	r3, [r0, #8]
 80137cc:	60c3      	str	r3, [r0, #12]
 80137ce:	bf05      	ittet	eq
 80137d0:	6103      	streq	r3, [r0, #16]
 80137d2:	6143      	streq	r3, [r0, #20]
 80137d4:	f100 0310 	addne.w	r3, r0, #16
 80137d8:	f100 0318 	addeq.w	r3, r0, #24
 80137dc:	e7e9      	b.n	80137b2 <_calloc_r+0x22>
 80137de:	2100      	movs	r1, #0
 80137e0:	f000 faf6 	bl	8013dd0 <memset>
 80137e4:	4620      	mov	r0, r4
 80137e6:	bd10      	pop	{r4, pc}
 80137e8:	f100 0308 	add.w	r3, r0, #8
 80137ec:	e7e1      	b.n	80137b2 <_calloc_r+0x22>
 80137ee:	bf00      	nop

080137f0 <__errno>:
 80137f0:	4b01      	ldr	r3, [pc, #4]	; (80137f8 <__errno+0x8>)
 80137f2:	6818      	ldr	r0, [r3, #0]
 80137f4:	4770      	bx	lr
 80137f6:	bf00      	nop
 80137f8:	20000d10 	.word	0x20000d10
 80137fc:	00000000 	.word	0x00000000

08013800 <fiprintf>:
 8013800:	b40e      	push	{r1, r2, r3}
 8013802:	b510      	push	{r4, lr}
 8013804:	b083      	sub	sp, #12
 8013806:	ab05      	add	r3, sp, #20
 8013808:	4c06      	ldr	r4, [pc, #24]	; (8013824 <fiprintf+0x24>)
 801380a:	f853 2b04 	ldr.w	r2, [r3], #4
 801380e:	9301      	str	r3, [sp, #4]
 8013810:	4601      	mov	r1, r0
 8013812:	6820      	ldr	r0, [r4, #0]
 8013814:	f000 fe1c 	bl	8014450 <_vfiprintf_r>
 8013818:	b003      	add	sp, #12
 801381a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801381e:	b003      	add	sp, #12
 8013820:	4770      	bx	lr
 8013822:	bf00      	nop
 8013824:	20000d10 	.word	0x20000d10
	...

08013830 <free>:
 8013830:	4b02      	ldr	r3, [pc, #8]	; (801383c <free+0xc>)
 8013832:	4601      	mov	r1, r0
 8013834:	6818      	ldr	r0, [r3, #0]
 8013836:	f001 bedb 	b.w	80155f0 <_free_r>
 801383a:	bf00      	nop
 801383c:	20000d10 	.word	0x20000d10

08013840 <_malloc_r>:
 8013840:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013844:	f101 050b 	add.w	r5, r1, #11
 8013848:	2d16      	cmp	r5, #22
 801384a:	b083      	sub	sp, #12
 801384c:	4606      	mov	r6, r0
 801384e:	d927      	bls.n	80138a0 <_malloc_r+0x60>
 8013850:	f035 0507 	bics.w	r5, r5, #7
 8013854:	f100 80b6 	bmi.w	80139c4 <_malloc_r+0x184>
 8013858:	42a9      	cmp	r1, r5
 801385a:	f200 80b3 	bhi.w	80139c4 <_malloc_r+0x184>
 801385e:	f000 fb07 	bl	8013e70 <__malloc_lock>
 8013862:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
 8013866:	d222      	bcs.n	80138ae <_malloc_r+0x6e>
 8013868:	4fc2      	ldr	r7, [pc, #776]	; (8013b74 <_malloc_r+0x334>)
 801386a:	08e8      	lsrs	r0, r5, #3
 801386c:	eb07 03c0 	add.w	r3, r7, r0, lsl #3
 8013870:	68dc      	ldr	r4, [r3, #12]
 8013872:	429c      	cmp	r4, r3
 8013874:	f000 81c9 	beq.w	8013c0a <_malloc_r+0x3ca>
 8013878:	6863      	ldr	r3, [r4, #4]
 801387a:	68e1      	ldr	r1, [r4, #12]
 801387c:	68a5      	ldr	r5, [r4, #8]
 801387e:	f023 0303 	bic.w	r3, r3, #3
 8013882:	4423      	add	r3, r4
 8013884:	4630      	mov	r0, r6
 8013886:	685a      	ldr	r2, [r3, #4]
 8013888:	60e9      	str	r1, [r5, #12]
 801388a:	f042 0201 	orr.w	r2, r2, #1
 801388e:	608d      	str	r5, [r1, #8]
 8013890:	605a      	str	r2, [r3, #4]
 8013892:	f000 faf5 	bl	8013e80 <__malloc_unlock>
 8013896:	3408      	adds	r4, #8
 8013898:	4620      	mov	r0, r4
 801389a:	b003      	add	sp, #12
 801389c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80138a0:	2910      	cmp	r1, #16
 80138a2:	f200 808f 	bhi.w	80139c4 <_malloc_r+0x184>
 80138a6:	f000 fae3 	bl	8013e70 <__malloc_lock>
 80138aa:	2510      	movs	r5, #16
 80138ac:	e7dc      	b.n	8013868 <_malloc_r+0x28>
 80138ae:	0a68      	lsrs	r0, r5, #9
 80138b0:	f000 808f 	beq.w	80139d2 <_malloc_r+0x192>
 80138b4:	2804      	cmp	r0, #4
 80138b6:	f200 8154 	bhi.w	8013b62 <_malloc_r+0x322>
 80138ba:	09a8      	lsrs	r0, r5, #6
 80138bc:	3038      	adds	r0, #56	; 0x38
 80138be:	0041      	lsls	r1, r0, #1
 80138c0:	4fac      	ldr	r7, [pc, #688]	; (8013b74 <_malloc_r+0x334>)
 80138c2:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 80138c6:	68cc      	ldr	r4, [r1, #12]
 80138c8:	42a1      	cmp	r1, r4
 80138ca:	d106      	bne.n	80138da <_malloc_r+0x9a>
 80138cc:	e00c      	b.n	80138e8 <_malloc_r+0xa8>
 80138ce:	2a00      	cmp	r2, #0
 80138d0:	f280 8082 	bge.w	80139d8 <_malloc_r+0x198>
 80138d4:	68e4      	ldr	r4, [r4, #12]
 80138d6:	42a1      	cmp	r1, r4
 80138d8:	d006      	beq.n	80138e8 <_malloc_r+0xa8>
 80138da:	6863      	ldr	r3, [r4, #4]
 80138dc:	f023 0303 	bic.w	r3, r3, #3
 80138e0:	1b5a      	subs	r2, r3, r5
 80138e2:	2a0f      	cmp	r2, #15
 80138e4:	ddf3      	ble.n	80138ce <_malloc_r+0x8e>
 80138e6:	3801      	subs	r0, #1
 80138e8:	3001      	adds	r0, #1
 80138ea:	49a2      	ldr	r1, [pc, #648]	; (8013b74 <_malloc_r+0x334>)
 80138ec:	693c      	ldr	r4, [r7, #16]
 80138ee:	f101 0e08 	add.w	lr, r1, #8
 80138f2:	4574      	cmp	r4, lr
 80138f4:	f000 817e 	beq.w	8013bf4 <_malloc_r+0x3b4>
 80138f8:	6863      	ldr	r3, [r4, #4]
 80138fa:	f023 0303 	bic.w	r3, r3, #3
 80138fe:	1b5a      	subs	r2, r3, r5
 8013900:	2a0f      	cmp	r2, #15
 8013902:	f300 8164 	bgt.w	8013bce <_malloc_r+0x38e>
 8013906:	2a00      	cmp	r2, #0
 8013908:	f8c1 e014 	str.w	lr, [r1, #20]
 801390c:	f8c1 e010 	str.w	lr, [r1, #16]
 8013910:	da73      	bge.n	80139fa <_malloc_r+0x1ba>
 8013912:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8013916:	f080 8139 	bcs.w	8013b8c <_malloc_r+0x34c>
 801391a:	08db      	lsrs	r3, r3, #3
 801391c:	eb01 08c3 	add.w	r8, r1, r3, lsl #3
 8013920:	ea4f 0ca3 	mov.w	ip, r3, asr #2
 8013924:	684a      	ldr	r2, [r1, #4]
 8013926:	f8d8 9008 	ldr.w	r9, [r8, #8]
 801392a:	f8c4 9008 	str.w	r9, [r4, #8]
 801392e:	2301      	movs	r3, #1
 8013930:	fa03 f30c 	lsl.w	r3, r3, ip
 8013934:	4313      	orrs	r3, r2
 8013936:	f8c4 800c 	str.w	r8, [r4, #12]
 801393a:	604b      	str	r3, [r1, #4]
 801393c:	f8c8 4008 	str.w	r4, [r8, #8]
 8013940:	f8c9 400c 	str.w	r4, [r9, #12]
 8013944:	1082      	asrs	r2, r0, #2
 8013946:	2401      	movs	r4, #1
 8013948:	4094      	lsls	r4, r2
 801394a:	429c      	cmp	r4, r3
 801394c:	d862      	bhi.n	8013a14 <_malloc_r+0x1d4>
 801394e:	4223      	tst	r3, r4
 8013950:	d106      	bne.n	8013960 <_malloc_r+0x120>
 8013952:	f020 0003 	bic.w	r0, r0, #3
 8013956:	0064      	lsls	r4, r4, #1
 8013958:	4223      	tst	r3, r4
 801395a:	f100 0004 	add.w	r0, r0, #4
 801395e:	d0fa      	beq.n	8013956 <_malloc_r+0x116>
 8013960:	eb07 08c0 	add.w	r8, r7, r0, lsl #3
 8013964:	46c4      	mov	ip, r8
 8013966:	4681      	mov	r9, r0
 8013968:	f8dc 300c 	ldr.w	r3, [ip, #12]
 801396c:	459c      	cmp	ip, r3
 801396e:	d107      	bne.n	8013980 <_malloc_r+0x140>
 8013970:	e142      	b.n	8013bf8 <_malloc_r+0x3b8>
 8013972:	2900      	cmp	r1, #0
 8013974:	f280 8152 	bge.w	8013c1c <_malloc_r+0x3dc>
 8013978:	68db      	ldr	r3, [r3, #12]
 801397a:	459c      	cmp	ip, r3
 801397c:	f000 813c 	beq.w	8013bf8 <_malloc_r+0x3b8>
 8013980:	685a      	ldr	r2, [r3, #4]
 8013982:	f022 0203 	bic.w	r2, r2, #3
 8013986:	1b51      	subs	r1, r2, r5
 8013988:	290f      	cmp	r1, #15
 801398a:	ddf2      	ble.n	8013972 <_malloc_r+0x132>
 801398c:	461c      	mov	r4, r3
 801398e:	f8d3 c00c 	ldr.w	ip, [r3, #12]
 8013992:	f854 8f08 	ldr.w	r8, [r4, #8]!
 8013996:	195a      	adds	r2, r3, r5
 8013998:	f045 0901 	orr.w	r9, r5, #1
 801399c:	f041 0501 	orr.w	r5, r1, #1
 80139a0:	f8c3 9004 	str.w	r9, [r3, #4]
 80139a4:	4630      	mov	r0, r6
 80139a6:	f8c8 c00c 	str.w	ip, [r8, #12]
 80139aa:	f8cc 8008 	str.w	r8, [ip, #8]
 80139ae:	617a      	str	r2, [r7, #20]
 80139b0:	613a      	str	r2, [r7, #16]
 80139b2:	f8c2 e00c 	str.w	lr, [r2, #12]
 80139b6:	f8c2 e008 	str.w	lr, [r2, #8]
 80139ba:	6055      	str	r5, [r2, #4]
 80139bc:	5051      	str	r1, [r2, r1]
 80139be:	f000 fa5f 	bl	8013e80 <__malloc_unlock>
 80139c2:	e769      	b.n	8013898 <_malloc_r+0x58>
 80139c4:	2400      	movs	r4, #0
 80139c6:	230c      	movs	r3, #12
 80139c8:	4620      	mov	r0, r4
 80139ca:	6033      	str	r3, [r6, #0]
 80139cc:	b003      	add	sp, #12
 80139ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80139d2:	217e      	movs	r1, #126	; 0x7e
 80139d4:	203f      	movs	r0, #63	; 0x3f
 80139d6:	e773      	b.n	80138c0 <_malloc_r+0x80>
 80139d8:	4423      	add	r3, r4
 80139da:	68e1      	ldr	r1, [r4, #12]
 80139dc:	685a      	ldr	r2, [r3, #4]
 80139de:	68a5      	ldr	r5, [r4, #8]
 80139e0:	f042 0201 	orr.w	r2, r2, #1
 80139e4:	60e9      	str	r1, [r5, #12]
 80139e6:	4630      	mov	r0, r6
 80139e8:	608d      	str	r5, [r1, #8]
 80139ea:	605a      	str	r2, [r3, #4]
 80139ec:	f000 fa48 	bl	8013e80 <__malloc_unlock>
 80139f0:	3408      	adds	r4, #8
 80139f2:	4620      	mov	r0, r4
 80139f4:	b003      	add	sp, #12
 80139f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80139fa:	4423      	add	r3, r4
 80139fc:	4630      	mov	r0, r6
 80139fe:	685a      	ldr	r2, [r3, #4]
 8013a00:	f042 0201 	orr.w	r2, r2, #1
 8013a04:	605a      	str	r2, [r3, #4]
 8013a06:	f000 fa3b 	bl	8013e80 <__malloc_unlock>
 8013a0a:	3408      	adds	r4, #8
 8013a0c:	4620      	mov	r0, r4
 8013a0e:	b003      	add	sp, #12
 8013a10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013a14:	68bc      	ldr	r4, [r7, #8]
 8013a16:	6863      	ldr	r3, [r4, #4]
 8013a18:	f023 0803 	bic.w	r8, r3, #3
 8013a1c:	4545      	cmp	r5, r8
 8013a1e:	d804      	bhi.n	8013a2a <_malloc_r+0x1ea>
 8013a20:	ebc5 0308 	rsb	r3, r5, r8
 8013a24:	2b0f      	cmp	r3, #15
 8013a26:	f300 808c 	bgt.w	8013b42 <_malloc_r+0x302>
 8013a2a:	4b53      	ldr	r3, [pc, #332]	; (8013b78 <_malloc_r+0x338>)
 8013a2c:	f8df a158 	ldr.w	sl, [pc, #344]	; 8013b88 <_malloc_r+0x348>
 8013a30:	681a      	ldr	r2, [r3, #0]
 8013a32:	f8da 3000 	ldr.w	r3, [sl]
 8013a36:	3301      	adds	r3, #1
 8013a38:	442a      	add	r2, r5
 8013a3a:	eb04 0b08 	add.w	fp, r4, r8
 8013a3e:	f000 8150 	beq.w	8013ce2 <_malloc_r+0x4a2>
 8013a42:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8013a46:	320f      	adds	r2, #15
 8013a48:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 8013a4c:	f022 020f 	bic.w	r2, r2, #15
 8013a50:	4611      	mov	r1, r2
 8013a52:	4630      	mov	r0, r6
 8013a54:	9201      	str	r2, [sp, #4]
 8013a56:	f7fd f903 	bl	8010c60 <_sbrk_r>
 8013a5a:	f1b0 3fff 	cmp.w	r0, #4294967295
 8013a5e:	4681      	mov	r9, r0
 8013a60:	9a01      	ldr	r2, [sp, #4]
 8013a62:	f000 80f5 	beq.w	8013c50 <_malloc_r+0x410>
 8013a66:	4583      	cmp	fp, r0
 8013a68:	f200 80ef 	bhi.w	8013c4a <_malloc_r+0x40a>
 8013a6c:	4b43      	ldr	r3, [pc, #268]	; (8013b7c <_malloc_r+0x33c>)
 8013a6e:	6819      	ldr	r1, [r3, #0]
 8013a70:	45cb      	cmp	fp, r9
 8013a72:	4411      	add	r1, r2
 8013a74:	6019      	str	r1, [r3, #0]
 8013a76:	f000 813d 	beq.w	8013cf4 <_malloc_r+0x4b4>
 8013a7a:	f8da 0000 	ldr.w	r0, [sl]
 8013a7e:	f8df e108 	ldr.w	lr, [pc, #264]	; 8013b88 <_malloc_r+0x348>
 8013a82:	3001      	adds	r0, #1
 8013a84:	bf1b      	ittet	ne
 8013a86:	ebcb 0b09 	rsbne	fp, fp, r9
 8013a8a:	4459      	addne	r1, fp
 8013a8c:	f8ce 9000 	streq.w	r9, [lr]
 8013a90:	6019      	strne	r1, [r3, #0]
 8013a92:	f019 0107 	ands.w	r1, r9, #7
 8013a96:	f000 8107 	beq.w	8013ca8 <_malloc_r+0x468>
 8013a9a:	f1c1 0008 	rsb	r0, r1, #8
 8013a9e:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
 8013aa2:	4481      	add	r9, r0
 8013aa4:	3108      	adds	r1, #8
 8013aa6:	444a      	add	r2, r9
 8013aa8:	f3c2 020b 	ubfx	r2, r2, #0, #12
 8013aac:	ebc2 0a01 	rsb	sl, r2, r1
 8013ab0:	4651      	mov	r1, sl
 8013ab2:	4630      	mov	r0, r6
 8013ab4:	9301      	str	r3, [sp, #4]
 8013ab6:	f7fd f8d3 	bl	8010c60 <_sbrk_r>
 8013aba:	1c43      	adds	r3, r0, #1
 8013abc:	9b01      	ldr	r3, [sp, #4]
 8013abe:	f000 8127 	beq.w	8013d10 <_malloc_r+0x4d0>
 8013ac2:	ebc9 0200 	rsb	r2, r9, r0
 8013ac6:	4452      	add	r2, sl
 8013ac8:	f042 0201 	orr.w	r2, r2, #1
 8013acc:	6819      	ldr	r1, [r3, #0]
 8013ace:	f8c7 9008 	str.w	r9, [r7, #8]
 8013ad2:	4451      	add	r1, sl
 8013ad4:	42bc      	cmp	r4, r7
 8013ad6:	f8c9 2004 	str.w	r2, [r9, #4]
 8013ada:	6019      	str	r1, [r3, #0]
 8013adc:	f8df a09c 	ldr.w	sl, [pc, #156]	; 8013b7c <_malloc_r+0x33c>
 8013ae0:	d016      	beq.n	8013b10 <_malloc_r+0x2d0>
 8013ae2:	f1b8 0f0f 	cmp.w	r8, #15
 8013ae6:	f240 80e2 	bls.w	8013cae <_malloc_r+0x46e>
 8013aea:	6862      	ldr	r2, [r4, #4]
 8013aec:	f1a8 030c 	sub.w	r3, r8, #12
 8013af0:	f023 0307 	bic.w	r3, r3, #7
 8013af4:	18e0      	adds	r0, r4, r3
 8013af6:	f002 0201 	and.w	r2, r2, #1
 8013afa:	f04f 0e05 	mov.w	lr, #5
 8013afe:	431a      	orrs	r2, r3
 8013b00:	2b0f      	cmp	r3, #15
 8013b02:	6062      	str	r2, [r4, #4]
 8013b04:	f8c0 e004 	str.w	lr, [r0, #4]
 8013b08:	f8c0 e008 	str.w	lr, [r0, #8]
 8013b0c:	f200 8104 	bhi.w	8013d18 <_malloc_r+0x4d8>
 8013b10:	4b1b      	ldr	r3, [pc, #108]	; (8013b80 <_malloc_r+0x340>)
 8013b12:	68bc      	ldr	r4, [r7, #8]
 8013b14:	681a      	ldr	r2, [r3, #0]
 8013b16:	4291      	cmp	r1, r2
 8013b18:	bf88      	it	hi
 8013b1a:	6019      	strhi	r1, [r3, #0]
 8013b1c:	4b19      	ldr	r3, [pc, #100]	; (8013b84 <_malloc_r+0x344>)
 8013b1e:	681a      	ldr	r2, [r3, #0]
 8013b20:	4291      	cmp	r1, r2
 8013b22:	6862      	ldr	r2, [r4, #4]
 8013b24:	bf88      	it	hi
 8013b26:	6019      	strhi	r1, [r3, #0]
 8013b28:	f022 0203 	bic.w	r2, r2, #3
 8013b2c:	4295      	cmp	r5, r2
 8013b2e:	eba2 0305 	sub.w	r3, r2, r5
 8013b32:	d801      	bhi.n	8013b38 <_malloc_r+0x2f8>
 8013b34:	2b0f      	cmp	r3, #15
 8013b36:	dc04      	bgt.n	8013b42 <_malloc_r+0x302>
 8013b38:	4630      	mov	r0, r6
 8013b3a:	f000 f9a1 	bl	8013e80 <__malloc_unlock>
 8013b3e:	2400      	movs	r4, #0
 8013b40:	e6aa      	b.n	8013898 <_malloc_r+0x58>
 8013b42:	1962      	adds	r2, r4, r5
 8013b44:	f043 0301 	orr.w	r3, r3, #1
 8013b48:	f045 0501 	orr.w	r5, r5, #1
 8013b4c:	6065      	str	r5, [r4, #4]
 8013b4e:	4630      	mov	r0, r6
 8013b50:	60ba      	str	r2, [r7, #8]
 8013b52:	6053      	str	r3, [r2, #4]
 8013b54:	f000 f994 	bl	8013e80 <__malloc_unlock>
 8013b58:	3408      	adds	r4, #8
 8013b5a:	4620      	mov	r0, r4
 8013b5c:	b003      	add	sp, #12
 8013b5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013b62:	2814      	cmp	r0, #20
 8013b64:	d969      	bls.n	8013c3a <_malloc_r+0x3fa>
 8013b66:	2854      	cmp	r0, #84	; 0x54
 8013b68:	f200 8097 	bhi.w	8013c9a <_malloc_r+0x45a>
 8013b6c:	0b28      	lsrs	r0, r5, #12
 8013b6e:	306e      	adds	r0, #110	; 0x6e
 8013b70:	0041      	lsls	r1, r0, #1
 8013b72:	e6a5      	b.n	80138c0 <_malloc_r+0x80>
 8013b74:	20000d14 	.word	0x20000d14
 8013b78:	20018788 	.word	0x20018788
 8013b7c:	2001878c 	.word	0x2001878c
 8013b80:	20018784 	.word	0x20018784
 8013b84:	20018780 	.word	0x20018780
 8013b88:	20001120 	.word	0x20001120
 8013b8c:	0a5a      	lsrs	r2, r3, #9
 8013b8e:	2a04      	cmp	r2, #4
 8013b90:	d956      	bls.n	8013c40 <_malloc_r+0x400>
 8013b92:	2a14      	cmp	r2, #20
 8013b94:	f200 80a7 	bhi.w	8013ce6 <_malloc_r+0x4a6>
 8013b98:	325b      	adds	r2, #91	; 0x5b
 8013b9a:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 8013b9e:	eb07 0c8c 	add.w	ip, r7, ip, lsl #2
 8013ba2:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 8013d58 <_malloc_r+0x518>
 8013ba6:	f8dc 1008 	ldr.w	r1, [ip, #8]
 8013baa:	4561      	cmp	r1, ip
 8013bac:	f000 8085 	beq.w	8013cba <_malloc_r+0x47a>
 8013bb0:	684a      	ldr	r2, [r1, #4]
 8013bb2:	f022 0203 	bic.w	r2, r2, #3
 8013bb6:	4293      	cmp	r3, r2
 8013bb8:	d202      	bcs.n	8013bc0 <_malloc_r+0x380>
 8013bba:	6889      	ldr	r1, [r1, #8]
 8013bbc:	458c      	cmp	ip, r1
 8013bbe:	d1f7      	bne.n	8013bb0 <_malloc_r+0x370>
 8013bc0:	68ca      	ldr	r2, [r1, #12]
 8013bc2:	687b      	ldr	r3, [r7, #4]
 8013bc4:	60e2      	str	r2, [r4, #12]
 8013bc6:	60a1      	str	r1, [r4, #8]
 8013bc8:	6094      	str	r4, [r2, #8]
 8013bca:	60cc      	str	r4, [r1, #12]
 8013bcc:	e6ba      	b.n	8013944 <_malloc_r+0x104>
 8013bce:	1963      	adds	r3, r4, r5
 8013bd0:	f042 0701 	orr.w	r7, r2, #1
 8013bd4:	f045 0501 	orr.w	r5, r5, #1
 8013bd8:	6065      	str	r5, [r4, #4]
 8013bda:	4630      	mov	r0, r6
 8013bdc:	614b      	str	r3, [r1, #20]
 8013bde:	610b      	str	r3, [r1, #16]
 8013be0:	f8c3 e00c 	str.w	lr, [r3, #12]
 8013be4:	f8c3 e008 	str.w	lr, [r3, #8]
 8013be8:	605f      	str	r7, [r3, #4]
 8013bea:	509a      	str	r2, [r3, r2]
 8013bec:	3408      	adds	r4, #8
 8013bee:	f000 f947 	bl	8013e80 <__malloc_unlock>
 8013bf2:	e651      	b.n	8013898 <_malloc_r+0x58>
 8013bf4:	684b      	ldr	r3, [r1, #4]
 8013bf6:	e6a5      	b.n	8013944 <_malloc_r+0x104>
 8013bf8:	f109 0901 	add.w	r9, r9, #1
 8013bfc:	f019 0f03 	tst.w	r9, #3
 8013c00:	f10c 0c08 	add.w	ip, ip, #8
 8013c04:	f47f aeb0 	bne.w	8013968 <_malloc_r+0x128>
 8013c08:	e02b      	b.n	8013c62 <_malloc_r+0x422>
 8013c0a:	f104 0308 	add.w	r3, r4, #8
 8013c0e:	6964      	ldr	r4, [r4, #20]
 8013c10:	42a3      	cmp	r3, r4
 8013c12:	bf08      	it	eq
 8013c14:	3002      	addeq	r0, #2
 8013c16:	f43f ae68 	beq.w	80138ea <_malloc_r+0xaa>
 8013c1a:	e62d      	b.n	8013878 <_malloc_r+0x38>
 8013c1c:	441a      	add	r2, r3
 8013c1e:	461c      	mov	r4, r3
 8013c20:	6851      	ldr	r1, [r2, #4]
 8013c22:	68db      	ldr	r3, [r3, #12]
 8013c24:	f854 5f08 	ldr.w	r5, [r4, #8]!
 8013c28:	f041 0101 	orr.w	r1, r1, #1
 8013c2c:	6051      	str	r1, [r2, #4]
 8013c2e:	4630      	mov	r0, r6
 8013c30:	60eb      	str	r3, [r5, #12]
 8013c32:	609d      	str	r5, [r3, #8]
 8013c34:	f000 f924 	bl	8013e80 <__malloc_unlock>
 8013c38:	e62e      	b.n	8013898 <_malloc_r+0x58>
 8013c3a:	305b      	adds	r0, #91	; 0x5b
 8013c3c:	0041      	lsls	r1, r0, #1
 8013c3e:	e63f      	b.n	80138c0 <_malloc_r+0x80>
 8013c40:	099a      	lsrs	r2, r3, #6
 8013c42:	3238      	adds	r2, #56	; 0x38
 8013c44:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 8013c48:	e7a9      	b.n	8013b9e <_malloc_r+0x35e>
 8013c4a:	42bc      	cmp	r4, r7
 8013c4c:	f43f af0e 	beq.w	8013a6c <_malloc_r+0x22c>
 8013c50:	68bc      	ldr	r4, [r7, #8]
 8013c52:	6862      	ldr	r2, [r4, #4]
 8013c54:	f022 0203 	bic.w	r2, r2, #3
 8013c58:	e768      	b.n	8013b2c <_malloc_r+0x2ec>
 8013c5a:	f8d8 8000 	ldr.w	r8, [r8]
 8013c5e:	4598      	cmp	r8, r3
 8013c60:	d177      	bne.n	8013d52 <_malloc_r+0x512>
 8013c62:	f010 0f03 	tst.w	r0, #3
 8013c66:	f1a8 0308 	sub.w	r3, r8, #8
 8013c6a:	f100 30ff 	add.w	r0, r0, #4294967295
 8013c6e:	d1f4      	bne.n	8013c5a <_malloc_r+0x41a>
 8013c70:	687b      	ldr	r3, [r7, #4]
 8013c72:	ea23 0304 	bic.w	r3, r3, r4
 8013c76:	607b      	str	r3, [r7, #4]
 8013c78:	0064      	lsls	r4, r4, #1
 8013c7a:	429c      	cmp	r4, r3
 8013c7c:	f63f aeca 	bhi.w	8013a14 <_malloc_r+0x1d4>
 8013c80:	2c00      	cmp	r4, #0
 8013c82:	f43f aec7 	beq.w	8013a14 <_malloc_r+0x1d4>
 8013c86:	4223      	tst	r3, r4
 8013c88:	4648      	mov	r0, r9
 8013c8a:	f47f ae69 	bne.w	8013960 <_malloc_r+0x120>
 8013c8e:	0064      	lsls	r4, r4, #1
 8013c90:	4223      	tst	r3, r4
 8013c92:	f100 0004 	add.w	r0, r0, #4
 8013c96:	d0fa      	beq.n	8013c8e <_malloc_r+0x44e>
 8013c98:	e662      	b.n	8013960 <_malloc_r+0x120>
 8013c9a:	f5b0 7faa 	cmp.w	r0, #340	; 0x154
 8013c9e:	d818      	bhi.n	8013cd2 <_malloc_r+0x492>
 8013ca0:	0be8      	lsrs	r0, r5, #15
 8013ca2:	3077      	adds	r0, #119	; 0x77
 8013ca4:	0041      	lsls	r1, r0, #1
 8013ca6:	e60b      	b.n	80138c0 <_malloc_r+0x80>
 8013ca8:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8013cac:	e6fb      	b.n	8013aa6 <_malloc_r+0x266>
 8013cae:	2301      	movs	r3, #1
 8013cb0:	f8c9 3004 	str.w	r3, [r9, #4]
 8013cb4:	464c      	mov	r4, r9
 8013cb6:	2200      	movs	r2, #0
 8013cb8:	e738      	b.n	8013b2c <_malloc_r+0x2ec>
 8013cba:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8013cbe:	1092      	asrs	r2, r2, #2
 8013cc0:	f04f 0c01 	mov.w	ip, #1
 8013cc4:	fa0c f202 	lsl.w	r2, ip, r2
 8013cc8:	4313      	orrs	r3, r2
 8013cca:	f8c8 3004 	str.w	r3, [r8, #4]
 8013cce:	460a      	mov	r2, r1
 8013cd0:	e778      	b.n	8013bc4 <_malloc_r+0x384>
 8013cd2:	f240 5354 	movw	r3, #1364	; 0x554
 8013cd6:	4298      	cmp	r0, r3
 8013cd8:	d817      	bhi.n	8013d0a <_malloc_r+0x4ca>
 8013cda:	0ca8      	lsrs	r0, r5, #18
 8013cdc:	307c      	adds	r0, #124	; 0x7c
 8013cde:	0041      	lsls	r1, r0, #1
 8013ce0:	e5ee      	b.n	80138c0 <_malloc_r+0x80>
 8013ce2:	3210      	adds	r2, #16
 8013ce4:	e6b4      	b.n	8013a50 <_malloc_r+0x210>
 8013ce6:	2a54      	cmp	r2, #84	; 0x54
 8013ce8:	d81e      	bhi.n	8013d28 <_malloc_r+0x4e8>
 8013cea:	0b1a      	lsrs	r2, r3, #12
 8013cec:	326e      	adds	r2, #110	; 0x6e
 8013cee:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 8013cf2:	e754      	b.n	8013b9e <_malloc_r+0x35e>
 8013cf4:	f3cb 000b 	ubfx	r0, fp, #0, #12
 8013cf8:	2800      	cmp	r0, #0
 8013cfa:	f47f aebe 	bne.w	8013a7a <_malloc_r+0x23a>
 8013cfe:	4442      	add	r2, r8
 8013d00:	68bb      	ldr	r3, [r7, #8]
 8013d02:	f042 0201 	orr.w	r2, r2, #1
 8013d06:	605a      	str	r2, [r3, #4]
 8013d08:	e702      	b.n	8013b10 <_malloc_r+0x2d0>
 8013d0a:	21fc      	movs	r1, #252	; 0xfc
 8013d0c:	207e      	movs	r0, #126	; 0x7e
 8013d0e:	e5d7      	b.n	80138c0 <_malloc_r+0x80>
 8013d10:	2201      	movs	r2, #1
 8013d12:	f04f 0a00 	mov.w	sl, #0
 8013d16:	e6d9      	b.n	8013acc <_malloc_r+0x28c>
 8013d18:	f104 0108 	add.w	r1, r4, #8
 8013d1c:	4630      	mov	r0, r6
 8013d1e:	f001 fc67 	bl	80155f0 <_free_r>
 8013d22:	f8da 1000 	ldr.w	r1, [sl]
 8013d26:	e6f3      	b.n	8013b10 <_malloc_r+0x2d0>
 8013d28:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8013d2c:	d804      	bhi.n	8013d38 <_malloc_r+0x4f8>
 8013d2e:	0bda      	lsrs	r2, r3, #15
 8013d30:	3277      	adds	r2, #119	; 0x77
 8013d32:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 8013d36:	e732      	b.n	8013b9e <_malloc_r+0x35e>
 8013d38:	f240 5154 	movw	r1, #1364	; 0x554
 8013d3c:	428a      	cmp	r2, r1
 8013d3e:	d804      	bhi.n	8013d4a <_malloc_r+0x50a>
 8013d40:	0c9a      	lsrs	r2, r3, #18
 8013d42:	327c      	adds	r2, #124	; 0x7c
 8013d44:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 8013d48:	e729      	b.n	8013b9e <_malloc_r+0x35e>
 8013d4a:	f04f 0cfc 	mov.w	ip, #252	; 0xfc
 8013d4e:	227e      	movs	r2, #126	; 0x7e
 8013d50:	e725      	b.n	8013b9e <_malloc_r+0x35e>
 8013d52:	687b      	ldr	r3, [r7, #4]
 8013d54:	e790      	b.n	8013c78 <_malloc_r+0x438>
 8013d56:	bf00      	nop
 8013d58:	20000d14 	.word	0x20000d14
 8013d5c:	00000000 	.word	0x00000000

08013d60 <memcmp>:
 8013d60:	2a03      	cmp	r2, #3
 8013d62:	b470      	push	{r4, r5, r6}
 8013d64:	d926      	bls.n	8013db4 <memcmp+0x54>
 8013d66:	ea40 0301 	orr.w	r3, r0, r1
 8013d6a:	079b      	lsls	r3, r3, #30
 8013d6c:	d011      	beq.n	8013d92 <memcmp+0x32>
 8013d6e:	7804      	ldrb	r4, [r0, #0]
 8013d70:	780d      	ldrb	r5, [r1, #0]
 8013d72:	42ac      	cmp	r4, r5
 8013d74:	d122      	bne.n	8013dbc <memcmp+0x5c>
 8013d76:	4402      	add	r2, r0
 8013d78:	1c43      	adds	r3, r0, #1
 8013d7a:	e005      	b.n	8013d88 <memcmp+0x28>
 8013d7c:	f813 4b01 	ldrb.w	r4, [r3], #1
 8013d80:	f811 5f01 	ldrb.w	r5, [r1, #1]!
 8013d84:	42ac      	cmp	r4, r5
 8013d86:	d119      	bne.n	8013dbc <memcmp+0x5c>
 8013d88:	4293      	cmp	r3, r2
 8013d8a:	d1f7      	bne.n	8013d7c <memcmp+0x1c>
 8013d8c:	2000      	movs	r0, #0
 8013d8e:	bc70      	pop	{r4, r5, r6}
 8013d90:	4770      	bx	lr
 8013d92:	460c      	mov	r4, r1
 8013d94:	4603      	mov	r3, r0
 8013d96:	681e      	ldr	r6, [r3, #0]
 8013d98:	6825      	ldr	r5, [r4, #0]
 8013d9a:	42ae      	cmp	r6, r5
 8013d9c:	4618      	mov	r0, r3
 8013d9e:	4621      	mov	r1, r4
 8013da0:	f103 0304 	add.w	r3, r3, #4
 8013da4:	f104 0404 	add.w	r4, r4, #4
 8013da8:	d104      	bne.n	8013db4 <memcmp+0x54>
 8013daa:	3a04      	subs	r2, #4
 8013dac:	2a03      	cmp	r2, #3
 8013dae:	4618      	mov	r0, r3
 8013db0:	4621      	mov	r1, r4
 8013db2:	d8f0      	bhi.n	8013d96 <memcmp+0x36>
 8013db4:	2a00      	cmp	r2, #0
 8013db6:	d1da      	bne.n	8013d6e <memcmp+0xe>
 8013db8:	4610      	mov	r0, r2
 8013dba:	e7e8      	b.n	8013d8e <memcmp+0x2e>
 8013dbc:	1b60      	subs	r0, r4, r5
 8013dbe:	bc70      	pop	{r4, r5, r6}
 8013dc0:	4770      	bx	lr
 8013dc2:	bf00      	nop
	...

08013dd0 <memset>:
 8013dd0:	b470      	push	{r4, r5, r6}
 8013dd2:	0784      	lsls	r4, r0, #30
 8013dd4:	d046      	beq.n	8013e64 <memset+0x94>
 8013dd6:	1e54      	subs	r4, r2, #1
 8013dd8:	2a00      	cmp	r2, #0
 8013dda:	d041      	beq.n	8013e60 <memset+0x90>
 8013ddc:	b2cd      	uxtb	r5, r1
 8013dde:	4603      	mov	r3, r0
 8013de0:	e002      	b.n	8013de8 <memset+0x18>
 8013de2:	1e62      	subs	r2, r4, #1
 8013de4:	b3e4      	cbz	r4, 8013e60 <memset+0x90>
 8013de6:	4614      	mov	r4, r2
 8013de8:	f803 5b01 	strb.w	r5, [r3], #1
 8013dec:	079a      	lsls	r2, r3, #30
 8013dee:	d1f8      	bne.n	8013de2 <memset+0x12>
 8013df0:	2c03      	cmp	r4, #3
 8013df2:	d92e      	bls.n	8013e52 <memset+0x82>
 8013df4:	b2cd      	uxtb	r5, r1
 8013df6:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8013dfa:	2c0f      	cmp	r4, #15
 8013dfc:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8013e00:	d919      	bls.n	8013e36 <memset+0x66>
 8013e02:	f103 0210 	add.w	r2, r3, #16
 8013e06:	4626      	mov	r6, r4
 8013e08:	3e10      	subs	r6, #16
 8013e0a:	2e0f      	cmp	r6, #15
 8013e0c:	f842 5c10 	str.w	r5, [r2, #-16]
 8013e10:	f842 5c0c 	str.w	r5, [r2, #-12]
 8013e14:	f842 5c08 	str.w	r5, [r2, #-8]
 8013e18:	f842 5c04 	str.w	r5, [r2, #-4]
 8013e1c:	f102 0210 	add.w	r2, r2, #16
 8013e20:	d8f2      	bhi.n	8013e08 <memset+0x38>
 8013e22:	f1a4 0210 	sub.w	r2, r4, #16
 8013e26:	f022 020f 	bic.w	r2, r2, #15
 8013e2a:	f004 040f 	and.w	r4, r4, #15
 8013e2e:	3210      	adds	r2, #16
 8013e30:	2c03      	cmp	r4, #3
 8013e32:	4413      	add	r3, r2
 8013e34:	d90d      	bls.n	8013e52 <memset+0x82>
 8013e36:	461e      	mov	r6, r3
 8013e38:	4622      	mov	r2, r4
 8013e3a:	3a04      	subs	r2, #4
 8013e3c:	2a03      	cmp	r2, #3
 8013e3e:	f846 5b04 	str.w	r5, [r6], #4
 8013e42:	d8fa      	bhi.n	8013e3a <memset+0x6a>
 8013e44:	1f22      	subs	r2, r4, #4
 8013e46:	f022 0203 	bic.w	r2, r2, #3
 8013e4a:	3204      	adds	r2, #4
 8013e4c:	4413      	add	r3, r2
 8013e4e:	f004 0403 	and.w	r4, r4, #3
 8013e52:	b12c      	cbz	r4, 8013e60 <memset+0x90>
 8013e54:	b2c9      	uxtb	r1, r1
 8013e56:	441c      	add	r4, r3
 8013e58:	f803 1b01 	strb.w	r1, [r3], #1
 8013e5c:	42a3      	cmp	r3, r4
 8013e5e:	d1fb      	bne.n	8013e58 <memset+0x88>
 8013e60:	bc70      	pop	{r4, r5, r6}
 8013e62:	4770      	bx	lr
 8013e64:	4614      	mov	r4, r2
 8013e66:	4603      	mov	r3, r0
 8013e68:	e7c2      	b.n	8013df0 <memset+0x20>
 8013e6a:	bf00      	nop
 8013e6c:	0000      	movs	r0, r0
	...

08013e70 <__malloc_lock>:
 8013e70:	4770      	bx	lr
 8013e72:	bf00      	nop
	...

08013e80 <__malloc_unlock>:
 8013e80:	4770      	bx	lr
 8013e82:	bf00      	nop
	...

08013e90 <_realloc_r>:
 8013e90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013e94:	4617      	mov	r7, r2
 8013e96:	b083      	sub	sp, #12
 8013e98:	460e      	mov	r6, r1
 8013e9a:	2900      	cmp	r1, #0
 8013e9c:	f000 80e7 	beq.w	801406e <_realloc_r+0x1de>
 8013ea0:	4681      	mov	r9, r0
 8013ea2:	f107 050b 	add.w	r5, r7, #11
 8013ea6:	f7ff ffe3 	bl	8013e70 <__malloc_lock>
 8013eaa:	f856 3c04 	ldr.w	r3, [r6, #-4]
 8013eae:	2d16      	cmp	r5, #22
 8013eb0:	f023 0403 	bic.w	r4, r3, #3
 8013eb4:	f1a6 0808 	sub.w	r8, r6, #8
 8013eb8:	d84c      	bhi.n	8013f54 <_realloc_r+0xc4>
 8013eba:	2210      	movs	r2, #16
 8013ebc:	4615      	mov	r5, r2
 8013ebe:	42af      	cmp	r7, r5
 8013ec0:	d84d      	bhi.n	8013f5e <_realloc_r+0xce>
 8013ec2:	4294      	cmp	r4, r2
 8013ec4:	f280 8084 	bge.w	8013fd0 <_realloc_r+0x140>
 8013ec8:	f8df b3ac 	ldr.w	fp, [pc, #940]	; 8014278 <_realloc_r+0x3e8>
 8013ecc:	f8db 0008 	ldr.w	r0, [fp, #8]
 8013ed0:	eb08 0104 	add.w	r1, r8, r4
 8013ed4:	4288      	cmp	r0, r1
 8013ed6:	f000 80d6 	beq.w	8014086 <_realloc_r+0x1f6>
 8013eda:	6848      	ldr	r0, [r1, #4]
 8013edc:	f020 0e01 	bic.w	lr, r0, #1
 8013ee0:	448e      	add	lr, r1
 8013ee2:	f8de e004 	ldr.w	lr, [lr, #4]
 8013ee6:	f01e 0f01 	tst.w	lr, #1
 8013eea:	d13f      	bne.n	8013f6c <_realloc_r+0xdc>
 8013eec:	f020 0003 	bic.w	r0, r0, #3
 8013ef0:	4420      	add	r0, r4
 8013ef2:	4290      	cmp	r0, r2
 8013ef4:	f280 80c1 	bge.w	801407a <_realloc_r+0x1ea>
 8013ef8:	07db      	lsls	r3, r3, #31
 8013efa:	f100 808f 	bmi.w	801401c <_realloc_r+0x18c>
 8013efe:	f856 3c08 	ldr.w	r3, [r6, #-8]
 8013f02:	ebc3 0a08 	rsb	sl, r3, r8
 8013f06:	f8da 3004 	ldr.w	r3, [sl, #4]
 8013f0a:	f023 0303 	bic.w	r3, r3, #3
 8013f0e:	eb00 0e03 	add.w	lr, r0, r3
 8013f12:	4596      	cmp	lr, r2
 8013f14:	db34      	blt.n	8013f80 <_realloc_r+0xf0>
 8013f16:	68cb      	ldr	r3, [r1, #12]
 8013f18:	688a      	ldr	r2, [r1, #8]
 8013f1a:	4657      	mov	r7, sl
 8013f1c:	60d3      	str	r3, [r2, #12]
 8013f1e:	609a      	str	r2, [r3, #8]
 8013f20:	f857 1f08 	ldr.w	r1, [r7, #8]!
 8013f24:	f8da 300c 	ldr.w	r3, [sl, #12]
 8013f28:	60cb      	str	r3, [r1, #12]
 8013f2a:	1f22      	subs	r2, r4, #4
 8013f2c:	2a24      	cmp	r2, #36	; 0x24
 8013f2e:	6099      	str	r1, [r3, #8]
 8013f30:	f200 8136 	bhi.w	80141a0 <_realloc_r+0x310>
 8013f34:	2a13      	cmp	r2, #19
 8013f36:	f240 80fd 	bls.w	8014134 <_realloc_r+0x2a4>
 8013f3a:	6833      	ldr	r3, [r6, #0]
 8013f3c:	f8ca 3008 	str.w	r3, [sl, #8]
 8013f40:	6873      	ldr	r3, [r6, #4]
 8013f42:	f8ca 300c 	str.w	r3, [sl, #12]
 8013f46:	2a1b      	cmp	r2, #27
 8013f48:	f200 8140 	bhi.w	80141cc <_realloc_r+0x33c>
 8013f4c:	3608      	adds	r6, #8
 8013f4e:	f10a 0310 	add.w	r3, sl, #16
 8013f52:	e0f0      	b.n	8014136 <_realloc_r+0x2a6>
 8013f54:	f025 0507 	bic.w	r5, r5, #7
 8013f58:	2d00      	cmp	r5, #0
 8013f5a:	462a      	mov	r2, r5
 8013f5c:	daaf      	bge.n	8013ebe <_realloc_r+0x2e>
 8013f5e:	230c      	movs	r3, #12
 8013f60:	2000      	movs	r0, #0
 8013f62:	f8c9 3000 	str.w	r3, [r9]
 8013f66:	b003      	add	sp, #12
 8013f68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013f6c:	07d9      	lsls	r1, r3, #31
 8013f6e:	d455      	bmi.n	801401c <_realloc_r+0x18c>
 8013f70:	f856 3c08 	ldr.w	r3, [r6, #-8]
 8013f74:	ebc3 0a08 	rsb	sl, r3, r8
 8013f78:	f8da 3004 	ldr.w	r3, [sl, #4]
 8013f7c:	f023 0303 	bic.w	r3, r3, #3
 8013f80:	4423      	add	r3, r4
 8013f82:	4293      	cmp	r3, r2
 8013f84:	db4a      	blt.n	801401c <_realloc_r+0x18c>
 8013f86:	4657      	mov	r7, sl
 8013f88:	f8da 100c 	ldr.w	r1, [sl, #12]
 8013f8c:	f857 0f08 	ldr.w	r0, [r7, #8]!
 8013f90:	1f22      	subs	r2, r4, #4
 8013f92:	2a24      	cmp	r2, #36	; 0x24
 8013f94:	60c1      	str	r1, [r0, #12]
 8013f96:	6088      	str	r0, [r1, #8]
 8013f98:	f200 810e 	bhi.w	80141b8 <_realloc_r+0x328>
 8013f9c:	2a13      	cmp	r2, #19
 8013f9e:	f240 8109 	bls.w	80141b4 <_realloc_r+0x324>
 8013fa2:	6831      	ldr	r1, [r6, #0]
 8013fa4:	f8ca 1008 	str.w	r1, [sl, #8]
 8013fa8:	6871      	ldr	r1, [r6, #4]
 8013faa:	f8ca 100c 	str.w	r1, [sl, #12]
 8013fae:	2a1b      	cmp	r2, #27
 8013fb0:	f200 8121 	bhi.w	80141f6 <_realloc_r+0x366>
 8013fb4:	3608      	adds	r6, #8
 8013fb6:	f10a 0210 	add.w	r2, sl, #16
 8013fba:	6831      	ldr	r1, [r6, #0]
 8013fbc:	6011      	str	r1, [r2, #0]
 8013fbe:	6871      	ldr	r1, [r6, #4]
 8013fc0:	6051      	str	r1, [r2, #4]
 8013fc2:	68b1      	ldr	r1, [r6, #8]
 8013fc4:	6091      	str	r1, [r2, #8]
 8013fc6:	461c      	mov	r4, r3
 8013fc8:	f8da 3004 	ldr.w	r3, [sl, #4]
 8013fcc:	463e      	mov	r6, r7
 8013fce:	46d0      	mov	r8, sl
 8013fd0:	1b62      	subs	r2, r4, r5
 8013fd2:	2a0f      	cmp	r2, #15
 8013fd4:	f003 0301 	and.w	r3, r3, #1
 8013fd8:	d80e      	bhi.n	8013ff8 <_realloc_r+0x168>
 8013fda:	4323      	orrs	r3, r4
 8013fdc:	4444      	add	r4, r8
 8013fde:	f8c8 3004 	str.w	r3, [r8, #4]
 8013fe2:	6863      	ldr	r3, [r4, #4]
 8013fe4:	f043 0301 	orr.w	r3, r3, #1
 8013fe8:	6063      	str	r3, [r4, #4]
 8013fea:	4648      	mov	r0, r9
 8013fec:	f7ff ff48 	bl	8013e80 <__malloc_unlock>
 8013ff0:	4630      	mov	r0, r6
 8013ff2:	b003      	add	sp, #12
 8013ff4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013ff8:	eb08 0105 	add.w	r1, r8, r5
 8013ffc:	431d      	orrs	r5, r3
 8013ffe:	f042 0301 	orr.w	r3, r2, #1
 8014002:	440a      	add	r2, r1
 8014004:	f8c8 5004 	str.w	r5, [r8, #4]
 8014008:	604b      	str	r3, [r1, #4]
 801400a:	6853      	ldr	r3, [r2, #4]
 801400c:	f043 0301 	orr.w	r3, r3, #1
 8014010:	3108      	adds	r1, #8
 8014012:	6053      	str	r3, [r2, #4]
 8014014:	4648      	mov	r0, r9
 8014016:	f001 faeb 	bl	80155f0 <_free_r>
 801401a:	e7e6      	b.n	8013fea <_realloc_r+0x15a>
 801401c:	4639      	mov	r1, r7
 801401e:	4648      	mov	r0, r9
 8014020:	f7ff fc0e 	bl	8013840 <_malloc_r>
 8014024:	4607      	mov	r7, r0
 8014026:	b1d8      	cbz	r0, 8014060 <_realloc_r+0x1d0>
 8014028:	f856 3c04 	ldr.w	r3, [r6, #-4]
 801402c:	f023 0201 	bic.w	r2, r3, #1
 8014030:	4442      	add	r2, r8
 8014032:	f1a0 0108 	sub.w	r1, r0, #8
 8014036:	4291      	cmp	r1, r2
 8014038:	f000 80ac 	beq.w	8014194 <_realloc_r+0x304>
 801403c:	1f22      	subs	r2, r4, #4
 801403e:	2a24      	cmp	r2, #36	; 0x24
 8014040:	f200 8099 	bhi.w	8014176 <_realloc_r+0x2e6>
 8014044:	2a13      	cmp	r2, #19
 8014046:	d86a      	bhi.n	801411e <_realloc_r+0x28e>
 8014048:	4603      	mov	r3, r0
 801404a:	4632      	mov	r2, r6
 801404c:	6811      	ldr	r1, [r2, #0]
 801404e:	6019      	str	r1, [r3, #0]
 8014050:	6851      	ldr	r1, [r2, #4]
 8014052:	6059      	str	r1, [r3, #4]
 8014054:	6892      	ldr	r2, [r2, #8]
 8014056:	609a      	str	r2, [r3, #8]
 8014058:	4631      	mov	r1, r6
 801405a:	4648      	mov	r0, r9
 801405c:	f001 fac8 	bl	80155f0 <_free_r>
 8014060:	4648      	mov	r0, r9
 8014062:	f7ff ff0d 	bl	8013e80 <__malloc_unlock>
 8014066:	4638      	mov	r0, r7
 8014068:	b003      	add	sp, #12
 801406a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801406e:	4611      	mov	r1, r2
 8014070:	b003      	add	sp, #12
 8014072:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014076:	f7ff bbe3 	b.w	8013840 <_malloc_r>
 801407a:	68ca      	ldr	r2, [r1, #12]
 801407c:	6889      	ldr	r1, [r1, #8]
 801407e:	4604      	mov	r4, r0
 8014080:	60ca      	str	r2, [r1, #12]
 8014082:	6091      	str	r1, [r2, #8]
 8014084:	e7a4      	b.n	8013fd0 <_realloc_r+0x140>
 8014086:	6841      	ldr	r1, [r0, #4]
 8014088:	f021 0103 	bic.w	r1, r1, #3
 801408c:	4421      	add	r1, r4
 801408e:	f105 0010 	add.w	r0, r5, #16
 8014092:	4281      	cmp	r1, r0
 8014094:	da5b      	bge.n	801414e <_realloc_r+0x2be>
 8014096:	07db      	lsls	r3, r3, #31
 8014098:	d4c0      	bmi.n	801401c <_realloc_r+0x18c>
 801409a:	f856 3c08 	ldr.w	r3, [r6, #-8]
 801409e:	ebc3 0a08 	rsb	sl, r3, r8
 80140a2:	f8da 3004 	ldr.w	r3, [sl, #4]
 80140a6:	f023 0303 	bic.w	r3, r3, #3
 80140aa:	eb01 0c03 	add.w	ip, r1, r3
 80140ae:	4560      	cmp	r0, ip
 80140b0:	f73f af66 	bgt.w	8013f80 <_realloc_r+0xf0>
 80140b4:	4657      	mov	r7, sl
 80140b6:	f8da 300c 	ldr.w	r3, [sl, #12]
 80140ba:	f857 1f08 	ldr.w	r1, [r7, #8]!
 80140be:	1f22      	subs	r2, r4, #4
 80140c0:	2a24      	cmp	r2, #36	; 0x24
 80140c2:	60cb      	str	r3, [r1, #12]
 80140c4:	6099      	str	r1, [r3, #8]
 80140c6:	f200 80b8 	bhi.w	801423a <_realloc_r+0x3aa>
 80140ca:	2a13      	cmp	r2, #19
 80140cc:	f240 80a9 	bls.w	8014222 <_realloc_r+0x392>
 80140d0:	6833      	ldr	r3, [r6, #0]
 80140d2:	f8ca 3008 	str.w	r3, [sl, #8]
 80140d6:	6873      	ldr	r3, [r6, #4]
 80140d8:	f8ca 300c 	str.w	r3, [sl, #12]
 80140dc:	2a1b      	cmp	r2, #27
 80140de:	f200 80b5 	bhi.w	801424c <_realloc_r+0x3bc>
 80140e2:	3608      	adds	r6, #8
 80140e4:	f10a 0310 	add.w	r3, sl, #16
 80140e8:	6832      	ldr	r2, [r6, #0]
 80140ea:	601a      	str	r2, [r3, #0]
 80140ec:	6872      	ldr	r2, [r6, #4]
 80140ee:	605a      	str	r2, [r3, #4]
 80140f0:	68b2      	ldr	r2, [r6, #8]
 80140f2:	609a      	str	r2, [r3, #8]
 80140f4:	eb0a 0205 	add.w	r2, sl, r5
 80140f8:	ebc5 030c 	rsb	r3, r5, ip
 80140fc:	f043 0301 	orr.w	r3, r3, #1
 8014100:	f8cb 2008 	str.w	r2, [fp, #8]
 8014104:	6053      	str	r3, [r2, #4]
 8014106:	f8da 3004 	ldr.w	r3, [sl, #4]
 801410a:	f003 0301 	and.w	r3, r3, #1
 801410e:	431d      	orrs	r5, r3
 8014110:	4648      	mov	r0, r9
 8014112:	f8ca 5004 	str.w	r5, [sl, #4]
 8014116:	f7ff feb3 	bl	8013e80 <__malloc_unlock>
 801411a:	4638      	mov	r0, r7
 801411c:	e769      	b.n	8013ff2 <_realloc_r+0x162>
 801411e:	6833      	ldr	r3, [r6, #0]
 8014120:	6003      	str	r3, [r0, #0]
 8014122:	6873      	ldr	r3, [r6, #4]
 8014124:	6043      	str	r3, [r0, #4]
 8014126:	2a1b      	cmp	r2, #27
 8014128:	d829      	bhi.n	801417e <_realloc_r+0x2ee>
 801412a:	f100 0308 	add.w	r3, r0, #8
 801412e:	f106 0208 	add.w	r2, r6, #8
 8014132:	e78b      	b.n	801404c <_realloc_r+0x1bc>
 8014134:	463b      	mov	r3, r7
 8014136:	6832      	ldr	r2, [r6, #0]
 8014138:	601a      	str	r2, [r3, #0]
 801413a:	6872      	ldr	r2, [r6, #4]
 801413c:	605a      	str	r2, [r3, #4]
 801413e:	68b2      	ldr	r2, [r6, #8]
 8014140:	609a      	str	r2, [r3, #8]
 8014142:	463e      	mov	r6, r7
 8014144:	4674      	mov	r4, lr
 8014146:	f8da 3004 	ldr.w	r3, [sl, #4]
 801414a:	46d0      	mov	r8, sl
 801414c:	e740      	b.n	8013fd0 <_realloc_r+0x140>
 801414e:	eb08 0205 	add.w	r2, r8, r5
 8014152:	1b4b      	subs	r3, r1, r5
 8014154:	f043 0301 	orr.w	r3, r3, #1
 8014158:	f8cb 2008 	str.w	r2, [fp, #8]
 801415c:	6053      	str	r3, [r2, #4]
 801415e:	f856 3c04 	ldr.w	r3, [r6, #-4]
 8014162:	f003 0301 	and.w	r3, r3, #1
 8014166:	431d      	orrs	r5, r3
 8014168:	4648      	mov	r0, r9
 801416a:	f846 5c04 	str.w	r5, [r6, #-4]
 801416e:	f7ff fe87 	bl	8013e80 <__malloc_unlock>
 8014172:	4630      	mov	r0, r6
 8014174:	e73d      	b.n	8013ff2 <_realloc_r+0x162>
 8014176:	4631      	mov	r1, r6
 8014178:	f001 fda2 	bl	8015cc0 <memmove>
 801417c:	e76c      	b.n	8014058 <_realloc_r+0x1c8>
 801417e:	68b3      	ldr	r3, [r6, #8]
 8014180:	6083      	str	r3, [r0, #8]
 8014182:	68f3      	ldr	r3, [r6, #12]
 8014184:	60c3      	str	r3, [r0, #12]
 8014186:	2a24      	cmp	r2, #36	; 0x24
 8014188:	d02c      	beq.n	80141e4 <_realloc_r+0x354>
 801418a:	f100 0310 	add.w	r3, r0, #16
 801418e:	f106 0210 	add.w	r2, r6, #16
 8014192:	e75b      	b.n	801404c <_realloc_r+0x1bc>
 8014194:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8014198:	f022 0203 	bic.w	r2, r2, #3
 801419c:	4414      	add	r4, r2
 801419e:	e717      	b.n	8013fd0 <_realloc_r+0x140>
 80141a0:	4631      	mov	r1, r6
 80141a2:	4638      	mov	r0, r7
 80141a4:	4674      	mov	r4, lr
 80141a6:	463e      	mov	r6, r7
 80141a8:	f001 fd8a 	bl	8015cc0 <memmove>
 80141ac:	46d0      	mov	r8, sl
 80141ae:	f8da 3004 	ldr.w	r3, [sl, #4]
 80141b2:	e70d      	b.n	8013fd0 <_realloc_r+0x140>
 80141b4:	463a      	mov	r2, r7
 80141b6:	e700      	b.n	8013fba <_realloc_r+0x12a>
 80141b8:	4631      	mov	r1, r6
 80141ba:	4638      	mov	r0, r7
 80141bc:	461c      	mov	r4, r3
 80141be:	463e      	mov	r6, r7
 80141c0:	f001 fd7e 	bl	8015cc0 <memmove>
 80141c4:	46d0      	mov	r8, sl
 80141c6:	f8da 3004 	ldr.w	r3, [sl, #4]
 80141ca:	e701      	b.n	8013fd0 <_realloc_r+0x140>
 80141cc:	68b3      	ldr	r3, [r6, #8]
 80141ce:	f8ca 3010 	str.w	r3, [sl, #16]
 80141d2:	68f3      	ldr	r3, [r6, #12]
 80141d4:	f8ca 3014 	str.w	r3, [sl, #20]
 80141d8:	2a24      	cmp	r2, #36	; 0x24
 80141da:	d018      	beq.n	801420e <_realloc_r+0x37e>
 80141dc:	3610      	adds	r6, #16
 80141de:	f10a 0318 	add.w	r3, sl, #24
 80141e2:	e7a8      	b.n	8014136 <_realloc_r+0x2a6>
 80141e4:	6933      	ldr	r3, [r6, #16]
 80141e6:	6103      	str	r3, [r0, #16]
 80141e8:	6973      	ldr	r3, [r6, #20]
 80141ea:	6143      	str	r3, [r0, #20]
 80141ec:	f106 0218 	add.w	r2, r6, #24
 80141f0:	f100 0318 	add.w	r3, r0, #24
 80141f4:	e72a      	b.n	801404c <_realloc_r+0x1bc>
 80141f6:	68b1      	ldr	r1, [r6, #8]
 80141f8:	f8ca 1010 	str.w	r1, [sl, #16]
 80141fc:	68f1      	ldr	r1, [r6, #12]
 80141fe:	f8ca 1014 	str.w	r1, [sl, #20]
 8014202:	2a24      	cmp	r2, #36	; 0x24
 8014204:	d00f      	beq.n	8014226 <_realloc_r+0x396>
 8014206:	3610      	adds	r6, #16
 8014208:	f10a 0218 	add.w	r2, sl, #24
 801420c:	e6d5      	b.n	8013fba <_realloc_r+0x12a>
 801420e:	6933      	ldr	r3, [r6, #16]
 8014210:	f8ca 3018 	str.w	r3, [sl, #24]
 8014214:	6973      	ldr	r3, [r6, #20]
 8014216:	f8ca 301c 	str.w	r3, [sl, #28]
 801421a:	3618      	adds	r6, #24
 801421c:	f10a 0320 	add.w	r3, sl, #32
 8014220:	e789      	b.n	8014136 <_realloc_r+0x2a6>
 8014222:	463b      	mov	r3, r7
 8014224:	e760      	b.n	80140e8 <_realloc_r+0x258>
 8014226:	6932      	ldr	r2, [r6, #16]
 8014228:	f8ca 2018 	str.w	r2, [sl, #24]
 801422c:	6972      	ldr	r2, [r6, #20]
 801422e:	f8ca 201c 	str.w	r2, [sl, #28]
 8014232:	3618      	adds	r6, #24
 8014234:	f10a 0220 	add.w	r2, sl, #32
 8014238:	e6bf      	b.n	8013fba <_realloc_r+0x12a>
 801423a:	4631      	mov	r1, r6
 801423c:	4638      	mov	r0, r7
 801423e:	f8cd c004 	str.w	ip, [sp, #4]
 8014242:	f001 fd3d 	bl	8015cc0 <memmove>
 8014246:	f8dd c004 	ldr.w	ip, [sp, #4]
 801424a:	e753      	b.n	80140f4 <_realloc_r+0x264>
 801424c:	68b3      	ldr	r3, [r6, #8]
 801424e:	f8ca 3010 	str.w	r3, [sl, #16]
 8014252:	68f3      	ldr	r3, [r6, #12]
 8014254:	f8ca 3014 	str.w	r3, [sl, #20]
 8014258:	2a24      	cmp	r2, #36	; 0x24
 801425a:	d003      	beq.n	8014264 <_realloc_r+0x3d4>
 801425c:	3610      	adds	r6, #16
 801425e:	f10a 0318 	add.w	r3, sl, #24
 8014262:	e741      	b.n	80140e8 <_realloc_r+0x258>
 8014264:	6933      	ldr	r3, [r6, #16]
 8014266:	f8ca 3018 	str.w	r3, [sl, #24]
 801426a:	6973      	ldr	r3, [r6, #20]
 801426c:	f8ca 301c 	str.w	r3, [sl, #28]
 8014270:	3618      	adds	r6, #24
 8014272:	f10a 0320 	add.w	r3, sl, #32
 8014276:	e737      	b.n	80140e8 <_realloc_r+0x258>
 8014278:	20000d14 	.word	0x20000d14
 801427c:	00000000 	.word	0x00000000

08014280 <stpcpy>:
 8014280:	ea41 0300 	orr.w	r3, r1, r0
 8014284:	079b      	lsls	r3, r3, #30
 8014286:	b410      	push	{r4}
 8014288:	d114      	bne.n	80142b4 <stpcpy+0x34>
 801428a:	680b      	ldr	r3, [r1, #0]
 801428c:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 8014290:	ea22 0203 	bic.w	r2, r2, r3
 8014294:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8014298:	d10c      	bne.n	80142b4 <stpcpy+0x34>
 801429a:	1d0c      	adds	r4, r1, #4
 801429c:	f840 3b04 	str.w	r3, [r0], #4
 80142a0:	4621      	mov	r1, r4
 80142a2:	f854 3b04 	ldr.w	r3, [r4], #4
 80142a6:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 80142aa:	ea22 0203 	bic.w	r2, r2, r3
 80142ae:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 80142b2:	d0f3      	beq.n	801429c <stpcpy+0x1c>
 80142b4:	4603      	mov	r3, r0
 80142b6:	f811 2b01 	ldrb.w	r2, [r1], #1
 80142ba:	4618      	mov	r0, r3
 80142bc:	f803 2b01 	strb.w	r2, [r3], #1
 80142c0:	2a00      	cmp	r2, #0
 80142c2:	d1f8      	bne.n	80142b6 <stpcpy+0x36>
 80142c4:	f85d 4b04 	ldr.w	r4, [sp], #4
 80142c8:	4770      	bx	lr
 80142ca:	bf00      	nop
 80142cc:	0000      	movs	r0, r0
	...

080142d0 <strlen>:
 80142d0:	f020 0103 	bic.w	r1, r0, #3
 80142d4:	f010 0003 	ands.w	r0, r0, #3
 80142d8:	f1c0 0000 	rsb	r0, r0, #0
 80142dc:	f851 3b04 	ldr.w	r3, [r1], #4
 80142e0:	f100 0c04 	add.w	ip, r0, #4
 80142e4:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 80142e8:	f06f 0200 	mvn.w	r2, #0
 80142ec:	bf1c      	itt	ne
 80142ee:	fa22 f20c 	lsrne.w	r2, r2, ip
 80142f2:	4313      	orrne	r3, r2
 80142f4:	f04f 0c01 	mov.w	ip, #1
 80142f8:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 80142fc:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 8014300:	eba3 020c 	sub.w	r2, r3, ip
 8014304:	ea22 0203 	bic.w	r2, r2, r3
 8014308:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 801430c:	bf04      	itt	eq
 801430e:	f851 3b04 	ldreq.w	r3, [r1], #4
 8014312:	3004      	addeq	r0, #4
 8014314:	d0f4      	beq.n	8014300 <strlen+0x30>
 8014316:	f1c2 0100 	rsb	r1, r2, #0
 801431a:	ea02 0201 	and.w	r2, r2, r1
 801431e:	fab2 f282 	clz	r2, r2
 8014322:	f1c2 021f 	rsb	r2, r2, #31
 8014326:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 801432a:	4770      	bx	lr
 801432c:	0000      	movs	r0, r0
	...

08014330 <strncmp>:
 8014330:	2a00      	cmp	r2, #0
 8014332:	d03e      	beq.n	80143b2 <strncmp+0x82>
 8014334:	ea40 0301 	orr.w	r3, r0, r1
 8014338:	f013 0303 	ands.w	r3, r3, #3
 801433c:	b4f0      	push	{r4, r5, r6, r7}
 801433e:	d125      	bne.n	801438c <strncmp+0x5c>
 8014340:	2a03      	cmp	r2, #3
 8014342:	d923      	bls.n	801438c <strncmp+0x5c>
 8014344:	6804      	ldr	r4, [r0, #0]
 8014346:	680d      	ldr	r5, [r1, #0]
 8014348:	42ac      	cmp	r4, r5
 801434a:	d11f      	bne.n	801438c <strncmp+0x5c>
 801434c:	3a04      	subs	r2, #4
 801434e:	d032      	beq.n	80143b6 <strncmp+0x86>
 8014350:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 8014354:	ea25 0404 	bic.w	r4, r5, r4
 8014358:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 801435c:	d12e      	bne.n	80143bc <strncmp+0x8c>
 801435e:	1d07      	adds	r7, r0, #4
 8014360:	1d0d      	adds	r5, r1, #4
 8014362:	e00d      	b.n	8014380 <strncmp+0x50>
 8014364:	f857 3b04 	ldr.w	r3, [r7], #4
 8014368:	680e      	ldr	r6, [r1, #0]
 801436a:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
 801436e:	42b3      	cmp	r3, r6
 8014370:	ea24 0403 	bic.w	r4, r4, r3
 8014374:	d10a      	bne.n	801438c <strncmp+0x5c>
 8014376:	3a04      	subs	r2, #4
 8014378:	d01d      	beq.n	80143b6 <strncmp+0x86>
 801437a:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 801437e:	d120      	bne.n	80143c2 <strncmp+0x92>
 8014380:	2a03      	cmp	r2, #3
 8014382:	4629      	mov	r1, r5
 8014384:	4638      	mov	r0, r7
 8014386:	f105 0504 	add.w	r5, r5, #4
 801438a:	d8eb      	bhi.n	8014364 <strncmp+0x34>
 801438c:	7803      	ldrb	r3, [r0, #0]
 801438e:	780c      	ldrb	r4, [r1, #0]
 8014390:	42a3      	cmp	r3, r4
 8014392:	f102 32ff 	add.w	r2, r2, #4294967295
 8014396:	d109      	bne.n	80143ac <strncmp+0x7c>
 8014398:	b16a      	cbz	r2, 80143b6 <strncmp+0x86>
 801439a:	b17b      	cbz	r3, 80143bc <strncmp+0x8c>
 801439c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 80143a0:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80143a4:	42a3      	cmp	r3, r4
 80143a6:	f102 32ff 	add.w	r2, r2, #4294967295
 80143aa:	d0f5      	beq.n	8014398 <strncmp+0x68>
 80143ac:	1b18      	subs	r0, r3, r4
 80143ae:	bcf0      	pop	{r4, r5, r6, r7}
 80143b0:	4770      	bx	lr
 80143b2:	4610      	mov	r0, r2
 80143b4:	4770      	bx	lr
 80143b6:	4610      	mov	r0, r2
 80143b8:	bcf0      	pop	{r4, r5, r6, r7}
 80143ba:	4770      	bx	lr
 80143bc:	4618      	mov	r0, r3
 80143be:	bcf0      	pop	{r4, r5, r6, r7}
 80143c0:	4770      	bx	lr
 80143c2:	2000      	movs	r0, #0
 80143c4:	e7f3      	b.n	80143ae <strncmp+0x7e>
 80143c6:	bf00      	nop
	...

080143d0 <__sprint_r.part.0>:
 80143d0:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 80143d2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80143d6:	049c      	lsls	r4, r3, #18
 80143d8:	460f      	mov	r7, r1
 80143da:	4692      	mov	sl, r2
 80143dc:	d52b      	bpl.n	8014436 <__sprint_r.part.0+0x66>
 80143de:	6893      	ldr	r3, [r2, #8]
 80143e0:	6812      	ldr	r2, [r2, #0]
 80143e2:	b333      	cbz	r3, 8014432 <__sprint_r.part.0+0x62>
 80143e4:	4680      	mov	r8, r0
 80143e6:	f102 0908 	add.w	r9, r2, #8
 80143ea:	e919 0060 	ldmdb	r9, {r5, r6}
 80143ee:	08b6      	lsrs	r6, r6, #2
 80143f0:	d017      	beq.n	8014422 <__sprint_r.part.0+0x52>
 80143f2:	3d04      	subs	r5, #4
 80143f4:	2400      	movs	r4, #0
 80143f6:	e001      	b.n	80143fc <__sprint_r.part.0+0x2c>
 80143f8:	42a6      	cmp	r6, r4
 80143fa:	d010      	beq.n	801441e <__sprint_r.part.0+0x4e>
 80143fc:	4640      	mov	r0, r8
 80143fe:	f855 1f04 	ldr.w	r1, [r5, #4]!
 8014402:	463a      	mov	r2, r7
 8014404:	f001 f83c 	bl	8015480 <_fputwc_r>
 8014408:	1c43      	adds	r3, r0, #1
 801440a:	f104 0401 	add.w	r4, r4, #1
 801440e:	d1f3      	bne.n	80143f8 <__sprint_r.part.0+0x28>
 8014410:	2300      	movs	r3, #0
 8014412:	f8ca 3008 	str.w	r3, [sl, #8]
 8014416:	f8ca 3004 	str.w	r3, [sl, #4]
 801441a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801441e:	f8da 3008 	ldr.w	r3, [sl, #8]
 8014422:	eba3 0386 	sub.w	r3, r3, r6, lsl #2
 8014426:	f8ca 3008 	str.w	r3, [sl, #8]
 801442a:	f109 0908 	add.w	r9, r9, #8
 801442e:	2b00      	cmp	r3, #0
 8014430:	d1db      	bne.n	80143ea <__sprint_r.part.0+0x1a>
 8014432:	2000      	movs	r0, #0
 8014434:	e7ec      	b.n	8014410 <__sprint_r.part.0+0x40>
 8014436:	f001 f9b3 	bl	80157a0 <__sfvwrite_r>
 801443a:	2300      	movs	r3, #0
 801443c:	f8ca 3008 	str.w	r3, [sl, #8]
 8014440:	f8ca 3004 	str.w	r3, [sl, #4]
 8014444:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

08014450 <_vfiprintf_r>:
 8014450:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014454:	b0ab      	sub	sp, #172	; 0xac
 8014456:	461c      	mov	r4, r3
 8014458:	9100      	str	r1, [sp, #0]
 801445a:	4693      	mov	fp, r2
 801445c:	9304      	str	r3, [sp, #16]
 801445e:	9001      	str	r0, [sp, #4]
 8014460:	b118      	cbz	r0, 801446a <_vfiprintf_r+0x1a>
 8014462:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8014464:	2b00      	cmp	r3, #0
 8014466:	f000 80e1 	beq.w	801462c <_vfiprintf_r+0x1dc>
 801446a:	9b00      	ldr	r3, [sp, #0]
 801446c:	8999      	ldrh	r1, [r3, #12]
 801446e:	b28a      	uxth	r2, r1
 8014470:	0490      	lsls	r0, r2, #18
 8014472:	d408      	bmi.n	8014486 <_vfiprintf_r+0x36>
 8014474:	4618      	mov	r0, r3
 8014476:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8014478:	f441 5200 	orr.w	r2, r1, #8192	; 0x2000
 801447c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8014480:	8182      	strh	r2, [r0, #12]
 8014482:	6643      	str	r3, [r0, #100]	; 0x64
 8014484:	b292      	uxth	r2, r2
 8014486:	0711      	lsls	r1, r2, #28
 8014488:	f140 80b0 	bpl.w	80145ec <_vfiprintf_r+0x19c>
 801448c:	9b00      	ldr	r3, [sp, #0]
 801448e:	691b      	ldr	r3, [r3, #16]
 8014490:	2b00      	cmp	r3, #0
 8014492:	f000 80ab 	beq.w	80145ec <_vfiprintf_r+0x19c>
 8014496:	f002 021a 	and.w	r2, r2, #26
 801449a:	2a0a      	cmp	r2, #10
 801449c:	f000 80b2 	beq.w	8014604 <_vfiprintf_r+0x1b4>
 80144a0:	2300      	movs	r3, #0
 80144a2:	f10d 0a68 	add.w	sl, sp, #104	; 0x68
 80144a6:	9309      	str	r3, [sp, #36]	; 0x24
 80144a8:	930f      	str	r3, [sp, #60]	; 0x3c
 80144aa:	930e      	str	r3, [sp, #56]	; 0x38
 80144ac:	9302      	str	r3, [sp, #8]
 80144ae:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 80144b2:	4654      	mov	r4, sl
 80144b4:	f89b 3000 	ldrb.w	r3, [fp]
 80144b8:	2b00      	cmp	r3, #0
 80144ba:	f000 849d 	beq.w	8014df8 <_vfiprintf_r+0x9a8>
 80144be:	2b25      	cmp	r3, #37	; 0x25
 80144c0:	f000 849a 	beq.w	8014df8 <_vfiprintf_r+0x9a8>
 80144c4:	465a      	mov	r2, fp
 80144c6:	e001      	b.n	80144cc <_vfiprintf_r+0x7c>
 80144c8:	2b25      	cmp	r3, #37	; 0x25
 80144ca:	d003      	beq.n	80144d4 <_vfiprintf_r+0x84>
 80144cc:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80144d0:	2b00      	cmp	r3, #0
 80144d2:	d1f9      	bne.n	80144c8 <_vfiprintf_r+0x78>
 80144d4:	ebcb 0602 	rsb	r6, fp, r2
 80144d8:	4615      	mov	r5, r2
 80144da:	b196      	cbz	r6, 8014502 <_vfiprintf_r+0xb2>
 80144dc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80144de:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80144e0:	f8c4 b000 	str.w	fp, [r4]
 80144e4:	3301      	adds	r3, #1
 80144e6:	4432      	add	r2, r6
 80144e8:	2b07      	cmp	r3, #7
 80144ea:	6066      	str	r6, [r4, #4]
 80144ec:	920f      	str	r2, [sp, #60]	; 0x3c
 80144ee:	930e      	str	r3, [sp, #56]	; 0x38
 80144f0:	dd77      	ble.n	80145e2 <_vfiprintf_r+0x192>
 80144f2:	2a00      	cmp	r2, #0
 80144f4:	f040 84a9 	bne.w	8014e4a <_vfiprintf_r+0x9fa>
 80144f8:	9b02      	ldr	r3, [sp, #8]
 80144fa:	920e      	str	r2, [sp, #56]	; 0x38
 80144fc:	4433      	add	r3, r6
 80144fe:	4654      	mov	r4, sl
 8014500:	9302      	str	r3, [sp, #8]
 8014502:	782b      	ldrb	r3, [r5, #0]
 8014504:	2b00      	cmp	r3, #0
 8014506:	f000 8359 	beq.w	8014bbc <_vfiprintf_r+0x76c>
 801450a:	2100      	movs	r1, #0
 801450c:	f04f 3cff 	mov.w	ip, #4294967295
 8014510:	1c68      	adds	r0, r5, #1
 8014512:	786b      	ldrb	r3, [r5, #1]
 8014514:	f88d 102f 	strb.w	r1, [sp, #47]	; 0x2f
 8014518:	4688      	mov	r8, r1
 801451a:	460d      	mov	r5, r1
 801451c:	4666      	mov	r6, ip
 801451e:	f100 0b01 	add.w	fp, r0, #1
 8014522:	f1a3 0220 	sub.w	r2, r3, #32
 8014526:	2a58      	cmp	r2, #88	; 0x58
 8014528:	f200 82a7 	bhi.w	8014a7a <_vfiprintf_r+0x62a>
 801452c:	e8df f012 	tbh	[pc, r2, lsl #1]
 8014530:	02a50297 	.word	0x02a50297
 8014534:	029f02a5 	.word	0x029f02a5
 8014538:	02a502a5 	.word	0x02a502a5
 801453c:	02a502a5 	.word	0x02a502a5
 8014540:	02a502a5 	.word	0x02a502a5
 8014544:	025f0252 	.word	0x025f0252
 8014548:	010c02a5 	.word	0x010c02a5
 801454c:	02a5026a 	.word	0x02a5026a
 8014550:	012e0128 	.word	0x012e0128
 8014554:	012e012e 	.word	0x012e012e
 8014558:	012e012e 	.word	0x012e012e
 801455c:	012e012e 	.word	0x012e012e
 8014560:	012e012e 	.word	0x012e012e
 8014564:	02a502a5 	.word	0x02a502a5
 8014568:	02a502a5 	.word	0x02a502a5
 801456c:	02a502a5 	.word	0x02a502a5
 8014570:	02a502a5 	.word	0x02a502a5
 8014574:	02a502a5 	.word	0x02a502a5
 8014578:	02a5013c 	.word	0x02a5013c
 801457c:	02a502a5 	.word	0x02a502a5
 8014580:	02a502a5 	.word	0x02a502a5
 8014584:	02a502a5 	.word	0x02a502a5
 8014588:	02a502a5 	.word	0x02a502a5
 801458c:	017302a5 	.word	0x017302a5
 8014590:	02a502a5 	.word	0x02a502a5
 8014594:	02a502a5 	.word	0x02a502a5
 8014598:	018a02a5 	.word	0x018a02a5
 801459c:	02a502a5 	.word	0x02a502a5
 80145a0:	02a501a2 	.word	0x02a501a2
 80145a4:	02a502a5 	.word	0x02a502a5
 80145a8:	02a502a5 	.word	0x02a502a5
 80145ac:	02a502a5 	.word	0x02a502a5
 80145b0:	02a502a5 	.word	0x02a502a5
 80145b4:	01c602a5 	.word	0x01c602a5
 80145b8:	02a501d8 	.word	0x02a501d8
 80145bc:	02a502a5 	.word	0x02a502a5
 80145c0:	01d80122 	.word	0x01d80122
 80145c4:	02a502a5 	.word	0x02a502a5
 80145c8:	02a50249 	.word	0x02a50249
 80145cc:	01120286 	.word	0x01120286
 80145d0:	020501f1 	.word	0x020501f1
 80145d4:	020b02a5 	.word	0x020b02a5
 80145d8:	008102a5 	.word	0x008102a5
 80145dc:	02a502a5 	.word	0x02a502a5
 80145e0:	0230      	.short	0x0230
 80145e2:	3408      	adds	r4, #8
 80145e4:	9b02      	ldr	r3, [sp, #8]
 80145e6:	4433      	add	r3, r6
 80145e8:	9302      	str	r3, [sp, #8]
 80145ea:	e78a      	b.n	8014502 <_vfiprintf_r+0xb2>
 80145ec:	9801      	ldr	r0, [sp, #4]
 80145ee:	9900      	ldr	r1, [sp, #0]
 80145f0:	f000 fd76 	bl	80150e0 <__swsetup_r>
 80145f4:	b9a8      	cbnz	r0, 8014622 <_vfiprintf_r+0x1d2>
 80145f6:	9b00      	ldr	r3, [sp, #0]
 80145f8:	899a      	ldrh	r2, [r3, #12]
 80145fa:	f002 021a 	and.w	r2, r2, #26
 80145fe:	2a0a      	cmp	r2, #10
 8014600:	f47f af4e 	bne.w	80144a0 <_vfiprintf_r+0x50>
 8014604:	9b00      	ldr	r3, [sp, #0]
 8014606:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 801460a:	2b00      	cmp	r3, #0
 801460c:	f6ff af48 	blt.w	80144a0 <_vfiprintf_r+0x50>
 8014610:	9801      	ldr	r0, [sp, #4]
 8014612:	9900      	ldr	r1, [sp, #0]
 8014614:	465a      	mov	r2, fp
 8014616:	4623      	mov	r3, r4
 8014618:	f000 fd22 	bl	8015060 <__sbprintf>
 801461c:	b02b      	add	sp, #172	; 0xac
 801461e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8014622:	f04f 30ff 	mov.w	r0, #4294967295
 8014626:	b02b      	add	sp, #172	; 0xac
 8014628:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801462c:	f000 ff10 	bl	8015450 <__sinit>
 8014630:	e71b      	b.n	801446a <_vfiprintf_r+0x1a>
 8014632:	f018 0f20 	tst.w	r8, #32
 8014636:	9503      	str	r5, [sp, #12]
 8014638:	46b4      	mov	ip, r6
 801463a:	f000 810b 	beq.w	8014854 <_vfiprintf_r+0x404>
 801463e:	9b04      	ldr	r3, [sp, #16]
 8014640:	3307      	adds	r3, #7
 8014642:	f023 0307 	bic.w	r3, r3, #7
 8014646:	f103 0208 	add.w	r2, r3, #8
 801464a:	e9d3 6700 	ldrd	r6, r7, [r3]
 801464e:	9204      	str	r2, [sp, #16]
 8014650:	2301      	movs	r3, #1
 8014652:	2200      	movs	r2, #0
 8014654:	f88d 202f 	strb.w	r2, [sp, #47]	; 0x2f
 8014658:	46e1      	mov	r9, ip
 801465a:	4615      	mov	r5, r2
 801465c:	f1bc 0f00 	cmp.w	ip, #0
 8014660:	bfa8      	it	ge
 8014662:	f028 0880 	bicge.w	r8, r8, #128	; 0x80
 8014666:	ea56 0207 	orrs.w	r2, r6, r7
 801466a:	f040 80c4 	bne.w	80147f6 <_vfiprintf_r+0x3a6>
 801466e:	f1bc 0f00 	cmp.w	ip, #0
 8014672:	f000 837d 	beq.w	8014d70 <_vfiprintf_r+0x920>
 8014676:	2b01      	cmp	r3, #1
 8014678:	f000 80c5 	beq.w	8014806 <_vfiprintf_r+0x3b6>
 801467c:	2b02      	cmp	r3, #2
 801467e:	f000 8383 	beq.w	8014d88 <_vfiprintf_r+0x938>
 8014682:	4651      	mov	r1, sl
 8014684:	08f2      	lsrs	r2, r6, #3
 8014686:	ea42 7247 	orr.w	r2, r2, r7, lsl #29
 801468a:	08f8      	lsrs	r0, r7, #3
 801468c:	f006 0307 	and.w	r3, r6, #7
 8014690:	4607      	mov	r7, r0
 8014692:	4616      	mov	r6, r2
 8014694:	3330      	adds	r3, #48	; 0x30
 8014696:	ea56 0207 	orrs.w	r2, r6, r7
 801469a:	f801 3d01 	strb.w	r3, [r1, #-1]!
 801469e:	d1f1      	bne.n	8014684 <_vfiprintf_r+0x234>
 80146a0:	f018 0f01 	tst.w	r8, #1
 80146a4:	9107      	str	r1, [sp, #28]
 80146a6:	f040 83f9 	bne.w	8014e9c <_vfiprintf_r+0xa4c>
 80146aa:	ebc1 090a 	rsb	r9, r1, sl
 80146ae:	45e1      	cmp	r9, ip
 80146b0:	464e      	mov	r6, r9
 80146b2:	bfb8      	it	lt
 80146b4:	4666      	movlt	r6, ip
 80146b6:	b105      	cbz	r5, 80146ba <_vfiprintf_r+0x26a>
 80146b8:	3601      	adds	r6, #1
 80146ba:	f018 0302 	ands.w	r3, r8, #2
 80146be:	9305      	str	r3, [sp, #20]
 80146c0:	bf18      	it	ne
 80146c2:	3602      	addne	r6, #2
 80146c4:	f018 0384 	ands.w	r3, r8, #132	; 0x84
 80146c8:	9306      	str	r3, [sp, #24]
 80146ca:	f040 81f6 	bne.w	8014aba <_vfiprintf_r+0x66a>
 80146ce:	9b03      	ldr	r3, [sp, #12]
 80146d0:	1b9d      	subs	r5, r3, r6
 80146d2:	2d00      	cmp	r5, #0
 80146d4:	f340 81f1 	ble.w	8014aba <_vfiprintf_r+0x66a>
 80146d8:	2d10      	cmp	r5, #16
 80146da:	f340 8489 	ble.w	8014ff0 <_vfiprintf_r+0xba0>
 80146de:	f8dd e038 	ldr.w	lr, [sp, #56]	; 0x38
 80146e2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80146e4:	4fc4      	ldr	r7, [pc, #784]	; (80149f8 <_vfiprintf_r+0x5a8>)
 80146e6:	4620      	mov	r0, r4
 80146e8:	2310      	movs	r3, #16
 80146ea:	4664      	mov	r4, ip
 80146ec:	4671      	mov	r1, lr
 80146ee:	4684      	mov	ip, r0
 80146f0:	e007      	b.n	8014702 <_vfiprintf_r+0x2b2>
 80146f2:	f101 0e02 	add.w	lr, r1, #2
 80146f6:	f10c 0c08 	add.w	ip, ip, #8
 80146fa:	4601      	mov	r1, r0
 80146fc:	3d10      	subs	r5, #16
 80146fe:	2d10      	cmp	r5, #16
 8014700:	dd13      	ble.n	801472a <_vfiprintf_r+0x2da>
 8014702:	1c48      	adds	r0, r1, #1
 8014704:	3210      	adds	r2, #16
 8014706:	2807      	cmp	r0, #7
 8014708:	920f      	str	r2, [sp, #60]	; 0x3c
 801470a:	f8cc 7000 	str.w	r7, [ip]
 801470e:	f8cc 3004 	str.w	r3, [ip, #4]
 8014712:	900e      	str	r0, [sp, #56]	; 0x38
 8014714:	dded      	ble.n	80146f2 <_vfiprintf_r+0x2a2>
 8014716:	2a00      	cmp	r2, #0
 8014718:	f040 81bf 	bne.w	8014a9a <_vfiprintf_r+0x64a>
 801471c:	3d10      	subs	r5, #16
 801471e:	2d10      	cmp	r5, #16
 8014720:	4611      	mov	r1, r2
 8014722:	f04f 0e01 	mov.w	lr, #1
 8014726:	46d4      	mov	ip, sl
 8014728:	dceb      	bgt.n	8014702 <_vfiprintf_r+0x2b2>
 801472a:	4663      	mov	r3, ip
 801472c:	4671      	mov	r1, lr
 801472e:	46a4      	mov	ip, r4
 8014730:	461c      	mov	r4, r3
 8014732:	442a      	add	r2, r5
 8014734:	2907      	cmp	r1, #7
 8014736:	920f      	str	r2, [sp, #60]	; 0x3c
 8014738:	6027      	str	r7, [r4, #0]
 801473a:	6065      	str	r5, [r4, #4]
 801473c:	910e      	str	r1, [sp, #56]	; 0x38
 801473e:	f300 8343 	bgt.w	8014dc8 <_vfiprintf_r+0x978>
 8014742:	3408      	adds	r4, #8
 8014744:	1c48      	adds	r0, r1, #1
 8014746:	e1bb      	b.n	8014ac0 <_vfiprintf_r+0x670>
 8014748:	4658      	mov	r0, fp
 801474a:	f048 0804 	orr.w	r8, r8, #4
 801474e:	f89b 3000 	ldrb.w	r3, [fp]
 8014752:	e6e4      	b.n	801451e <_vfiprintf_r+0xce>
 8014754:	f018 0320 	ands.w	r3, r8, #32
 8014758:	9503      	str	r5, [sp, #12]
 801475a:	46b4      	mov	ip, r6
 801475c:	d062      	beq.n	8014824 <_vfiprintf_r+0x3d4>
 801475e:	9b04      	ldr	r3, [sp, #16]
 8014760:	3307      	adds	r3, #7
 8014762:	f023 0307 	bic.w	r3, r3, #7
 8014766:	f103 0208 	add.w	r2, r3, #8
 801476a:	e9d3 6700 	ldrd	r6, r7, [r3]
 801476e:	9204      	str	r2, [sp, #16]
 8014770:	2300      	movs	r3, #0
 8014772:	e76e      	b.n	8014652 <_vfiprintf_r+0x202>
 8014774:	f048 0840 	orr.w	r8, r8, #64	; 0x40
 8014778:	f89b 3000 	ldrb.w	r3, [fp]
 801477c:	4658      	mov	r0, fp
 801477e:	e6ce      	b.n	801451e <_vfiprintf_r+0xce>
 8014780:	f048 0880 	orr.w	r8, r8, #128	; 0x80
 8014784:	f89b 3000 	ldrb.w	r3, [fp]
 8014788:	4658      	mov	r0, fp
 801478a:	e6c8      	b.n	801451e <_vfiprintf_r+0xce>
 801478c:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8014790:	2500      	movs	r5, #0
 8014792:	f81b 3b01 	ldrb.w	r3, [fp], #1
 8014796:	eb05 0585 	add.w	r5, r5, r5, lsl #2
 801479a:	eb02 0545 	add.w	r5, r2, r5, lsl #1
 801479e:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 80147a2:	2a09      	cmp	r2, #9
 80147a4:	d9f5      	bls.n	8014792 <_vfiprintf_r+0x342>
 80147a6:	e6bc      	b.n	8014522 <_vfiprintf_r+0xd2>
 80147a8:	f048 0810 	orr.w	r8, r8, #16
 80147ac:	f018 0f20 	tst.w	r8, #32
 80147b0:	9503      	str	r5, [sp, #12]
 80147b2:	46b4      	mov	ip, r6
 80147b4:	f88d 102f 	strb.w	r1, [sp, #47]	; 0x2f
 80147b8:	f000 809a 	beq.w	80148f0 <_vfiprintf_r+0x4a0>
 80147bc:	9904      	ldr	r1, [sp, #16]
 80147be:	3107      	adds	r1, #7
 80147c0:	f021 0107 	bic.w	r1, r1, #7
 80147c4:	e9d1 2300 	ldrd	r2, r3, [r1]
 80147c8:	3108      	adds	r1, #8
 80147ca:	9104      	str	r1, [sp, #16]
 80147cc:	4616      	mov	r6, r2
 80147ce:	461f      	mov	r7, r3
 80147d0:	2a00      	cmp	r2, #0
 80147d2:	f173 0300 	sbcs.w	r3, r3, #0
 80147d6:	f2c0 83a3 	blt.w	8014f20 <_vfiprintf_r+0xad0>
 80147da:	f1bc 0f00 	cmp.w	ip, #0
 80147de:	bfa8      	it	ge
 80147e0:	f028 0880 	bicge.w	r8, r8, #128	; 0x80
 80147e4:	ea56 0207 	orrs.w	r2, r6, r7
 80147e8:	f89d 502f 	ldrb.w	r5, [sp, #47]	; 0x2f
 80147ec:	46e1      	mov	r9, ip
 80147ee:	f04f 0301 	mov.w	r3, #1
 80147f2:	f43f af3c 	beq.w	801466e <_vfiprintf_r+0x21e>
 80147f6:	2b01      	cmp	r3, #1
 80147f8:	f47f af40 	bne.w	801467c <_vfiprintf_r+0x22c>
 80147fc:	2f00      	cmp	r7, #0
 80147fe:	bf08      	it	eq
 8014800:	2e0a      	cmpeq	r6, #10
 8014802:	f080 8331 	bcs.w	8014e68 <_vfiprintf_r+0xa18>
 8014806:	ab2a      	add	r3, sp, #168	; 0xa8
 8014808:	3630      	adds	r6, #48	; 0x30
 801480a:	f803 6d41 	strb.w	r6, [r3, #-65]!
 801480e:	ebc3 090a 	rsb	r9, r3, sl
 8014812:	9307      	str	r3, [sp, #28]
 8014814:	e74b      	b.n	80146ae <_vfiprintf_r+0x25e>
 8014816:	f048 0810 	orr.w	r8, r8, #16
 801481a:	f018 0320 	ands.w	r3, r8, #32
 801481e:	9503      	str	r5, [sp, #12]
 8014820:	46b4      	mov	ip, r6
 8014822:	d19c      	bne.n	801475e <_vfiprintf_r+0x30e>
 8014824:	f018 0210 	ands.w	r2, r8, #16
 8014828:	f040 82f4 	bne.w	8014e14 <_vfiprintf_r+0x9c4>
 801482c:	f018 0340 	ands.w	r3, r8, #64	; 0x40
 8014830:	f000 82f0 	beq.w	8014e14 <_vfiprintf_r+0x9c4>
 8014834:	9904      	ldr	r1, [sp, #16]
 8014836:	4613      	mov	r3, r2
 8014838:	460a      	mov	r2, r1
 801483a:	3204      	adds	r2, #4
 801483c:	880e      	ldrh	r6, [r1, #0]
 801483e:	9204      	str	r2, [sp, #16]
 8014840:	2700      	movs	r7, #0
 8014842:	e706      	b.n	8014652 <_vfiprintf_r+0x202>
 8014844:	f048 0810 	orr.w	r8, r8, #16
 8014848:	f018 0f20 	tst.w	r8, #32
 801484c:	9503      	str	r5, [sp, #12]
 801484e:	46b4      	mov	ip, r6
 8014850:	f47f aef5 	bne.w	801463e <_vfiprintf_r+0x1ee>
 8014854:	9a04      	ldr	r2, [sp, #16]
 8014856:	f018 0f10 	tst.w	r8, #16
 801485a:	4613      	mov	r3, r2
 801485c:	f040 82e1 	bne.w	8014e22 <_vfiprintf_r+0x9d2>
 8014860:	f018 0f40 	tst.w	r8, #64	; 0x40
 8014864:	f000 82dd 	beq.w	8014e22 <_vfiprintf_r+0x9d2>
 8014868:	8816      	ldrh	r6, [r2, #0]
 801486a:	3204      	adds	r2, #4
 801486c:	2700      	movs	r7, #0
 801486e:	2301      	movs	r3, #1
 8014870:	9204      	str	r2, [sp, #16]
 8014872:	e6ee      	b.n	8014652 <_vfiprintf_r+0x202>
 8014874:	4a61      	ldr	r2, [pc, #388]	; (80149fc <_vfiprintf_r+0x5ac>)
 8014876:	9503      	str	r5, [sp, #12]
 8014878:	f018 0f20 	tst.w	r8, #32
 801487c:	46b4      	mov	ip, r6
 801487e:	f88d 102f 	strb.w	r1, [sp, #47]	; 0x2f
 8014882:	9209      	str	r2, [sp, #36]	; 0x24
 8014884:	f000 808e 	beq.w	80149a4 <_vfiprintf_r+0x554>
 8014888:	9a04      	ldr	r2, [sp, #16]
 801488a:	3207      	adds	r2, #7
 801488c:	f022 0207 	bic.w	r2, r2, #7
 8014890:	e9d2 6700 	ldrd	r6, r7, [r2]
 8014894:	f102 0108 	add.w	r1, r2, #8
 8014898:	9104      	str	r1, [sp, #16]
 801489a:	f018 0f01 	tst.w	r8, #1
 801489e:	f000 828c 	beq.w	8014dba <_vfiprintf_r+0x96a>
 80148a2:	ea56 0207 	orrs.w	r2, r6, r7
 80148a6:	f000 8288 	beq.w	8014dba <_vfiprintf_r+0x96a>
 80148aa:	2230      	movs	r2, #48	; 0x30
 80148ac:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
 80148b0:	f048 0802 	orr.w	r8, r8, #2
 80148b4:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
 80148b8:	2302      	movs	r3, #2
 80148ba:	e6ca      	b.n	8014652 <_vfiprintf_r+0x202>
 80148bc:	9a04      	ldr	r2, [sp, #16]
 80148be:	9503      	str	r5, [sp, #12]
 80148c0:	6813      	ldr	r3, [r2, #0]
 80148c2:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
 80148c6:	4613      	mov	r3, r2
 80148c8:	3304      	adds	r3, #4
 80148ca:	2601      	movs	r6, #1
 80148cc:	2100      	movs	r1, #0
 80148ce:	9304      	str	r3, [sp, #16]
 80148d0:	ab10      	add	r3, sp, #64	; 0x40
 80148d2:	f88d 102f 	strb.w	r1, [sp, #47]	; 0x2f
 80148d6:	46b1      	mov	r9, r6
 80148d8:	9307      	str	r3, [sp, #28]
 80148da:	f04f 0c00 	mov.w	ip, #0
 80148de:	e6ec      	b.n	80146ba <_vfiprintf_r+0x26a>
 80148e0:	f018 0f20 	tst.w	r8, #32
 80148e4:	9503      	str	r5, [sp, #12]
 80148e6:	46b4      	mov	ip, r6
 80148e8:	f88d 102f 	strb.w	r1, [sp, #47]	; 0x2f
 80148ec:	f47f af66 	bne.w	80147bc <_vfiprintf_r+0x36c>
 80148f0:	f018 0f10 	tst.w	r8, #16
 80148f4:	f040 82a0 	bne.w	8014e38 <_vfiprintf_r+0x9e8>
 80148f8:	f018 0f40 	tst.w	r8, #64	; 0x40
 80148fc:	f000 829c 	beq.w	8014e38 <_vfiprintf_r+0x9e8>
 8014900:	9904      	ldr	r1, [sp, #16]
 8014902:	f9b1 6000 	ldrsh.w	r6, [r1]
 8014906:	3104      	adds	r1, #4
 8014908:	17f7      	asrs	r7, r6, #31
 801490a:	4632      	mov	r2, r6
 801490c:	463b      	mov	r3, r7
 801490e:	9104      	str	r1, [sp, #16]
 8014910:	e75e      	b.n	80147d0 <_vfiprintf_r+0x380>
 8014912:	9904      	ldr	r1, [sp, #16]
 8014914:	9503      	str	r5, [sp, #12]
 8014916:	2330      	movs	r3, #48	; 0x30
 8014918:	460a      	mov	r2, r1
 801491a:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
 801491e:	2378      	movs	r3, #120	; 0x78
 8014920:	3204      	adds	r2, #4
 8014922:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
 8014926:	4b36      	ldr	r3, [pc, #216]	; (8014a00 <_vfiprintf_r+0x5b0>)
 8014928:	9309      	str	r3, [sp, #36]	; 0x24
 801492a:	46b4      	mov	ip, r6
 801492c:	f048 0802 	orr.w	r8, r8, #2
 8014930:	680e      	ldr	r6, [r1, #0]
 8014932:	9204      	str	r2, [sp, #16]
 8014934:	2700      	movs	r7, #0
 8014936:	2302      	movs	r3, #2
 8014938:	e68b      	b.n	8014652 <_vfiprintf_r+0x202>
 801493a:	f048 0820 	orr.w	r8, r8, #32
 801493e:	f89b 3000 	ldrb.w	r3, [fp]
 8014942:	4658      	mov	r0, fp
 8014944:	e5eb      	b.n	801451e <_vfiprintf_r+0xce>
 8014946:	9a04      	ldr	r2, [sp, #16]
 8014948:	9503      	str	r5, [sp, #12]
 801494a:	6813      	ldr	r3, [r2, #0]
 801494c:	9307      	str	r3, [sp, #28]
 801494e:	2100      	movs	r1, #0
 8014950:	46b4      	mov	ip, r6
 8014952:	f88d 102f 	strb.w	r1, [sp, #47]	; 0x2f
 8014956:	1d16      	adds	r6, r2, #4
 8014958:	2b00      	cmp	r3, #0
 801495a:	f000 834f 	beq.w	8014ffc <_vfiprintf_r+0xbac>
 801495e:	f1bc 0f00 	cmp.w	ip, #0
 8014962:	f2c0 8329 	blt.w	8014fb8 <_vfiprintf_r+0xb68>
 8014966:	9d07      	ldr	r5, [sp, #28]
 8014968:	f8cd c010 	str.w	ip, [sp, #16]
 801496c:	4662      	mov	r2, ip
 801496e:	4628      	mov	r0, r5
 8014970:	2100      	movs	r1, #0
 8014972:	f001 f955 	bl	8015c20 <memchr>
 8014976:	f8dd c010 	ldr.w	ip, [sp, #16]
 801497a:	2800      	cmp	r0, #0
 801497c:	f000 834f 	beq.w	801501e <_vfiprintf_r+0xbce>
 8014980:	ebc5 0900 	rsb	r9, r5, r0
 8014984:	9604      	str	r6, [sp, #16]
 8014986:	f89d 502f 	ldrb.w	r5, [sp, #47]	; 0x2f
 801498a:	f04f 0c00 	mov.w	ip, #0
 801498e:	e68e      	b.n	80146ae <_vfiprintf_r+0x25e>
 8014990:	4a1b      	ldr	r2, [pc, #108]	; (8014a00 <_vfiprintf_r+0x5b0>)
 8014992:	9503      	str	r5, [sp, #12]
 8014994:	f018 0f20 	tst.w	r8, #32
 8014998:	46b4      	mov	ip, r6
 801499a:	9209      	str	r2, [sp, #36]	; 0x24
 801499c:	f88d 102f 	strb.w	r1, [sp, #47]	; 0x2f
 80149a0:	f47f af72 	bne.w	8014888 <_vfiprintf_r+0x438>
 80149a4:	9904      	ldr	r1, [sp, #16]
 80149a6:	f018 0f10 	tst.w	r8, #16
 80149aa:	460a      	mov	r2, r1
 80149ac:	f040 823f 	bne.w	8014e2e <_vfiprintf_r+0x9de>
 80149b0:	f018 0f40 	tst.w	r8, #64	; 0x40
 80149b4:	f000 823b 	beq.w	8014e2e <_vfiprintf_r+0x9de>
 80149b8:	3204      	adds	r2, #4
 80149ba:	880e      	ldrh	r6, [r1, #0]
 80149bc:	9204      	str	r2, [sp, #16]
 80149be:	2700      	movs	r7, #0
 80149c0:	e76b      	b.n	801489a <_vfiprintf_r+0x44a>
 80149c2:	f89b 3000 	ldrb.w	r3, [fp]
 80149c6:	2b6c      	cmp	r3, #108	; 0x6c
 80149c8:	f000 82e9 	beq.w	8014f9e <_vfiprintf_r+0xb4e>
 80149cc:	f048 0810 	orr.w	r8, r8, #16
 80149d0:	4658      	mov	r0, fp
 80149d2:	e5a4      	b.n	801451e <_vfiprintf_r+0xce>
 80149d4:	9a04      	ldr	r2, [sp, #16]
 80149d6:	6815      	ldr	r5, [r2, #0]
 80149d8:	4613      	mov	r3, r2
 80149da:	2d00      	cmp	r5, #0
 80149dc:	f103 0304 	add.w	r3, r3, #4
 80149e0:	f2c0 82e5 	blt.w	8014fae <_vfiprintf_r+0xb5e>
 80149e4:	9304      	str	r3, [sp, #16]
 80149e6:	f89b 3000 	ldrb.w	r3, [fp]
 80149ea:	4658      	mov	r0, fp
 80149ec:	e597      	b.n	801451e <_vfiprintf_r+0xce>
 80149ee:	f89b 3000 	ldrb.w	r3, [fp]
 80149f2:	4658      	mov	r0, fp
 80149f4:	212b      	movs	r1, #43	; 0x2b
 80149f6:	e592      	b.n	801451e <_vfiprintf_r+0xce>
 80149f8:	0801ce00 	.word	0x0801ce00
 80149fc:	0801ce10 	.word	0x0801ce10
 8014a00:	0801ce24 	.word	0x0801ce24
 8014a04:	f89b 3000 	ldrb.w	r3, [fp]
 8014a08:	2b2a      	cmp	r3, #42	; 0x2a
 8014a0a:	f10b 0001 	add.w	r0, fp, #1
 8014a0e:	f000 830f 	beq.w	8015030 <_vfiprintf_r+0xbe0>
 8014a12:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8014a16:	2a09      	cmp	r2, #9
 8014a18:	4683      	mov	fp, r0
 8014a1a:	f04f 0600 	mov.w	r6, #0
 8014a1e:	f63f ad80 	bhi.w	8014522 <_vfiprintf_r+0xd2>
 8014a22:	f81b 3b01 	ldrb.w	r3, [fp], #1
 8014a26:	eb06 0686 	add.w	r6, r6, r6, lsl #2
 8014a2a:	eb02 0646 	add.w	r6, r2, r6, lsl #1
 8014a2e:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8014a32:	2a09      	cmp	r2, #9
 8014a34:	d9f5      	bls.n	8014a22 <_vfiprintf_r+0x5d2>
 8014a36:	ea46 76e6 	orr.w	r6, r6, r6, asr #31
 8014a3a:	e572      	b.n	8014522 <_vfiprintf_r+0xd2>
 8014a3c:	f018 0f20 	tst.w	r8, #32
 8014a40:	f88d 102f 	strb.w	r1, [sp, #47]	; 0x2f
 8014a44:	f000 8283 	beq.w	8014f4e <_vfiprintf_r+0xafe>
 8014a48:	9a04      	ldr	r2, [sp, #16]
 8014a4a:	9902      	ldr	r1, [sp, #8]
 8014a4c:	6813      	ldr	r3, [r2, #0]
 8014a4e:	17cf      	asrs	r7, r1, #31
 8014a50:	4608      	mov	r0, r1
 8014a52:	3204      	adds	r2, #4
 8014a54:	4639      	mov	r1, r7
 8014a56:	9204      	str	r2, [sp, #16]
 8014a58:	e9c3 0100 	strd	r0, r1, [r3]
 8014a5c:	e52a      	b.n	80144b4 <_vfiprintf_r+0x64>
 8014a5e:	4658      	mov	r0, fp
 8014a60:	f89b 3000 	ldrb.w	r3, [fp]
 8014a64:	2900      	cmp	r1, #0
 8014a66:	f47f ad5a 	bne.w	801451e <_vfiprintf_r+0xce>
 8014a6a:	2120      	movs	r1, #32
 8014a6c:	e557      	b.n	801451e <_vfiprintf_r+0xce>
 8014a6e:	f048 0801 	orr.w	r8, r8, #1
 8014a72:	4658      	mov	r0, fp
 8014a74:	f89b 3000 	ldrb.w	r3, [fp]
 8014a78:	e551      	b.n	801451e <_vfiprintf_r+0xce>
 8014a7a:	9503      	str	r5, [sp, #12]
 8014a7c:	f88d 102f 	strb.w	r1, [sp, #47]	; 0x2f
 8014a80:	2b00      	cmp	r3, #0
 8014a82:	f000 809b 	beq.w	8014bbc <_vfiprintf_r+0x76c>
 8014a86:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
 8014a8a:	2300      	movs	r3, #0
 8014a8c:	2601      	movs	r6, #1
 8014a8e:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
 8014a92:	ab10      	add	r3, sp, #64	; 0x40
 8014a94:	46b1      	mov	r9, r6
 8014a96:	9307      	str	r3, [sp, #28]
 8014a98:	e71f      	b.n	80148da <_vfiprintf_r+0x48a>
 8014a9a:	9801      	ldr	r0, [sp, #4]
 8014a9c:	9900      	ldr	r1, [sp, #0]
 8014a9e:	9308      	str	r3, [sp, #32]
 8014aa0:	aa0d      	add	r2, sp, #52	; 0x34
 8014aa2:	f7ff fc95 	bl	80143d0 <__sprint_r.part.0>
 8014aa6:	2800      	cmp	r0, #0
 8014aa8:	f040 808f 	bne.w	8014bca <_vfiprintf_r+0x77a>
 8014aac:	990e      	ldr	r1, [sp, #56]	; 0x38
 8014aae:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8014ab0:	9b08      	ldr	r3, [sp, #32]
 8014ab2:	f101 0e01 	add.w	lr, r1, #1
 8014ab6:	46d4      	mov	ip, sl
 8014ab8:	e620      	b.n	80146fc <_vfiprintf_r+0x2ac>
 8014aba:	990e      	ldr	r1, [sp, #56]	; 0x38
 8014abc:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8014abe:	1c48      	adds	r0, r1, #1
 8014ac0:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
 8014ac4:	b16b      	cbz	r3, 8014ae2 <_vfiprintf_r+0x692>
 8014ac6:	3201      	adds	r2, #1
 8014ac8:	f10d 032f 	add.w	r3, sp, #47	; 0x2f
 8014acc:	2101      	movs	r1, #1
 8014ace:	2807      	cmp	r0, #7
 8014ad0:	920f      	str	r2, [sp, #60]	; 0x3c
 8014ad2:	900e      	str	r0, [sp, #56]	; 0x38
 8014ad4:	6023      	str	r3, [r4, #0]
 8014ad6:	6061      	str	r1, [r4, #4]
 8014ad8:	f300 8134 	bgt.w	8014d44 <_vfiprintf_r+0x8f4>
 8014adc:	4601      	mov	r1, r0
 8014ade:	3408      	adds	r4, #8
 8014ae0:	3001      	adds	r0, #1
 8014ae2:	9b05      	ldr	r3, [sp, #20]
 8014ae4:	b163      	cbz	r3, 8014b00 <_vfiprintf_r+0x6b0>
 8014ae6:	3202      	adds	r2, #2
 8014ae8:	a90c      	add	r1, sp, #48	; 0x30
 8014aea:	2302      	movs	r3, #2
 8014aec:	2807      	cmp	r0, #7
 8014aee:	920f      	str	r2, [sp, #60]	; 0x3c
 8014af0:	900e      	str	r0, [sp, #56]	; 0x38
 8014af2:	e884 000a 	stmia.w	r4, {r1, r3}
 8014af6:	f300 8134 	bgt.w	8014d62 <_vfiprintf_r+0x912>
 8014afa:	4601      	mov	r1, r0
 8014afc:	3408      	adds	r4, #8
 8014afe:	3001      	adds	r0, #1
 8014b00:	9b06      	ldr	r3, [sp, #24]
 8014b02:	2b80      	cmp	r3, #128	; 0x80
 8014b04:	f000 80d4 	beq.w	8014cb0 <_vfiprintf_r+0x860>
 8014b08:	ebc9 070c 	rsb	r7, r9, ip
 8014b0c:	2f00      	cmp	r7, #0
 8014b0e:	dd2b      	ble.n	8014b68 <_vfiprintf_r+0x718>
 8014b10:	2f10      	cmp	r7, #16
 8014b12:	4dab      	ldr	r5, [pc, #684]	; (8014dc0 <_vfiprintf_r+0x970>)
 8014b14:	dd1f      	ble.n	8014b56 <_vfiprintf_r+0x706>
 8014b16:	46a6      	mov	lr, r4
 8014b18:	2310      	movs	r3, #16
 8014b1a:	9c01      	ldr	r4, [sp, #4]
 8014b1c:	e007      	b.n	8014b2e <_vfiprintf_r+0x6de>
 8014b1e:	f101 0c02 	add.w	ip, r1, #2
 8014b22:	f10e 0e08 	add.w	lr, lr, #8
 8014b26:	4601      	mov	r1, r0
 8014b28:	3f10      	subs	r7, #16
 8014b2a:	2f10      	cmp	r7, #16
 8014b2c:	dd11      	ble.n	8014b52 <_vfiprintf_r+0x702>
 8014b2e:	1c48      	adds	r0, r1, #1
 8014b30:	3210      	adds	r2, #16
 8014b32:	2807      	cmp	r0, #7
 8014b34:	920f      	str	r2, [sp, #60]	; 0x3c
 8014b36:	f8ce 5000 	str.w	r5, [lr]
 8014b3a:	f8ce 3004 	str.w	r3, [lr, #4]
 8014b3e:	900e      	str	r0, [sp, #56]	; 0x38
 8014b40:	dded      	ble.n	8014b1e <_vfiprintf_r+0x6ce>
 8014b42:	bb6a      	cbnz	r2, 8014ba0 <_vfiprintf_r+0x750>
 8014b44:	3f10      	subs	r7, #16
 8014b46:	2f10      	cmp	r7, #16
 8014b48:	f04f 0c01 	mov.w	ip, #1
 8014b4c:	4611      	mov	r1, r2
 8014b4e:	46d6      	mov	lr, sl
 8014b50:	dced      	bgt.n	8014b2e <_vfiprintf_r+0x6de>
 8014b52:	4674      	mov	r4, lr
 8014b54:	4660      	mov	r0, ip
 8014b56:	443a      	add	r2, r7
 8014b58:	2807      	cmp	r0, #7
 8014b5a:	920f      	str	r2, [sp, #60]	; 0x3c
 8014b5c:	e884 00a0 	stmia.w	r4, {r5, r7}
 8014b60:	900e      	str	r0, [sp, #56]	; 0x38
 8014b62:	dc3b      	bgt.n	8014bdc <_vfiprintf_r+0x78c>
 8014b64:	3408      	adds	r4, #8
 8014b66:	3001      	adds	r0, #1
 8014b68:	eb02 0309 	add.w	r3, r2, r9
 8014b6c:	9a07      	ldr	r2, [sp, #28]
 8014b6e:	930f      	str	r3, [sp, #60]	; 0x3c
 8014b70:	2807      	cmp	r0, #7
 8014b72:	e884 0204 	stmia.w	r4, {r2, r9}
 8014b76:	900e      	str	r0, [sp, #56]	; 0x38
 8014b78:	dd3d      	ble.n	8014bf6 <_vfiprintf_r+0x7a6>
 8014b7a:	2b00      	cmp	r3, #0
 8014b7c:	f040 813f 	bne.w	8014dfe <_vfiprintf_r+0x9ae>
 8014b80:	f018 0f04 	tst.w	r8, #4
 8014b84:	930e      	str	r3, [sp, #56]	; 0x38
 8014b86:	f040 8130 	bne.w	8014dea <_vfiprintf_r+0x99a>
 8014b8a:	9b02      	ldr	r3, [sp, #8]
 8014b8c:	9a03      	ldr	r2, [sp, #12]
 8014b8e:	4296      	cmp	r6, r2
 8014b90:	bfac      	ite	ge
 8014b92:	199b      	addge	r3, r3, r6
 8014b94:	189b      	addlt	r3, r3, r2
 8014b96:	9302      	str	r3, [sp, #8]
 8014b98:	2300      	movs	r3, #0
 8014b9a:	930e      	str	r3, [sp, #56]	; 0x38
 8014b9c:	4654      	mov	r4, sl
 8014b9e:	e489      	b.n	80144b4 <_vfiprintf_r+0x64>
 8014ba0:	4620      	mov	r0, r4
 8014ba2:	9900      	ldr	r1, [sp, #0]
 8014ba4:	9305      	str	r3, [sp, #20]
 8014ba6:	aa0d      	add	r2, sp, #52	; 0x34
 8014ba8:	f7ff fc12 	bl	80143d0 <__sprint_r.part.0>
 8014bac:	b968      	cbnz	r0, 8014bca <_vfiprintf_r+0x77a>
 8014bae:	990e      	ldr	r1, [sp, #56]	; 0x38
 8014bb0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8014bb2:	9b05      	ldr	r3, [sp, #20]
 8014bb4:	f101 0c01 	add.w	ip, r1, #1
 8014bb8:	46d6      	mov	lr, sl
 8014bba:	e7b5      	b.n	8014b28 <_vfiprintf_r+0x6d8>
 8014bbc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8014bbe:	b123      	cbz	r3, 8014bca <_vfiprintf_r+0x77a>
 8014bc0:	9801      	ldr	r0, [sp, #4]
 8014bc2:	9900      	ldr	r1, [sp, #0]
 8014bc4:	aa0d      	add	r2, sp, #52	; 0x34
 8014bc6:	f7ff fc03 	bl	80143d0 <__sprint_r.part.0>
 8014bca:	9b00      	ldr	r3, [sp, #0]
 8014bcc:	899b      	ldrh	r3, [r3, #12]
 8014bce:	065b      	lsls	r3, r3, #25
 8014bd0:	f53f ad27 	bmi.w	8014622 <_vfiprintf_r+0x1d2>
 8014bd4:	9802      	ldr	r0, [sp, #8]
 8014bd6:	b02b      	add	sp, #172	; 0xac
 8014bd8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8014bdc:	2a00      	cmp	r2, #0
 8014bde:	f040 8192 	bne.w	8014f06 <_vfiprintf_r+0xab6>
 8014be2:	2201      	movs	r2, #1
 8014be4:	9907      	ldr	r1, [sp, #28]
 8014be6:	f8cd 906c 	str.w	r9, [sp, #108]	; 0x6c
 8014bea:	464b      	mov	r3, r9
 8014bec:	f8cd 903c 	str.w	r9, [sp, #60]	; 0x3c
 8014bf0:	911a      	str	r1, [sp, #104]	; 0x68
 8014bf2:	920e      	str	r2, [sp, #56]	; 0x38
 8014bf4:	4654      	mov	r4, sl
 8014bf6:	f104 0208 	add.w	r2, r4, #8
 8014bfa:	f018 0f04 	tst.w	r8, #4
 8014bfe:	d039      	beq.n	8014c74 <_vfiprintf_r+0x824>
 8014c00:	9903      	ldr	r1, [sp, #12]
 8014c02:	1b8d      	subs	r5, r1, r6
 8014c04:	2d00      	cmp	r5, #0
 8014c06:	dd35      	ble.n	8014c74 <_vfiprintf_r+0x824>
 8014c08:	2d10      	cmp	r5, #16
 8014c0a:	f340 8203 	ble.w	8015014 <_vfiprintf_r+0xbc4>
 8014c0e:	980e      	ldr	r0, [sp, #56]	; 0x38
 8014c10:	4f6c      	ldr	r7, [pc, #432]	; (8014dc4 <_vfiprintf_r+0x974>)
 8014c12:	f8dd 8004 	ldr.w	r8, [sp, #4]
 8014c16:	f8dd 9000 	ldr.w	r9, [sp]
 8014c1a:	2410      	movs	r4, #16
 8014c1c:	e006      	b.n	8014c2c <_vfiprintf_r+0x7dc>
 8014c1e:	f100 0e02 	add.w	lr, r0, #2
 8014c22:	3208      	adds	r2, #8
 8014c24:	4608      	mov	r0, r1
 8014c26:	3d10      	subs	r5, #16
 8014c28:	2d10      	cmp	r5, #16
 8014c2a:	dd10      	ble.n	8014c4e <_vfiprintf_r+0x7fe>
 8014c2c:	1c41      	adds	r1, r0, #1
 8014c2e:	3310      	adds	r3, #16
 8014c30:	2907      	cmp	r1, #7
 8014c32:	930f      	str	r3, [sp, #60]	; 0x3c
 8014c34:	6017      	str	r7, [r2, #0]
 8014c36:	6054      	str	r4, [r2, #4]
 8014c38:	910e      	str	r1, [sp, #56]	; 0x38
 8014c3a:	ddf0      	ble.n	8014c1e <_vfiprintf_r+0x7ce>
 8014c3c:	2b00      	cmp	r3, #0
 8014c3e:	d12a      	bne.n	8014c96 <_vfiprintf_r+0x846>
 8014c40:	3d10      	subs	r5, #16
 8014c42:	2d10      	cmp	r5, #16
 8014c44:	f04f 0e01 	mov.w	lr, #1
 8014c48:	4618      	mov	r0, r3
 8014c4a:	4652      	mov	r2, sl
 8014c4c:	dcee      	bgt.n	8014c2c <_vfiprintf_r+0x7dc>
 8014c4e:	442b      	add	r3, r5
 8014c50:	f1be 0f07 	cmp.w	lr, #7
 8014c54:	930f      	str	r3, [sp, #60]	; 0x3c
 8014c56:	6017      	str	r7, [r2, #0]
 8014c58:	6055      	str	r5, [r2, #4]
 8014c5a:	f8cd e038 	str.w	lr, [sp, #56]	; 0x38
 8014c5e:	dd09      	ble.n	8014c74 <_vfiprintf_r+0x824>
 8014c60:	2b00      	cmp	r3, #0
 8014c62:	d092      	beq.n	8014b8a <_vfiprintf_r+0x73a>
 8014c64:	9801      	ldr	r0, [sp, #4]
 8014c66:	9900      	ldr	r1, [sp, #0]
 8014c68:	aa0d      	add	r2, sp, #52	; 0x34
 8014c6a:	f7ff fbb1 	bl	80143d0 <__sprint_r.part.0>
 8014c6e:	2800      	cmp	r0, #0
 8014c70:	d1ab      	bne.n	8014bca <_vfiprintf_r+0x77a>
 8014c72:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8014c74:	9a02      	ldr	r2, [sp, #8]
 8014c76:	9903      	ldr	r1, [sp, #12]
 8014c78:	428e      	cmp	r6, r1
 8014c7a:	bfac      	ite	ge
 8014c7c:	1992      	addge	r2, r2, r6
 8014c7e:	1852      	addlt	r2, r2, r1
 8014c80:	9202      	str	r2, [sp, #8]
 8014c82:	2b00      	cmp	r3, #0
 8014c84:	d088      	beq.n	8014b98 <_vfiprintf_r+0x748>
 8014c86:	9801      	ldr	r0, [sp, #4]
 8014c88:	9900      	ldr	r1, [sp, #0]
 8014c8a:	aa0d      	add	r2, sp, #52	; 0x34
 8014c8c:	f7ff fba0 	bl	80143d0 <__sprint_r.part.0>
 8014c90:	2800      	cmp	r0, #0
 8014c92:	d081      	beq.n	8014b98 <_vfiprintf_r+0x748>
 8014c94:	e799      	b.n	8014bca <_vfiprintf_r+0x77a>
 8014c96:	4640      	mov	r0, r8
 8014c98:	4649      	mov	r1, r9
 8014c9a:	aa0d      	add	r2, sp, #52	; 0x34
 8014c9c:	f7ff fb98 	bl	80143d0 <__sprint_r.part.0>
 8014ca0:	2800      	cmp	r0, #0
 8014ca2:	d192      	bne.n	8014bca <_vfiprintf_r+0x77a>
 8014ca4:	980e      	ldr	r0, [sp, #56]	; 0x38
 8014ca6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8014ca8:	f100 0e01 	add.w	lr, r0, #1
 8014cac:	4652      	mov	r2, sl
 8014cae:	e7ba      	b.n	8014c26 <_vfiprintf_r+0x7d6>
 8014cb0:	9b03      	ldr	r3, [sp, #12]
 8014cb2:	1b9f      	subs	r7, r3, r6
 8014cb4:	2f00      	cmp	r7, #0
 8014cb6:	f77f af27 	ble.w	8014b08 <_vfiprintf_r+0x6b8>
 8014cba:	2f10      	cmp	r7, #16
 8014cbc:	4d40      	ldr	r5, [pc, #256]	; (8014dc0 <_vfiprintf_r+0x970>)
 8014cbe:	f340 81b5 	ble.w	801502c <_vfiprintf_r+0xbdc>
 8014cc2:	4620      	mov	r0, r4
 8014cc4:	2310      	movs	r3, #16
 8014cc6:	4664      	mov	r4, ip
 8014cc8:	4684      	mov	ip, r0
 8014cca:	e007      	b.n	8014cdc <_vfiprintf_r+0x88c>
 8014ccc:	f101 0e02 	add.w	lr, r1, #2
 8014cd0:	f10c 0c08 	add.w	ip, ip, #8
 8014cd4:	4601      	mov	r1, r0
 8014cd6:	3f10      	subs	r7, #16
 8014cd8:	2f10      	cmp	r7, #16
 8014cda:	dd11      	ble.n	8014d00 <_vfiprintf_r+0x8b0>
 8014cdc:	1c48      	adds	r0, r1, #1
 8014cde:	3210      	adds	r2, #16
 8014ce0:	2807      	cmp	r0, #7
 8014ce2:	920f      	str	r2, [sp, #60]	; 0x3c
 8014ce4:	f8cc 5000 	str.w	r5, [ip]
 8014ce8:	f8cc 3004 	str.w	r3, [ip, #4]
 8014cec:	900e      	str	r0, [sp, #56]	; 0x38
 8014cee:	dded      	ble.n	8014ccc <_vfiprintf_r+0x87c>
 8014cf0:	b9c2      	cbnz	r2, 8014d24 <_vfiprintf_r+0x8d4>
 8014cf2:	3f10      	subs	r7, #16
 8014cf4:	2f10      	cmp	r7, #16
 8014cf6:	f04f 0e01 	mov.w	lr, #1
 8014cfa:	4611      	mov	r1, r2
 8014cfc:	46d4      	mov	ip, sl
 8014cfe:	dced      	bgt.n	8014cdc <_vfiprintf_r+0x88c>
 8014d00:	4663      	mov	r3, ip
 8014d02:	46a4      	mov	ip, r4
 8014d04:	461c      	mov	r4, r3
 8014d06:	443a      	add	r2, r7
 8014d08:	f1be 0f07 	cmp.w	lr, #7
 8014d0c:	920f      	str	r2, [sp, #60]	; 0x3c
 8014d0e:	e884 00a0 	stmia.w	r4, {r5, r7}
 8014d12:	f8cd e038 	str.w	lr, [sp, #56]	; 0x38
 8014d16:	f300 80f0 	bgt.w	8014efa <_vfiprintf_r+0xaaa>
 8014d1a:	3408      	adds	r4, #8
 8014d1c:	f10e 0001 	add.w	r0, lr, #1
 8014d20:	4671      	mov	r1, lr
 8014d22:	e6f1      	b.n	8014b08 <_vfiprintf_r+0x6b8>
 8014d24:	9801      	ldr	r0, [sp, #4]
 8014d26:	9900      	ldr	r1, [sp, #0]
 8014d28:	9305      	str	r3, [sp, #20]
 8014d2a:	aa0d      	add	r2, sp, #52	; 0x34
 8014d2c:	f7ff fb50 	bl	80143d0 <__sprint_r.part.0>
 8014d30:	2800      	cmp	r0, #0
 8014d32:	f47f af4a 	bne.w	8014bca <_vfiprintf_r+0x77a>
 8014d36:	990e      	ldr	r1, [sp, #56]	; 0x38
 8014d38:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8014d3a:	9b05      	ldr	r3, [sp, #20]
 8014d3c:	f101 0e01 	add.w	lr, r1, #1
 8014d40:	46d4      	mov	ip, sl
 8014d42:	e7c8      	b.n	8014cd6 <_vfiprintf_r+0x886>
 8014d44:	2a00      	cmp	r2, #0
 8014d46:	f040 80c7 	bne.w	8014ed8 <_vfiprintf_r+0xa88>
 8014d4a:	9b05      	ldr	r3, [sp, #20]
 8014d4c:	2b00      	cmp	r3, #0
 8014d4e:	f000 8087 	beq.w	8014e60 <_vfiprintf_r+0xa10>
 8014d52:	aa0c      	add	r2, sp, #48	; 0x30
 8014d54:	2302      	movs	r3, #2
 8014d56:	921a      	str	r2, [sp, #104]	; 0x68
 8014d58:	4608      	mov	r0, r1
 8014d5a:	931b      	str	r3, [sp, #108]	; 0x6c
 8014d5c:	461a      	mov	r2, r3
 8014d5e:	4654      	mov	r4, sl
 8014d60:	e6cb      	b.n	8014afa <_vfiprintf_r+0x6aa>
 8014d62:	2a00      	cmp	r2, #0
 8014d64:	f040 80a7 	bne.w	8014eb6 <_vfiprintf_r+0xa66>
 8014d68:	2001      	movs	r0, #1
 8014d6a:	4611      	mov	r1, r2
 8014d6c:	4654      	mov	r4, sl
 8014d6e:	e6c7      	b.n	8014b00 <_vfiprintf_r+0x6b0>
 8014d70:	bb03      	cbnz	r3, 8014db4 <_vfiprintf_r+0x964>
 8014d72:	f018 0f01 	tst.w	r8, #1
 8014d76:	d01d      	beq.n	8014db4 <_vfiprintf_r+0x964>
 8014d78:	ab2a      	add	r3, sp, #168	; 0xa8
 8014d7a:	2230      	movs	r2, #48	; 0x30
 8014d7c:	f803 2d41 	strb.w	r2, [r3, #-65]!
 8014d80:	ebc3 090a 	rsb	r9, r3, sl
 8014d84:	9307      	str	r3, [sp, #28]
 8014d86:	e492      	b.n	80146ae <_vfiprintf_r+0x25e>
 8014d88:	9809      	ldr	r0, [sp, #36]	; 0x24
 8014d8a:	46d1      	mov	r9, sl
 8014d8c:	0933      	lsrs	r3, r6, #4
 8014d8e:	f006 010f 	and.w	r1, r6, #15
 8014d92:	ea43 7307 	orr.w	r3, r3, r7, lsl #28
 8014d96:	093a      	lsrs	r2, r7, #4
 8014d98:	461e      	mov	r6, r3
 8014d9a:	4617      	mov	r7, r2
 8014d9c:	5c43      	ldrb	r3, [r0, r1]
 8014d9e:	f809 3d01 	strb.w	r3, [r9, #-1]!
 8014da2:	ea56 0307 	orrs.w	r3, r6, r7
 8014da6:	d1f1      	bne.n	8014d8c <_vfiprintf_r+0x93c>
 8014da8:	464b      	mov	r3, r9
 8014daa:	f8cd 901c 	str.w	r9, [sp, #28]
 8014dae:	ebc3 090a 	rsb	r9, r3, sl
 8014db2:	e47c      	b.n	80146ae <_vfiprintf_r+0x25e>
 8014db4:	f8cd a01c 	str.w	sl, [sp, #28]
 8014db8:	e479      	b.n	80146ae <_vfiprintf_r+0x25e>
 8014dba:	2302      	movs	r3, #2
 8014dbc:	e449      	b.n	8014652 <_vfiprintf_r+0x202>
 8014dbe:	bf00      	nop
 8014dc0:	0801cdf0 	.word	0x0801cdf0
 8014dc4:	0801ce00 	.word	0x0801ce00
 8014dc8:	2a00      	cmp	r2, #0
 8014dca:	f040 80d7 	bne.w	8014f7c <_vfiprintf_r+0xb2c>
 8014dce:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
 8014dd2:	2b00      	cmp	r3, #0
 8014dd4:	f000 80ae 	beq.w	8014f34 <_vfiprintf_r+0xae4>
 8014dd8:	2301      	movs	r3, #1
 8014dda:	f10d 012f 	add.w	r1, sp, #47	; 0x2f
 8014dde:	4618      	mov	r0, r3
 8014de0:	931b      	str	r3, [sp, #108]	; 0x6c
 8014de2:	461a      	mov	r2, r3
 8014de4:	911a      	str	r1, [sp, #104]	; 0x68
 8014de6:	4654      	mov	r4, sl
 8014de8:	e678      	b.n	8014adc <_vfiprintf_r+0x68c>
 8014dea:	9a03      	ldr	r2, [sp, #12]
 8014dec:	1b95      	subs	r5, r2, r6
 8014dee:	2d00      	cmp	r5, #0
 8014df0:	4652      	mov	r2, sl
 8014df2:	f73f af09 	bgt.w	8014c08 <_vfiprintf_r+0x7b8>
 8014df6:	e6c8      	b.n	8014b8a <_vfiprintf_r+0x73a>
 8014df8:	465d      	mov	r5, fp
 8014dfa:	f7ff bb82 	b.w	8014502 <_vfiprintf_r+0xb2>
 8014dfe:	9801      	ldr	r0, [sp, #4]
 8014e00:	9900      	ldr	r1, [sp, #0]
 8014e02:	aa0d      	add	r2, sp, #52	; 0x34
 8014e04:	f7ff fae4 	bl	80143d0 <__sprint_r.part.0>
 8014e08:	2800      	cmp	r0, #0
 8014e0a:	f47f aede 	bne.w	8014bca <_vfiprintf_r+0x77a>
 8014e0e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8014e10:	4652      	mov	r2, sl
 8014e12:	e6f2      	b.n	8014bfa <_vfiprintf_r+0x7aa>
 8014e14:	9904      	ldr	r1, [sp, #16]
 8014e16:	460a      	mov	r2, r1
 8014e18:	3204      	adds	r2, #4
 8014e1a:	680e      	ldr	r6, [r1, #0]
 8014e1c:	9204      	str	r2, [sp, #16]
 8014e1e:	2700      	movs	r7, #0
 8014e20:	e417      	b.n	8014652 <_vfiprintf_r+0x202>
 8014e22:	3204      	adds	r2, #4
 8014e24:	681e      	ldr	r6, [r3, #0]
 8014e26:	9204      	str	r2, [sp, #16]
 8014e28:	2301      	movs	r3, #1
 8014e2a:	2700      	movs	r7, #0
 8014e2c:	e411      	b.n	8014652 <_vfiprintf_r+0x202>
 8014e2e:	6816      	ldr	r6, [r2, #0]
 8014e30:	3204      	adds	r2, #4
 8014e32:	9204      	str	r2, [sp, #16]
 8014e34:	2700      	movs	r7, #0
 8014e36:	e530      	b.n	801489a <_vfiprintf_r+0x44a>
 8014e38:	9a04      	ldr	r2, [sp, #16]
 8014e3a:	6816      	ldr	r6, [r2, #0]
 8014e3c:	4613      	mov	r3, r2
 8014e3e:	3304      	adds	r3, #4
 8014e40:	17f7      	asrs	r7, r6, #31
 8014e42:	9304      	str	r3, [sp, #16]
 8014e44:	4632      	mov	r2, r6
 8014e46:	463b      	mov	r3, r7
 8014e48:	e4c2      	b.n	80147d0 <_vfiprintf_r+0x380>
 8014e4a:	9801      	ldr	r0, [sp, #4]
 8014e4c:	9900      	ldr	r1, [sp, #0]
 8014e4e:	aa0d      	add	r2, sp, #52	; 0x34
 8014e50:	f7ff fabe 	bl	80143d0 <__sprint_r.part.0>
 8014e54:	2800      	cmp	r0, #0
 8014e56:	f47f aeb8 	bne.w	8014bca <_vfiprintf_r+0x77a>
 8014e5a:	4654      	mov	r4, sl
 8014e5c:	f7ff bbc2 	b.w	80145e4 <_vfiprintf_r+0x194>
 8014e60:	4608      	mov	r0, r1
 8014e62:	4654      	mov	r4, sl
 8014e64:	4611      	mov	r1, r2
 8014e66:	e64b      	b.n	8014b00 <_vfiprintf_r+0x6b0>
 8014e68:	46d1      	mov	r9, sl
 8014e6a:	f8cd c014 	str.w	ip, [sp, #20]
 8014e6e:	4630      	mov	r0, r6
 8014e70:	4639      	mov	r1, r7
 8014e72:	220a      	movs	r2, #10
 8014e74:	2300      	movs	r3, #0
 8014e76:	f7eb fa4b 	bl	8000310 <__aeabi_uldivmod>
 8014e7a:	3230      	adds	r2, #48	; 0x30
 8014e7c:	4630      	mov	r0, r6
 8014e7e:	4639      	mov	r1, r7
 8014e80:	f809 2d01 	strb.w	r2, [r9, #-1]!
 8014e84:	2300      	movs	r3, #0
 8014e86:	220a      	movs	r2, #10
 8014e88:	f7eb fa42 	bl	8000310 <__aeabi_uldivmod>
 8014e8c:	4606      	mov	r6, r0
 8014e8e:	460f      	mov	r7, r1
 8014e90:	ea56 0307 	orrs.w	r3, r6, r7
 8014e94:	d1eb      	bne.n	8014e6e <_vfiprintf_r+0xa1e>
 8014e96:	f8dd c014 	ldr.w	ip, [sp, #20]
 8014e9a:	e785      	b.n	8014da8 <_vfiprintf_r+0x958>
 8014e9c:	2b30      	cmp	r3, #48	; 0x30
 8014e9e:	9b07      	ldr	r3, [sp, #28]
 8014ea0:	d085      	beq.n	8014dae <_vfiprintf_r+0x95e>
 8014ea2:	3b01      	subs	r3, #1
 8014ea4:	461a      	mov	r2, r3
 8014ea6:	9307      	str	r3, [sp, #28]
 8014ea8:	2330      	movs	r3, #48	; 0x30
 8014eaa:	ebc2 090a 	rsb	r9, r2, sl
 8014eae:	f801 3c01 	strb.w	r3, [r1, #-1]
 8014eb2:	f7ff bbfc 	b.w	80146ae <_vfiprintf_r+0x25e>
 8014eb6:	9801      	ldr	r0, [sp, #4]
 8014eb8:	9900      	ldr	r1, [sp, #0]
 8014eba:	f8cd c014 	str.w	ip, [sp, #20]
 8014ebe:	aa0d      	add	r2, sp, #52	; 0x34
 8014ec0:	f7ff fa86 	bl	80143d0 <__sprint_r.part.0>
 8014ec4:	2800      	cmp	r0, #0
 8014ec6:	f47f ae80 	bne.w	8014bca <_vfiprintf_r+0x77a>
 8014eca:	990e      	ldr	r1, [sp, #56]	; 0x38
 8014ecc:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8014ece:	f8dd c014 	ldr.w	ip, [sp, #20]
 8014ed2:	1c48      	adds	r0, r1, #1
 8014ed4:	4654      	mov	r4, sl
 8014ed6:	e613      	b.n	8014b00 <_vfiprintf_r+0x6b0>
 8014ed8:	9801      	ldr	r0, [sp, #4]
 8014eda:	9900      	ldr	r1, [sp, #0]
 8014edc:	f8cd c020 	str.w	ip, [sp, #32]
 8014ee0:	aa0d      	add	r2, sp, #52	; 0x34
 8014ee2:	f7ff fa75 	bl	80143d0 <__sprint_r.part.0>
 8014ee6:	2800      	cmp	r0, #0
 8014ee8:	f47f ae6f 	bne.w	8014bca <_vfiprintf_r+0x77a>
 8014eec:	990e      	ldr	r1, [sp, #56]	; 0x38
 8014eee:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8014ef0:	f8dd c020 	ldr.w	ip, [sp, #32]
 8014ef4:	1c48      	adds	r0, r1, #1
 8014ef6:	4654      	mov	r4, sl
 8014ef8:	e5f3      	b.n	8014ae2 <_vfiprintf_r+0x692>
 8014efa:	2a00      	cmp	r2, #0
 8014efc:	d167      	bne.n	8014fce <_vfiprintf_r+0xb7e>
 8014efe:	2001      	movs	r0, #1
 8014f00:	4611      	mov	r1, r2
 8014f02:	4654      	mov	r4, sl
 8014f04:	e600      	b.n	8014b08 <_vfiprintf_r+0x6b8>
 8014f06:	9801      	ldr	r0, [sp, #4]
 8014f08:	9900      	ldr	r1, [sp, #0]
 8014f0a:	aa0d      	add	r2, sp, #52	; 0x34
 8014f0c:	f7ff fa60 	bl	80143d0 <__sprint_r.part.0>
 8014f10:	2800      	cmp	r0, #0
 8014f12:	f47f ae5a 	bne.w	8014bca <_vfiprintf_r+0x77a>
 8014f16:	980e      	ldr	r0, [sp, #56]	; 0x38
 8014f18:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8014f1a:	3001      	adds	r0, #1
 8014f1c:	4654      	mov	r4, sl
 8014f1e:	e623      	b.n	8014b68 <_vfiprintf_r+0x718>
 8014f20:	252d      	movs	r5, #45	; 0x2d
 8014f22:	4276      	negs	r6, r6
 8014f24:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
 8014f28:	f88d 502f 	strb.w	r5, [sp, #47]	; 0x2f
 8014f2c:	46e1      	mov	r9, ip
 8014f2e:	2301      	movs	r3, #1
 8014f30:	f7ff bb94 	b.w	801465c <_vfiprintf_r+0x20c>
 8014f34:	9b05      	ldr	r3, [sp, #20]
 8014f36:	4611      	mov	r1, r2
 8014f38:	2001      	movs	r0, #1
 8014f3a:	4654      	mov	r4, sl
 8014f3c:	2b00      	cmp	r3, #0
 8014f3e:	f43f ade3 	beq.w	8014b08 <_vfiprintf_r+0x6b8>
 8014f42:	aa0c      	add	r2, sp, #48	; 0x30
 8014f44:	2302      	movs	r3, #2
 8014f46:	e88a 000c 	stmia.w	sl, {r2, r3}
 8014f4a:	461a      	mov	r2, r3
 8014f4c:	e5d5      	b.n	8014afa <_vfiprintf_r+0x6aa>
 8014f4e:	f018 0f10 	tst.w	r8, #16
 8014f52:	d10b      	bne.n	8014f6c <_vfiprintf_r+0xb1c>
 8014f54:	f018 0f40 	tst.w	r8, #64	; 0x40
 8014f58:	d008      	beq.n	8014f6c <_vfiprintf_r+0xb1c>
 8014f5a:	9a04      	ldr	r2, [sp, #16]
 8014f5c:	6813      	ldr	r3, [r2, #0]
 8014f5e:	3204      	adds	r2, #4
 8014f60:	9204      	str	r2, [sp, #16]
 8014f62:	f8bd 2008 	ldrh.w	r2, [sp, #8]
 8014f66:	801a      	strh	r2, [r3, #0]
 8014f68:	f7ff baa4 	b.w	80144b4 <_vfiprintf_r+0x64>
 8014f6c:	9a04      	ldr	r2, [sp, #16]
 8014f6e:	6813      	ldr	r3, [r2, #0]
 8014f70:	3204      	adds	r2, #4
 8014f72:	9204      	str	r2, [sp, #16]
 8014f74:	9a02      	ldr	r2, [sp, #8]
 8014f76:	601a      	str	r2, [r3, #0]
 8014f78:	f7ff ba9c 	b.w	80144b4 <_vfiprintf_r+0x64>
 8014f7c:	9801      	ldr	r0, [sp, #4]
 8014f7e:	9900      	ldr	r1, [sp, #0]
 8014f80:	f8cd c020 	str.w	ip, [sp, #32]
 8014f84:	aa0d      	add	r2, sp, #52	; 0x34
 8014f86:	f7ff fa23 	bl	80143d0 <__sprint_r.part.0>
 8014f8a:	2800      	cmp	r0, #0
 8014f8c:	f47f ae1d 	bne.w	8014bca <_vfiprintf_r+0x77a>
 8014f90:	990e      	ldr	r1, [sp, #56]	; 0x38
 8014f92:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8014f94:	f8dd c020 	ldr.w	ip, [sp, #32]
 8014f98:	1c48      	adds	r0, r1, #1
 8014f9a:	4654      	mov	r4, sl
 8014f9c:	e590      	b.n	8014ac0 <_vfiprintf_r+0x670>
 8014f9e:	f048 0820 	orr.w	r8, r8, #32
 8014fa2:	f10b 0001 	add.w	r0, fp, #1
 8014fa6:	f89b 3001 	ldrb.w	r3, [fp, #1]
 8014faa:	f7ff bab8 	b.w	801451e <_vfiprintf_r+0xce>
 8014fae:	426d      	negs	r5, r5
 8014fb0:	9304      	str	r3, [sp, #16]
 8014fb2:	4658      	mov	r0, fp
 8014fb4:	f7ff bbc9 	b.w	801474a <_vfiprintf_r+0x2fa>
 8014fb8:	9807      	ldr	r0, [sp, #28]
 8014fba:	9604      	str	r6, [sp, #16]
 8014fbc:	f7ff f988 	bl	80142d0 <strlen>
 8014fc0:	f89d 502f 	ldrb.w	r5, [sp, #47]	; 0x2f
 8014fc4:	4681      	mov	r9, r0
 8014fc6:	f04f 0c00 	mov.w	ip, #0
 8014fca:	f7ff bb70 	b.w	80146ae <_vfiprintf_r+0x25e>
 8014fce:	9801      	ldr	r0, [sp, #4]
 8014fd0:	9900      	ldr	r1, [sp, #0]
 8014fd2:	f8cd c014 	str.w	ip, [sp, #20]
 8014fd6:	aa0d      	add	r2, sp, #52	; 0x34
 8014fd8:	f7ff f9fa 	bl	80143d0 <__sprint_r.part.0>
 8014fdc:	2800      	cmp	r0, #0
 8014fde:	f47f adf4 	bne.w	8014bca <_vfiprintf_r+0x77a>
 8014fe2:	990e      	ldr	r1, [sp, #56]	; 0x38
 8014fe4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8014fe6:	f8dd c014 	ldr.w	ip, [sp, #20]
 8014fea:	1c48      	adds	r0, r1, #1
 8014fec:	4654      	mov	r4, sl
 8014fee:	e58b      	b.n	8014b08 <_vfiprintf_r+0x6b8>
 8014ff0:	990e      	ldr	r1, [sp, #56]	; 0x38
 8014ff2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8014ff4:	4f15      	ldr	r7, [pc, #84]	; (801504c <_vfiprintf_r+0xbfc>)
 8014ff6:	3101      	adds	r1, #1
 8014ff8:	f7ff bb9b 	b.w	8014732 <_vfiprintf_r+0x2e2>
 8014ffc:	f1bc 0f06 	cmp.w	ip, #6
 8015000:	bf28      	it	cs
 8015002:	f04f 0c06 	movcs.w	ip, #6
 8015006:	4b12      	ldr	r3, [pc, #72]	; (8015050 <_vfiprintf_r+0xc00>)
 8015008:	9604      	str	r6, [sp, #16]
 801500a:	46e1      	mov	r9, ip
 801500c:	ea2c 76ec 	bic.w	r6, ip, ip, asr #31
 8015010:	9307      	str	r3, [sp, #28]
 8015012:	e462      	b.n	80148da <_vfiprintf_r+0x48a>
 8015014:	990e      	ldr	r1, [sp, #56]	; 0x38
 8015016:	4f0d      	ldr	r7, [pc, #52]	; (801504c <_vfiprintf_r+0xbfc>)
 8015018:	f101 0e01 	add.w	lr, r1, #1
 801501c:	e617      	b.n	8014c4e <_vfiprintf_r+0x7fe>
 801501e:	46e1      	mov	r9, ip
 8015020:	f89d 502f 	ldrb.w	r5, [sp, #47]	; 0x2f
 8015024:	9604      	str	r6, [sp, #16]
 8015026:	4684      	mov	ip, r0
 8015028:	f7ff bb41 	b.w	80146ae <_vfiprintf_r+0x25e>
 801502c:	4686      	mov	lr, r0
 801502e:	e66a      	b.n	8014d06 <_vfiprintf_r+0x8b6>
 8015030:	9a04      	ldr	r2, [sp, #16]
 8015032:	f89b 3001 	ldrb.w	r3, [fp, #1]
 8015036:	6816      	ldr	r6, [r2, #0]
 8015038:	3204      	adds	r2, #4
 801503a:	2e00      	cmp	r6, #0
 801503c:	9204      	str	r2, [sp, #16]
 801503e:	f6bf aa6e 	bge.w	801451e <_vfiprintf_r+0xce>
 8015042:	f04f 36ff 	mov.w	r6, #4294967295
 8015046:	f7ff ba6a 	b.w	801451e <_vfiprintf_r+0xce>
 801504a:	bf00      	nop
 801504c:	0801ce00 	.word	0x0801ce00
 8015050:	08019130 	.word	0x08019130
	...

08015060 <__sbprintf>:
 8015060:	e92d 42f0 	stmdb	sp!, {r4, r5, r6, r7, r9, lr}
 8015064:	460c      	mov	r4, r1
 8015066:	f5ad 6d8d 	sub.w	sp, sp, #1128	; 0x468
 801506a:	f8b1 e00c 	ldrh.w	lr, [r1, #12]
 801506e:	69e7      	ldr	r7, [r4, #28]
 8015070:	6e49      	ldr	r1, [r1, #100]	; 0x64
 8015072:	f8b4 900e 	ldrh.w	r9, [r4, #14]
 8015076:	9119      	str	r1, [sp, #100]	; 0x64
 8015078:	ad1a      	add	r5, sp, #104	; 0x68
 801507a:	f44f 6680 	mov.w	r6, #1024	; 0x400
 801507e:	f02e 0e02 	bic.w	lr, lr, #2
 8015082:	f04f 0c00 	mov.w	ip, #0
 8015086:	9707      	str	r7, [sp, #28]
 8015088:	4669      	mov	r1, sp
 801508a:	6a67      	ldr	r7, [r4, #36]	; 0x24
 801508c:	9500      	str	r5, [sp, #0]
 801508e:	9504      	str	r5, [sp, #16]
 8015090:	9602      	str	r6, [sp, #8]
 8015092:	9605      	str	r6, [sp, #20]
 8015094:	f8ad e00c 	strh.w	lr, [sp, #12]
 8015098:	f8ad 900e 	strh.w	r9, [sp, #14]
 801509c:	9709      	str	r7, [sp, #36]	; 0x24
 801509e:	f8cd c018 	str.w	ip, [sp, #24]
 80150a2:	4606      	mov	r6, r0
 80150a4:	f7ff f9d4 	bl	8014450 <_vfiprintf_r>
 80150a8:	1e05      	subs	r5, r0, #0
 80150aa:	db07      	blt.n	80150bc <__sbprintf+0x5c>
 80150ac:	4630      	mov	r0, r6
 80150ae:	4669      	mov	r1, sp
 80150b0:	f000 f936 	bl	8015320 <_fflush_r>
 80150b4:	2800      	cmp	r0, #0
 80150b6:	bf18      	it	ne
 80150b8:	f04f 35ff 	movne.w	r5, #4294967295
 80150bc:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 80150c0:	065b      	lsls	r3, r3, #25
 80150c2:	d503      	bpl.n	80150cc <__sbprintf+0x6c>
 80150c4:	89a3      	ldrh	r3, [r4, #12]
 80150c6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80150ca:	81a3      	strh	r3, [r4, #12]
 80150cc:	4628      	mov	r0, r5
 80150ce:	f50d 6d8d 	add.w	sp, sp, #1128	; 0x468
 80150d2:	e8bd 82f0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, pc}
 80150d6:	bf00      	nop
	...

080150e0 <__swsetup_r>:
 80150e0:	b538      	push	{r3, r4, r5, lr}
 80150e2:	4b2f      	ldr	r3, [pc, #188]	; (80151a0 <__swsetup_r+0xc0>)
 80150e4:	681b      	ldr	r3, [r3, #0]
 80150e6:	4605      	mov	r5, r0
 80150e8:	460c      	mov	r4, r1
 80150ea:	b113      	cbz	r3, 80150f2 <__swsetup_r+0x12>
 80150ec:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80150ee:	2a00      	cmp	r2, #0
 80150f0:	d036      	beq.n	8015160 <__swsetup_r+0x80>
 80150f2:	89a2      	ldrh	r2, [r4, #12]
 80150f4:	b293      	uxth	r3, r2
 80150f6:	0718      	lsls	r0, r3, #28
 80150f8:	d50c      	bpl.n	8015114 <__swsetup_r+0x34>
 80150fa:	6920      	ldr	r0, [r4, #16]
 80150fc:	b1a8      	cbz	r0, 801512a <__swsetup_r+0x4a>
 80150fe:	f013 0201 	ands.w	r2, r3, #1
 8015102:	d01e      	beq.n	8015142 <__swsetup_r+0x62>
 8015104:	6963      	ldr	r3, [r4, #20]
 8015106:	2200      	movs	r2, #0
 8015108:	425b      	negs	r3, r3
 801510a:	61a3      	str	r3, [r4, #24]
 801510c:	60a2      	str	r2, [r4, #8]
 801510e:	b1f0      	cbz	r0, 801514e <__swsetup_r+0x6e>
 8015110:	2000      	movs	r0, #0
 8015112:	bd38      	pop	{r3, r4, r5, pc}
 8015114:	06d9      	lsls	r1, r3, #27
 8015116:	d53b      	bpl.n	8015190 <__swsetup_r+0xb0>
 8015118:	0758      	lsls	r0, r3, #29
 801511a:	d425      	bmi.n	8015168 <__swsetup_r+0x88>
 801511c:	6920      	ldr	r0, [r4, #16]
 801511e:	f042 0308 	orr.w	r3, r2, #8
 8015122:	81a3      	strh	r3, [r4, #12]
 8015124:	b29b      	uxth	r3, r3
 8015126:	2800      	cmp	r0, #0
 8015128:	d1e9      	bne.n	80150fe <__swsetup_r+0x1e>
 801512a:	f403 7220 	and.w	r2, r3, #640	; 0x280
 801512e:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8015132:	d0e4      	beq.n	80150fe <__swsetup_r+0x1e>
 8015134:	4628      	mov	r0, r5
 8015136:	4621      	mov	r1, r4
 8015138:	f000 fd02 	bl	8015b40 <__smakebuf_r>
 801513c:	89a3      	ldrh	r3, [r4, #12]
 801513e:	6920      	ldr	r0, [r4, #16]
 8015140:	e7dd      	b.n	80150fe <__swsetup_r+0x1e>
 8015142:	0799      	lsls	r1, r3, #30
 8015144:	bf58      	it	pl
 8015146:	6962      	ldrpl	r2, [r4, #20]
 8015148:	60a2      	str	r2, [r4, #8]
 801514a:	2800      	cmp	r0, #0
 801514c:	d1e0      	bne.n	8015110 <__swsetup_r+0x30>
 801514e:	89a3      	ldrh	r3, [r4, #12]
 8015150:	061a      	lsls	r2, r3, #24
 8015152:	d5de      	bpl.n	8015112 <__swsetup_r+0x32>
 8015154:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8015158:	81a3      	strh	r3, [r4, #12]
 801515a:	f04f 30ff 	mov.w	r0, #4294967295
 801515e:	bd38      	pop	{r3, r4, r5, pc}
 8015160:	4618      	mov	r0, r3
 8015162:	f000 f975 	bl	8015450 <__sinit>
 8015166:	e7c4      	b.n	80150f2 <__swsetup_r+0x12>
 8015168:	6b21      	ldr	r1, [r4, #48]	; 0x30
 801516a:	b149      	cbz	r1, 8015180 <__swsetup_r+0xa0>
 801516c:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8015170:	4299      	cmp	r1, r3
 8015172:	d003      	beq.n	801517c <__swsetup_r+0x9c>
 8015174:	4628      	mov	r0, r5
 8015176:	f000 fa3b 	bl	80155f0 <_free_r>
 801517a:	89a2      	ldrh	r2, [r4, #12]
 801517c:	2300      	movs	r3, #0
 801517e:	6323      	str	r3, [r4, #48]	; 0x30
 8015180:	f022 0224 	bic.w	r2, r2, #36	; 0x24
 8015184:	2300      	movs	r3, #0
 8015186:	6920      	ldr	r0, [r4, #16]
 8015188:	6063      	str	r3, [r4, #4]
 801518a:	b292      	uxth	r2, r2
 801518c:	6020      	str	r0, [r4, #0]
 801518e:	e7c6      	b.n	801511e <__swsetup_r+0x3e>
 8015190:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8015194:	2309      	movs	r3, #9
 8015196:	602b      	str	r3, [r5, #0]
 8015198:	f04f 30ff 	mov.w	r0, #4294967295
 801519c:	81a2      	strh	r2, [r4, #12]
 801519e:	bd38      	pop	{r3, r4, r5, pc}
 80151a0:	20000d10 	.word	0x20000d10
	...

080151b0 <abort>:
 80151b0:	b508      	push	{r3, lr}
 80151b2:	2006      	movs	r0, #6
 80151b4:	f000 fe1c 	bl	8015df0 <raise>
 80151b8:	2001      	movs	r0, #1
 80151ba:	f7fd fb49 	bl	8012850 <_exit>
 80151be:	bf00      	nop

080151c0 <__sflush_r>:
 80151c0:	898b      	ldrh	r3, [r1, #12]
 80151c2:	b29a      	uxth	r2, r3
 80151c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80151c8:	460d      	mov	r5, r1
 80151ca:	0711      	lsls	r1, r2, #28
 80151cc:	4680      	mov	r8, r0
 80151ce:	d43c      	bmi.n	801524a <__sflush_r+0x8a>
 80151d0:	686a      	ldr	r2, [r5, #4]
 80151d2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80151d6:	2a00      	cmp	r2, #0
 80151d8:	81ab      	strh	r3, [r5, #12]
 80151da:	dd65      	ble.n	80152a8 <__sflush_r+0xe8>
 80151dc:	6aae      	ldr	r6, [r5, #40]	; 0x28
 80151de:	2e00      	cmp	r6, #0
 80151e0:	d04b      	beq.n	801527a <__sflush_r+0xba>
 80151e2:	b29b      	uxth	r3, r3
 80151e4:	f403 5280 	and.w	r2, r3, #4096	; 0x1000
 80151e8:	2100      	movs	r1, #0
 80151ea:	b292      	uxth	r2, r2
 80151ec:	f8d8 4000 	ldr.w	r4, [r8]
 80151f0:	f8c8 1000 	str.w	r1, [r8]
 80151f4:	2a00      	cmp	r2, #0
 80151f6:	d05b      	beq.n	80152b0 <__sflush_r+0xf0>
 80151f8:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 80151fa:	075f      	lsls	r7, r3, #29
 80151fc:	d505      	bpl.n	801520a <__sflush_r+0x4a>
 80151fe:	6869      	ldr	r1, [r5, #4]
 8015200:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8015202:	1a52      	subs	r2, r2, r1
 8015204:	b10b      	cbz	r3, 801520a <__sflush_r+0x4a>
 8015206:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8015208:	1ad2      	subs	r2, r2, r3
 801520a:	4640      	mov	r0, r8
 801520c:	69e9      	ldr	r1, [r5, #28]
 801520e:	2300      	movs	r3, #0
 8015210:	47b0      	blx	r6
 8015212:	1c46      	adds	r6, r0, #1
 8015214:	d056      	beq.n	80152c4 <__sflush_r+0x104>
 8015216:	89ab      	ldrh	r3, [r5, #12]
 8015218:	692a      	ldr	r2, [r5, #16]
 801521a:	602a      	str	r2, [r5, #0]
 801521c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8015220:	b29b      	uxth	r3, r3
 8015222:	2200      	movs	r2, #0
 8015224:	606a      	str	r2, [r5, #4]
 8015226:	04da      	lsls	r2, r3, #19
 8015228:	81ab      	strh	r3, [r5, #12]
 801522a:	d43b      	bmi.n	80152a4 <__sflush_r+0xe4>
 801522c:	6b29      	ldr	r1, [r5, #48]	; 0x30
 801522e:	f8c8 4000 	str.w	r4, [r8]
 8015232:	b311      	cbz	r1, 801527a <__sflush_r+0xba>
 8015234:	f105 0340 	add.w	r3, r5, #64	; 0x40
 8015238:	4299      	cmp	r1, r3
 801523a:	d002      	beq.n	8015242 <__sflush_r+0x82>
 801523c:	4640      	mov	r0, r8
 801523e:	f000 f9d7 	bl	80155f0 <_free_r>
 8015242:	2000      	movs	r0, #0
 8015244:	6328      	str	r0, [r5, #48]	; 0x30
 8015246:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801524a:	692e      	ldr	r6, [r5, #16]
 801524c:	b1ae      	cbz	r6, 801527a <__sflush_r+0xba>
 801524e:	682c      	ldr	r4, [r5, #0]
 8015250:	602e      	str	r6, [r5, #0]
 8015252:	0791      	lsls	r1, r2, #30
 8015254:	bf0c      	ite	eq
 8015256:	696b      	ldreq	r3, [r5, #20]
 8015258:	2300      	movne	r3, #0
 801525a:	1ba4      	subs	r4, r4, r6
 801525c:	60ab      	str	r3, [r5, #8]
 801525e:	e00a      	b.n	8015276 <__sflush_r+0xb6>
 8015260:	4632      	mov	r2, r6
 8015262:	4623      	mov	r3, r4
 8015264:	6a6f      	ldr	r7, [r5, #36]	; 0x24
 8015266:	69e9      	ldr	r1, [r5, #28]
 8015268:	4640      	mov	r0, r8
 801526a:	47b8      	blx	r7
 801526c:	2800      	cmp	r0, #0
 801526e:	eba4 0400 	sub.w	r4, r4, r0
 8015272:	4406      	add	r6, r0
 8015274:	dd04      	ble.n	8015280 <__sflush_r+0xc0>
 8015276:	2c00      	cmp	r4, #0
 8015278:	dcf2      	bgt.n	8015260 <__sflush_r+0xa0>
 801527a:	2000      	movs	r0, #0
 801527c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8015280:	89ab      	ldrh	r3, [r5, #12]
 8015282:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8015286:	81ab      	strh	r3, [r5, #12]
 8015288:	f04f 30ff 	mov.w	r0, #4294967295
 801528c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8015290:	89ab      	ldrh	r3, [r5, #12]
 8015292:	692a      	ldr	r2, [r5, #16]
 8015294:	6069      	str	r1, [r5, #4]
 8015296:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 801529a:	b29b      	uxth	r3, r3
 801529c:	81ab      	strh	r3, [r5, #12]
 801529e:	04db      	lsls	r3, r3, #19
 80152a0:	602a      	str	r2, [r5, #0]
 80152a2:	d5c3      	bpl.n	801522c <__sflush_r+0x6c>
 80152a4:	6528      	str	r0, [r5, #80]	; 0x50
 80152a6:	e7c1      	b.n	801522c <__sflush_r+0x6c>
 80152a8:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 80152aa:	2a00      	cmp	r2, #0
 80152ac:	dc96      	bgt.n	80151dc <__sflush_r+0x1c>
 80152ae:	e7e4      	b.n	801527a <__sflush_r+0xba>
 80152b0:	2301      	movs	r3, #1
 80152b2:	4640      	mov	r0, r8
 80152b4:	69e9      	ldr	r1, [r5, #28]
 80152b6:	47b0      	blx	r6
 80152b8:	1c43      	adds	r3, r0, #1
 80152ba:	4602      	mov	r2, r0
 80152bc:	d019      	beq.n	80152f2 <__sflush_r+0x132>
 80152be:	89ab      	ldrh	r3, [r5, #12]
 80152c0:	6aae      	ldr	r6, [r5, #40]	; 0x28
 80152c2:	e79a      	b.n	80151fa <__sflush_r+0x3a>
 80152c4:	f8d8 1000 	ldr.w	r1, [r8]
 80152c8:	2900      	cmp	r1, #0
 80152ca:	d0e1      	beq.n	8015290 <__sflush_r+0xd0>
 80152cc:	291d      	cmp	r1, #29
 80152ce:	d007      	beq.n	80152e0 <__sflush_r+0x120>
 80152d0:	2916      	cmp	r1, #22
 80152d2:	d005      	beq.n	80152e0 <__sflush_r+0x120>
 80152d4:	89ab      	ldrh	r3, [r5, #12]
 80152d6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80152da:	81ab      	strh	r3, [r5, #12]
 80152dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80152e0:	89ab      	ldrh	r3, [r5, #12]
 80152e2:	692a      	ldr	r2, [r5, #16]
 80152e4:	602a      	str	r2, [r5, #0]
 80152e6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80152ea:	2200      	movs	r2, #0
 80152ec:	81ab      	strh	r3, [r5, #12]
 80152ee:	606a      	str	r2, [r5, #4]
 80152f0:	e79c      	b.n	801522c <__sflush_r+0x6c>
 80152f2:	f8d8 3000 	ldr.w	r3, [r8]
 80152f6:	2b00      	cmp	r3, #0
 80152f8:	d0e1      	beq.n	80152be <__sflush_r+0xfe>
 80152fa:	2b1d      	cmp	r3, #29
 80152fc:	d007      	beq.n	801530e <__sflush_r+0x14e>
 80152fe:	2b16      	cmp	r3, #22
 8015300:	d005      	beq.n	801530e <__sflush_r+0x14e>
 8015302:	89ab      	ldrh	r3, [r5, #12]
 8015304:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8015308:	81ab      	strh	r3, [r5, #12]
 801530a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801530e:	f8c8 4000 	str.w	r4, [r8]
 8015312:	e7b2      	b.n	801527a <__sflush_r+0xba>
	...

08015320 <_fflush_r>:
 8015320:	b510      	push	{r4, lr}
 8015322:	4604      	mov	r4, r0
 8015324:	b082      	sub	sp, #8
 8015326:	b108      	cbz	r0, 801532c <_fflush_r+0xc>
 8015328:	6b83      	ldr	r3, [r0, #56]	; 0x38
 801532a:	b153      	cbz	r3, 8015342 <_fflush_r+0x22>
 801532c:	f9b1 000c 	ldrsh.w	r0, [r1, #12]
 8015330:	b908      	cbnz	r0, 8015336 <_fflush_r+0x16>
 8015332:	b002      	add	sp, #8
 8015334:	bd10      	pop	{r4, pc}
 8015336:	4620      	mov	r0, r4
 8015338:	b002      	add	sp, #8
 801533a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801533e:	f7ff bf3f 	b.w	80151c0 <__sflush_r>
 8015342:	9101      	str	r1, [sp, #4]
 8015344:	f000 f884 	bl	8015450 <__sinit>
 8015348:	9901      	ldr	r1, [sp, #4]
 801534a:	e7ef      	b.n	801532c <_fflush_r+0xc>
 801534c:	0000      	movs	r0, r0
	...

08015350 <_cleanup_r>:
 8015350:	4901      	ldr	r1, [pc, #4]	; (8015358 <_cleanup_r+0x8>)
 8015352:	f000 bbb5 	b.w	8015ac0 <_fwalk_reent>
 8015356:	bf00      	nop
 8015358:	08016011 	.word	0x08016011
 801535c:	00000000 	.word	0x00000000

08015360 <__sinit.part.1>:
 8015360:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015364:	4b35      	ldr	r3, [pc, #212]	; (801543c <__sinit.part.1+0xdc>)
 8015366:	6845      	ldr	r5, [r0, #4]
 8015368:	63c3      	str	r3, [r0, #60]	; 0x3c
 801536a:	2400      	movs	r4, #0
 801536c:	4607      	mov	r7, r0
 801536e:	f500 723b 	add.w	r2, r0, #748	; 0x2ec
 8015372:	2304      	movs	r3, #4
 8015374:	2103      	movs	r1, #3
 8015376:	f8c0 12e4 	str.w	r1, [r0, #740]	; 0x2e4
 801537a:	f8c0 22e8 	str.w	r2, [r0, #744]	; 0x2e8
 801537e:	f8c0 42e0 	str.w	r4, [r0, #736]	; 0x2e0
 8015382:	b083      	sub	sp, #12
 8015384:	602c      	str	r4, [r5, #0]
 8015386:	606c      	str	r4, [r5, #4]
 8015388:	60ac      	str	r4, [r5, #8]
 801538a:	666c      	str	r4, [r5, #100]	; 0x64
 801538c:	81ec      	strh	r4, [r5, #14]
 801538e:	612c      	str	r4, [r5, #16]
 8015390:	616c      	str	r4, [r5, #20]
 8015392:	61ac      	str	r4, [r5, #24]
 8015394:	81ab      	strh	r3, [r5, #12]
 8015396:	4621      	mov	r1, r4
 8015398:	f105 005c 	add.w	r0, r5, #92	; 0x5c
 801539c:	2208      	movs	r2, #8
 801539e:	f7fe fd17 	bl	8013dd0 <memset>
 80153a2:	68be      	ldr	r6, [r7, #8]
 80153a4:	f8df b098 	ldr.w	fp, [pc, #152]	; 8015440 <__sinit.part.1+0xe0>
 80153a8:	f8df a098 	ldr.w	sl, [pc, #152]	; 8015444 <__sinit.part.1+0xe4>
 80153ac:	f8df 9098 	ldr.w	r9, [pc, #152]	; 8015448 <__sinit.part.1+0xe8>
 80153b0:	f8df 8098 	ldr.w	r8, [pc, #152]	; 801544c <__sinit.part.1+0xec>
 80153b4:	f8c5 b020 	str.w	fp, [r5, #32]
 80153b8:	2301      	movs	r3, #1
 80153ba:	2209      	movs	r2, #9
 80153bc:	f8c5 a024 	str.w	sl, [r5, #36]	; 0x24
 80153c0:	f8c5 9028 	str.w	r9, [r5, #40]	; 0x28
 80153c4:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
 80153c8:	61ed      	str	r5, [r5, #28]
 80153ca:	4621      	mov	r1, r4
 80153cc:	81f3      	strh	r3, [r6, #14]
 80153ce:	81b2      	strh	r2, [r6, #12]
 80153d0:	f106 005c 	add.w	r0, r6, #92	; 0x5c
 80153d4:	6034      	str	r4, [r6, #0]
 80153d6:	6074      	str	r4, [r6, #4]
 80153d8:	60b4      	str	r4, [r6, #8]
 80153da:	6674      	str	r4, [r6, #100]	; 0x64
 80153dc:	6134      	str	r4, [r6, #16]
 80153de:	6174      	str	r4, [r6, #20]
 80153e0:	61b4      	str	r4, [r6, #24]
 80153e2:	2208      	movs	r2, #8
 80153e4:	9301      	str	r3, [sp, #4]
 80153e6:	f7fe fcf3 	bl	8013dd0 <memset>
 80153ea:	68fd      	ldr	r5, [r7, #12]
 80153ec:	61f6      	str	r6, [r6, #28]
 80153ee:	2012      	movs	r0, #18
 80153f0:	2202      	movs	r2, #2
 80153f2:	f8c6 b020 	str.w	fp, [r6, #32]
 80153f6:	f8c6 a024 	str.w	sl, [r6, #36]	; 0x24
 80153fa:	f8c6 9028 	str.w	r9, [r6, #40]	; 0x28
 80153fe:	f8c6 802c 	str.w	r8, [r6, #44]	; 0x2c
 8015402:	4621      	mov	r1, r4
 8015404:	81a8      	strh	r0, [r5, #12]
 8015406:	81ea      	strh	r2, [r5, #14]
 8015408:	602c      	str	r4, [r5, #0]
 801540a:	606c      	str	r4, [r5, #4]
 801540c:	60ac      	str	r4, [r5, #8]
 801540e:	666c      	str	r4, [r5, #100]	; 0x64
 8015410:	612c      	str	r4, [r5, #16]
 8015412:	616c      	str	r4, [r5, #20]
 8015414:	61ac      	str	r4, [r5, #24]
 8015416:	f105 005c 	add.w	r0, r5, #92	; 0x5c
 801541a:	2208      	movs	r2, #8
 801541c:	f7fe fcd8 	bl	8013dd0 <memset>
 8015420:	9b01      	ldr	r3, [sp, #4]
 8015422:	61ed      	str	r5, [r5, #28]
 8015424:	f8c5 b020 	str.w	fp, [r5, #32]
 8015428:	f8c5 a024 	str.w	sl, [r5, #36]	; 0x24
 801542c:	f8c5 9028 	str.w	r9, [r5, #40]	; 0x28
 8015430:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
 8015434:	63bb      	str	r3, [r7, #56]	; 0x38
 8015436:	b003      	add	sp, #12
 8015438:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801543c:	08015351 	.word	0x08015351
 8015440:	08015e41 	.word	0x08015e41
 8015444:	08015e71 	.word	0x08015e71
 8015448:	08015eb1 	.word	0x08015eb1
 801544c:	08015ed1 	.word	0x08015ed1

08015450 <__sinit>:
 8015450:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8015452:	b103      	cbz	r3, 8015456 <__sinit+0x6>
 8015454:	4770      	bx	lr
 8015456:	f7ff bf83 	b.w	8015360 <__sinit.part.1>
 801545a:	bf00      	nop
 801545c:	0000      	movs	r0, r0
	...

08015460 <__sfp_lock_acquire>:
 8015460:	4770      	bx	lr
 8015462:	bf00      	nop
	...

08015470 <__sfp_lock_release>:
 8015470:	4770      	bx	lr
 8015472:	bf00      	nop
	...

08015480 <_fputwc_r>:
 8015480:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015484:	8993      	ldrh	r3, [r2, #12]
 8015486:	4614      	mov	r4, r2
 8015488:	049a      	lsls	r2, r3, #18
 801548a:	b082      	sub	sp, #8
 801548c:	4607      	mov	r7, r0
 801548e:	460e      	mov	r6, r1
 8015490:	d406      	bmi.n	80154a0 <_fputwc_r+0x20>
 8015492:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8015494:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8015498:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 801549c:	81a3      	strh	r3, [r4, #12]
 801549e:	6662      	str	r2, [r4, #100]	; 0x64
 80154a0:	f000 fb46 	bl	8015b30 <__locale_mb_cur_max>
 80154a4:	2801      	cmp	r0, #1
 80154a6:	d041      	beq.n	801552c <_fputwc_r+0xac>
 80154a8:	4638      	mov	r0, r7
 80154aa:	a901      	add	r1, sp, #4
 80154ac:	4632      	mov	r2, r6
 80154ae:	f104 035c 	add.w	r3, r4, #92	; 0x5c
 80154b2:	f000 fd6d 	bl	8015f90 <_wcrtomb_r>
 80154b6:	f1b0 3fff 	cmp.w	r0, #4294967295
 80154ba:	4680      	mov	r8, r0
 80154bc:	d02f      	beq.n	801551e <_fputwc_r+0x9e>
 80154be:	2800      	cmp	r0, #0
 80154c0:	d03c      	beq.n	801553c <_fputwc_r+0xbc>
 80154c2:	f89d 1004 	ldrb.w	r1, [sp, #4]
 80154c6:	2500      	movs	r5, #0
 80154c8:	e009      	b.n	80154de <_fputwc_r+0x5e>
 80154ca:	6823      	ldr	r3, [r4, #0]
 80154cc:	7019      	strb	r1, [r3, #0]
 80154ce:	6823      	ldr	r3, [r4, #0]
 80154d0:	3301      	adds	r3, #1
 80154d2:	6023      	str	r3, [r4, #0]
 80154d4:	3501      	adds	r5, #1
 80154d6:	45a8      	cmp	r8, r5
 80154d8:	d930      	bls.n	801553c <_fputwc_r+0xbc>
 80154da:	ab01      	add	r3, sp, #4
 80154dc:	5d59      	ldrb	r1, [r3, r5]
 80154de:	68a3      	ldr	r3, [r4, #8]
 80154e0:	3b01      	subs	r3, #1
 80154e2:	2b00      	cmp	r3, #0
 80154e4:	60a3      	str	r3, [r4, #8]
 80154e6:	daf0      	bge.n	80154ca <_fputwc_r+0x4a>
 80154e8:	69a2      	ldr	r2, [r4, #24]
 80154ea:	4293      	cmp	r3, r2
 80154ec:	db07      	blt.n	80154fe <_fputwc_r+0x7e>
 80154ee:	6823      	ldr	r3, [r4, #0]
 80154f0:	7019      	strb	r1, [r3, #0]
 80154f2:	6823      	ldr	r3, [r4, #0]
 80154f4:	7819      	ldrb	r1, [r3, #0]
 80154f6:	290a      	cmp	r1, #10
 80154f8:	f103 0301 	add.w	r3, r3, #1
 80154fc:	d1e9      	bne.n	80154d2 <_fputwc_r+0x52>
 80154fe:	4638      	mov	r0, r7
 8015500:	4622      	mov	r2, r4
 8015502:	f000 fced 	bl	8015ee0 <__swbuf_r>
 8015506:	f1a0 30ff 	sub.w	r0, r0, #4294967295
 801550a:	fab0 f080 	clz	r0, r0
 801550e:	0940      	lsrs	r0, r0, #5
 8015510:	2800      	cmp	r0, #0
 8015512:	d0df      	beq.n	80154d4 <_fputwc_r+0x54>
 8015514:	f04f 30ff 	mov.w	r0, #4294967295
 8015518:	b002      	add	sp, #8
 801551a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801551e:	89a3      	ldrh	r3, [r4, #12]
 8015520:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8015524:	81a3      	strh	r3, [r4, #12]
 8015526:	b002      	add	sp, #8
 8015528:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801552c:	1e73      	subs	r3, r6, #1
 801552e:	2bfe      	cmp	r3, #254	; 0xfe
 8015530:	d8ba      	bhi.n	80154a8 <_fputwc_r+0x28>
 8015532:	b2f1      	uxtb	r1, r6
 8015534:	4680      	mov	r8, r0
 8015536:	f88d 1004 	strb.w	r1, [sp, #4]
 801553a:	e7c4      	b.n	80154c6 <_fputwc_r+0x46>
 801553c:	4630      	mov	r0, r6
 801553e:	b002      	add	sp, #8
 8015540:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08015550 <_malloc_trim_r>:
 8015550:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8015552:	4f23      	ldr	r7, [pc, #140]	; (80155e0 <_malloc_trim_r+0x90>)
 8015554:	460c      	mov	r4, r1
 8015556:	4606      	mov	r6, r0
 8015558:	f7fe fc8a 	bl	8013e70 <__malloc_lock>
 801555c:	68bb      	ldr	r3, [r7, #8]
 801555e:	685d      	ldr	r5, [r3, #4]
 8015560:	f025 0503 	bic.w	r5, r5, #3
 8015564:	1b29      	subs	r1, r5, r4
 8015566:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
 801556a:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
 801556e:	f021 010f 	bic.w	r1, r1, #15
 8015572:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
 8015576:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 801557a:	db07      	blt.n	801558c <_malloc_trim_r+0x3c>
 801557c:	4630      	mov	r0, r6
 801557e:	2100      	movs	r1, #0
 8015580:	f7fb fb6e 	bl	8010c60 <_sbrk_r>
 8015584:	68bb      	ldr	r3, [r7, #8]
 8015586:	442b      	add	r3, r5
 8015588:	4298      	cmp	r0, r3
 801558a:	d004      	beq.n	8015596 <_malloc_trim_r+0x46>
 801558c:	4630      	mov	r0, r6
 801558e:	f7fe fc77 	bl	8013e80 <__malloc_unlock>
 8015592:	2000      	movs	r0, #0
 8015594:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8015596:	4630      	mov	r0, r6
 8015598:	4261      	negs	r1, r4
 801559a:	f7fb fb61 	bl	8010c60 <_sbrk_r>
 801559e:	3001      	adds	r0, #1
 80155a0:	d00d      	beq.n	80155be <_malloc_trim_r+0x6e>
 80155a2:	4b10      	ldr	r3, [pc, #64]	; (80155e4 <_malloc_trim_r+0x94>)
 80155a4:	68ba      	ldr	r2, [r7, #8]
 80155a6:	6819      	ldr	r1, [r3, #0]
 80155a8:	1b2d      	subs	r5, r5, r4
 80155aa:	f045 0501 	orr.w	r5, r5, #1
 80155ae:	4630      	mov	r0, r6
 80155b0:	1b09      	subs	r1, r1, r4
 80155b2:	6055      	str	r5, [r2, #4]
 80155b4:	6019      	str	r1, [r3, #0]
 80155b6:	f7fe fc63 	bl	8013e80 <__malloc_unlock>
 80155ba:	2001      	movs	r0, #1
 80155bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80155be:	4630      	mov	r0, r6
 80155c0:	2100      	movs	r1, #0
 80155c2:	f7fb fb4d 	bl	8010c60 <_sbrk_r>
 80155c6:	68ba      	ldr	r2, [r7, #8]
 80155c8:	1a83      	subs	r3, r0, r2
 80155ca:	2b0f      	cmp	r3, #15
 80155cc:	ddde      	ble.n	801558c <_malloc_trim_r+0x3c>
 80155ce:	4c06      	ldr	r4, [pc, #24]	; (80155e8 <_malloc_trim_r+0x98>)
 80155d0:	4904      	ldr	r1, [pc, #16]	; (80155e4 <_malloc_trim_r+0x94>)
 80155d2:	6824      	ldr	r4, [r4, #0]
 80155d4:	f043 0301 	orr.w	r3, r3, #1
 80155d8:	1b00      	subs	r0, r0, r4
 80155da:	6053      	str	r3, [r2, #4]
 80155dc:	6008      	str	r0, [r1, #0]
 80155de:	e7d5      	b.n	801558c <_malloc_trim_r+0x3c>
 80155e0:	20000d14 	.word	0x20000d14
 80155e4:	2001878c 	.word	0x2001878c
 80155e8:	20001120 	.word	0x20001120
 80155ec:	00000000 	.word	0x00000000

080155f0 <_free_r>:
 80155f0:	2900      	cmp	r1, #0
 80155f2:	d04e      	beq.n	8015692 <_free_r+0xa2>
 80155f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80155f8:	460c      	mov	r4, r1
 80155fa:	4680      	mov	r8, r0
 80155fc:	f7fe fc38 	bl	8013e70 <__malloc_lock>
 8015600:	f854 7c04 	ldr.w	r7, [r4, #-4]
 8015604:	4962      	ldr	r1, [pc, #392]	; (8015790 <_free_r+0x1a0>)
 8015606:	f027 0201 	bic.w	r2, r7, #1
 801560a:	f1a4 0508 	sub.w	r5, r4, #8
 801560e:	18ab      	adds	r3, r5, r2
 8015610:	688e      	ldr	r6, [r1, #8]
 8015612:	6858      	ldr	r0, [r3, #4]
 8015614:	429e      	cmp	r6, r3
 8015616:	f020 0003 	bic.w	r0, r0, #3
 801561a:	d05a      	beq.n	80156d2 <_free_r+0xe2>
 801561c:	07fe      	lsls	r6, r7, #31
 801561e:	6058      	str	r0, [r3, #4]
 8015620:	d40b      	bmi.n	801563a <_free_r+0x4a>
 8015622:	f854 7c08 	ldr.w	r7, [r4, #-8]
 8015626:	1bed      	subs	r5, r5, r7
 8015628:	f101 0e08 	add.w	lr, r1, #8
 801562c:	68ac      	ldr	r4, [r5, #8]
 801562e:	4574      	cmp	r4, lr
 8015630:	443a      	add	r2, r7
 8015632:	d067      	beq.n	8015704 <_free_r+0x114>
 8015634:	68ef      	ldr	r7, [r5, #12]
 8015636:	60e7      	str	r7, [r4, #12]
 8015638:	60bc      	str	r4, [r7, #8]
 801563a:	181c      	adds	r4, r3, r0
 801563c:	6864      	ldr	r4, [r4, #4]
 801563e:	07e4      	lsls	r4, r4, #31
 8015640:	d40c      	bmi.n	801565c <_free_r+0x6c>
 8015642:	4f54      	ldr	r7, [pc, #336]	; (8015794 <_free_r+0x1a4>)
 8015644:	689c      	ldr	r4, [r3, #8]
 8015646:	42bc      	cmp	r4, r7
 8015648:	4402      	add	r2, r0
 801564a:	d07c      	beq.n	8015746 <_free_r+0x156>
 801564c:	68d8      	ldr	r0, [r3, #12]
 801564e:	60e0      	str	r0, [r4, #12]
 8015650:	f042 0301 	orr.w	r3, r2, #1
 8015654:	6084      	str	r4, [r0, #8]
 8015656:	606b      	str	r3, [r5, #4]
 8015658:	50aa      	str	r2, [r5, r2]
 801565a:	e003      	b.n	8015664 <_free_r+0x74>
 801565c:	f042 0301 	orr.w	r3, r2, #1
 8015660:	606b      	str	r3, [r5, #4]
 8015662:	50aa      	str	r2, [r5, r2]
 8015664:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8015668:	d214      	bcs.n	8015694 <_free_r+0xa4>
 801566a:	08d2      	lsrs	r2, r2, #3
 801566c:	eb01 03c2 	add.w	r3, r1, r2, lsl #3
 8015670:	6848      	ldr	r0, [r1, #4]
 8015672:	689f      	ldr	r7, [r3, #8]
 8015674:	60af      	str	r7, [r5, #8]
 8015676:	1092      	asrs	r2, r2, #2
 8015678:	2401      	movs	r4, #1
 801567a:	fa04 f202 	lsl.w	r2, r4, r2
 801567e:	4310      	orrs	r0, r2
 8015680:	60eb      	str	r3, [r5, #12]
 8015682:	6048      	str	r0, [r1, #4]
 8015684:	609d      	str	r5, [r3, #8]
 8015686:	60fd      	str	r5, [r7, #12]
 8015688:	4640      	mov	r0, r8
 801568a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 801568e:	f7fe bbf7 	b.w	8013e80 <__malloc_unlock>
 8015692:	4770      	bx	lr
 8015694:	0a53      	lsrs	r3, r2, #9
 8015696:	2b04      	cmp	r3, #4
 8015698:	d847      	bhi.n	801572a <_free_r+0x13a>
 801569a:	0993      	lsrs	r3, r2, #6
 801569c:	f103 0438 	add.w	r4, r3, #56	; 0x38
 80156a0:	0060      	lsls	r0, r4, #1
 80156a2:	eb01 0080 	add.w	r0, r1, r0, lsl #2
 80156a6:	493a      	ldr	r1, [pc, #232]	; (8015790 <_free_r+0x1a0>)
 80156a8:	6883      	ldr	r3, [r0, #8]
 80156aa:	4283      	cmp	r3, r0
 80156ac:	d043      	beq.n	8015736 <_free_r+0x146>
 80156ae:	6859      	ldr	r1, [r3, #4]
 80156b0:	f021 0103 	bic.w	r1, r1, #3
 80156b4:	4291      	cmp	r1, r2
 80156b6:	d902      	bls.n	80156be <_free_r+0xce>
 80156b8:	689b      	ldr	r3, [r3, #8]
 80156ba:	4298      	cmp	r0, r3
 80156bc:	d1f7      	bne.n	80156ae <_free_r+0xbe>
 80156be:	68da      	ldr	r2, [r3, #12]
 80156c0:	60ea      	str	r2, [r5, #12]
 80156c2:	60ab      	str	r3, [r5, #8]
 80156c4:	4640      	mov	r0, r8
 80156c6:	6095      	str	r5, [r2, #8]
 80156c8:	60dd      	str	r5, [r3, #12]
 80156ca:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80156ce:	f7fe bbd7 	b.w	8013e80 <__malloc_unlock>
 80156d2:	07ff      	lsls	r7, r7, #31
 80156d4:	4402      	add	r2, r0
 80156d6:	d407      	bmi.n	80156e8 <_free_r+0xf8>
 80156d8:	f854 3c08 	ldr.w	r3, [r4, #-8]
 80156dc:	1aed      	subs	r5, r5, r3
 80156de:	441a      	add	r2, r3
 80156e0:	68a8      	ldr	r0, [r5, #8]
 80156e2:	68eb      	ldr	r3, [r5, #12]
 80156e4:	60c3      	str	r3, [r0, #12]
 80156e6:	6098      	str	r0, [r3, #8]
 80156e8:	4b2b      	ldr	r3, [pc, #172]	; (8015798 <_free_r+0x1a8>)
 80156ea:	681b      	ldr	r3, [r3, #0]
 80156ec:	f042 0001 	orr.w	r0, r2, #1
 80156f0:	429a      	cmp	r2, r3
 80156f2:	6068      	str	r0, [r5, #4]
 80156f4:	608d      	str	r5, [r1, #8]
 80156f6:	d3c7      	bcc.n	8015688 <_free_r+0x98>
 80156f8:	4b28      	ldr	r3, [pc, #160]	; (801579c <_free_r+0x1ac>)
 80156fa:	4640      	mov	r0, r8
 80156fc:	6819      	ldr	r1, [r3, #0]
 80156fe:	f7ff ff27 	bl	8015550 <_malloc_trim_r>
 8015702:	e7c1      	b.n	8015688 <_free_r+0x98>
 8015704:	1819      	adds	r1, r3, r0
 8015706:	6849      	ldr	r1, [r1, #4]
 8015708:	07c9      	lsls	r1, r1, #31
 801570a:	d409      	bmi.n	8015720 <_free_r+0x130>
 801570c:	68d9      	ldr	r1, [r3, #12]
 801570e:	689b      	ldr	r3, [r3, #8]
 8015710:	4402      	add	r2, r0
 8015712:	f042 0001 	orr.w	r0, r2, #1
 8015716:	60d9      	str	r1, [r3, #12]
 8015718:	608b      	str	r3, [r1, #8]
 801571a:	6068      	str	r0, [r5, #4]
 801571c:	50aa      	str	r2, [r5, r2]
 801571e:	e7b3      	b.n	8015688 <_free_r+0x98>
 8015720:	f042 0301 	orr.w	r3, r2, #1
 8015724:	606b      	str	r3, [r5, #4]
 8015726:	50aa      	str	r2, [r5, r2]
 8015728:	e7ae      	b.n	8015688 <_free_r+0x98>
 801572a:	2b14      	cmp	r3, #20
 801572c:	d814      	bhi.n	8015758 <_free_r+0x168>
 801572e:	f103 045b 	add.w	r4, r3, #91	; 0x5b
 8015732:	0060      	lsls	r0, r4, #1
 8015734:	e7b5      	b.n	80156a2 <_free_r+0xb2>
 8015736:	684a      	ldr	r2, [r1, #4]
 8015738:	10a4      	asrs	r4, r4, #2
 801573a:	2001      	movs	r0, #1
 801573c:	40a0      	lsls	r0, r4
 801573e:	4302      	orrs	r2, r0
 8015740:	604a      	str	r2, [r1, #4]
 8015742:	461a      	mov	r2, r3
 8015744:	e7bc      	b.n	80156c0 <_free_r+0xd0>
 8015746:	f042 0301 	orr.w	r3, r2, #1
 801574a:	614d      	str	r5, [r1, #20]
 801574c:	610d      	str	r5, [r1, #16]
 801574e:	60ec      	str	r4, [r5, #12]
 8015750:	60ac      	str	r4, [r5, #8]
 8015752:	606b      	str	r3, [r5, #4]
 8015754:	50aa      	str	r2, [r5, r2]
 8015756:	e797      	b.n	8015688 <_free_r+0x98>
 8015758:	2b54      	cmp	r3, #84	; 0x54
 801575a:	d804      	bhi.n	8015766 <_free_r+0x176>
 801575c:	0b13      	lsrs	r3, r2, #12
 801575e:	f103 046e 	add.w	r4, r3, #110	; 0x6e
 8015762:	0060      	lsls	r0, r4, #1
 8015764:	e79d      	b.n	80156a2 <_free_r+0xb2>
 8015766:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 801576a:	d804      	bhi.n	8015776 <_free_r+0x186>
 801576c:	0bd3      	lsrs	r3, r2, #15
 801576e:	f103 0477 	add.w	r4, r3, #119	; 0x77
 8015772:	0060      	lsls	r0, r4, #1
 8015774:	e795      	b.n	80156a2 <_free_r+0xb2>
 8015776:	f240 5054 	movw	r0, #1364	; 0x554
 801577a:	4283      	cmp	r3, r0
 801577c:	d804      	bhi.n	8015788 <_free_r+0x198>
 801577e:	0c93      	lsrs	r3, r2, #18
 8015780:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8015784:	0060      	lsls	r0, r4, #1
 8015786:	e78c      	b.n	80156a2 <_free_r+0xb2>
 8015788:	20fc      	movs	r0, #252	; 0xfc
 801578a:	247e      	movs	r4, #126	; 0x7e
 801578c:	e789      	b.n	80156a2 <_free_r+0xb2>
 801578e:	bf00      	nop
 8015790:	20000d14 	.word	0x20000d14
 8015794:	20000d1c 	.word	0x20000d1c
 8015798:	2000111c 	.word	0x2000111c
 801579c:	20018788 	.word	0x20018788

080157a0 <__sfvwrite_r>:
 80157a0:	6893      	ldr	r3, [r2, #8]
 80157a2:	2b00      	cmp	r3, #0
 80157a4:	d07a      	beq.n	801589c <__sfvwrite_r+0xfc>
 80157a6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80157aa:	f8b1 e00c 	ldrh.w	lr, [r1, #12]
 80157ae:	f01e 0f08 	tst.w	lr, #8
 80157b2:	b083      	sub	sp, #12
 80157b4:	460c      	mov	r4, r1
 80157b6:	4681      	mov	r9, r0
 80157b8:	4616      	mov	r6, r2
 80157ba:	d026      	beq.n	801580a <__sfvwrite_r+0x6a>
 80157bc:	690b      	ldr	r3, [r1, #16]
 80157be:	b323      	cbz	r3, 801580a <__sfvwrite_r+0x6a>
 80157c0:	f00e 0802 	and.w	r8, lr, #2
 80157c4:	fa1f f088 	uxth.w	r0, r8
 80157c8:	6835      	ldr	r5, [r6, #0]
 80157ca:	b370      	cbz	r0, 801582a <__sfvwrite_r+0x8a>
 80157cc:	f04f 0a00 	mov.w	sl, #0
 80157d0:	f8df b2e0 	ldr.w	fp, [pc, #736]	; 8015ab4 <__sfvwrite_r+0x314>
 80157d4:	46d0      	mov	r8, sl
 80157d6:	45d8      	cmp	r8, fp
 80157d8:	4643      	mov	r3, r8
 80157da:	4652      	mov	r2, sl
 80157dc:	bf28      	it	cs
 80157de:	465b      	movcs	r3, fp
 80157e0:	4648      	mov	r0, r9
 80157e2:	f1b8 0f00 	cmp.w	r8, #0
 80157e6:	d053      	beq.n	8015890 <__sfvwrite_r+0xf0>
 80157e8:	69e1      	ldr	r1, [r4, #28]
 80157ea:	6a67      	ldr	r7, [r4, #36]	; 0x24
 80157ec:	47b8      	blx	r7
 80157ee:	2800      	cmp	r0, #0
 80157f0:	dd73      	ble.n	80158da <__sfvwrite_r+0x13a>
 80157f2:	68b3      	ldr	r3, [r6, #8]
 80157f4:	1a1b      	subs	r3, r3, r0
 80157f6:	4482      	add	sl, r0
 80157f8:	ebc0 0808 	rsb	r8, r0, r8
 80157fc:	60b3      	str	r3, [r6, #8]
 80157fe:	2b00      	cmp	r3, #0
 8015800:	d1e9      	bne.n	80157d6 <__sfvwrite_r+0x36>
 8015802:	2000      	movs	r0, #0
 8015804:	b003      	add	sp, #12
 8015806:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801580a:	4648      	mov	r0, r9
 801580c:	4621      	mov	r1, r4
 801580e:	f7ff fc67 	bl	80150e0 <__swsetup_r>
 8015812:	2800      	cmp	r0, #0
 8015814:	f040 8145 	bne.w	8015aa2 <__sfvwrite_r+0x302>
 8015818:	f8b4 e00c 	ldrh.w	lr, [r4, #12]
 801581c:	6835      	ldr	r5, [r6, #0]
 801581e:	f00e 0802 	and.w	r8, lr, #2
 8015822:	fa1f f088 	uxth.w	r0, r8
 8015826:	2800      	cmp	r0, #0
 8015828:	d1d0      	bne.n	80157cc <__sfvwrite_r+0x2c>
 801582a:	f01e 0b01 	ands.w	fp, lr, #1
 801582e:	d15d      	bne.n	80158ec <__sfvwrite_r+0x14c>
 8015830:	46d8      	mov	r8, fp
 8015832:	f1b8 0f00 	cmp.w	r8, #0
 8015836:	d025      	beq.n	8015884 <__sfvwrite_r+0xe4>
 8015838:	f41e 7f00 	tst.w	lr, #512	; 0x200
 801583c:	68a7      	ldr	r7, [r4, #8]
 801583e:	d02f      	beq.n	80158a0 <__sfvwrite_r+0x100>
 8015840:	45b8      	cmp	r8, r7
 8015842:	46ba      	mov	sl, r7
 8015844:	f0c0 80a9 	bcc.w	801599a <__sfvwrite_r+0x1fa>
 8015848:	f41e 6f90 	tst.w	lr, #1152	; 0x480
 801584c:	f040 80b6 	bne.w	80159bc <__sfvwrite_r+0x21c>
 8015850:	6820      	ldr	r0, [r4, #0]
 8015852:	4652      	mov	r2, sl
 8015854:	4659      	mov	r1, fp
 8015856:	f000 fa33 	bl	8015cc0 <memmove>
 801585a:	68a0      	ldr	r0, [r4, #8]
 801585c:	6822      	ldr	r2, [r4, #0]
 801585e:	1bc0      	subs	r0, r0, r7
 8015860:	eb02 030a 	add.w	r3, r2, sl
 8015864:	60a0      	str	r0, [r4, #8]
 8015866:	6023      	str	r3, [r4, #0]
 8015868:	4640      	mov	r0, r8
 801586a:	68b3      	ldr	r3, [r6, #8]
 801586c:	1a1b      	subs	r3, r3, r0
 801586e:	4483      	add	fp, r0
 8015870:	ebc0 0808 	rsb	r8, r0, r8
 8015874:	60b3      	str	r3, [r6, #8]
 8015876:	2b00      	cmp	r3, #0
 8015878:	d0c3      	beq.n	8015802 <__sfvwrite_r+0x62>
 801587a:	f8b4 e00c 	ldrh.w	lr, [r4, #12]
 801587e:	f1b8 0f00 	cmp.w	r8, #0
 8015882:	d1d9      	bne.n	8015838 <__sfvwrite_r+0x98>
 8015884:	f8d5 b000 	ldr.w	fp, [r5]
 8015888:	f8d5 8004 	ldr.w	r8, [r5, #4]
 801588c:	3508      	adds	r5, #8
 801588e:	e7d0      	b.n	8015832 <__sfvwrite_r+0x92>
 8015890:	f8d5 a000 	ldr.w	sl, [r5]
 8015894:	f8d5 8004 	ldr.w	r8, [r5, #4]
 8015898:	3508      	adds	r5, #8
 801589a:	e79c      	b.n	80157d6 <__sfvwrite_r+0x36>
 801589c:	2000      	movs	r0, #0
 801589e:	4770      	bx	lr
 80158a0:	6820      	ldr	r0, [r4, #0]
 80158a2:	6923      	ldr	r3, [r4, #16]
 80158a4:	4298      	cmp	r0, r3
 80158a6:	d803      	bhi.n	80158b0 <__sfvwrite_r+0x110>
 80158a8:	6962      	ldr	r2, [r4, #20]
 80158aa:	4590      	cmp	r8, r2
 80158ac:	f080 80b9 	bcs.w	8015a22 <__sfvwrite_r+0x282>
 80158b0:	4547      	cmp	r7, r8
 80158b2:	bf28      	it	cs
 80158b4:	4647      	movcs	r7, r8
 80158b6:	463a      	mov	r2, r7
 80158b8:	4659      	mov	r1, fp
 80158ba:	f000 fa01 	bl	8015cc0 <memmove>
 80158be:	68a3      	ldr	r3, [r4, #8]
 80158c0:	6822      	ldr	r2, [r4, #0]
 80158c2:	1bdb      	subs	r3, r3, r7
 80158c4:	443a      	add	r2, r7
 80158c6:	60a3      	str	r3, [r4, #8]
 80158c8:	6022      	str	r2, [r4, #0]
 80158ca:	2b00      	cmp	r3, #0
 80158cc:	d14a      	bne.n	8015964 <__sfvwrite_r+0x1c4>
 80158ce:	4648      	mov	r0, r9
 80158d0:	4621      	mov	r1, r4
 80158d2:	f7ff fd25 	bl	8015320 <_fflush_r>
 80158d6:	2800      	cmp	r0, #0
 80158d8:	d044      	beq.n	8015964 <__sfvwrite_r+0x1c4>
 80158da:	89a3      	ldrh	r3, [r4, #12]
 80158dc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80158e0:	f04f 30ff 	mov.w	r0, #4294967295
 80158e4:	81a3      	strh	r3, [r4, #12]
 80158e6:	b003      	add	sp, #12
 80158e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80158ec:	4680      	mov	r8, r0
 80158ee:	9000      	str	r0, [sp, #0]
 80158f0:	4683      	mov	fp, r0
 80158f2:	4682      	mov	sl, r0
 80158f4:	f1ba 0f00 	cmp.w	sl, #0
 80158f8:	d02c      	beq.n	8015954 <__sfvwrite_r+0x1b4>
 80158fa:	9b00      	ldr	r3, [sp, #0]
 80158fc:	2b00      	cmp	r3, #0
 80158fe:	d050      	beq.n	80159a2 <__sfvwrite_r+0x202>
 8015900:	6820      	ldr	r0, [r4, #0]
 8015902:	6921      	ldr	r1, [r4, #16]
 8015904:	f8d4 e008 	ldr.w	lr, [r4, #8]
 8015908:	6962      	ldr	r2, [r4, #20]
 801590a:	45d0      	cmp	r8, sl
 801590c:	4643      	mov	r3, r8
 801590e:	bf28      	it	cs
 8015910:	4653      	movcs	r3, sl
 8015912:	4288      	cmp	r0, r1
 8015914:	461f      	mov	r7, r3
 8015916:	d904      	bls.n	8015922 <__sfvwrite_r+0x182>
 8015918:	eb0e 0c02 	add.w	ip, lr, r2
 801591c:	4563      	cmp	r3, ip
 801591e:	f300 8092 	bgt.w	8015a46 <__sfvwrite_r+0x2a6>
 8015922:	4293      	cmp	r3, r2
 8015924:	db20      	blt.n	8015968 <__sfvwrite_r+0x1c8>
 8015926:	4613      	mov	r3, r2
 8015928:	6a67      	ldr	r7, [r4, #36]	; 0x24
 801592a:	69e1      	ldr	r1, [r4, #28]
 801592c:	4648      	mov	r0, r9
 801592e:	465a      	mov	r2, fp
 8015930:	47b8      	blx	r7
 8015932:	1e07      	subs	r7, r0, #0
 8015934:	ddd1      	ble.n	80158da <__sfvwrite_r+0x13a>
 8015936:	ebb8 0807 	subs.w	r8, r8, r7
 801593a:	d025      	beq.n	8015988 <__sfvwrite_r+0x1e8>
 801593c:	68b3      	ldr	r3, [r6, #8]
 801593e:	1bdb      	subs	r3, r3, r7
 8015940:	44bb      	add	fp, r7
 8015942:	ebc7 0a0a 	rsb	sl, r7, sl
 8015946:	60b3      	str	r3, [r6, #8]
 8015948:	2b00      	cmp	r3, #0
 801594a:	f43f af5a 	beq.w	8015802 <__sfvwrite_r+0x62>
 801594e:	f1ba 0f00 	cmp.w	sl, #0
 8015952:	d1d2      	bne.n	80158fa <__sfvwrite_r+0x15a>
 8015954:	2300      	movs	r3, #0
 8015956:	f8d5 b000 	ldr.w	fp, [r5]
 801595a:	f8d5 a004 	ldr.w	sl, [r5, #4]
 801595e:	9300      	str	r3, [sp, #0]
 8015960:	3508      	adds	r5, #8
 8015962:	e7c7      	b.n	80158f4 <__sfvwrite_r+0x154>
 8015964:	4638      	mov	r0, r7
 8015966:	e780      	b.n	801586a <__sfvwrite_r+0xca>
 8015968:	461a      	mov	r2, r3
 801596a:	4659      	mov	r1, fp
 801596c:	9301      	str	r3, [sp, #4]
 801596e:	f000 f9a7 	bl	8015cc0 <memmove>
 8015972:	68a2      	ldr	r2, [r4, #8]
 8015974:	6821      	ldr	r1, [r4, #0]
 8015976:	9b01      	ldr	r3, [sp, #4]
 8015978:	ebb8 0807 	subs.w	r8, r8, r7
 801597c:	eba2 0203 	sub.w	r2, r2, r3
 8015980:	440b      	add	r3, r1
 8015982:	60a2      	str	r2, [r4, #8]
 8015984:	6023      	str	r3, [r4, #0]
 8015986:	d1d9      	bne.n	801593c <__sfvwrite_r+0x19c>
 8015988:	4648      	mov	r0, r9
 801598a:	4621      	mov	r1, r4
 801598c:	f7ff fcc8 	bl	8015320 <_fflush_r>
 8015990:	2800      	cmp	r0, #0
 8015992:	d1a2      	bne.n	80158da <__sfvwrite_r+0x13a>
 8015994:	f8cd 8000 	str.w	r8, [sp]
 8015998:	e7d0      	b.n	801593c <__sfvwrite_r+0x19c>
 801599a:	6820      	ldr	r0, [r4, #0]
 801599c:	4647      	mov	r7, r8
 801599e:	46c2      	mov	sl, r8
 80159a0:	e757      	b.n	8015852 <__sfvwrite_r+0xb2>
 80159a2:	4658      	mov	r0, fp
 80159a4:	210a      	movs	r1, #10
 80159a6:	4652      	mov	r2, sl
 80159a8:	f000 f93a 	bl	8015c20 <memchr>
 80159ac:	2800      	cmp	r0, #0
 80159ae:	d073      	beq.n	8015a98 <__sfvwrite_r+0x2f8>
 80159b0:	3001      	adds	r0, #1
 80159b2:	2301      	movs	r3, #1
 80159b4:	ebcb 0800 	rsb	r8, fp, r0
 80159b8:	9300      	str	r3, [sp, #0]
 80159ba:	e7a1      	b.n	8015900 <__sfvwrite_r+0x160>
 80159bc:	6967      	ldr	r7, [r4, #20]
 80159be:	6921      	ldr	r1, [r4, #16]
 80159c0:	6823      	ldr	r3, [r4, #0]
 80159c2:	eb07 0747 	add.w	r7, r7, r7, lsl #1
 80159c6:	1a5b      	subs	r3, r3, r1
 80159c8:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
 80159cc:	1c58      	adds	r0, r3, #1
 80159ce:	107f      	asrs	r7, r7, #1
 80159d0:	4440      	add	r0, r8
 80159d2:	4287      	cmp	r7, r0
 80159d4:	463a      	mov	r2, r7
 80159d6:	bf3c      	itt	cc
 80159d8:	4607      	movcc	r7, r0
 80159da:	463a      	movcc	r2, r7
 80159dc:	f41e 6f80 	tst.w	lr, #1024	; 0x400
 80159e0:	9300      	str	r3, [sp, #0]
 80159e2:	d046      	beq.n	8015a72 <__sfvwrite_r+0x2d2>
 80159e4:	4611      	mov	r1, r2
 80159e6:	4648      	mov	r0, r9
 80159e8:	f7fd ff2a 	bl	8013840 <_malloc_r>
 80159ec:	9b00      	ldr	r3, [sp, #0]
 80159ee:	4682      	mov	sl, r0
 80159f0:	2800      	cmp	r0, #0
 80159f2:	d059      	beq.n	8015aa8 <__sfvwrite_r+0x308>
 80159f4:	461a      	mov	r2, r3
 80159f6:	6921      	ldr	r1, [r4, #16]
 80159f8:	9300      	str	r3, [sp, #0]
 80159fa:	f7ea ff61 	bl	80008c0 <memcpy>
 80159fe:	89a2      	ldrh	r2, [r4, #12]
 8015a00:	9b00      	ldr	r3, [sp, #0]
 8015a02:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 8015a06:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8015a0a:	81a2      	strh	r2, [r4, #12]
 8015a0c:	eb0a 0003 	add.w	r0, sl, r3
 8015a10:	1afb      	subs	r3, r7, r3
 8015a12:	f8c4 a010 	str.w	sl, [r4, #16]
 8015a16:	6167      	str	r7, [r4, #20]
 8015a18:	6020      	str	r0, [r4, #0]
 8015a1a:	60a3      	str	r3, [r4, #8]
 8015a1c:	4647      	mov	r7, r8
 8015a1e:	46c2      	mov	sl, r8
 8015a20:	e717      	b.n	8015852 <__sfvwrite_r+0xb2>
 8015a22:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 8015a26:	4543      	cmp	r3, r8
 8015a28:	bf28      	it	cs
 8015a2a:	4643      	movcs	r3, r8
 8015a2c:	6a67      	ldr	r7, [r4, #36]	; 0x24
 8015a2e:	fb93 f3f2 	sdiv	r3, r3, r2
 8015a32:	4648      	mov	r0, r9
 8015a34:	fb03 f302 	mul.w	r3, r3, r2
 8015a38:	69e1      	ldr	r1, [r4, #28]
 8015a3a:	465a      	mov	r2, fp
 8015a3c:	47b8      	blx	r7
 8015a3e:	2800      	cmp	r0, #0
 8015a40:	f73f af13 	bgt.w	801586a <__sfvwrite_r+0xca>
 8015a44:	e749      	b.n	80158da <__sfvwrite_r+0x13a>
 8015a46:	4662      	mov	r2, ip
 8015a48:	4659      	mov	r1, fp
 8015a4a:	f8cd c004 	str.w	ip, [sp, #4]
 8015a4e:	f000 f937 	bl	8015cc0 <memmove>
 8015a52:	6823      	ldr	r3, [r4, #0]
 8015a54:	f8dd c004 	ldr.w	ip, [sp, #4]
 8015a58:	4463      	add	r3, ip
 8015a5a:	6023      	str	r3, [r4, #0]
 8015a5c:	4648      	mov	r0, r9
 8015a5e:	4621      	mov	r1, r4
 8015a60:	f7ff fc5e 	bl	8015320 <_fflush_r>
 8015a64:	f8dd c004 	ldr.w	ip, [sp, #4]
 8015a68:	2800      	cmp	r0, #0
 8015a6a:	f47f af36 	bne.w	80158da <__sfvwrite_r+0x13a>
 8015a6e:	4667      	mov	r7, ip
 8015a70:	e761      	b.n	8015936 <__sfvwrite_r+0x196>
 8015a72:	4648      	mov	r0, r9
 8015a74:	f7fe fa0c 	bl	8013e90 <_realloc_r>
 8015a78:	9b00      	ldr	r3, [sp, #0]
 8015a7a:	4682      	mov	sl, r0
 8015a7c:	2800      	cmp	r0, #0
 8015a7e:	d1c5      	bne.n	8015a0c <__sfvwrite_r+0x26c>
 8015a80:	4648      	mov	r0, r9
 8015a82:	6921      	ldr	r1, [r4, #16]
 8015a84:	f7ff fdb4 	bl	80155f0 <_free_r>
 8015a88:	89a3      	ldrh	r3, [r4, #12]
 8015a8a:	220c      	movs	r2, #12
 8015a8c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8015a90:	b29b      	uxth	r3, r3
 8015a92:	f8c9 2000 	str.w	r2, [r9]
 8015a96:	e721      	b.n	80158dc <__sfvwrite_r+0x13c>
 8015a98:	2301      	movs	r3, #1
 8015a9a:	f10a 0801 	add.w	r8, sl, #1
 8015a9e:	9300      	str	r3, [sp, #0]
 8015aa0:	e72e      	b.n	8015900 <__sfvwrite_r+0x160>
 8015aa2:	f04f 30ff 	mov.w	r0, #4294967295
 8015aa6:	e6ad      	b.n	8015804 <__sfvwrite_r+0x64>
 8015aa8:	230c      	movs	r3, #12
 8015aaa:	f8c9 3000 	str.w	r3, [r9]
 8015aae:	89a3      	ldrh	r3, [r4, #12]
 8015ab0:	e714      	b.n	80158dc <__sfvwrite_r+0x13c>
 8015ab2:	bf00      	nop
 8015ab4:	7ffffc00 	.word	0x7ffffc00
	...

08015ac0 <_fwalk_reent>:
 8015ac0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8015ac4:	f510 7738 	adds.w	r7, r0, #736	; 0x2e0
 8015ac8:	d01f      	beq.n	8015b0a <_fwalk_reent+0x4a>
 8015aca:	4688      	mov	r8, r1
 8015acc:	4606      	mov	r6, r0
 8015ace:	f04f 0900 	mov.w	r9, #0
 8015ad2:	687d      	ldr	r5, [r7, #4]
 8015ad4:	68bc      	ldr	r4, [r7, #8]
 8015ad6:	3d01      	subs	r5, #1
 8015ad8:	d411      	bmi.n	8015afe <_fwalk_reent+0x3e>
 8015ada:	89a3      	ldrh	r3, [r4, #12]
 8015adc:	2b01      	cmp	r3, #1
 8015ade:	f105 35ff 	add.w	r5, r5, #4294967295
 8015ae2:	d908      	bls.n	8015af6 <_fwalk_reent+0x36>
 8015ae4:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 8015ae8:	3301      	adds	r3, #1
 8015aea:	4621      	mov	r1, r4
 8015aec:	4630      	mov	r0, r6
 8015aee:	d002      	beq.n	8015af6 <_fwalk_reent+0x36>
 8015af0:	47c0      	blx	r8
 8015af2:	ea49 0900 	orr.w	r9, r9, r0
 8015af6:	1c6b      	adds	r3, r5, #1
 8015af8:	f104 0468 	add.w	r4, r4, #104	; 0x68
 8015afc:	d1ed      	bne.n	8015ada <_fwalk_reent+0x1a>
 8015afe:	683f      	ldr	r7, [r7, #0]
 8015b00:	2f00      	cmp	r7, #0
 8015b02:	d1e6      	bne.n	8015ad2 <_fwalk_reent+0x12>
 8015b04:	4648      	mov	r0, r9
 8015b06:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8015b0a:	46b9      	mov	r9, r7
 8015b0c:	4648      	mov	r0, r9
 8015b0e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8015b12:	bf00      	nop
	...

08015b20 <__locale_charset>:
 8015b20:	4800      	ldr	r0, [pc, #0]	; (8015b24 <__locale_charset+0x4>)
 8015b22:	4770      	bx	lr
 8015b24:	20001124 	.word	0x20001124
	...

08015b30 <__locale_mb_cur_max>:
 8015b30:	4b01      	ldr	r3, [pc, #4]	; (8015b38 <__locale_mb_cur_max+0x8>)
 8015b32:	6818      	ldr	r0, [r3, #0]
 8015b34:	4770      	bx	lr
 8015b36:	bf00      	nop
 8015b38:	20001144 	.word	0x20001144
 8015b3c:	00000000 	.word	0x00000000

08015b40 <__smakebuf_r>:
 8015b40:	898b      	ldrh	r3, [r1, #12]
 8015b42:	b29a      	uxth	r2, r3
 8015b44:	f012 0f02 	tst.w	r2, #2
 8015b48:	d13c      	bne.n	8015bc4 <__smakebuf_r+0x84>
 8015b4a:	b5f0      	push	{r4, r5, r6, r7, lr}
 8015b4c:	460c      	mov	r4, r1
 8015b4e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8015b52:	2900      	cmp	r1, #0
 8015b54:	b091      	sub	sp, #68	; 0x44
 8015b56:	4605      	mov	r5, r0
 8015b58:	db19      	blt.n	8015b8e <__smakebuf_r+0x4e>
 8015b5a:	aa01      	add	r2, sp, #4
 8015b5c:	f7fb f890 	bl	8010c80 <_fstat_r>
 8015b60:	2800      	cmp	r0, #0
 8015b62:	db12      	blt.n	8015b8a <__smakebuf_r+0x4a>
 8015b64:	9b02      	ldr	r3, [sp, #8]
 8015b66:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
 8015b6a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8015b6e:	f5a3 5700 	sub.w	r7, r3, #8192	; 0x2000
 8015b72:	fab7 f787 	clz	r7, r7
 8015b76:	ea4f 1757 	mov.w	r7, r7, lsr #5
 8015b7a:	d02a      	beq.n	8015bd2 <__smakebuf_r+0x92>
 8015b7c:	89a3      	ldrh	r3, [r4, #12]
 8015b7e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8015b82:	81a3      	strh	r3, [r4, #12]
 8015b84:	f44f 6680 	mov.w	r6, #1024	; 0x400
 8015b88:	e00b      	b.n	8015ba2 <__smakebuf_r+0x62>
 8015b8a:	89a3      	ldrh	r3, [r4, #12]
 8015b8c:	b29a      	uxth	r2, r3
 8015b8e:	f012 0f80 	tst.w	r2, #128	; 0x80
 8015b92:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8015b96:	81a3      	strh	r3, [r4, #12]
 8015b98:	bf0c      	ite	eq
 8015b9a:	f44f 6680 	moveq.w	r6, #1024	; 0x400
 8015b9e:	2640      	movne	r6, #64	; 0x40
 8015ba0:	2700      	movs	r7, #0
 8015ba2:	4628      	mov	r0, r5
 8015ba4:	4631      	mov	r1, r6
 8015ba6:	f7fd fe4b 	bl	8013840 <_malloc_r>
 8015baa:	89a3      	ldrh	r3, [r4, #12]
 8015bac:	b340      	cbz	r0, 8015c00 <__smakebuf_r+0xc0>
 8015bae:	4a1a      	ldr	r2, [pc, #104]	; (8015c18 <__smakebuf_r+0xd8>)
 8015bb0:	63ea      	str	r2, [r5, #60]	; 0x3c
 8015bb2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8015bb6:	81a3      	strh	r3, [r4, #12]
 8015bb8:	6020      	str	r0, [r4, #0]
 8015bba:	6120      	str	r0, [r4, #16]
 8015bbc:	6166      	str	r6, [r4, #20]
 8015bbe:	b99f      	cbnz	r7, 8015be8 <__smakebuf_r+0xa8>
 8015bc0:	b011      	add	sp, #68	; 0x44
 8015bc2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8015bc4:	f101 0343 	add.w	r3, r1, #67	; 0x43
 8015bc8:	2201      	movs	r2, #1
 8015bca:	600b      	str	r3, [r1, #0]
 8015bcc:	610b      	str	r3, [r1, #16]
 8015bce:	614a      	str	r2, [r1, #20]
 8015bd0:	4770      	bx	lr
 8015bd2:	4b12      	ldr	r3, [pc, #72]	; (8015c1c <__smakebuf_r+0xdc>)
 8015bd4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8015bd6:	429a      	cmp	r2, r3
 8015bd8:	d1d0      	bne.n	8015b7c <__smakebuf_r+0x3c>
 8015bda:	89a3      	ldrh	r3, [r4, #12]
 8015bdc:	f44f 6680 	mov.w	r6, #1024	; 0x400
 8015be0:	4333      	orrs	r3, r6
 8015be2:	81a3      	strh	r3, [r4, #12]
 8015be4:	64e6      	str	r6, [r4, #76]	; 0x4c
 8015be6:	e7dc      	b.n	8015ba2 <__smakebuf_r+0x62>
 8015be8:	4628      	mov	r0, r5
 8015bea:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8015bee:	f7fb f857 	bl	8010ca0 <_isatty_r>
 8015bf2:	2800      	cmp	r0, #0
 8015bf4:	d0e4      	beq.n	8015bc0 <__smakebuf_r+0x80>
 8015bf6:	89a3      	ldrh	r3, [r4, #12]
 8015bf8:	f043 0301 	orr.w	r3, r3, #1
 8015bfc:	81a3      	strh	r3, [r4, #12]
 8015bfe:	e7df      	b.n	8015bc0 <__smakebuf_r+0x80>
 8015c00:	059a      	lsls	r2, r3, #22
 8015c02:	d4dd      	bmi.n	8015bc0 <__smakebuf_r+0x80>
 8015c04:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8015c08:	f043 0302 	orr.w	r3, r3, #2
 8015c0c:	2101      	movs	r1, #1
 8015c0e:	81a3      	strh	r3, [r4, #12]
 8015c10:	6022      	str	r2, [r4, #0]
 8015c12:	6122      	str	r2, [r4, #16]
 8015c14:	6161      	str	r1, [r4, #20]
 8015c16:	e7d3      	b.n	8015bc0 <__smakebuf_r+0x80>
 8015c18:	08015351 	.word	0x08015351
 8015c1c:	08015eb1 	.word	0x08015eb1

08015c20 <memchr>:
 8015c20:	0783      	lsls	r3, r0, #30
 8015c22:	b470      	push	{r4, r5, r6}
 8015c24:	b2c9      	uxtb	r1, r1
 8015c26:	d040      	beq.n	8015caa <memchr+0x8a>
 8015c28:	1e54      	subs	r4, r2, #1
 8015c2a:	2a00      	cmp	r2, #0
 8015c2c:	d03f      	beq.n	8015cae <memchr+0x8e>
 8015c2e:	7803      	ldrb	r3, [r0, #0]
 8015c30:	428b      	cmp	r3, r1
 8015c32:	bf18      	it	ne
 8015c34:	1c43      	addne	r3, r0, #1
 8015c36:	d106      	bne.n	8015c46 <memchr+0x26>
 8015c38:	e01d      	b.n	8015c76 <memchr+0x56>
 8015c3a:	b1f4      	cbz	r4, 8015c7a <memchr+0x5a>
 8015c3c:	7802      	ldrb	r2, [r0, #0]
 8015c3e:	428a      	cmp	r2, r1
 8015c40:	f104 34ff 	add.w	r4, r4, #4294967295
 8015c44:	d017      	beq.n	8015c76 <memchr+0x56>
 8015c46:	f013 0f03 	tst.w	r3, #3
 8015c4a:	4618      	mov	r0, r3
 8015c4c:	f103 0301 	add.w	r3, r3, #1
 8015c50:	d1f3      	bne.n	8015c3a <memchr+0x1a>
 8015c52:	2c03      	cmp	r4, #3
 8015c54:	d814      	bhi.n	8015c80 <memchr+0x60>
 8015c56:	b184      	cbz	r4, 8015c7a <memchr+0x5a>
 8015c58:	7803      	ldrb	r3, [r0, #0]
 8015c5a:	428b      	cmp	r3, r1
 8015c5c:	d00b      	beq.n	8015c76 <memchr+0x56>
 8015c5e:	1905      	adds	r5, r0, r4
 8015c60:	1c43      	adds	r3, r0, #1
 8015c62:	e002      	b.n	8015c6a <memchr+0x4a>
 8015c64:	7802      	ldrb	r2, [r0, #0]
 8015c66:	428a      	cmp	r2, r1
 8015c68:	d005      	beq.n	8015c76 <memchr+0x56>
 8015c6a:	42ab      	cmp	r3, r5
 8015c6c:	4618      	mov	r0, r3
 8015c6e:	f103 0301 	add.w	r3, r3, #1
 8015c72:	d1f7      	bne.n	8015c64 <memchr+0x44>
 8015c74:	2000      	movs	r0, #0
 8015c76:	bc70      	pop	{r4, r5, r6}
 8015c78:	4770      	bx	lr
 8015c7a:	4620      	mov	r0, r4
 8015c7c:	bc70      	pop	{r4, r5, r6}
 8015c7e:	4770      	bx	lr
 8015c80:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 8015c84:	4602      	mov	r2, r0
 8015c86:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 8015c8a:	4610      	mov	r0, r2
 8015c8c:	3204      	adds	r2, #4
 8015c8e:	6803      	ldr	r3, [r0, #0]
 8015c90:	4073      	eors	r3, r6
 8015c92:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
 8015c96:	ea25 0303 	bic.w	r3, r5, r3
 8015c9a:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8015c9e:	d1da      	bne.n	8015c56 <memchr+0x36>
 8015ca0:	3c04      	subs	r4, #4
 8015ca2:	2c03      	cmp	r4, #3
 8015ca4:	4610      	mov	r0, r2
 8015ca6:	d8f0      	bhi.n	8015c8a <memchr+0x6a>
 8015ca8:	e7d5      	b.n	8015c56 <memchr+0x36>
 8015caa:	4614      	mov	r4, r2
 8015cac:	e7d1      	b.n	8015c52 <memchr+0x32>
 8015cae:	4610      	mov	r0, r2
 8015cb0:	e7e1      	b.n	8015c76 <memchr+0x56>
 8015cb2:	bf00      	nop
	...

08015cc0 <memmove>:
 8015cc0:	4288      	cmp	r0, r1
 8015cc2:	b5f0      	push	{r4, r5, r6, r7, lr}
 8015cc4:	d90d      	bls.n	8015ce2 <memmove+0x22>
 8015cc6:	188b      	adds	r3, r1, r2
 8015cc8:	4298      	cmp	r0, r3
 8015cca:	d20a      	bcs.n	8015ce2 <memmove+0x22>
 8015ccc:	1881      	adds	r1, r0, r2
 8015cce:	2a00      	cmp	r2, #0
 8015cd0:	d054      	beq.n	8015d7c <memmove+0xbc>
 8015cd2:	1a9a      	subs	r2, r3, r2
 8015cd4:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8015cd8:	f801 4d01 	strb.w	r4, [r1, #-1]!
 8015cdc:	4293      	cmp	r3, r2
 8015cde:	d1f9      	bne.n	8015cd4 <memmove+0x14>
 8015ce0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8015ce2:	2a0f      	cmp	r2, #15
 8015ce4:	d948      	bls.n	8015d78 <memmove+0xb8>
 8015ce6:	ea40 0301 	orr.w	r3, r0, r1
 8015cea:	079b      	lsls	r3, r3, #30
 8015cec:	d147      	bne.n	8015d7e <memmove+0xbe>
 8015cee:	f100 0410 	add.w	r4, r0, #16
 8015cf2:	f101 0310 	add.w	r3, r1, #16
 8015cf6:	4615      	mov	r5, r2
 8015cf8:	f853 6c10 	ldr.w	r6, [r3, #-16]
 8015cfc:	f844 6c10 	str.w	r6, [r4, #-16]
 8015d00:	f853 6c0c 	ldr.w	r6, [r3, #-12]
 8015d04:	f844 6c0c 	str.w	r6, [r4, #-12]
 8015d08:	f853 6c08 	ldr.w	r6, [r3, #-8]
 8015d0c:	f844 6c08 	str.w	r6, [r4, #-8]
 8015d10:	3d10      	subs	r5, #16
 8015d12:	f853 6c04 	ldr.w	r6, [r3, #-4]
 8015d16:	f844 6c04 	str.w	r6, [r4, #-4]
 8015d1a:	2d0f      	cmp	r5, #15
 8015d1c:	f103 0310 	add.w	r3, r3, #16
 8015d20:	f104 0410 	add.w	r4, r4, #16
 8015d24:	d8e8      	bhi.n	8015cf8 <memmove+0x38>
 8015d26:	f1a2 0310 	sub.w	r3, r2, #16
 8015d2a:	f023 030f 	bic.w	r3, r3, #15
 8015d2e:	f002 0e0f 	and.w	lr, r2, #15
 8015d32:	3310      	adds	r3, #16
 8015d34:	f1be 0f03 	cmp.w	lr, #3
 8015d38:	4419      	add	r1, r3
 8015d3a:	4403      	add	r3, r0
 8015d3c:	d921      	bls.n	8015d82 <memmove+0xc2>
 8015d3e:	1f1e      	subs	r6, r3, #4
 8015d40:	460d      	mov	r5, r1
 8015d42:	4674      	mov	r4, lr
 8015d44:	3c04      	subs	r4, #4
 8015d46:	f855 7b04 	ldr.w	r7, [r5], #4
 8015d4a:	f846 7f04 	str.w	r7, [r6, #4]!
 8015d4e:	2c03      	cmp	r4, #3
 8015d50:	d8f8      	bhi.n	8015d44 <memmove+0x84>
 8015d52:	f1ae 0404 	sub.w	r4, lr, #4
 8015d56:	f024 0403 	bic.w	r4, r4, #3
 8015d5a:	3404      	adds	r4, #4
 8015d5c:	4423      	add	r3, r4
 8015d5e:	4421      	add	r1, r4
 8015d60:	f002 0203 	and.w	r2, r2, #3
 8015d64:	b152      	cbz	r2, 8015d7c <memmove+0xbc>
 8015d66:	3b01      	subs	r3, #1
 8015d68:	440a      	add	r2, r1
 8015d6a:	f811 4b01 	ldrb.w	r4, [r1], #1
 8015d6e:	f803 4f01 	strb.w	r4, [r3, #1]!
 8015d72:	4291      	cmp	r1, r2
 8015d74:	d1f9      	bne.n	8015d6a <memmove+0xaa>
 8015d76:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8015d78:	4603      	mov	r3, r0
 8015d7a:	e7f3      	b.n	8015d64 <memmove+0xa4>
 8015d7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8015d7e:	4603      	mov	r3, r0
 8015d80:	e7f1      	b.n	8015d66 <memmove+0xa6>
 8015d82:	4672      	mov	r2, lr
 8015d84:	e7ee      	b.n	8015d64 <memmove+0xa4>
 8015d86:	bf00      	nop
	...

08015d90 <_raise_r>:
 8015d90:	291f      	cmp	r1, #31
 8015d92:	b538      	push	{r3, r4, r5, lr}
 8015d94:	d822      	bhi.n	8015ddc <_raise_r+0x4c>
 8015d96:	f8d0 22dc 	ldr.w	r2, [r0, #732]	; 0x2dc
 8015d9a:	4605      	mov	r5, r0
 8015d9c:	460c      	mov	r4, r1
 8015d9e:	b19a      	cbz	r2, 8015dc8 <_raise_r+0x38>
 8015da0:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8015da4:	b183      	cbz	r3, 8015dc8 <_raise_r+0x38>
 8015da6:	2b01      	cmp	r3, #1
 8015da8:	d00c      	beq.n	8015dc4 <_raise_r+0x34>
 8015daa:	1c59      	adds	r1, r3, #1
 8015dac:	d006      	beq.n	8015dbc <_raise_r+0x2c>
 8015dae:	2500      	movs	r5, #0
 8015db0:	4620      	mov	r0, r4
 8015db2:	f842 5024 	str.w	r5, [r2, r4, lsl #2]
 8015db6:	4798      	blx	r3
 8015db8:	4628      	mov	r0, r5
 8015dba:	bd38      	pop	{r3, r4, r5, pc}
 8015dbc:	2316      	movs	r3, #22
 8015dbe:	6003      	str	r3, [r0, #0]
 8015dc0:	2001      	movs	r0, #1
 8015dc2:	bd38      	pop	{r3, r4, r5, pc}
 8015dc4:	2000      	movs	r0, #0
 8015dc6:	bd38      	pop	{r3, r4, r5, pc}
 8015dc8:	4628      	mov	r0, r5
 8015dca:	f000 f831 	bl	8015e30 <_getpid_r>
 8015dce:	4622      	mov	r2, r4
 8015dd0:	4601      	mov	r1, r0
 8015dd2:	4628      	mov	r0, r5
 8015dd4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8015dd8:	f000 b812 	b.w	8015e00 <_kill_r>
 8015ddc:	2316      	movs	r3, #22
 8015dde:	6003      	str	r3, [r0, #0]
 8015de0:	f04f 30ff 	mov.w	r0, #4294967295
 8015de4:	bd38      	pop	{r3, r4, r5, pc}
 8015de6:	bf00      	nop
	...

08015df0 <raise>:
 8015df0:	4b02      	ldr	r3, [pc, #8]	; (8015dfc <raise+0xc>)
 8015df2:	4601      	mov	r1, r0
 8015df4:	6818      	ldr	r0, [r3, #0]
 8015df6:	f7ff bfcb 	b.w	8015d90 <_raise_r>
 8015dfa:	bf00      	nop
 8015dfc:	20000d10 	.word	0x20000d10

08015e00 <_kill_r>:
 8015e00:	b538      	push	{r3, r4, r5, lr}
 8015e02:	4c08      	ldr	r4, [pc, #32]	; (8015e24 <_kill_r+0x24>)
 8015e04:	2300      	movs	r3, #0
 8015e06:	4605      	mov	r5, r0
 8015e08:	4608      	mov	r0, r1
 8015e0a:	4611      	mov	r1, r2
 8015e0c:	6023      	str	r3, [r4, #0]
 8015e0e:	f7fc fd2f 	bl	8012870 <_kill>
 8015e12:	1c43      	adds	r3, r0, #1
 8015e14:	d000      	beq.n	8015e18 <_kill_r+0x18>
 8015e16:	bd38      	pop	{r3, r4, r5, pc}
 8015e18:	6823      	ldr	r3, [r4, #0]
 8015e1a:	2b00      	cmp	r3, #0
 8015e1c:	d0fb      	beq.n	8015e16 <_kill_r+0x16>
 8015e1e:	602b      	str	r3, [r5, #0]
 8015e20:	bd38      	pop	{r3, r4, r5, pc}
 8015e22:	bf00      	nop
 8015e24:	200187b4 	.word	0x200187b4
	...

08015e30 <_getpid_r>:
 8015e30:	f7fc bd16 	b.w	8012860 <_getpid>
	...

08015e40 <__sread>:
 8015e40:	b510      	push	{r4, lr}
 8015e42:	460c      	mov	r4, r1
 8015e44:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8015e48:	f7fa feb2 	bl	8010bb0 <_read_r>
 8015e4c:	2800      	cmp	r0, #0
 8015e4e:	db03      	blt.n	8015e58 <__sread+0x18>
 8015e50:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8015e52:	4403      	add	r3, r0
 8015e54:	6523      	str	r3, [r4, #80]	; 0x50
 8015e56:	bd10      	pop	{r4, pc}
 8015e58:	89a3      	ldrh	r3, [r4, #12]
 8015e5a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8015e5e:	81a3      	strh	r3, [r4, #12]
 8015e60:	bd10      	pop	{r4, pc}
 8015e62:	bf00      	nop
	...

08015e70 <__swrite>:
 8015e70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015e74:	4616      	mov	r6, r2
 8015e76:	898a      	ldrh	r2, [r1, #12]
 8015e78:	461d      	mov	r5, r3
 8015e7a:	05d3      	lsls	r3, r2, #23
 8015e7c:	460c      	mov	r4, r1
 8015e7e:	4607      	mov	r7, r0
 8015e80:	d506      	bpl.n	8015e90 <__swrite+0x20>
 8015e82:	2200      	movs	r2, #0
 8015e84:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8015e88:	2302      	movs	r3, #2
 8015e8a:	f7fa feb9 	bl	8010c00 <_lseek_r>
 8015e8e:	89a2      	ldrh	r2, [r4, #12]
 8015e90:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8015e94:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8015e98:	81a2      	strh	r2, [r4, #12]
 8015e9a:	4638      	mov	r0, r7
 8015e9c:	4632      	mov	r2, r6
 8015e9e:	462b      	mov	r3, r5
 8015ea0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8015ea4:	f7fa beb4 	b.w	8010c10 <_write_r>
	...

08015eb0 <__sseek>:
 8015eb0:	b510      	push	{r4, lr}
 8015eb2:	460c      	mov	r4, r1
 8015eb4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8015eb8:	f7fa fea2 	bl	8010c00 <_lseek_r>
 8015ebc:	89a3      	ldrh	r3, [r4, #12]
 8015ebe:	1c42      	adds	r2, r0, #1
 8015ec0:	bf0e      	itee	eq
 8015ec2:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8015ec6:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8015eca:	6520      	strne	r0, [r4, #80]	; 0x50
 8015ecc:	81a3      	strh	r3, [r4, #12]
 8015ece:	bd10      	pop	{r4, pc}

08015ed0 <__sclose>:
 8015ed0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8015ed4:	f7fa bebc 	b.w	8010c50 <_close_r>
	...

08015ee0 <__swbuf_r>:
 8015ee0:	b570      	push	{r4, r5, r6, lr}
 8015ee2:	460d      	mov	r5, r1
 8015ee4:	4614      	mov	r4, r2
 8015ee6:	4606      	mov	r6, r0
 8015ee8:	b110      	cbz	r0, 8015ef0 <__swbuf_r+0x10>
 8015eea:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8015eec:	2b00      	cmp	r3, #0
 8015eee:	d048      	beq.n	8015f82 <__swbuf_r+0xa2>
 8015ef0:	89a2      	ldrh	r2, [r4, #12]
 8015ef2:	69a3      	ldr	r3, [r4, #24]
 8015ef4:	60a3      	str	r3, [r4, #8]
 8015ef6:	b291      	uxth	r1, r2
 8015ef8:	0708      	lsls	r0, r1, #28
 8015efa:	d538      	bpl.n	8015f6e <__swbuf_r+0x8e>
 8015efc:	6923      	ldr	r3, [r4, #16]
 8015efe:	2b00      	cmp	r3, #0
 8015f00:	d035      	beq.n	8015f6e <__swbuf_r+0x8e>
 8015f02:	0489      	lsls	r1, r1, #18
 8015f04:	b2ed      	uxtb	r5, r5
 8015f06:	d515      	bpl.n	8015f34 <__swbuf_r+0x54>
 8015f08:	6822      	ldr	r2, [r4, #0]
 8015f0a:	6961      	ldr	r1, [r4, #20]
 8015f0c:	1ad3      	subs	r3, r2, r3
 8015f0e:	428b      	cmp	r3, r1
 8015f10:	da1c      	bge.n	8015f4c <__swbuf_r+0x6c>
 8015f12:	3301      	adds	r3, #1
 8015f14:	68a1      	ldr	r1, [r4, #8]
 8015f16:	1c50      	adds	r0, r2, #1
 8015f18:	3901      	subs	r1, #1
 8015f1a:	60a1      	str	r1, [r4, #8]
 8015f1c:	6020      	str	r0, [r4, #0]
 8015f1e:	7015      	strb	r5, [r2, #0]
 8015f20:	6962      	ldr	r2, [r4, #20]
 8015f22:	429a      	cmp	r2, r3
 8015f24:	d01a      	beq.n	8015f5c <__swbuf_r+0x7c>
 8015f26:	89a3      	ldrh	r3, [r4, #12]
 8015f28:	07db      	lsls	r3, r3, #31
 8015f2a:	d501      	bpl.n	8015f30 <__swbuf_r+0x50>
 8015f2c:	2d0a      	cmp	r5, #10
 8015f2e:	d015      	beq.n	8015f5c <__swbuf_r+0x7c>
 8015f30:	4628      	mov	r0, r5
 8015f32:	bd70      	pop	{r4, r5, r6, pc}
 8015f34:	6e61      	ldr	r1, [r4, #100]	; 0x64
 8015f36:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8015f3a:	f421 5100 	bic.w	r1, r1, #8192	; 0x2000
 8015f3e:	81a2      	strh	r2, [r4, #12]
 8015f40:	6822      	ldr	r2, [r4, #0]
 8015f42:	6661      	str	r1, [r4, #100]	; 0x64
 8015f44:	6961      	ldr	r1, [r4, #20]
 8015f46:	1ad3      	subs	r3, r2, r3
 8015f48:	428b      	cmp	r3, r1
 8015f4a:	dbe2      	blt.n	8015f12 <__swbuf_r+0x32>
 8015f4c:	4630      	mov	r0, r6
 8015f4e:	4621      	mov	r1, r4
 8015f50:	f7ff f9e6 	bl	8015320 <_fflush_r>
 8015f54:	b940      	cbnz	r0, 8015f68 <__swbuf_r+0x88>
 8015f56:	6822      	ldr	r2, [r4, #0]
 8015f58:	2301      	movs	r3, #1
 8015f5a:	e7db      	b.n	8015f14 <__swbuf_r+0x34>
 8015f5c:	4630      	mov	r0, r6
 8015f5e:	4621      	mov	r1, r4
 8015f60:	f7ff f9de 	bl	8015320 <_fflush_r>
 8015f64:	2800      	cmp	r0, #0
 8015f66:	d0e3      	beq.n	8015f30 <__swbuf_r+0x50>
 8015f68:	f04f 30ff 	mov.w	r0, #4294967295
 8015f6c:	bd70      	pop	{r4, r5, r6, pc}
 8015f6e:	4630      	mov	r0, r6
 8015f70:	4621      	mov	r1, r4
 8015f72:	f7ff f8b5 	bl	80150e0 <__swsetup_r>
 8015f76:	2800      	cmp	r0, #0
 8015f78:	d1f6      	bne.n	8015f68 <__swbuf_r+0x88>
 8015f7a:	89a2      	ldrh	r2, [r4, #12]
 8015f7c:	6923      	ldr	r3, [r4, #16]
 8015f7e:	b291      	uxth	r1, r2
 8015f80:	e7bf      	b.n	8015f02 <__swbuf_r+0x22>
 8015f82:	f7ff fa65 	bl	8015450 <__sinit>
 8015f86:	e7b3      	b.n	8015ef0 <__swbuf_r+0x10>
	...

08015f90 <_wcrtomb_r>:
 8015f90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015f94:	4605      	mov	r5, r0
 8015f96:	b086      	sub	sp, #24
 8015f98:	461e      	mov	r6, r3
 8015f9a:	460c      	mov	r4, r1
 8015f9c:	b1a1      	cbz	r1, 8015fc8 <_wcrtomb_r+0x38>
 8015f9e:	4b10      	ldr	r3, [pc, #64]	; (8015fe0 <_wcrtomb_r+0x50>)
 8015fa0:	4617      	mov	r7, r2
 8015fa2:	f8d3 8000 	ldr.w	r8, [r3]
 8015fa6:	f7ff fdbb 	bl	8015b20 <__locale_charset>
 8015faa:	9600      	str	r6, [sp, #0]
 8015fac:	4603      	mov	r3, r0
 8015fae:	4621      	mov	r1, r4
 8015fb0:	463a      	mov	r2, r7
 8015fb2:	4628      	mov	r0, r5
 8015fb4:	47c0      	blx	r8
 8015fb6:	1c43      	adds	r3, r0, #1
 8015fb8:	d103      	bne.n	8015fc2 <_wcrtomb_r+0x32>
 8015fba:	2200      	movs	r2, #0
 8015fbc:	238a      	movs	r3, #138	; 0x8a
 8015fbe:	6032      	str	r2, [r6, #0]
 8015fc0:	602b      	str	r3, [r5, #0]
 8015fc2:	b006      	add	sp, #24
 8015fc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8015fc8:	4b05      	ldr	r3, [pc, #20]	; (8015fe0 <_wcrtomb_r+0x50>)
 8015fca:	681f      	ldr	r7, [r3, #0]
 8015fcc:	f7ff fda8 	bl	8015b20 <__locale_charset>
 8015fd0:	9600      	str	r6, [sp, #0]
 8015fd2:	4603      	mov	r3, r0
 8015fd4:	4622      	mov	r2, r4
 8015fd6:	4628      	mov	r0, r5
 8015fd8:	a903      	add	r1, sp, #12
 8015fda:	47b8      	blx	r7
 8015fdc:	e7eb      	b.n	8015fb6 <_wcrtomb_r+0x26>
 8015fde:	bf00      	nop
 8015fe0:	20001148 	.word	0x20001148
	...

08015ff0 <__ascii_wctomb>:
 8015ff0:	b121      	cbz	r1, 8015ffc <__ascii_wctomb+0xc>
 8015ff2:	2aff      	cmp	r2, #255	; 0xff
 8015ff4:	d804      	bhi.n	8016000 <__ascii_wctomb+0x10>
 8015ff6:	700a      	strb	r2, [r1, #0]
 8015ff8:	2001      	movs	r0, #1
 8015ffa:	4770      	bx	lr
 8015ffc:	4608      	mov	r0, r1
 8015ffe:	4770      	bx	lr
 8016000:	238a      	movs	r3, #138	; 0x8a
 8016002:	6003      	str	r3, [r0, #0]
 8016004:	f04f 30ff 	mov.w	r0, #4294967295
 8016008:	4770      	bx	lr
 801600a:	bf00      	nop
 801600c:	0000      	movs	r0, r0
	...

08016010 <_fclose_r>:
 8016010:	2900      	cmp	r1, #0
 8016012:	d03d      	beq.n	8016090 <_fclose_r+0x80>
 8016014:	b570      	push	{r4, r5, r6, lr}
 8016016:	4605      	mov	r5, r0
 8016018:	460c      	mov	r4, r1
 801601a:	b108      	cbz	r0, 8016020 <_fclose_r+0x10>
 801601c:	6b83      	ldr	r3, [r0, #56]	; 0x38
 801601e:	b37b      	cbz	r3, 8016080 <_fclose_r+0x70>
 8016020:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8016024:	b90b      	cbnz	r3, 801602a <_fclose_r+0x1a>
 8016026:	2000      	movs	r0, #0
 8016028:	bd70      	pop	{r4, r5, r6, pc}
 801602a:	4628      	mov	r0, r5
 801602c:	4621      	mov	r1, r4
 801602e:	f7ff f8c7 	bl	80151c0 <__sflush_r>
 8016032:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8016034:	4606      	mov	r6, r0
 8016036:	b133      	cbz	r3, 8016046 <_fclose_r+0x36>
 8016038:	4628      	mov	r0, r5
 801603a:	69e1      	ldr	r1, [r4, #28]
 801603c:	4798      	blx	r3
 801603e:	2800      	cmp	r0, #0
 8016040:	bfb8      	it	lt
 8016042:	f04f 36ff 	movlt.w	r6, #4294967295
 8016046:	89a3      	ldrh	r3, [r4, #12]
 8016048:	061b      	lsls	r3, r3, #24
 801604a:	d41c      	bmi.n	8016086 <_fclose_r+0x76>
 801604c:	6b21      	ldr	r1, [r4, #48]	; 0x30
 801604e:	b141      	cbz	r1, 8016062 <_fclose_r+0x52>
 8016050:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8016054:	4299      	cmp	r1, r3
 8016056:	d002      	beq.n	801605e <_fclose_r+0x4e>
 8016058:	4628      	mov	r0, r5
 801605a:	f7ff fac9 	bl	80155f0 <_free_r>
 801605e:	2300      	movs	r3, #0
 8016060:	6323      	str	r3, [r4, #48]	; 0x30
 8016062:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8016064:	b121      	cbz	r1, 8016070 <_fclose_r+0x60>
 8016066:	4628      	mov	r0, r5
 8016068:	f7ff fac2 	bl	80155f0 <_free_r>
 801606c:	2300      	movs	r3, #0
 801606e:	6463      	str	r3, [r4, #68]	; 0x44
 8016070:	f7ff f9f6 	bl	8015460 <__sfp_lock_acquire>
 8016074:	2300      	movs	r3, #0
 8016076:	81a3      	strh	r3, [r4, #12]
 8016078:	f7ff f9fa 	bl	8015470 <__sfp_lock_release>
 801607c:	4630      	mov	r0, r6
 801607e:	bd70      	pop	{r4, r5, r6, pc}
 8016080:	f7ff f9e6 	bl	8015450 <__sinit>
 8016084:	e7cc      	b.n	8016020 <_fclose_r+0x10>
 8016086:	4628      	mov	r0, r5
 8016088:	6921      	ldr	r1, [r4, #16]
 801608a:	f7ff fab1 	bl	80155f0 <_free_r>
 801608e:	e7dd      	b.n	801604c <_fclose_r+0x3c>
 8016090:	2000      	movs	r0, #0
 8016092:	4770      	bx	lr
	...
 80160a0:	656c6469 	.word	0x656c6469
	...

080160b0 <ch_debug>:
 80160b0:	6e69616d 18001600 08440404 1814100c     main......D.....
 80160c0:	1e1d1c00 00000000 00000000 00000000     ................

080160d0 <wa>:
 80160d0:	20001350 20001520 200016f0 200018c0     P..  .. ... ... 
 80160e0:	20001a90 00000000 00000000 00000000     ... ............
 80160f0:	00000a0d 202a2a2a 6e72654b 203a6c65     ....*** Kernel: 
 8016100:	20202020 00002020 202a2a2a 706d6f43           ..*** Comp
 8016110:	64656c69 2020203a 00002020 202a2a2a     iled:     ..*** 
 8016120:	706d6f43 72656c69 2020203a 00002020     Compiler:     ..
 8016130:	202a2a2a 68637241 63657469 65727574     *** Architecture
 8016140:	0000203a 202a2a2a 65726f43 72615620     : ..*** Core Var
 8016150:	746e6169 0000203a 202a2a2a 74726f50     iant: ..*** Port
 8016160:	666e4920 20203a6f 00002020 202a2a2a      Info:    ..*** 
 8016170:	74616c50 6d726f66 2020203a 00002020     Platform:     ..
 8016180:	202a2a2a 74736554 616f4220 203a6472     *** Test Board: 
 8016190:	00002020 202d2d2d 74736554 73614320       ..--- Test Cas
 80161a0:	00002065 00002820 202d2d2d 75736552     e .. (..--- Resu
 80161b0:	203a746c 4c494146 20455255 00002328     lt: FAILURE (#..
 80161c0:	00005b20 616e6946 6572206c 746c7573      [..Final result
 80161d0:	0000203a 202a2a2a 62696843 2f534f69     : ..*** ChibiOS/
 80161e0:	74205452 20747365 74697573 00000065     RT test suite...
 80161f0:	002a2a2a 0000295d 202d2d2d 75736552     ***.])..--- Resu
 8016200:	203a746c 43435553 00535345 4c494146     lt: SUCCESS.FAIL
 8016210:	00455255 2e302e33 76656430 00000000     URE.3.0.0dev....
 8016220:	206e754a 32203332 20353130 3331202d     Jun 23 2015 - 13
 8016230:	3a36323a 00003732 20434347 2e392e34     :26:27..GCC 4.9.
 8016240:	30322033 31313431 28203931 656c6572     3 20141119 (rele
 8016250:	29657361 52415b20 6d652f4d 64646562     ase) [ARM/embedd
 8016260:	342d6465 622d395f 636e6172 65722068     ed-4_9-branch re
 8016270:	69736976 32206e6f 37323831 00005d38     vision 218278]..
 8016280:	764d5241 454d2d37 00000000 74726f43     ARMv7-ME....Cort
 8016290:	4d2d7865 00004634 61766441 6465636e     ex-M4F..Advanced
 80162a0:	72656b20 206c656e 65646f6d 00000000      kernel mode....
 80162b0:	334d5453 30344632 69482037 50206867     STM32F407 High P
 80162c0:	6f667265 6e616d72 77206563 20687469     erformance with 
 80162d0:	20505344 20646e61 00555046 694d5453     DSP and FPU.STMi
 80162e0:	656f7263 7463656c 696e6f72 53207363     croelectronics S
 80162f0:	32334d54 442d3446 6f637369 79726576     TM32F4-Discovery
	...

08016310 <patterns>:
 8016310:	08016380 08016460 080165d0 08016630     .c..`d...e..0f..
 8016320:	08016640 08016680 08016730 080167a0     @f...f..0g...g..
 8016330:	08016880 080168e0 08016900 00000000     .h...h...i......

08016340 <testthd1>:
 8016340:	080163fc 00000000 00000000 08003001     .c...........0..

08016350 <testthd2>:
 8016350:	080163e0 00000000 00000000 080030e1     .c...........0..

08016360 <testthd3>:
 8016360:	080163c4 00000000 00000000 080031c1     .c...........1..

08016370 <testthd4>:
 8016370:	080163b4 00000000 00000000 080032f1     .c...........2..

08016380 <patternthd>:
 8016380:	08016340 08016350 08016360 08016370     @c..Pc..`c..pc..
	...
 80163a0:	00000043 00000042 00000041 44434241     C...B...A...ABCD
 80163b0:	00000045 65726854 2c736461 6c656420     E...Threads, del
 80163c0:	00737961 65726854 2c736461 69727020     ays.Threads, pri
 80163d0:	7469726f 68632079 65676e61 00000000     ority change....
 80163e0:	65726854 2c736461 716e6520 69756575     Threads, enqueui
 80163f0:	7420676e 20747365 00003223 65726854     ng test #2..Thre
 8016400:	2c736461 716e6520 69756575 7420676e     ads, enqueuing t
 8016410:	20747365 00003123 00000000 00000000     est #1..........

08016420 <testsem1>:
 8016420:	080164d8 08003531 00000000 08003391     .d..15.......3..

08016430 <testsem2>:
 8016430:	080164c4 08003541 00000000 08003591     .d..A5.......5..

08016440 <testsem3>:
 8016440:	080164a4 08003551 00000000 080036f1     .d..Q5.......6..

08016450 <testsem4>:
 8016450:	08016480 00000000 00000000 080037c1     .d...........7..

08016460 <patternsem>:
 8016460:	08016420 08016430 08016440 08016450      d..0d..@d..Pd..
	...
 8016480:	616e6942 53207972 70616d65 65726f68     Binary Semaphore
 8016490:	66202c73 74636e75 616e6f69 7974696c     s, functionality
 80164a0:	00000000 616d6553 726f6870 202c7365     ....Semaphores, 
 80164b0:	6d6f7461 73206369 616e6769 61772d6c     atomic signal-wa
 80164c0:	00007469 616d6553 726f6870 202c7365     it..Semaphores, 
 80164d0:	656d6974 0074756f 616d6553 726f6870     timeout.Semaphor
 80164e0:	202c7365 75716e65 6e697565 00000067     es, enqueuing...

080164f0 <testmtx5>:
 80164f0:	08016578 08003a71 00000000 08003d31     xe..q:......1=..

08016500 <testmtx6>:
 8016500:	08016560 08003f11 00000000 08003df1     `e...?.......=..

08016510 <testmtx7>:
 8016510:	08016548 08003f31 00000000 08003f81     He..1?.......?..

08016520 <testmtx8>:
 8016520:	08016534 08003f51 00000000 08004041     4e..Q?......A@..
 8016530:	00434241 646e6f43 2c726156 6f6f6220     ABC.CondVar, boo
 8016540:	74207473 00747365 646e6f43 2c726156     st test.CondVar,
 8016550:	6f726220 61636461 74207473 00747365      broadcast test.
 8016560:	646e6f43 2c726156 67697320 206c616e     CondVar, signal 
 8016570:	74736574 00000000 6574754d 2c736578     test....Mutexes,
 8016580:	61747320 00737574 6574754d 2c736578      status.Mutexes,
 8016590:	69727020 7469726f 65722079 6e727574      priority return
 80165a0:	00000000 6574754d 2c736578 69727020     ....Mutexes, pri
 80165b0:	7469726f 6e652079 75657571 20676e69     ority enqueuing 
 80165c0:	74736574 00000000 00000000 00000000     test............

080165d0 <patternmtx>:
 80165d0:	080165f0 08016600 080164f0 08016500     .e...f...d...e..
 80165e0:	08016510 08016520 00000000 00000000     .e.. e..........

080165f0 <testmtx1>:
 80165f0:	080165a4 08003a41 00000000 08003921     .e..A:......!9..

08016600 <testmtx4>:
 8016600:	08016588 08003a51 00000000 08003ac1     .e..Q:.......:..

08016610 <testmsg1>:
 8016610:	08016620 00000000 00000000 08004121      f..........!A..
 8016620:	7373654d 73656761 6f6c202c 0000706f     Messages, loop..

08016630 <patternmsg>:
 8016630:	08016610 00000000 00000000 00000000     .f..............

08016640 <patternmbox>:
 8016640:	08016670 00000000 00000000 00000000     pf..............
 8016650:	6c69614d 65786f62 71202c73 69756575     Mailboxes, queui
 8016660:	6120676e 7420646e 6f656d69 00737475     ng and timeouts.

08016670 <testmbox1>:
 8016670:	08016650 080047a1 00000000 080041c1     Pf...G.......A..

08016680 <patternevt>:
 8016680:	08016700 08016690 08016720 00000000     .g...f.. g......

08016690 <testevt2>:
 8016690:	080166b4 08004891 00000000 080048b1     .f...H.......H..
 80166a0:	6e657645 202c7374 656d6974 7374756f     Events, timeouts
 80166b0:	00000000 6e657645 202c7374 74696177     ....Events, wait
 80166c0:	646e6120 6f726220 61636461 00007473      and broadcast..
 80166d0:	6e657645 202c7374 69676572 61727473     Events, registra
 80166e0:	6e6f6974 646e6120 73696420 63746170     tion and dispatc
 80166f0:	00000068 00000000 00000000 00000000     h...............

08016700 <testevt1>:
 8016700:	080166d0 08004881 00000000 080047f1     .f...H.......G..

08016710 <evhndl>:
 8016710:	080047e1 080047d1 080047c1 00000000     .G...G...G......

08016720 <testevt3>:
 8016720:	080166a0 080048a1 00000000 08004b91     .f...H.......K..

08016730 <patternheap>:
 8016730:	08016770 00000000 00000000 00000000     pg..............
 8016740:	70616548 6c61202c 61636f6c 6e6f6974     Heap, allocation
 8016750:	646e6120 61726620 6e656d67 69746174      and fragmentati
 8016760:	74206e6f 00747365 00000000 00000000     on test.........

08016770 <testheap1>:
 8016770:	08016740 08004e81 00000000 08004c31     @g...N......1L..
 8016780:	6f6d654d 50207972 736c6f6f 7571202c     Memory Pools, qu
 8016790:	2f657565 75716564 00657565 00000000     eue/dequeue.....

080167a0 <patternpools>:
 80167a0:	080167b0 00000000 00000000 00000000     .g..............

080167b0 <testpools1>:
 80167b0:	08016780 08004eb1 00000000 08004ec1     .g...N.......N..

080167c0 <testdyn1>:
 80167c0:	08016854 08005091 00000000 08004f81     Th...P.......O..

080167d0 <testdyn2>:
 80167d0:	08016824 080051d1 00000000 080050d1     $h...Q.......P..

080167e0 <testdyn3>:
 80167e0:	080167fc 080050b1 00000000 08005211     .g...P.......R..
 80167f0:	00004241 44434241 00000000 616e7944     AB..ABCD....Dyna
 8016800:	2063696d 73495041 6572202c 74736967     mic APIs, regist
 8016810:	61207972 7220646e 72656665 65636e65     ry and reference
 8016820:	00000073 616e7944 2063696d 73495041     s...Dynamic APIs
 8016830:	6874202c 64616572 72632073 69746165     , threads creati
 8016840:	66206e6f 206d6f72 6f6d656d 70207972     on from memory p
 8016850:	006c6f6f 616e7944 2063696d 73495041     ool.Dynamic APIs
 8016860:	6874202c 64616572 72632073 69746165     , threads creati
 8016870:	66206e6f 206d6f72 70616568 00000000     on from heap....

08016880 <patterndyn>:
 8016880:	080167c0 080167d0 080167e0 00000000     .g...g...g......

08016890 <testqueues1>:
 8016890:	080168c8 08005381 00000000 08005401     .h...S.......T..

080168a0 <testqueues2>:
 80168a0:	080168b0 080053d1 00000000 08005671     .h...S......qV..
 80168b0:	75657551 202c7365 7074756f 71207475     Queues, output q
 80168c0:	65756575 00000073 75657551 202c7365     ueues...Queues, 
 80168d0:	75706e69 75712074 73657565 00000000     input queues....

080168e0 <patternqueues>:
 80168e0:	08016890 080168a0 00000000 00000000     .h...h..........

080168f0 <testbmk8>:
 80168f0:	08016b50 00000000 00000000 08005f21     Pk..........!_..

08016900 <patternbmk>:
 8016900:	08016c60 08016970 08016960 08016950     `l..pi..`i..Pi..
 8016910:	08016ca0 08016cb0 08016cc0 080168f0     .l...l...l...h..
 8016920:	08016c50 08016940 08016c70 08016c80     Pl..@i..pl...l..
 8016930:	08016c90 00000000 00000000 00000000     .l..............

08016940 <testbmk10>:
 8016940:	08016b08 00000000 00000000 080060e1     .k...........`..

08016950 <testbmk4>:
 8016950:	08016be4 00000000 00000000 08005c81     .k...........\..

08016960 <testbmk3>:
 8016960:	08016c00 00000000 00000000 08005b71     .l..........q[..

08016970 <testbmk2>:
 8016970:	08016c18 00000000 00000000 08005b01     .l...........[..
 8016980:	202d2d2d 74737953 203a6d65 00000000     --- System: ....
 8016990:	74796220 00007365 202d2d2d 65726854      bytes..--- Thre
 80169a0:	203a6461 00000000 202d2d2d 656d6954     ad: ....--- Time
 80169b0:	203a2072 00000000 202d2d2d 616d6553     r : ....--- Sema
 80169c0:	203a6870 00000000 202d2d2d 6e657645     ph: ....--- Even
 80169d0:	203a5374 00000000 202d2d2d 6e657645     tS: ....--- Even
 80169e0:	203a4c74 00000000 202d2d2d 6574754d     tL: ....--- Mute
 80169f0:	203a2078 00000000 202d2d2d 646e6f43     x : ....--- Cond
 8016a00:	203a2e56 00000000 202d2d2d 75657551     V.: ....--- Queu
 8016a10:	203a2065 00000000 202d2d2d 6c69614d     e : ....--- Mail
 8016a20:	203a2e42 00000000 202d2d2d 726f6353     B.: ....--- Scor
 8016a30:	203a2065 00000000 72687420 73646165     e : .... threads
 8016a40:	0000532f 67736d20 2c532f73 00000020     /S.. msgs/S, ...
 8016a50:	78746320 2f637773 00000053 73657220      ctxswc/S... res
 8016a60:	64656863 73656c75 202c532f 00000000     chedules/S, ....
 8016a70:	74796220 532f7365 00000000 6d697420      bytes/S.... tim
 8016a80:	2f737265 00000053 69617720 69732b74     ers/S... wait+si
 8016a90:	6c616e67 0000532f 636f6c20 6e752b6b     gnal/S.. lock+un
 8016aa0:	6b636f6c 0000532f 636e6542 72616d68     lock/S..Benchmar
 8016ab0:	52202c6b 66204d41 70746f6f 746e6972     k, RAM footprint
 8016ac0:	00000000 636e6542 72616d68 6d202c6b     ....Benchmark, m
 8016ad0:	78657475 6c207365 2f6b636f 6f6c6e75     utexes lock/unlo
 8016ae0:	00006b63 636e6542 72616d68 73202c6b     ck..Benchmark, s
 8016af0:	70616d65 65726f68 61772073 732f7469     emaphores wait/s
 8016b00:	616e6769 0000006c 636e6542 72616d68     ignal...Benchmar
 8016b10:	76202c6b 75747269 74206c61 72656d69     k, virtual timer
 8016b20:	65732073 65722f74 00746573 636e6542     s set/reset.Benc
 8016b30:	72616d68 49202c6b 51204f2f 65756575     hmark, I/O Queue
 8016b40:	68742073 67756f72 74757068 00000000     s throughput....
 8016b50:	636e6542 72616d68 72202c6b 646e756f     Benchmark, round
 8016b60:	626f7220 63206e69 65746e6f 73207478      robin context s
 8016b70:	63746977 676e6968 00000000 636e6542     witching....Benc
 8016b80:	72616d68 6d202c6b 20737361 63736572     hmark, mass resc
 8016b90:	75646568 202c656c 68742035 64616572     hedule, 5 thread
 8016ba0:	00000073 636e6542 72616d68 74202c6b     s...Benchmark, t
 8016bb0:	61657268 202c7364 61657263 6f206574     hreads, create o
 8016bc0:	00796c6e 636e6542 72616d68 74202c6b     nly.Benchmark, t
 8016bd0:	61657268 202c7364 6c6c7566 63796320     hreads, full cyc
 8016be0:	0000656c 636e6542 72616d68 63202c6b     le..Benchmark, c
 8016bf0:	65746e6f 73207478 63746977 00000068     ontext switch...
 8016c00:	636e6542 72616d68 6d202c6b 61737365     Benchmark, messa
 8016c10:	20736567 00003323 636e6542 72616d68     ges #3..Benchmar
 8016c20:	6d202c6b 61737365 20736567 00003223     k, messages #2..
 8016c30:	636e6542 72616d68 6d202c6b 61737365     Benchmark, messa
 8016c40:	20736567 00003123 00000000 00000000     ges #1..........

08016c50 <testbmk9>:
 8016c50:	08016b2c 00000000 00000000 08006031     ,k..........1`..

08016c60 <testbmk1>:
 8016c60:	08016c30 00000000 00000000 08005a91     0l...........Z..

08016c70 <testbmk11>:
 8016c70:	08016ae4 08005f11 00000000 08006161     .j..._......aa..

08016c80 <testbmk12>:
 8016c80:	08016ac4 08006241 00000000 080061d1     .j..Ab.......a..

08016c90 <testbmk13>:
 8016c90:	08016aa8 00000000 00000000 080058d1     .j...........X..

08016ca0 <testbmk5>:
 8016ca0:	08016bc4 00000000 00000000 08005d41     .k..........A]..

08016cb0 <testbmk6>:
 8016cb0:	08016ba4 00000000 00000000 080059e1     .k...........Y..

08016cc0 <testbmk7>:
 8016cc0:	08016b7c 08005f01 00000000 08005dc1     |k..._.......]..
 8016cd0:	5f6c6168 5f646c6c 74696e69 00000000     hal_lld_init....
 8016ce0:	496c6170 0074696e 2063616d 74696e49     palInit.mac Init
 8016cf0:	2e2e6465 0000002e 00000000 00000000     ed..............

08016d00 <vmt>:
 8016d00:	08006491 08006471 080064d1 080064b1     .d..qd...d...d..
 8016d10:	080064c1 080064a1 08006481 08006461     .d...d...d..ad..

08016d20 <_stm32_dma_streams>:
 8016d20:	40026010 40026008 000b0000 40026028     .`.@.`.@....(`.@
 8016d30:	40026008 000c0106 40026040 40026008     .`.@....@`.@.`.@
 8016d40:	000d0210 40026058 40026008 000e0316     ....X`.@.`.@....
 8016d50:	40026070 4002600c 000f0400 40026088     p`.@.`.@.....`.@
 8016d60:	4002600c 00100506 400260a0 4002600c     .`.@.....`.@.`.@
 8016d70:	00110610 400260b8 4002600c 002f0716     .....`.@.`.@../.
 8016d80:	40026410 40026408 00380800 40026428     .d.@.d.@..8.(d.@
 8016d90:	40026408 00390906 40026440 40026408     .d.@..9.@d.@.d.@
 8016da0:	003a0a10 40026458 40026408 003b0b16     ..:.Xd.@.d.@..;.
 8016db0:	40026470 4002640c 003c0c00 40026488     pd.@.d.@..<..d.@
 8016dc0:	4002640c 00440d06 400264a0 4002640c     .d.@..D..d.@.d.@
 8016dd0:	00450e10 400264b8 4002640c 00460f16     ..E..d.@.d.@..F.

08016de0 <default_mac_address>:
 8016de0:	371355aa 00001001 00000000 00000000     .U.7............
 8016df0:	2043494e 6c206f6e 206b6e69 00007075     NIC no link up..
 8016e00:	2043414d 6c696166 00657275 44485445     MAC failure.ETHD
 8016e10:	73252031 0000000a 5f69696d 646e6966     1 %s....mii_find
 8016e20:	7968705f 00000000 52414f42 48505f44     _phy....BOARD_PH
 8016e30:	45525f59 5f544553 414c4544 64252059     Y_RESET_DELAY %d
 8016e40:	0000000a 2043494e 636f6c63 0000006b     ....NIC clock...
 8016e50:	20414d44 74746553 73676e69 00000000     DMA Settings....
 8016e60:	4f464946 754c4620 00006873 00000000     FIFO FLush......

08016e70 <default_config>:
 8016e70:	00009600 40000000 00000000 00000000     .......@........

08016e80 <pal_default_config>:
 8016e80:	2a82aa28 00280028 ffffffff 40000054     (..*(.(.....T..@
 8016e90:	0000ffff b5560bb0 00000000 00082080     ......V...... ..
 8016ea0:	00000240 ffffffff 55514515 0000ffff     @........EQU....
 8016eb0:	04000000 00000040 00a5aa09 00000000     ....@...........
 8016ec0:	ffffffff 54000050 0000fcff 88bb00b0     ....P..T........
 8016ed0:	00067700 55000100 00000000 ffffffff     .w.....U........
 8016ee0:	00155055 00000fff 00000000 00000000     UP..............
 8016ef0:	00000040 00000000 ffffffff 00000000     @...............
 8016f00:	0000ffff 00000000 00000000 00000000     ................
 8016f10:	00000000 ffffffff 00000000 0000ffff     ................
	...
 8016f28:	28811000 00000000 ffffffff 14400000     ...(..........@.
 8016f38:	0000febf 00000000 0bb0b000 00000000     ................
 8016f48:	00000000 ffffffff 00000000 0000ffff     ................
	...
 8016f60:	00040000 00000000 ffffffff 00000000     ................
 8016f70:	0000fdff 00000000 00000000 00000000     ................
 8016f80:	7069776c 65726874 00006461 69706374     lwipthread..tcpi
 8016f90:	6e695f70 00007469 2043494e 72617473     p_init..NIC star
 8016fa0:	00646574 6c626163 73692065 0a732520     ted.cable is %s.
 8016fb0:	00000000 20746f6e 6b6e696c 00006465     ....not linked..

08016fc0 <mac_config.8981>:
 8016fc0:	20004373 00000000 00000000 00000000     sC. ............

08016fd0 <ethbroadcast>:
 8016fd0:	ffffffff 0000ffff 00000000 00000000     ................
 8016fe0:	65737341 6f697472 2522206e 66202273     Assertion "%s" f
 8016ff0:	656c6961 74612064 6e696c20 64252065     ailed at line %d
 8017000:	206e6920 000a7325 6974656e 683e2d66      in %s..netif->h
 8017010:	64646177 656c5f72 756d206e 62207473     waddr_len must b
 8017020:	68742065 61732065 6120656d 54452073     e the same as ET
 8017030:	50524148 4157485f 5f524444 204e454c     HARP_HWADDR_LEN 
 8017040:	20726f66 61687465 00217072 2e2f2e2e     for etharp!.../.
 8017050:	2e2e2f2e 2f736f2f 2f747865 7069776c     ./../os/ext/lwip
 8017060:	342e312d 732f312e 6e2f6372 66697465     -1.4.1/src/netif
 8017070:	6874652f 2e707261 00000063 5f707261     /etharp.c...arp_
 8017080:	6c626174 5d695b65 3d20712e 554e203d     table[i].q == NU
 8017090:	00004c4c 203c2069 5f505241 4c424154     LL..i < ARP_TABL
 80170a0:	49535f45 0000455a 5f707261 6c626174     E_SIZE..arp_tabl
 80170b0:	5d695b65 6174732e 3d206574 5445203d     e[i].state == ET
 80170c0:	50524148 4154535f 455f4554 5954504d     HARP_STATE_EMPTY
 80170d0:	00000000 5f687465 20746572 4e203d21     ....eth_ret != N
 80170e0:	204c4c55 69202626 65725f70 3d212074     ULL && ip_ret !=
 80170f0:	4c554e20 0000004c 6974656e 3d212066      NULL...netif !=
 8017100:	4c554e20 0000004c 63656863 6874206b      NULL...check th
 8017110:	66207461 74737269 75627020 61632066     at first pbuf ca
 8017120:	6f68206e 7320646c 63757274 74652074     n hold struct et
 8017130:	70726168 7264685f 00000000 5f707261     harp_hdr....arp_
 8017140:	6c626174 72615b65 64695f70 732e5d78     table[arp_idx].s
 8017150:	65746174 203d3e20 41485445 535f5052     tate >= ETHARP_S
 8017160:	45544154 4154535f 00454c42 70206f6e     TATE_STABLE.no p
 8017170:	656b6361 75712074 73657565 6c6c6120     acket queues all
 8017180:	6465776f 00000021 3d212071 4c554e20     owed!...q != NUL
 8017190:	0000004c 64617069 21207264 554e203d     L...ipaddr != NU
 80171a0:	00004c4c 276e6143 6f6d2074 6f206576     LL..Can't move o
 80171b0:	20726576 64616568 69207265 6170206e     ver header in pa
 80171c0:	74656b63 00000000 6974656e 683e2d66     cket....netif->h
 80171d0:	64646177 656c5f72 3d3d206e 48544520     waddr_len == ETH
 80171e0:	5f505241 44415748 4c5f5244 00004e45     ARP_HWADDR_LEN..

080171f0 <ethzero>:
	...
 8017200:	6c696166 74206465 7263206f 65746165     failed to create
 8017210:	6d656d20 74756d5f 00007865 2e2f2e2e      mem_mutex..../.
 8017220:	2e2e2f2e 2f736f2f 2f747865 7069776c     ./../os/ext/lwip
 8017230:	342e312d 732f312e 632f6372 2f65726f     -1.4.1/src/core/
 8017240:	2e6d656d 00000063 5f6d656d 65657266     mem.c...mem_free
 8017250:	6173203a 7974696e 65686320 61206b63     : sanity check a
 8017260:	6e67696c 746e656d 00000000 5f6d656d     lignment....mem_
 8017270:	65657266 656c203a 206c6167 6f6d656d     free: legal memo
 8017280:	00007972 5f6d656d 65657266 656d203a     ry..mem_free: me
 8017290:	753e2d6d 00646573 67756c70 6c6f685f     m->used.plug_hol
 80172a0:	203a7365 206d656d 72203d3e 00006d61     es: mem >= ram..
 80172b0:	67756c70 6c6f685f 203a7365 206d656d     plug_holes: mem 
 80172c0:	6172203c 6e655f6d 00000064 67756c70     < ram_end...plug
 80172d0:	6c6f685f 203a7365 2d6d656d 6573753e     _holes: mem->use
 80172e0:	3d3d2064 00003020 67756c70 6c6f685f     d == 0..plug_hol
 80172f0:	203a7365 2d6d656d 78656e3e 3d3c2074     es: mem->next <=
 8017300:	4d454d20 5a49535f 4c415f45 454e4749      MEM_SIZE_ALIGNE
 8017310:	00000044 5f6d656d 6d697274 656c203a     D...mem_trim: le
 8017320:	206c6167 6f6d656d 00007972 5f6d656d     gal memory..mem_
 8017330:	6d697274 6e616320 6c6e6f20 68732079     trim can only sh
 8017340:	6b6e6972 6d656d20 0079726f 5f6d656d     rink memory.mem_
 8017350:	6c6c616d 203a636f 6f6c6c61 65746163     malloc: allocate
 8017360:	656d2064 79726f6d 746f6e20 6f626120     d memory not abo
 8017370:	72206576 655f6d61 002e646e 5f6d656d     ve ram_end..mem_
 8017380:	6c6c616d 203a636f 6f6c6c61 65746163     malloc: allocate
 8017390:	656d2064 79726f6d 6f727020 6c726570     d memory properl
 80173a0:	6c612079 656e6769 00002e64 5f6d656d     y aligned...mem_
 80173b0:	6c6c616d 203a636f 696e6173 63207974     malloc: sanity c
 80173c0:	6b636568 696c6120 656d6e67 0000746e     heck alignment..

080173d0 <memp_num>:
 80173d0:	00040004 00080005 00050010 0002000f     ................
 80173e0:	00080004 00030008 00100020 00000000     ........ .......
 80173f0:	706d656d 6c616d5f 3a636f6c 70797420     memp_malloc: typ
 8017400:	203c2065 504d454d 58414d5f 00000000     e < MEMP_MAX....
 8017410:	2e2f2e2e 2e2e2f2e 2f736f2f 2f747865     ../../../os/ext/
 8017420:	7069776c 342e312d 732f312e 632f6372     lwip-1.4.1/src/c
 8017430:	2f65726f 706d656d 0000632e 706d656d     ore/memp.c..memp
 8017440:	6c616d5f 3a636f6c 6d656d20 72702070     _malloc: memp pr
 8017450:	7265706f 6120796c 6e67696c 00006465     operly aligned..
 8017460:	706d656d 6572665f 6d203a65 70206d65     memp_free: mem p
 8017470:	65706f72 20796c72 67696c61 0064656e     roperly aligned.

08017480 <memp_sizes>:
 8017480:	0020001c 001c0098 00200010 00100018     .. ....... .....
 8017490:	0014002c 00100014 05fc0010 00000000     ,...............
 80174a0:	69206f4e 2074696e 636e7566 6e6f6974     No init function
 80174b0:	76696720 00006e65 2e2f2e2e 2e2e2f2e      given..../../..
 80174c0:	2f736f2f 2f747865 7069776c 342e312d     /os/ext/lwip-1.4
 80174d0:	732f312e 632f6372 2f65726f 6974656e     .1/src/core/neti
 80174e0:	00632e66 00000000 00000000 00000000     f.c.............
 80174f0:	66756270 6c6c615f 6465636f 7375635f     pbuf_alloced_cus
 8017500:	3a6d6f74 64616220 75627020 616c2066     tom: bad pbuf la
 8017510:	00726579 2e2f2e2e 2e2e2f2e 2f736f2f     yer.../../../os/
 8017520:	2f747865 7069776c 342e312d 732f312e     ext/lwip-1.4.1/s
 8017530:	632f6372 2f65726f 66756270 0000632e     rc/core/pbuf.c..
 8017540:	72636e69 6e656d65 616d5f74 74696e67     increment_magnit
 8017550:	20656475 70203d3c 656c3e2d 0000006e     ude <= p->len...
 8017560:	20646162 66756270 70797420 00000065     bad pbuf type...
 8017570:	66756270 6572665f 73203a65 20656e61     pbuf_free: sane 
 8017580:	65707974 00000000 66756270 6572665f     type....pbuf_fre
 8017590:	70203a65 65723e2d 203e2066 00000030     e: p->ref > 0...
 80175a0:	3e2d6370 74737563 665f6d6f 5f656572     pc->custom_free_
 80175b0:	636e7566 6e6f6974 203d2120 4c4c554e     function != NULL
 80175c0:	00000000 66756270 6c6c615f 203a636f     ....pbuf_alloc: 
 80175d0:	20646162 66756270 79616c20 00007265     bad pbuf layer..
 80175e0:	63656863 2d70206b 7961703e 64616f6c     check p->payload
 80175f0:	70202b20 656c3e2d 6f64206e 6e207365      + p->len does n
 8017600:	6f20746f 66726576 20776f6c 66756270     ot overflow pbuf
 8017610:	00000000 5f6d6572 206e656c 616d203c     ....rem_len < ma
 8017620:	31755f78 00745f36 66756270 6c6c615f     x_u16_t.pbuf_all
 8017630:	203a636f 66756270 3e2d7120 6c796170     oc: pbuf q->payl
 8017640:	2064616f 706f7270 796c7265 696c6120     oad properly ali
 8017650:	64656e67 00000000 66756270 6c6c615f     gned....pbuf_all
 8017660:	203a636f 6f727265 756f656e 79742073     oc: erroneous ty
 8017670:	00006570 66756270 6165725f 636f6c6c     pe..pbuf_realloc
 8017680:	2070203a 4e203d21 004c4c55 66756270     : p != NULL.pbuf
 8017690:	6165725f 636f6c6c 6173203a 7020656e     _realloc: sane p
 80176a0:	79743e2d 00006570 776f7267 6d203c20     ->type..grow < m
 80176b0:	755f7861 745f3631 00000000 66756270     ax_u16_t....pbuf
 80176c0:	6165725f 636f6c6c 2071203a 4e203d21     _realloc: q != N
 80176d0:	004c4c55 5f6d656d 6d697274 74657220     ULL.mem_trim ret
 80176e0:	656e7275 20712064 4e203d3d 004c4c55     urned q == NULL.
 80176f0:	21206828 554e203d 20294c4c 28202626     (h != NULL) && (
 8017700:	3d212074 4c554e20 2820294c 676f7270     t != NULL) (prog
 8017710:	6d6d6172 76207265 616c6f69 20736574     rammer violates 
 8017720:	29495041 00000000 743e2d70 6c5f746f     API)....p->tot_l
 8017730:	3d206e65 2d70203d 6e656c3e 666f2820     en == p->len (of
 8017740:	73616c20 62702074 69206675 6863206e      last pbuf in ch
 8017750:	296e6961 00000000 6e3e2d70 20747865     ain)....p->next 
 8017760:	4e203d3d 004c4c55 743e2d70 6c5f746f     == NULL.p->tot_l
 8017770:	3d206e65 2d70203d 6e656c3e 71202b20     en == p->len + q
 8017780:	6f743e2d 656c5f74 0000006e 743e2d70     ->tot_len...p->t
 8017790:	6c5f746f 3d206e65 2d70203d 6e656c3e     ot_len == p->len
 80177a0:	00000000 66756270 706f635f 74203a79     ....pbuf_copy: t
 80177b0:	65677261 6f6e2074 69622074 6e652067     arget not big en
 80177c0:	6867756f 206f7420 646c6f68 756f7320     ough to hold sou
 80177d0:	00656372 7366666f 745f7465 3d3c206f     rce.offset_to <=
 80177e0:	745f7020 6c3e2d6f 00006e65 7366666f      p_to->len..offs
 80177f0:	665f7465 206d6f72 70203d3c 6f72665f     et_from <= p_fro
 8017800:	6c3e2d6d 00006e65 6f745f70 203d2120     m->len..p_to != 
 8017810:	4c4c554e 00000000 66756270 706f635f     NULL....pbuf_cop
 8017820:	20292879 73656f64 746f6e20 6c6c6120     y() does not all
 8017830:	7020776f 656b6361 75712074 73657565     ow packet queues
 8017840:	00000a21 66756270 706f635f 61705f79     !...pbuf_copy_pa
 8017850:	61697472 69203a6c 6c61766e 62206469     rtial: invalid b
 8017860:	00006675 66756270 706f635f 61705f79     uf..pbuf_copy_pa
 8017870:	61697472 69203a6c 6c61766e 64206469     rtial: invalid d
 8017880:	70617461 00007274 66756270 6b61745f     ataptr..pbuf_tak
 8017890:	69203a65 6c61766e 62206469 00006675     e: invalid buf..
 80178a0:	66756270 6b61745f 69203a65 6c61766e     pbuf_take: inval
 80178b0:	64206469 70617461 00007274 66756270     id dataptr..pbuf
 80178c0:	6b61745f 69203a65 6c61766e 70206469     _take: invalid p
 80178d0:	00667562 20646964 20746f6e 79706f63     buf.did not copy
 80178e0:	6c6c6120 74616420 00000061 66756270      all data...pbuf
 80178f0:	706f635f 61662079 64656c69 00000000     _copy failed....

08017900 <tcp_pcb_lists>:
 8017900:	2000cb5c 2000cb6c 2000cb60 2000cb50     \.. l.. `.. P.. 

08017910 <tcp_backoff>:
 8017910:	04030201 07070605 07070707 00000007     ................
 8017920:	5f706374 646e6962 6163203a 6e6f206e     tcp_bind: can on
 8017930:	6220796c 20646e69 73206e69 65746174     ly bind in state
 8017940:	4f4c4320 00444553 2e2f2e2e 2e2e2f2e      CLOSED.../../..
 8017950:	2f736f2f 2f747865 7069776c 342e312d     /os/ext/lwip-1.4
 8017960:	732f312e 632f6372 2f65726f 2e706374     .1/src/core/tcp.
 8017970:	00000063 5f706374 7473696c 203a6e65     c...tcp_listen: 
 8017980:	20626370 65726c61 20796461 6e6e6f63     pcb already conn
 8017990:	65746365 00000064 5f77656e 5f766372     ected...new_rcv_
 80179a0:	5f6e6e61 20646e77 30203d3c 66666678     ann_wnd <= 0xfff
 80179b0:	00000066 276e6f64 61632074 74206c6c     f...don't call t
 80179c0:	725f7063 65766365 6f662064 696c2072     cp_recved for li
 80179d0:	6e657473 6263702d 00000073 5f706374     sten-pcbs...tcp_
 80179e0:	76636572 203a6465 206e656c 6c756f77     recved: len woul
 80179f0:	72772064 72207061 775f7663 000a646e     d wrap rcv_wnd..
 8017a00:	61766e69 2064696c 6b636f73 73207465     invalid socket s
 8017a10:	65746174 726f6620 63657220 61632076     tate for recv ca
 8017a20:	61626c6c 00006b63 61766e69 2064696c     llback..invalid 
 8017a30:	6b636f73 73207465 65746174 726f6620     socket state for
 8017a40:	6e657320 61632074 61626c6c 00006b63      sent callback..
 8017a50:	61766e69 2064696c 6b636f73 73207465     invalid socket s
 8017a60:	65746174 726f6620 72726520 6c616320     tate for err cal
 8017a70:	6361626c 0000006b 61766e69 2064696c     lback...invalid 
 8017a80:	6b636f73 73207465 65746174 726f6620     socket state for
 8017a90:	6c6f7020 0000006c 5f706374 776f6c73      poll...tcp_slow
 8017aa0:	3a726d74 74636120 20657669 2d626370     tmr: active pcb-
 8017ab0:	6174733e 21206574 4c43203d 4445534f     >state != CLOSED
 8017ac0:	0000000a 5f706374 776f6c73 3a726d74     ....tcp_slowtmr:
 8017ad0:	74636120 20657669 2d626370 6174733e      active pcb->sta
 8017ae0:	21206574 494c203d 4e455453 0000000a     te != LISTEN....
 8017af0:	5f706374 776f6c73 3a726d74 74636120     tcp_slowtmr: act
 8017b00:	20657669 2d626370 6174733e 21206574     ive pcb->state !
 8017b10:	4954203d 572d454d 0a544941 00000000     = TIME-WAIT.....
 8017b20:	5f706374 776f6c73 3a726d74 64696d20     tcp_slowtmr: mid
 8017b30:	20656c64 20706374 74203d21 615f7063     dle tcp != tcp_a
 8017b40:	76697463 63705f65 00007362 5f706374     ctive_pcbs..tcp_
 8017b50:	776f6c73 3a726d74 72696620 70207473     slowtmr: first p
 8017b60:	3d206263 6374203d 63615f70 65766974     cb == tcp_active
 8017b70:	6263705f 00000073 5f706374 776f6c73     _pcbs...tcp_slow
 8017b80:	3a726d74 4d495420 41572d45 70205449     tmr: TIME-WAIT p
 8017b90:	3e2d6263 74617473 3d3d2065 4d495420     cb->state == TIM
 8017ba0:	41572d45 00005449 5f706374 776f6c73     E-WAIT..tcp_slow
 8017bb0:	3a726d74 64696d20 20656c64 20706374     tmr: middle tcp 
 8017bc0:	74203d21 745f7063 63705f77 00007362     != tcp_tw_pcbs..
 8017bd0:	5f706374 776f6c73 3a726d74 72696620     tcp_slowtmr: fir
 8017be0:	70207473 3d206263 6374203d 77745f70     st pcb == tcp_tw
 8017bf0:	6263705f 00000073 65736e75 7320746e     _pcbs...unsent s
 8017c00:	656d6765 2073746e 6b61656c 00676e69     egments leaking.
 8017c10:	63616e75 2064656b 6d676573 73746e65     unacked segments
 8017c20:	61656c20 676e696b 00000000 65736f6f      leaking....oose
 8017c30:	65732071 6e656d67 6c207374 696b6165     q segments leaki
 8017c40:	0000676e 2d626370 616c663e 26207367     ng..pcb->flags &
 8017c50:	5f465420 4c435852 4445534f 00000000      TF_RXCLOSED....
 8017c60:	276e6f64 61632074 74206c6c 615f7063     don't call tcp_a
 8017c70:	74726f62 7063742f 6162615f 6e6f646e     bort/tcp_abandon
 8017c80:	726f6620 73696c20 2d6e6574 73626370      for listen-pcbs
 8017c90:	00000000 5f706374 6e6e6f63 3a746365     ....tcp_connect:
 8017ca0:	6e616320 6c6e6f20 6f632079 63656e6e      can only connec
 8017cb0:	72662074 73206d6f 65746174 4f4c4320     t from state CLO
 8017cc0:	00444553 5f4e5953 544e4553 00000000     SED.SYN_SENT....
 8017cd0:	5f4e5953 44564352 00000000 41545345     SYN_RCVD....ESTA
 8017ce0:	53494c42 00444548 5f4e4946 54494157     BLISHED.FIN_WAIT
 8017cf0:	0000315f 5f4e4946 54494157 0000325f     _1..FIN_WAIT_2..
 8017d00:	534f4c43 41575f45 00005449 534f4c43     CLOSE_WAIT..CLOS
 8017d10:	00474e49 5453414c 4b43415f 00000000     ING.LAST_ACK....
 8017d20:	454d4954 4941575f 00000054 00000000     TIME_WAIT.......

08017d30 <tcp_persist_backoff>:
 8017d30:	180c0603 00786030 00000000 00000000     ....0`x.........
 8017d40:	5f706374 65636572 3a657669 6f727720     tcp_receive: wro
 8017d50:	7320676e 65746174 00000000 2e2f2e2e     ng state....../.
 8017d60:	2e2e2f2e 2f736f2f 2f747865 7069776c     ./../os/ext/lwip
 8017d70:	342e312d 732f312e 632f6372 2f65726f     -1.4.1/src/core/
 8017d80:	5f706374 632e6e69 00000000 2d626370     tcp_in.c....pcb-
 8017d90:	646e733e 6575715f 656c6575 3d3e206e     >snd_queuelen >=
 8017da0:	75627020 6c635f66 6e286e65 2d747865      pbuf_clen(next-
 8017db0:	0029703e 5f706374 65636572 3a657669     >p).tcp_receive:
 8017dc0:	6c617620 71206469 65756575 6e656c20      valid queue len
 8017dd0:	00687467 65736e69 20702e67 4e203d21     gth.inseg.p != N
 8017de0:	004c4c55 61736e69 6f20656e 65736666     ULL.insane offse
 8017df0:	00002174 66756270 6f6f7420 6f687320     t!..pbuf too sho
 8017e00:	00217472 66756270 6165685f 20726564     rt!.pbuf_header 
 8017e10:	6c696166 00006465 5f706374 65636572     failed..tcp_rece
 8017e20:	3a657669 67657320 746e656d 746f6e20     ive: segment not
 8017e30:	69727420 64656d6d 726f6320 74636572      trimmed correct
 8017e40:	7420796c 6372206f 6e775f76 00000a64     ly to rcv_wnd...
 8017e50:	5f706374 65636572 3a657669 67657320     tcp_receive: seg
 8017e60:	746e656d 746f6e20 69727420 64656d6d     ment not trimmed
 8017e70:	726f6320 74636572 7420796c 6f6f206f      correctly to oo
 8017e80:	20716573 75657571 00000a65 5f706374     seq queue...tcp_
 8017e90:	65636572 3a657669 70637420 206e656c     receive: tcplen 
 8017ea0:	6372203e 6e775f76 00000a64 5f706374     > rcv_wnd...tcp_
 8017eb0:	65636572 3a657669 736f6f20 74207165     receive: ooseq t
 8017ec0:	656c7063 203e206e 5f766372 0a646e77     cplen > rcv_wnd.
 8017ed0:	00000000 5f706374 75706e69 61203a74     ....tcp_input: a
 8017ee0:	76697463 63702065 733e2d62 65746174     ctive pcb->state
 8017ef0:	203d2120 534f4c43 00004445 5f706374      != CLOSED..tcp_
 8017f00:	75706e69 61203a74 76697463 63702065     input: active pc
 8017f10:	733e2d62 65746174 203d2120 454d4954     b->state != TIME
 8017f20:	4941572d 00000054 5f706374 75706e69     -WAIT...tcp_inpu
 8017f30:	61203a74 76697463 63702065 733e2d62     t: active pcb->s
 8017f40:	65746174 203d2120 5453494c 00004e45     tate != LISTEN..
 8017f50:	5f706374 75706e69 70203a74 3e2d6263     tcp_input: pcb->
 8017f60:	7478656e 203d2120 20626370 66656228     next != pcb (bef
 8017f70:	2065726f 68636163 00002965 5f706374     ore cache)..tcp_
 8017f80:	75706e69 70203a74 3e2d6263 7478656e     input: pcb->next
 8017f90:	203d2120 20626370 74666128 63207265      != pcb (after c
 8017fa0:	65686361 00000029 5f706374 75706e69     ache)...tcp_inpu
 8017fb0:	54203a74 2d454d49 54494157 62637020     t: TIME-WAIT pcb
 8017fc0:	74733e2d 20657461 54203d3d 2d454d49     ->state == TIME-
 8017fd0:	54494157 00000000 5f706374 75706e69     WAIT....tcp_inpu
 8017fe0:	70203a74 3e2d6263 74617473 3d212065     t: pcb->state !=
 8017ff0:	4f4c4320 00444553 2d626370 646e733e      CLOSED.pcb->snd
 8018000:	6575715f 656c6575 203e206e 00000030     _queuelen > 0...
 8018010:	2d626370 6363613e 20747065 4e203d21     pcb->accept != N
 8018020:	004c4c55 2d626370 6665723e 64657375     ULL.pcb->refused
 8018030:	7461645f 3d3d2061 4c554e20 0000004c     _data == NULL...
 8018040:	63656863 6874206b 66207461 74737269     check that first
 8018050:	75627020 61632066 6f68206e 7320646c      pbuf can hold s
 8018060:	63757274 63742074 64685f70 00000072     truct tcp_hdr...
 8018070:	2e2f2e2e 2e2e2f2e 2f736f2f 2f747865     ../../../os/ext/
 8018080:	7069776c 342e312d 732f312e 632f6372     lwip-1.4.1/src/c
 8018090:	2f65726f 5f706374 2e74756f 00000063     ore/tcp_out.c...
 80180a0:	6465656e 636e7520 6e696168 70206465     need unchained p
 80180b0:	00667562 5f706374 74697277 61203a65     buf.tcp_write: a
 80180c0:	3d206772 554e203d 28204c4c 676f7270     rg == NULL (prog
 80180d0:	6d6d6172 76207265 616c6f69 20736574     rammer violates 
 80180e0:	29495041 00000000 5f706374 74697277     API)....tcp_writ
 80180f0:	70203a65 73667562 206e6f20 75657571     e: pbufs on queu
 8018100:	3e3d2065 20746120 7361656c 6e6f2074     e => at least on
 8018110:	75712065 20657565 2d6e6f6e 74706d65     e queue non-empt
 8018120:	00000079 5f706374 74697277 6e203a65     y...tcp_write: n
 8018130:	6270206f 20736675 71206e6f 65756575     o pbufs on queue
 8018140:	203e3d20 68746f62 65757120 20736575      => both queues 
 8018150:	74706d65 00000079 6f636e69 7369736e     empty...inconsis
 8018160:	646e6574 65766f20 7a697372 73762065     tend oversize vs
 8018170:	656c202e 0000006e 65736e75 6f5f746e     . len...unsent_o
 8018180:	73726576 20657a69 6d73696d 68637461     versize mismatch
 8018190:	63702820 753e2d62 6e65736e 73692074      (pcb->unsent is
 80181a0:	4c554e20 0000294c 5f706374 74697277      NULL)..tcp_writ
 80181b0:	63203a65 6b636568 61687420 69662074     e: check that fi
 80181c0:	20747372 66756270 6e616320 6c6f6820     rst pbuf can hol
 80181d0:	68742064 6f632065 656c706d 73206574     d the complete s
 80181e0:	656c6765 0000006e 7265766f 657a6973     eglen...oversize
 80181f0:	203d3d20 00000030 76657270 6765735f      == 0...prev_seg
 8018200:	203d2120 4c4c554e 00000000 5f706374      != NULL....tcp_
 8018210:	74697277 63203a65 6f6e6e61 6f632074     write: cannot co
 8018220:	7461636e 74616e65 68772065 70206e65     ncatenate when p
 8018230:	3e2d6263 65736e75 6920746e 6d652073     cb->unsent is em
 8018240:	00797470 5f706374 74697277 76203a65     pty.tcp_write: v
 8018250:	64696c61 65757120 6c206575 74676e65     alid queue lengt
 8018260:	00000068 5f706374 75716e65 5f657565     h...tcp_enqueue_
 8018270:	67616c66 6e203a73 20646565 68746965     flags: need eith
 8018280:	54207265 535f5043 6f204e59 43542072     er TCP_SYN or TC
 8018290:	49465f50 6e69204e 616c6620 28207367     P_FIN in flags (
 80182a0:	676f7270 6d6d6172 76207265 616c6f69     programmer viola
 80182b0:	20736574 29495041 00000000 5f706374     tes API)....tcp_
 80182c0:	75716e65 5f657565 67616c66 63203a73     enqueue_flags: c
 80182d0:	6b636568 61687420 69662074 20747372     heck that first 
 80182e0:	66756270 6e616320 6c6f6820 706f2064     pbuf can hold op
 80182f0:	6e656c74 00000000 2d676573 7063743e     tlen....seg->tcp
 8018300:	20726468 20746f6e 67696c61 0064656e     hdr not aligned.
 8018310:	5f706374 75716e65 5f657565 67616c66     tcp_enqueue_flag
 8018320:	69203a73 6c61766e 73206469 656d6765     s: invalid segme
 8018330:	6c20746e 74676e65 00000068 5f706374     nt length...tcp_
 8018340:	75716e65 5f657565 67616c66 69203a73     enqueue_flags: i
 8018350:	6c61766e 71206469 65756575 6e656c20     nvalid queue len
 8018360:	00687467 276e6f64 61632074 74206c6c     gth.don't call t
 8018370:	6f5f7063 75707475 6f662074 696c2072     cp_output for li
 8018380:	6e657473 6263702d 00000073 20545352     sten-pcbs...RST 
 8018390:	20746f6e 65707865 64657463 72656820     not expected her
 80183a0:	00002165 00000000 00000000 00000000     e!..............
 80183b0:	66756270 6165685f 20726564 6c696166     pbuf_header fail
 80183c0:	000a6465 2e2f2e2e 2e2e2f2e 2f736f2f     ed..../../../os/
 80183d0:	2f747865 7069776c 342e312d 732f312e     ext/lwip-1.4.1/s
 80183e0:	632f6372 2f65726f 2e706475 00000063     rc/core/udp.c...
 80183f0:	703e2d70 6f6c7961 3d206461 7069203d     p->payload == ip
 8018400:	00726468 69626572 3d20646e 0030203d     hdr.rebind == 0.
 8018410:	63656863 6874206b 66207461 74737269     check that first
 8018420:	75627020 61632066 6f68206e 7320646c      pbuf can hold s
 8018430:	63757274 64752074 64685f70 00000072     truct udp_hdr...
 8018440:	63656863 6874206b 66207461 74737269     check that first
 8018450:	75627020 61632066 6f68206e 6920646c      pbuf can hold i
 8018460:	20706d63 7373656d 00656761 2e2f2e2e     cmp message.../.
 8018470:	2e2e2f2e 2f736f2f 2f747865 7069776c     ./../os/ext/lwip
 8018480:	342e312d 732f312e 632f6372 2f65726f     -1.4.1/src/core/
 8018490:	34767069 6d63692f 00632e70 706d6369     ipv4/icmp.c.icmp
 80184a0:	706e695f 203a7475 69766f6d 7020676e     _input: moving p
 80184b0:	61703e2d 616f6c79 6f742064 20706920     ->payload to ip 
 80184c0:	64616568 66207265 656c6961 00000a64     header failed...
 80184d0:	63656863 6874206b 66207461 74737269     check that first
 80184e0:	75627020 61632066 6f68206e 7320646c      pbuf can hold s
 80184f0:	63757274 68742074 43492065 6820504d     truct the ICMP h
 8018500:	65646165 00000072 706d6369 706e695f     eader...icmp_inp
 8018510:	203a7475 79706f63 20676e69 6e206f74     ut: copying to n
 8018520:	70207765 20667562 6c696166 000a6465     ew pbuf failed..
 8018530:	706d6369 706e695f 203a7475 74736572     icmp_input: rest
 8018540:	6e69726f 726f2067 6e696769 70206c61     oring original p
 8018550:	61703e2d 616f6c79 61662064 64656c69     ->payload failed
 8018560:	0000000a 00000000 00000000 00000000     ................
 8018570:	723e2d70 3d206665 0031203d 2e2f2e2e     p->ref == 1.../.
 8018580:	2e2e2f2e 2f736f2f 2f747865 7069776c     ./../os/ext/lwip
 8018590:	342e312d 732f312e 632f6372 2f65726f     -1.4.1/src/core/
 80185a0:	34767069 2e70692f 00000063 63656863     ipv4/ip.c...chec
 80185b0:	6874206b 66207461 74737269 75627020     k that first pbu
 80185c0:	61632066 6f68206e 7320646c 63757274     f can hold struc
 80185d0:	70692074 7264685f 00000000 00000000     t ip_hdr........
 80185e0:	2e2f2e2e 2e2e2f2e 2f736f2f 2f747865     ../../../os/ext/
 80185f0:	7069776c 342e312d 732f312e 632f6372     lwip-1.4.1/src/c
 8018600:	2f65726f 34767069 5f70692f 67617266     ore/ipv4/ip_frag
 8018610:	0000632e 20726370 4e203d21 004c4c55     .c..pcr != NULL.
 8018620:	696e6173 63207974 6b636568 6e696c20     sanity check lin
 8018630:	2064656b 7473696c 00000000 76657270     ked list....prev
 8018640:	203d2120 00727069 76657270 656e3e2d      != ipr.prev->ne
 8018650:	3d207478 7069203d 00000072 66756270     xt == ipr...pbuf
 8018660:	72665f73 20646565 6c63202b 3c206e65     s_freed + clen <
 8018670:	7830203d 66666666 00000000 725f7069     = 0xffff....ip_r
 8018680:	73736165 7562705f 756f6366 3e20746e     eass_pbufcount >
 8018690:	6c63203d 00006e65 63656863 7266206b     = clen..check fr
 80186a0:	656d6761 2073746e 276e6f64 766f2074     agments don't ov
 80186b0:	616c7265 00000070 696e6173 63207974     erlap...sanity c
 80186c0:	6b636568 00000000 696c6176 65746164     heck....validate
 80186d0:	7461645f 61726761 656e3a6d 705f7478     _datagram:next_p
 80186e0:	21667562 4c554e3d 0000004c 696c6176     buf!=NULL...vali
 80186f0:	65746164 7461645f 61726761 61643a6d     date_datagram:da
 8018700:	72676174 65206d61 3d21646e 61746164     tagram end!=data
 8018710:	6d617267 6e656c20 00000000 73696874     gram len....this
 8018720:	65656e20 61207364 75627020 6e692066      needs a pbuf in
 8018730:	656e6f20 65697020 00216563 00000000      one piece!.....
 8018740:	5f737973 656d6974 3a74756f 6d697420     sys_timeout: tim
 8018750:	74756f65 203d2120 4c4c554e 6f70202c     eout != NULL, po
 8018760:	4d206c6f 5f504d45 5f535953 454d4954     ol MEMP_SYS_TIME
 8018770:	2054554f 65207369 7974706d 00000000     OUT is empty....
 8018780:	2e2f2e2e 2e2e2f2e 2f736f2f 2f747865     ../../../os/ext/
 8018790:	7069776c 342e312d 732f312e 632f6372     lwip-1.4.1/src/c
 80187a0:	2f65726f 656d6974 632e7372 00000000     ore/timers.c....
 80187b0:	6374656e 5f6e6e6f 76636572 6e69203a     netconn_recv: in
 80187c0:	696c6176 6f702064 65746e69 00000072     valid pointer...
 80187d0:	2e2f2e2e 2e2e2f2e 2f736f2f 2f747865     ../../../os/ext/
 80187e0:	7069776c 342e312d 732f312e 612f6372     lwip-1.4.1/src/a
 80187f0:	612f6970 6c5f6970 632e6269 00000000     pi/api_lib.c....
 8018800:	6374656e 5f6e6e6f 76636572 6e69203a     netconn_recv: in
 8018810:	696c6176 6f632064 00006e6e 6374656e     valid conn..netc
 8018820:	5f6e6e6f 65636361 203a7470 61766e69     onn_accept: inva
 8018830:	2064696c 76636572 786f626d 00000000     lid recvmbox....
 8018840:	20667562 4e203d21 004c4c55 6374656e     buf != NULL.netc
 8018850:	5f6e6e6f 736f6c63 69203a65 6c61766e     onn_close: inval
 8018860:	63206469 006e6e6f 65657266 20676e69     id conn.freeing 
 8018870:	6e6e6f63 74697720 74756f68 65726620     conn without fre
 8018880:	676e6965 62637020 00000000 6e6e6f63     eing pcb....conn
 8018890:	73616820 206f6e20 635f706f 6c706d6f      has no op_compl
 80188a0:	64657465 00000000 6e6e6f63 73616820     eted....conn has
 80188b0:	206f6e20 76636572 786f626d 00000000      no recvmbox....
 80188c0:	6e6e6f63 63613e2d 74706563 786f626d     conn->acceptmbox
 80188d0:	6f687320 6e646c75 65207427 74736978      shouldn't exist
 80188e0:	00000000 6374656e 5f6e6e6f 61746567     ....netconn_geta
 80188f0:	3a726464 766e6920 64696c61 6e6f6320     ddr: invalid con
 8018900:	0000006e 6374656e 5f6e6e6f 61746567     n...netconn_geta
 8018910:	3a726464 766e6920 64696c61 64646120     ddr: invalid add
 8018920:	00000072 6374656e 5f6e6e6f 61746567     r...netconn_geta
 8018930:	3a726464 766e6920 64696c61 726f7020     ddr: invalid por
 8018940:	00000074 6374656e 5f6e6e6f 646e6962     t...netconn_bind
 8018950:	6e69203a 696c6176 6f632064 00006e6e     : invalid conn..
 8018960:	6374656e 5f6e6e6f 6e6e6f63 3a746365     netconn_connect:
 8018970:	766e6920 64696c61 6e6f6320 0000006e      invalid conn...
 8018980:	6374656e 5f6e6e6f 63736964 656e6e6f     netconn_disconne
 8018990:	203a7463 61766e69 2064696c 6e6e6f63     ct: invalid conn
 80189a0:	00000000 6374656e 5f6e6e6f 7473696c     ....netconn_list
 80189b0:	203a6e65 61766e69 2064696c 6e6e6f63     en: invalid conn
 80189c0:	00000000 6374656e 5f6e6e6f 65636361     ....netconn_acce
 80189d0:	203a7470 61766e69 2064696c 6e696f70     pt: invalid poin
 80189e0:	00726574 6374656e 5f6e6e6f 65636361     ter.netconn_acce
 80189f0:	203a7470 61766e69 2064696c 6e6e6f63     pt: invalid conn
 8018a00:	00000000 6374656e 5f6e6e6f 65636361     ....netconn_acce
 8018a10:	203a7470 61766e69 2064696c 65636361     pt: invalid acce
 8018a20:	626d7470 0000786f 6374656e 5f6e6e6f     ptmbox..netconn_
 8018a30:	646e6573 6e69203a 696c6176 6f632064     send: invalid co
 8018a40:	00006e6e 6374656e 5f6e6e6f 74697277     nn..netconn_writ
 8018a50:	69203a65 6c61766e 63206469 006e6e6f     e: invalid conn.
 8018a60:	6374656e 5f6e6e6f 74697277 69203a65     netconn_write: i
 8018a70:	6c61766e 63206469 2d6e6e6f 7079743e     nvalid conn->typ
 8018a80:	00000065 00000000 00000000 00000000     e...............
 8018a90:	76636572 7063745f 73756d20 61682074     recv_tcp must ha
 8018aa0:	61206576 62637020 67726120 6e656d75     ve a pcb argumen
 8018ab0:	00000074 2e2f2e2e 2e2e2f2e 2f736f2f     t...../../../os/
 8018ac0:	2f747865 7069776c 342e312d 732f312e     ext/lwip-1.4.1/s
 8018ad0:	612f6372 612f6970 6d5f6970 632e6773     rc/api/api_msg.c
 8018ae0:	00000000 76636572 7063745f 73756d20     ....recv_tcp mus
 8018af0:	61682074 61206576 7261206e 656d7567     t have an argume
 8018b00:	0000746e 76636572 7063745f 6572203a     nt..recv_tcp: re
 8018b10:	66207663 7720726f 676e6f72 62637020     cv for wrong pcb
 8018b20:	00000021 73696874 20736920 20726f66     !...this is for 
 8018b30:	20706374 6374656e 736e6e6f 6c6e6f20     tcp netconns onl
 8018b40:	00000079 6e6e6f63 73756d20 65622074     y...conn must be
 8018b50:	206e6920 74617473 454e2065 4e4f4354      in state NETCON
 8018b60:	4c435f4e 0045534f 20626370 65726c61     N_CLOSE.pcb alre
 8018b70:	20796461 736f6c63 00006465 6e6e6f63     ady closed..conn
 8018b80:	75633e2d 6e657272 736d5f74 3d212067     ->current_msg !=
 8018b90:	4c554e20 0000004c 736f6c43 20676e69      NULL...Closing 
 8018ba0:	696c2061 6e657473 62637020 79616d20     a listen pcb may
 8018bb0:	746f6e20 69616620 0000216c 6e6e6f63      not fail!..conn
 8018bc0:	74733e2d 20657461 4e203d3d 4f435445     ->state == NETCO
 8018bd0:	575f4e4e 45544952 00000000 6e6e6f63     NN_WRITE....conn
 8018be0:	63703e2d 63742e62 3d212070 4c554e20     ->pcb.tcp != NUL
 8018bf0:	0000004c 6e6e6f63 72773e2d 5f657469     L...conn->write_
 8018c00:	7366666f 3c207465 6e6f6320 633e2d6e     offset < conn->c
 8018c10:	65727275 6d5f746e 3e2d6773 2e67736d     urrent_msg->msg.
 8018c20:	656c2e77 0000006e 775f6f64 65746972     w.len...do_write
 8018c30:	65726f6d 6e69203a 696c6176 656c2064     more: invalid le
 8018c40:	6874676e 00000021 6e6e6f63 203d2120     ngth!...conn != 
 8018c50:	4c4c554e 00000000 6e6e6f63 74733e2d     NULL....conn->st
 8018c60:	20657461 4e203d3d 4f435445 435f4e4e     ate == NETCONN_C
 8018c70:	454e4e4f 00005443 6e6f6328 633e2d6e     ONNECT..(conn->c
 8018c80:	65727275 6d5f746e 21206773 554e203d     urrent_msg != NU
 8018c90:	20294c4c 63207c7c 2d6e6e6f 5f6e693e     LL) || conn->in_
 8018ca0:	5f6e6f6e 636f6c62 676e696b 6e6f635f     non_blocking_con
 8018cb0:	7463656e 00000000 6e6e6f63 75633e2d     nect....conn->cu
 8018cc0:	6e657272 736d5f74 3d3d2067 4c554e20     rrent_msg == NUL
 8018cd0:	0000004c 76636572 7064755f 73756d20     L...recv_udp mus
 8018ce0:	61682074 61206576 62637020 67726120     t have a pcb arg
 8018cf0:	6e656d75 00000074 76636572 7064755f     ument...recv_udp
 8018d00:	73756d20 61682074 61206576 7261206e      must have an ar
 8018d10:	656d7567 0000746e 76636572 7064755f     gument..recv_udp
 8018d20:	6572203a 66207663 7720726f 676e6f72     : recv for wrong
 8018d30:	62637020 00000021 6374656e 5f6e6e6f      pcb!...netconn_
 8018d40:	6f6c6c61 75203a63 6665646e 64656e69     alloc: undefined
 8018d50:	74656e20 6e6e6f63 7079745f 00000065      netconn_type...
 8018d60:	20424350 7473756d 20656220 6c616564     PCB must be deal
 8018d70:	61636f6c 20646574 7374756f 20656469     located outside 
 8018d80:	73696874 6e756620 6f697463 0000006e     this function...
 8018d90:	76636572 786f626d 73756d20 65622074     recvmbox must be
 8018da0:	61656420 636f6c6c 64657461 66656220      deallocated bef
 8018db0:	2065726f 6c6c6163 20676e69 73696874     ore calling this
 8018dc0:	6e756620 6f697463 0000006e 65636361      function...acce
 8018dd0:	626d7470 6d20786f 20747375 64206562     ptmbox must be d
 8018de0:	6c6c6165 7461636f 62206465 726f6665     eallocated befor
 8018df0:	61632065 6e696c6c 68742067 66207369     e calling this f
 8018e00:	74636e75 006e6f69 2d626370 6174733e     unction.pcb->sta
 8018e10:	3d206574 494c203d 4e455453 61632820     te == LISTEN (ca
 8018e20:	64656c6c 726f6620 6f727720 7020676e     lled for wrong p
 8018e30:	293f6263 00000000 2d67736d 6e6f633e     cb?)....msg->con
 8018e40:	743e2d6e 20657079 4e203d3d 4f435445     n->type == NETCO
 8018e50:	545f4e4e 00005043 636f6c62 676e696b     NN_TCP..blocking
 8018e60:	6e6f6320 7463656e 206e6920 676f7270      connect in prog
 8018e70:	73736572 00000000 65726c61 20796461     ress....already 
 8018e80:	74697277 20676e69 6320726f 69736f6c     writing or closi
 8018e90:	0000676e 61766e49 2064696c 6374656e     ng..Invalid netc
 8018ea0:	206e6e6f 65707974 00000000 2d67736d     onn type....msg-
 8018eb0:	67736d3e 6c2e772e 21206e65 0030203d     >msg.w.len != 0.
 8018ec0:	61766e69 2064696c 6374656e 5f6e6e6f     invalid netconn_
 8018ed0:	65707974 00000000 00000000 00000000     type............
 8018ee0:	6274656e 615f6675 636f6c6c 6e69203a     netbuf_alloc: in
 8018ef0:	696c6176 75622064 00000066 2e2f2e2e     valid buf...../.
 8018f00:	2e2e2f2e 2f736f2f 2f747865 7069776c     ./../os/ext/lwip
 8018f10:	342e312d 732f312e 612f6372 6e2f6970     -1.4.1/src/api/n
 8018f20:	75627465 00632e66 63656863 6874206b     etbuf.c.check th
 8018f30:	66207461 74737269 75627020 61632066     at first pbuf ca
 8018f40:	6f68206e 7320646c 00657a69 6274656e     n hold size.netb
 8018f50:	665f6675 3a656572 766e6920 64696c61     uf_free: invalid
 8018f60:	66756220 00000000 6274656e 725f6675      buf....netbuf_r
 8018f70:	203a6665 61766e69 2064696c 00667562     ef: invalid buf.
 8018f80:	6274656e 725f6675 203a6665 61766e69     netbuf_ref: inva
 8018f90:	2064696c 64616568 00000000 6274656e     lid head....netb
 8018fa0:	635f6675 6e696168 6e69203a 696c6176     uf_chain: invali
 8018fb0:	61742064 00006c69 6274656e 645f6675     d tail..netbuf_d
 8018fc0:	3a617461 766e6920 64696c61 66756220     ata: invalid buf
 8018fd0:	00000000 6274656e 645f6675 3a617461     ....netbuf_data:
 8018fe0:	766e6920 64696c61 74616420 72747061      invalid dataptr
 8018ff0:	00000000 6274656e 645f6675 3a617461     ....netbuf_data:
 8019000:	766e6920 64696c61 6e656c20 00000000      invalid len....
 8019010:	69706374 68745f70 64616572 6e69203a     tcpip_thread: in
 8019020:	696c6176 656d2064 67617373 00000065     valid message...
 8019030:	2e2f2e2e 2e2e2f2e 2f736f2f 2f747865     ../../../os/ext/
 8019040:	7069776c 342e312d 732f312e 612f6372     lwip-1.4.1/src/a
 8019050:	742f6970 70697063 0000632e 6c696166     pi/tcpip.c..fail
 8019060:	74206465 7263206f 65746165 70637420     ed to create tcp
 8019070:	745f7069 61657268 626d2064 0000786f     ip_thread mbox..
 8019080:	69706374 68745f70 64616572 00000000     tcpip_thread....

08019090 <main_cfg>:
 8019090:	73726576 206e6f69 3122203d 00223130     version = "101".

080190a0 <modbus_cfg>:
 80190a0:	52444441 3d535345 22303122 4d414e0a     ADDRESS="10".NAM
 80190b0:	52223d45 0a224354 564c4156 5b3d5345     E="RTC".VALVES=[
 80190c0:	4c415622 22314556 4156222c 3245564c     "VALVE1","VALVE2
 80190d0:	00005d22 00000000 00000000 00000000     "]..............
 80190e0:	6e69616d 6766632e 00000000 62646f6d     main.cfg....modb
 80190f0:	632e7375 00006766 656d6974 63657073     us.cfg..timespec
 8019100:	6974203a 2520656d 73752064 202e6365     : time %d usec. 
 8019110:	73206425 202e6365 000a6425 00000000     %d sec. %d......

08019120 <lcfg_table>:
 8019120:	080190e0 08019090 080190ec 080190a0     ................
 8019130:	6c756e28 0000296c 00000000 00000000     (null)..........
 8019140:	6f736552 65637275 6b615420 25206e65     Resource Taken %
 8019150:	00000a73 65757274 00000000 736c6166     s...true....fals
 8019160:	00000065 00435452 28435452 00002945     e...RTC.RTC(E)..
 8019170:	28435452 29564449 00000000 00000000     RTC(IDV)........

08019180 <CSWTCH.7>:
 8019180:	04040200 06040404 00000000 00000000     ................

08019190 <__FUNCTION__.9022>:
 8019190:	55424d78 536c6974 69427465 00007374     xMBUtilSetBits..
 80191a0:	65657246 62646f4d 6d2f7375 7562646f     FreeModbus/modbu
 80191b0:	75662f73 6974636e 2f736e6f 7475626d     s/functions/mbut
 80191c0:	2e736c69 00000063 424e6375 20737469     ils.c...ucNBits 
 80191d0:	38203d3c 00000000 00000000 00000000     <= 8............

080191e0 <aucCRCLo>:
 80191e0:	01c1c000 c20203c3 c70706c6 04c4c505     ................
 80191f0:	cd0d0ccc 0ececf0f 0bcbca0a c80809c9     ................
 8019200:	d91918d8 1adadb1b 1fdfde1e dc1c1ddd     ................
 8019210:	15d5d414 d61617d7 d31312d2 10d0d111     ................
 8019220:	f13130f0 32f2f333 37f7f636 f43435f5     .01.3..26..7.54.
 8019230:	3dfdfc3c fe3e3fff fb3b3afa 38f8f939     <..=.?>..:;.9..8
 8019240:	29e9e828 ea2a2beb ef2f2eee 2ceced2d     (..).+*.../.-..,
 8019250:	e52524e4 26e6e727 23e3e222 e02021e1     .$%.'..&"..#.! .
 8019260:	a16160a0 62a2a363 67a7a666 a46465a5     .`a.c..bf..g.ed.
 8019270:	6dadac6c ae6e6faf ab6b6aaa 68a8a969     l..m.on..jk.i..h
 8019280:	79b9b878 ba7a7bbb bf7f7ebe 7cbcbd7d     x..y.{z..~..}..|
 8019290:	b57574b4 76b6b777 73b3b272 b07071b1     .tu.w..vr..s.qp.
 80192a0:	51919050 92525393 97575696 54949555     P..Q.SR..VW.U..T
 80192b0:	9d5d5c9c 5e9e9f5f 5b9b9a5a 98585999     .\]._..^Z..[.YX.
 80192c0:	89494888 4a8a8b4b 4f8f8e4e 8c4c4d8d     .HI.K..JN..O.ML.
 80192d0:	45858444 86464787 83434282 40808141     D..E.GF..BC.A..@

080192e0 <aucCRCHi>:
 80192e0:	4081c100 4180c001 4180c001 4081c100     ...@...A...A...@
 80192f0:	4180c001 4081c100 4081c100 4180c001     ...A...@...@...A
 8019300:	4180c001 4081c100 4081c100 4180c001     ...A...@...@...A
 8019310:	4081c100 4180c001 4180c001 4081c100     ...@...A...A...@
 8019320:	4180c001 4081c100 4081c100 4180c001     ...A...@...@...A
 8019330:	4081c100 4180c001 4180c001 4081c100     ...@...A...A...@
 8019340:	4081c100 4180c001 4180c001 4081c100     ...@...A...A...@
 8019350:	4180c001 4081c100 4081c100 4180c001     ...A...@...@...A
 8019360:	4180c001 4081c100 4081c100 4180c001     ...A...@...@...A
 8019370:	4081c100 4180c001 4180c001 4081c100     ...@...A...A...@
 8019380:	4081c100 4180c001 4180c001 4081c100     ...@...A...A...@
 8019390:	4180c001 4081c100 4081c100 4180c001     ...A...@...@...A
 80193a0:	4081c100 4180c001 4180c001 4081c100     ...@...A...A...@
 80193b0:	4180c001 4081c100 4081c100 4180c001     ...A...@...@...A
 80193c0:	4180c001 4081c100 4081c100 4180c001     ...A...@...@...A
 80193d0:	4081c100 4180c001 4180c001 4081c100     ...@...A...A...@

080193e0 <__FUNCTION__.9293>:
 80193e0:	4d424d78 65747361 55545272 6e617254     xMBMasterRTUTran
 80193f0:	74696d73 004d5346 00000000 00000000     smitFSM.........

08019400 <__FUNCTION__.9306>:
 8019400:	4d424d78 65747361 55545272 656d6954     xMBMasterRTUTime
 8019410:	70784572 64657269 00000000 00000000     rExpired........
 8019420:	65657246 62646f4d 6d2f7375 7562646f     FreeModbus/modbu
 8019430:	74722f73 626d2f75 5f757472 00632e6d     s/rtu/mbrtu_m.c.
 8019440:	614d7375 72657473 42766352 65666675     usMasterRcvBuffe
 8019450:	736f5072 4d203c20 45535f42 44505f52     rPos < MB_SER_PD
 8019460:	49535f55 4d5f455a 00005841 53652028     U_SIZE_MAX..( eS
 8019470:	7453646e 20657461 53203d3d 45544154     ndState == STATE
 8019480:	545f4d5f 44495f58 2920454c 207c7c20     _M_TX_IDLE ) || 
 8019490:	53652028 7453646e 20657461 53203d3d     ( eSndState == S
 80194a0:	45544154 545f4d5f 46585f58 29205257     TATE_M_TX_XFWR )
 80194b0:	00000000 76635265 74617453 3d3d2065     ....eRcvState ==
 80194c0:	41545320 4d5f4554 5f58525f 454c4449      STATE_M_RX_IDLE
 80194d0:	00000000 52652028 74537663 20657461     ....( eRcvState 
 80194e0:	53203d3d 45544154 525f4d5f 4e495f58     == STATE_M_RX_IN
 80194f0:	29205449 207c7c20 52652028 74537663     IT ) || ( eRcvSt
 8019500:	20657461 53203d3d 45544154 525f4d5f     ate == STATE_M_R
 8019510:	43525f58 20292056 28207c7c 63526520     X_RCV ) || ( eRc
 8019520:	61745376 3d206574 5453203d 5f455441     vState == STATE_
 8019530:	58525f4d 5252455f 2920524f 207c7c20     M_RX_ERROR ) || 
 8019540:	52652028 74537663 20657461 53203d3d     ( eRcvState == S
 8019550:	45544154 525f4d5f 44495f58 2920454c     TATE_M_RX_IDLE )
 8019560:	00000000 53652028 7453646e 20657461     ....( eSndState 
 8019570:	53203d3d 45544154 545f4d5f 46585f58     == STATE_M_TX_XF
 8019580:	29205257 207c7c20 53652028 7453646e     WR ) || ( eSndSt
 8019590:	20657461 53203d3d 45544154 545f4d5f     ate == STATE_M_T
 80195a0:	44495f58 2920454c 00000000 00000000     X_IDLE )........

080195b0 <__FUNCTION__.9270>:
 80195b0:	4d424d65 65747361 55545272 65636552     eMBMasterRTURece
 80195c0:	00657669 00000000 00000000 00000000     ive.............

080195d0 <__FUNCTION__.9283>:
 80195d0:	4d424d78 65747361 55545272 65636552     xMBMasterRTURece
 80195e0:	46657669 00004d53 00000000 00000000     iveFSM..........
 80195f0:	656c6552 20657361 6f736552 65637275     Release Resource
 8019600:	00000000 7473614d 69207265 65732073     ....Master is se
 8019610:	6e69646e 00000067 00000000 00000000     nding...........

08019620 <xMasterFuncHandlers>:
 8019620:	00000011 080117d1 00000004 08011771     ............q...
 8019630:	00000003 08011541 00000010 080113f1     ....A...........
 8019640:	00000006 080113c1 00000017 080116e1     ................
 8019650:	00000001 08011141 00000005 08011261     ....A.......a...
 8019660:	0000000f 080112c1 00000002 08011321     ............!...
	...
 80196a0:	524d7375 6f486765 7542646c 64255b66     usMRegHoldBuf[%d
 80196b0:	25203a5d 00000a64 524d7375 6e496765     ]: %d...usMRegIn
 80196c0:	5b667542 3a5d6425 0a642520 00000000     Buf[%d]: %d.....
 80196d0:	434d6375 426c696f 255b6675 203a5d64     ucMCoilBuf[%d]: 
 80196e0:	000a6425 6f437478 524e6c69 5b736765     %d..xtCoilNRegs[
 80196f0:	3a5d6425 0a642520 00000000 00000000     %d]: %d.........
 8019700:	69726170 65207974 00007272 6d617266     parity err..fram
 8019710:	20676e69 00727265 73696f6e 72652065     ing err.noise er
 8019720:	00000072 7265766f 206e7572 00727265     r...overrun err.
 8019730:	656c6469 6e696c20 72652065 00000072     idle line err...
 8019740:	74726175 20787220 00727265 65636552     uart rx err.Rece
 8019750:	20657669 62616e45 0000656c 65636552     ive Enable..Rece
 8019760:	20657669 61736944 00656c62 6e617254     ive Disable.Tran
 8019770:	74696d73 616e4520 00656c62 6e617254     smit Enable.Tran
 8019780:	74696d73 73694420 656c6261 00000000     smit Disable....
 8019790:	74697865 00000000 78635f5f 75705f61     exit....__cxa_pu
 80197a0:	765f6572 75747269 29286c61 00312320     re_virtual() #1.

080197b0 <vmt>:
 80197b0:	080128b1 08012891 080128a1 08012881     .(...(...(...(..

080197c0 <http_crnl_2>:
 80197c0:	2d2d0a0d 00000000 00000000 00000000     ..--............

080197d0 <PAGE_START>:
 80197d0:	4f44213c 50595443 74682045 50206c6d     <!DOCTYPE html P
 80197e0:	494c4255 2d222043 33572f2f 442f2f43     UBLIC "-//W3C//D
 80197f0:	48204454 204c4d54 31302e34 4e452f2f     TD HTML 4.01//EN
 8019800:	68222022 3a707474 77772f2f 33772e77     " "http://www.w3
 8019810:	67726f2e 2f52542f 6c6d7468 74732f34     .org/TR/html4/st
 8019820:	74636972 6474642e 0a0d3e22 6d74683c     rict.dtd">..<htm
 8019830:	0a0d3e6c 6165683c 0a0d3e64 743c2020     l>..<head>..  <t
 8019840:	656c7469 646f4d3e 54535542 736b7361     itle>ModBUSTasks
 8019850:	76726556 61746e65 69742f3c 3e656c74     Verventa</title>
 8019860:	20200a0d 74656d3c 74682061 652d7074     ..  <meta http-e
 8019870:	76697571 6f43223d 6e65746e 79542d74     quiv="Content-Ty
 8019880:	0d226570 6f63200a 6e65746e 74223d74     pe".. content="t
 8019890:	2f747865 6c6d7468 6863203b 65737261     ext/html; charse
 80198a0:	69773d74 776f646e 32312d73 3e223235     t=windows-1252">
 80198b0:	20200a0d 74656d3c 74682061 652d7074     ..  <meta http-e
 80198c0:	76697571 6572223d 73657266 63202268     quiv="refresh" c
 80198d0:	65746e6f 223d746e 0d3e2231 3c20200a     ontent="1">..  <
 80198e0:	6174656d 6e6f6320 746e6574 534d223d     meta content="MS
 80198f0:	4c4d5448 302e3620 38322e30 312e3030     HTML 6.00.2800.1
 8019900:	22313635 6d616e20 47223d65 52454e45     561" name="GENER
 8019910:	524f5441 0a0d3e22 733c2020 656c7974     ATOR">..  <style
 8019920:	66223d20 2d746e6f 67696577 203a7468      ="font-weight: 
 8019930:	6d726f6e 203b6c61 746e6f66 6d61662d     normal; font-fam
 8019940:	3a796c69 72655620 616e6164 3c3e223b     ily: Verdana;"><
 8019950:	7974732f 0d3e656c 682f3c0a 3e646165     /style>..</head>
 8019960:	623c0a0d 3e79646f 683c0a0d 733c3e34     ..<body>..<h4><s
 8019970:	6c6c616d 79747320 223d656c 746e6f66     mall style="font
 8019980:	6d61662d 3a796c69 72655620 616e6164     -family: Verdana
 8019990:	3c3e223b 6c616d73 623c3e6c 3c3e6769     ;"><small><big><
 80199a0:	3e676962 6769623c 73200a0d 656c7974     big><big.. style
 80199b0:	6f66223d 772d746e 68676965 62203a74     ="font-weight: b
 80199c0:	3b646c6f 623c3e22 3c3e6769 6f727473     old;"><big><stro
 80199d0:	3c3e676e 3c3e6d65 6e617073 73200a0d     ng><em><span.. s
 80199e0:	656c7974 6f66223d 732d746e 656c7974     tyle="font-style
 80199f0:	7469203a 63696c61 563e223b 65767265     : italic;">Verve
 8019a00:	2061746e 62646f4d 44207375 63697665     nta Modbus Devic
 8019a10:	53207365 75746174 732f3c73 3e6e6170     es Status</span>
 8019a20:	6d652f3c 732f3c3e 6e6f7274 2f3c3e67     </em></strong></
 8019a30:	3e676962 69622f3c 2f3c3e67 3e676962     big></big></big>
 8019a40:	69622f3c 2f3c3e67 6c616d73 2f3c3e6c     </big></small></
 8019a50:	6c616d73 2f3c3e6c 0d3e3468 72683c0a     small></h4>..<hr
 8019a60:	79747320 223d656c 74646977 31203a68      style="width: 1
 8019a70:	3b253030 69656820 3a746867 78703220     00%; height: 2px
 8019a80:	3c3e223b 6e617073 73200a0d 656c7974     ;"><span.. style
 8019a90:	6f66223d 772d746e 68676965 62203a74     ="font-weight: b
 8019aa0:	3b646c6f 0a0d3e22 70732f3c 3c3e6e61     old;">..</span><
 8019ab0:	6e617073 79747320 223d656c 746e6f66     span style="font
 8019ac0:	6965772d 3a746867 6c6f6220 3e223b64     -weight: bold;">
 8019ad0:	743c0a0d 656c6261 79747320 223d656c     ..<table style="
 8019ae0:	74646977 39203a68 78703136 6568203b     width: 961px; he
 8019af0:	74686769 3033203a 223b7870 726f6220     ight: 30px;" bor
 8019b00:	3d726564 0d223122 6563200a 61706c6c     der="1".. cellpa
 8019b10:	6e696464 32223d67 65632022 70736c6c     dding="2" cellsp
 8019b20:	6e696361 32223d67 0a0d3e22 743c2020     acing="2">..  <t
 8019b30:	79646f62 200a0d3e 3c202020 0d3e7274     body>..    <tr>.
 8019b40:	2020200a 3c202020 0a0d6474 79747320     .      <td.. sty
 8019b50:	223d656c 746e6f66 6d61662d 3a796c69     le="font-family:
 8019b60:	72655620 616e6164 6f66203b 772d746e      Verdana; font-w
 8019b70:	68676965 62203a74 3b646c6f 6e6f6620     eight: bold; fon
 8019b80:	74732d74 3a656c79 61746920 3b63696c     t-style: italic;
 8019b90:	63616220 6f72676b 2d646e75 6f6c6f63      background-colo
 8019ba0:	72203a72 35286267 35202c31 32202c31     r: rgb(51, 51, 2
 8019bb0:	3b293535 78657420 6c612d74 3a6e6769     55); text-align:
 8019bc0:	6e656320 3b726574 733c3e22 6c6c616d      center;"><small
 8019bd0:	0d613c3e 7268200a 223d6665 7265562f     ><a.. href="/Ver
 8019be0:	746e6576 614d5f61 72657473 6d74682e     venta_Master.htm
 8019bf0:	3c3e226c 6e617073 79747320 223d656c     l"><span style="
 8019c00:	6f6c6f63 77203a72 65746968 483e223b     color: white;">H
 8019c10:	0d656d6f 6761700a 732f3c65 3e6e6170     ome..page</span>
 8019c20:	3e612f3c 6d732f3c 3e6c6c61 64742f3c     </a></small></td
 8019c30:	200a0d3e 3c202020 3e72742f 20200a0d     >..    </tr>..  
 8019c40:	62742f3c 3e79646f 2f3c0a0d 6c626174     </tbody>..</tabl
 8019c50:	0a0d3e65 3e72623c 2f3c0a0d 6e617073     e>..<br>..</span
 8019c60:	70733c3e 73206e61 656c7974 6f66223d     ><span style="fo
 8019c70:	772d746e 68676965 62203a74 3b646c6f     nt-weight: bold;
 8019c80:	2f3c3e22 6e617073 6d733c3e 3e6c6c61     "></span><small>
 8019c90:	6170733c 200a0d6e 6c797473 66223d65     <span.. style="f
 8019ca0:	2d746e6f 696d6166 203a796c 64726556     ont-family: Verd
 8019cb0:	3b616e61 754e3e22 7265626d 20666f20     ana;">Number of 
 8019cc0:	65676170 74696820 0a0d3a73 00000000     page hits:......
 8019cd0:	3e72623c 3e72623c 00000000 6261743c     <br><br>....<tab
 8019ce0:	3c3e656c 61656874 743c3e64 743c3e72     le><thead><tr><t
 8019cf0:	623c3e64 6d616e3e 64743c65 3e623c3e     d><b>name<td><b>
 8019d00:	72646461 3e64743c 733e623c 6b636174     addr<td><b>stack
 8019d10:	3e64743c 703e623c 3c6f6972 3c3e6474     <td><b>prio<td><
 8019d20:	65723e62 743c7366 623c3e64 6174733e     b>refs<td><b>sta
 8019d30:	743c6574 623c3e64 6d69743e 742f3c65     te<td><b>time</t
 8019d40:	2f3c3e72 61656874 2f3c3e64 00003e62     r></thead></b>..
 8019d50:	3e72743c 00000000 3e64743c 00000000     <tr>....<td>....
 8019d60:	72742f3c 0000003e 61742f3c 3e656c62     </tr>...</table>
 8019d70:	00000000 6261743c 3c3e656c 3c3e7274     ....<table><tr><
 8019d80:	61656874 743c3e64 616e3e68 743c656d     thead><th>name<t
 8019d90:	64613e68 73657264 68743c73 6174733e     h>address<th>sta
 8019da0:	743c6574 65723e68 6d695471 74754f65     te<th>reqTimeOut
 8019db0:	3e68743c 75716572 73747365 3e68743c     <th>requests<th>
 8019dc0:	636e7566 6e6f6974 3e68743c 53676572     function<th>regS
 8019dd0:	74726174 3e68743c 43676572 746e756f     tart<th>regCount
 8019de0:	3e68743c 3c554841 483e6874 2f3c5552     <th>AHU<th>HRU</
 8019df0:	61656874 2f3c3e64 003e7274 65646e69     thead></tr>.inde
 8019e00:	25203a78 00000a64 64742f3c 0000003e     x: %d...</td>...
 8019e10:	4e4e4f43 45544345 00000044 4e4e4f43     CONNECTED...CONN
 8019e20:	49544345 454c4e4f 00005353 6c667562     ECTIONLESS..bufl
 8019e30:	203a6e65 200a6925 3a667562 0a732520     en: %i. buf: %s.
 8019e40:	00000000 20544547 0000002f 20544547     ....GET /...GET 
 8019e50:	7373612f 2f737465 616c7073 735f6873     /assets/splash_s
 8019e60:	65657263 706a2e6e 00000067 676d692f     creen.jpg.../img
 8019e70:	6c70732f 5f687361 65726373 6a2e6e65     /splash_screen.j
 8019e80:	00006770 20544547 4d54532f 34463233     pg..GET /STM32F4
 8019e90:	41543778 2e534b53 6c6d7468 00000000     x7TASKS.html....
 8019ea0:	20544547 444f4d2f 54535542 534b5341     GET /MODBUSTASKS
 8019eb0:	6d74682e 0000006c 20544547 6c70752f     .html...GET /upl
 8019ec0:	6364616f 69666e6f 74682e67 00006c6d     oadconfig.html..
 8019ed0:	20544547 7265562f 746e6576 614d5f61     GET /Verventa_Ma
 8019ee0:	72657473 6d74682e 0000006c 20544547     ster.html...GET 
 8019ef0:	0000202f 3430342f 6d74682e 0000006c     / ../404.html...
 8019f00:	54534f50 70752f20 64616f6c 6967632e     POST /upload.cgi
 8019f10:	00000000 72617473 70752074 64616f6c     ....start upload
 8019f20:	6c696620 2e2e2e65 00000000 656c6966      file.......file
 8019f30:	656d616e 0000003d 656c6966 656d616e     name=...filename
 8019f40:	7325203a 74697720 656c2068 6874676e     : %s with length
 8019f50:	6425203a 0000000a 20746f6e 7473616c     : %d....not last
 8019f60:	74616420 61702061 67616b63 2e2e2e65      data package...
 8019f70:	0000000a 70747468 76726573 00007265     ....httpserver..
 8019f80:	70747468 7265735f 3a726576 766e6920     http_server: inv
 8019f90:	64696c61 6e6f6320 0000006e 2f626577     alid conn...web/
 8019fa0:	2e626577 00000063 00000000 00000000     web.c...........

08019fb0 <octet_stream>:
 8019fb0:	6574636f 74732d74 6d616572 0000000d     octet-stream....

08019fc0 <file_404_html>:
 8019fc0:	0801a560 0801a290 0801a29a 000002a4     `...............
	...

08019fe0 <file_img_splash_screen_jpg>:
 8019fe0:	00000000 0801a580 0801a597 00001f22     ............"...
	...

0801a000 <data_upload_html>:
 801a000:	6c70752f 6364616f 69666e6f 74682e67     /uploadconfig.ht
 801a010:	48006c6d 2f505454 20302e31 20303032     ml.HTTP/1.0 200 
 801a020:	0a0d4b4f 76726553 203a7265 2f504975     OK..Server: uIP/
 801a030:	20392e30 74746828 2f2f3a70 6b6e7564     0.9 (http://dunk
 801a040:	2e736c65 2f6d6f63 6d616461 7069752f     els.com/adam/uip
 801a050:	0a0d292f 746e6f43 2d746e65 65707974     /)..Content-type
 801a060:	6574203a 682f7478 0d6c6d74 3c0a0d0a     : text/html....<
 801a070:	434f4421 45505954 4d544820 5550204c     !DOCTYPE HTML PU
 801a080:	43494c42 2f2d2220 4333572f 54442f2f     BLIC "-//W3C//DT
 801a090:	54482044 34204c4d 2031302e 6e617254     D HTML 4.01 Tran
 801a0a0:	69746973 6c616e6f 4e452f2f 0a0d3e22     sitional//EN">..
 801a0b0:	6d74683c 0a0d3e6c 683c2020 3e646165     <html>..  <head>
 801a0c0:	20200a0d 74656d3c 74682061 652d7074     ..  <meta http-e
 801a0d0:	76697571 6f63223d 6e65746e 79742d74     quiv="content-ty
 801a0e0:	20226570 746e6f63 3d746e65 78657422     pe" content="tex
 801a0f0:	74682f74 203b6c6d 72616863 3d746573     t/html; charset=
 801a100:	646e6977 2d73776f 30353231 0a0d3e22     windows-1250">..
 801a110:	743c2020 656c7469 7265563e 746e6576       <title>Vervent
 801a120:	70552061 64616f6c 69742f3c 3e656c74     a Upload</title>
 801a130:	20200a0d 65682f3c 0d3e6461 3c20200a     ..  </head>..  <
 801a140:	79646f62 200a0d3e 3c202020 6d726f66     body>..    <form
 801a150:	74636120 206e6f69 752f223d 616f6c70      action ="/uploa
 801a160:	67632e64 65202269 7974636e 223d6570     d.cgi" enctype="
 801a170:	746c756d 72617069 6f662f74 642d6d72     multipart/form-d
 801a180:	22617461 74656d20 3d646f68 736f7022     ata" method="pos
 801a190:	0d3e2274 3c20200a 6c503e70 65736165     t">..  <p>Please
 801a1a0:	65707320 79666963 63206120 69666e6f      specify a confi
 801a1b0:	69662067 7420656c 7075206f 64616f6c     g file to upload
 801a1c0:	746e6920 623c206f 7265563e 746e6576      into <b>Vervent
 801a1d0:	622f3c61 6f6d203e 73756264 6e6f6320     a</b> modbus con
 801a1e0:	6c6f7274 3a72656c 20200a0d 623c2020     troller:..    <b
 801a1f0:	0a0d3e72 20202020 706e693c 74207475     r>..    <input t
 801a200:	3d657079 6c696622 6e202265 3d656d61     ype="file" name=
 801a210:	74616422 6c696661 73202265 3d657a69     "datafile" size=
 801a220:	22303422 200a0d3e 702f3c20 200a0d3e     "40">..  </p>.. 
 801a230:	69643c20 0a0d3e76 20202020 706e693c      <div>..    <inp
 801a240:	74207475 3d657079 62757322 2274696d     ut type="submit"
 801a250:	6c617620 223d6575 6f6c7055 3e226461      value="Upload">
 801a260:	20200a0d 69642f3c 0a0d3e76 6f662f3c     ..  </div>..</fo
 801a270:	0d3e6d72 3c20200a 646f622f 0a0d3e79     rm>..  </body>..
 801a280:	74682f3c 0d3e6c6d 0000000a 00000000     </html>.........

0801a290 <data_404_html>:
 801a290:	3430342f 6d74682e 5448006c 312f5054     /404.html.HTTP/1
 801a2a0:	3420302e 46203430 20656c69 20746f6e     .0 404 File not 
 801a2b0:	6e756f66 530a0d64 65767265 6c203a72     found..Server: l
 801a2c0:	2f504977 2d657270 20362e30 74746828     wIP/pre-0.6 (htt
 801a2d0:	2f2f3a70 2e777777 73636973 2f65732e     p://www.sics.se/
 801a2e0:	6164617e 776c2f6d 292f7069 6f430a0d     ~adam/lwip/)..Co
 801a2f0:	6e65746e 79742d74 203a6570 74786574     ntent-type: text
 801a300:	6d74682f 0d0a0d6c 74683c0a 0d3e6c6d     /html....<html>.
 801a310:	65683c0a 3c3e6461 6c746974 776c3e65     .<head><title>lw
 801a320:	2d205049 4c204120 74686769 67696577     IP - A Lightweig
 801a330:	54207468 492f5043 74532050 3c6b6361     ht TCP/IP Stack<
 801a340:	7469742f 3c3e656c 6165682f 0a0d3e64     /title></head>..
 801a350:	646f623c 67622079 6f6c6f63 77223d72     <body bgcolor="w
 801a360:	65746968 65742022 223d7478 63616c62     hite" text="blac
 801a370:	0d3e226b 200a0d0a 3c202020 6c626174     k">....    <tabl
 801a380:	69772065 3d687464 30303122 0d3e2225     e width="100%">.
 801a390:	2020200a 3c202020 76207274 67696c61     .      <tr valig
 801a3a0:	74223d6e 3e22706f 2064743c 74646977     n="top"><td widt
 801a3b0:	38223d68 093e2230 0a0d2020 3c202009     h="80">.  ...  <
 801a3c0:	72682061 223d6665 70747468 772f2f3a     a href="http://w
 801a3d0:	732e7777 2e736369 222f6573 6d693c3e     ww.sics.se/"><im
 801a3e0:	72732067 2f223d63 2f676d69 73636973     g src="/img/sics
 801a3f0:	6669672e 090a0d22 6f622020 72656472     .gif"...  border
 801a400:	2230223d 746c6120 4953223d 6c205343     ="0" alt="SICS l
 801a410:	226f676f 74697420 223d656c 53434953     ogo" title="SICS
 801a420:	676f6c20 3c3e226f 0d3e612f 2f3c090a      logo"></a>...</
 801a430:	3c3e6474 77206474 68746469 3035223d     td><td width="50
 801a440:	093e2230 0a0d2020 3c202009 6c3e3168     0">.  ...  <h1>l
 801a450:	20504977 2041202d 6867694c 69657774     wIP - A Lightwei
 801a460:	20746867 2f504354 53205049 6b636174     ght TCP/IP Stack
 801a470:	31682f3c 090a0d3e 683c2020 30343e32     </h1>...  <h2>40
 801a480:	202d2034 65676150 746f6e20 756f6620     4 - Page not fou
 801a490:	2f3c646e 0d3e3268 2020090a 0d3e703c     nd</h2>...  <p>.
 801a4a0:	2020090a 6f532020 2c797272 65687420     ..    Sorry, the
 801a4b0:	67617020 6f792065 72612075 65722065      page you are re
 801a4c0:	73657571 676e6974 73617720 746f6e20     questing was not
 801a4d0:	756f6620 6f20646e 6874206e 0a0d7369      found on this..
 801a4e0:	20202009 72657320 2e726576 090a0d20     .    server. ...
 801a4f0:	2f3c2020 0a0d3e70 742f3c09 743c3e64       </p>...</td><t
 801a500:	0a0d3e64 26202009 7073626e 090a0d3b     d>...  &nbsp;...
 801a510:	64742f3c 742f3c3e 0a0d3e72 20202020     </td></tr>..    
 801a520:	2f3c2020 6c626174 0a0d3e65 6f622f3c       </table>..</bo
 801a530:	0d3e7964 682f3c0a 3e6c6d74 00000a0d     dy>..</html>....

0801a540 <file_Verventa_Master_html>:
 801a540:	08019fc0 0801c4c0 0801c4d6 0000082c     ............,...
	...

0801a560 <file_upload_html>:
 801a560:	08019fe0 0801a000 0801a00d 0000027c     ............|...
	...

0801a580 <data_img_splash_screen_jpg>:
 801a580:	676d692f 6c70732f 5f687361 65726373     /img/splash_scre
 801a590:	6a2e6e65 48006770 2f505454 20302e31     en.jpg.HTTP/1.0 
 801a5a0:	20303032 0a0d4b4f 76726553 203a7265     200 OK..Server: 
 801a5b0:	5049776c 6572702f 362e302d 74682820     lwIP/pre-0.6 (ht
 801a5c0:	2f3a7074 7777772f 6369732e 65732e73     tp://www.sics.se
 801a5d0:	64617e2f 6c2f6d61 2f706977 430a0d29     /~adam/lwip/)..C
 801a5e0:	65746e6f 742d746e 3a657079 616d6920     ontent-type: ima
 801a5f0:	6a2f6567 0d676570 ff0a0d0a 00e0ffd8     ge/jpeg.........
 801a600:	49464a10 01010046 00010001 ff000001     .JFIF...........
 801a610:	004300db 04040305 04050304 05050404     ..C.............
 801a620:	0c070605 07070708 0b0b0f07 0f110c09     ................
 801a630:	0f111212 16131111 1413171c 1111151a     ................
 801a640:	1a182118 1f1f1d1d 2217131f 241e2224     .!........."$".$
 801a650:	1e1f1e1c 4300dbff 05050501 0e070607     .......C........
 801a660:	1e0e0808 1e141114 1e1e1e1e 1e1e1e1e     ................
 801a670:	1e1e1e1e 1e1e1e1e 1e1e1e1e 1e1e1e1e     ................
 801a680:	1e1e1e1e 1e1e1e1e 1e1e1e1e 1e1e1e1e     ................
 801a690:	1e1e1e1e 1e1e1e1e 00c0ff1e 96000811     ................
 801a6a0:	0103c800 11020022 01110301 1f00c4ff     ...."...........
 801a6b0:	05010000 01010101 00000101 00000000     ................
 801a6c0:	02010000 06050403 0a090807 00c4ff0b     ................
 801a6d0:	020010b5 02030301 05050304 00000404     ................
 801a6e0:	02017d01 11040003 31211205 51130641     .}........!1A..Q
 801a6f0:	71220761 91813214 422308a1 5215c1b1     a."q.2....#B...R
 801a700:	3324f0d1 09827262 1817160a 26251a19     ..$3br........%&
 801a710:	2a292827 37363534 433a3938 47464544     '()*456789:CDEFG
 801a720:	534a4948 57565554 635a5958 67666564     HIJSTUVWXYZcdefg
 801a730:	736a6968 77767574 837a7978 87868584     hijstuvwxyz.....
 801a740:	928a8988 96959493 9a999897 a5a4a3a2     ................
 801a750:	a9a8a7a6 b4b3b2aa b8b7b6b5 c3c2bab9     ................
 801a760:	c7c6c5c4 d2cac9c8 d6d5d4d3 dad9d8d7     ................
 801a770:	e4e3e2e1 e8e7e6e5 f2f1eae9 f6f5f4f3     ................
 801a780:	faf9f8f7 1f00c4ff 01030001 01010101     ................
 801a790:	01010101 00000000 02010000 06050403     ................
 801a7a0:	0a090807 00c4ff0b 020011b5 04040201     ................
 801a7b0:	05070403 01000404 01007702 04110302     .........w......
 801a7c0:	06312105 07514112 22137161 14088132     .!1..AQ.aq."2...
 801a7d0:	b1a19142 332309c1 6215f052 160ad172     B.....#3R..br...
 801a7e0:	25e13424 191817f1 2827261a 36352a29     $4.%.....&'()*56
 801a7f0:	3a393837 46454443 4a494847 56555453     789:CDEFGHIJSTUV
 801a800:	5a595857 66656463 6a696867 76757473     WXYZcdefghijstuv
 801a810:	7a797877 85848382 89888786 9493928a     wxyz............
 801a820:	98979695 a3a29a99 a7a6a5a4 b2aaa9a8     ................
 801a830:	b6b5b4b3 bab9b8b7 c5c4c3c2 c9c8c7c6     ................
 801a840:	d4d3d2ca d8d7d6d5 e3e2dad9 e7e6e5e4     ................
 801a850:	f2eae9e8 f6f5f4f3 faf9f8f7 0c00daff     ................
 801a860:	02000103 00110311 fff5003f 173f8c00     ........?.....?.
 801a870:	0600fff5 134dd278 db74d34f e4081688     ....x.M.O.t.....
 801a880:	6cb93adf 01a3e7b0 34fc6f5c 68fb8a5f     .:.l....\o.4_..h
 801a890:	f1fd27da 1700ff2f 0fb53f59 f97995fc     .'../...Y?....y.
 801a8a0:	0ee7f11f 5a5e237f d7e43907 7531e2cc     .....#^Z.9....1u
 801a8b0:	494956a3 c7fdecda abace123 ab509711     .VII....#.....P.
 801a8c0:	71728a56 b777bd4d f603eda9 fd6ff18b     V.rqM.w.......o.
 801a8d0:	fb4f7401 2efe5fe6 f845fb81 a28dbeaf     .tO.._....E.....
 801a8e0:	bfecfe03 be785dfc 0ee4794e 74034e69     .....]x.Ny..iN.t
 801a8f0:	ae1f6bfd 7a66fed7 4f9eeabf eb4000ff     .k....fz...O..@.
 801a900:	3300fff1 19edc7d9 00ffb3e2 3f136d30     ...3........0m.?
 801a910:	00ff4bee 683fd0c5 07e715bf fc07d146     .K....?h....F...
 801a920:	2efe5f02 9c7b5dbc 0ca0f775 bb3e8a13     ._...]{.u.....>.
 801a930:	7fd8f95f fd3f79aa fcc7af03 b43f68cf     _....y?......h?.
 801a940:	cf008b67 ff892ef6 ff4b7c00 3fd0c500     g........|K....?
 801a950:	1116bf68 105dec9f ff25c07f c5ebe200     h.....]...%.....
 801a960:	dc9381f3 513b46f3 00ffdaf5 53fdc3cc     .....F;Q.......S
 801a970:	e800ffc9 e63f7e1d 34fc477b 9f318b5f     .....~?.{G.4_.1.
 801a980:	fe135dec 00ff97f8 1afea38b ff98c533     .]..........3...
 801a990:	892e9000 cb7c00ff d7c500ff 34ee608c     ......|......`.4
 801a9a0:	8f26e399 76fed7ae 4f9eea1f eb4000ff     ..&....v...O..@.
 801a9b0:	3300fff1 17ed07da f88fb3e2 ff9c6893     ...3.........h..
 801a9c0:	ff2fb100 fc471700 338b6734 5d2000ff     ../...G.4g.3.. ]
 801a9d0:	97f8fe17 af8b00ff 23cf3917 3ea4d91e     .........9.#...>
 801a9e0:	47e1c798 00ff6bd7 4ff50f3b a000ff27     ...G.k..;..O'...
 801a9f0:	00fff875 475aef99 5f15afc7 b4d2962b     u.....ZG..._+...
 801aa00:	918edb54 7af67fca 0b00ffbf f41fc5af     T......z........
 801aa10:	00ffd10f fc9fd4ef c25bbc72 a87f769f     ........r.[..v..
 801aa20:	77fdcaad 6c18f085 ad4a5756 f3492968     ...w...lVWJ.h)I.
 801aa30:	34f1bf5d a1f8207f ae726298 3061c529     ]..4. ...br.).a0
 801aa40:	1ea77073 af6c454b 2dfe0d4e e17fd3b3     sp..KEl.N..-....
 801aa50:	fea3f875 fd3ffa81 00ff93fa 00ff518e     u.....?......Q..
 801aa60:	1fc5af0b ffd10ff4 9fd4ef00 cabc72fc     .............r..
 801aa70:	00fff78a f33fb0b1 fe011fe9 f39fe6b1     ......?.........
 801aa80:	ffa647fe f1ebc200 f403fd47 27f5fb7f     .G......G......'
 801aa90:	a31c00ff 8a5f17fe a31fe83f a9df00ff     ......_.?.......
 801aaa0:	79e5f83f 637f1495 d2e77f60 348ff50f     ?..y...c`......4
 801aab0:	f29f00ff 17fe373d e83f8a5f 00ffa31f     ....=7.._.?.....
 801aac0:	f83fa9df baf01fe5 00ff51fc fe1ffd40     ..?......Q..@...
 801aad0:	00ff49fd a8cc2bc7 031bfba3 903e00ff     .I...+........>.
 801aae0:	a779ac7f 9100fffc baf0bfe9 00ff51fc     ..y..........Q..
 801aaf0:	fe1ffd40 00ff49fd 00ff28c7 8fe2d785     @....I...(......
 801ab00:	ffe807fa 4feaf700 655e39fe d8d81f45     .......O.9^eE...
 801ab10:	83f4f91f 3fcd63fd 4d8ffce7 d78500ff     .....c.?...M....
 801ab20:	07fa8fe2 f700ffe8 39fe4fea bf2efc47     .........O.9G...
 801ab30:	3fd07f14 bf00ff47 caf17f52 fe282af3     ...?G...R....*(.
 801ab40:	00ffc0c6 eb1fa4cf 00ff691e 9f7be43f     .........i..?.{.
 801ab50:	7a893fc3 55bc89df 677f9316 c40b45a7     .?.z...U...g.E..
 801ab60:	70145aee d59151d9 ae28fd88 fc2fe027     .Z.p.Q....(.'./.
 801ab70:	fa7f5b94 83fe2fe1 105f7c45 f161a961     .[.../..E|_.a.a.
 801ab80:	65a3144a a79ffa65 be328670 57ea0033     J..ee...p.2.3..W
 801ab90:	6ae69393 cf1cd1ef 00ff45ed ff7c5625     ...j.....E..%V|.
 801aba0:	389ccf00 96d7d0cf e73c0ff0 fd52afa9     ...8......<...R.
 801abb0:	abe4bfa8 b9fccf4d 06afc7c3 fe8eb7bc     ....M...........
 801abc0:	9a5f139c 3f8dbfe2 d69ff957 00ff39dc     .._....?W....9..
 801abd0:	f83f9c22 c601f923 9d347e7a a83dc7f1     ".?.#...z~4...=.
 801abe0:	d2e99f27 1f181897 607b608d d2a74730     '........`{`0G..
 801abf0:	f1dc9d83 50946f40 cf769cc3 0704a019     ....@o.P..v.....
 801ac00:	dae1cf1d e3c0f394 6e7f2fb5 cba79382     ........./.n....
 801ac10:	0681d6ed e7394047 8e3a4e8a 7fe0b9b4     ....G@9..N:.....
 801ac20:	8ee04c4a 62a0f187 40729d9e 93878ee6     JL.....b..r@....
 801ac30:	8c4be981 90dedf63 33921400 ff4648ed     ..K.c......3.HF.
 801ac40:	cb4f8500 b915f738 e5157e58 722bfc26     ..O.8...X~..&.+r
 801ac50:	dfe072bf ff5113f9 f4bfb700 7ec21fa9     .r....Q........~
 801ac60:	c900ff31 00ff8d67 6afa7fb8 57144501     1...g......j.E.W
 801ac70:	05999fd3 2d6b614f 94bdf5ed 256e1900     ....Oak-......n%
 801ac80:	81139058 f50388b9 f86a0535 dd46fe3f     X.......5.j.?.F.
 801ac90:	e0bffe1f 8bd100ff 304e5251 b5115d72     ........QRN0r]..
 801aca0:	63952a08 1e69b307 7ff061e3 4b69b1c2     .*.c..i..a....iK
 801acb0:	ae2e786f ee61ca2e 77876256 3d40afaa     ox....a.Vb.w..@=
 801acc0:	6bbe0f32 a16dfcc4 4fbc863f beb4a379     2..k..m.?..Oy...
 801acd0:	49818170 c0ca8d31 07df2730 c6fa7a9f     p..I1...0'...z..
 801ace0:	e9f86dbe 262500ff b9fe00ff a200ffc3     .m....%&........
 801acf0:	873fbed6 234e0c73 9b552815 bdd7d76a     ..?.s.N#.(U.j...
 801ad00:	192ffad1 263c1865 144a9d06 5a925ad4     ../.e.<&..J..Z.Z
 801ad10:	f77b5675 c3a977db f6154551 4581e667     uV{..w..QE..g..E
 801ad20:	7b075014 4afe17f0 70fdbf2d 4100ff97     .P.{...J-..p...A
 801ad30:	bf808fa2 ff6d51f2 bf84eb00 f9150dfa     .....Qm.........
 801ad40:	ff1300ff f0afbe00 af9fcdaf 8bfc2ff0     ............./..
 801ad50:	e49ff85f a2f66b8e ab9200ff f4f84f3f     _....k......?O..
 801ad60:	f21af987 00ff8cbc ffd4ebf5 f91f6a00     .............j..
 801ad70:	9f0ef32a f8f370e8 c0e3f21a fc7ac7e9     *....p........z.
 801ad80:	79fc15bb feccbffa f9cfe1c0 00ff6115     ...y.........a..
 801ad90:	3121bfc0 b5af27fc fe18761c 2d7cd6b5     ..!1.'...v....|-
 801ada0:	8ee74df0 a83450fc 44f01627 e4d46d9e     .M...P4.'..D.m..
 801adb0:	4040cb67 902477e0 5a00ff07 677fc9bd     g.@@.w$....Z...g
 801adc0:	3300094f e364ebac ff100f07 a82ad900     O..3..d.......*.
 801add0:	8fd6eae0 39861634 d9e513a7 1147555d     ....4..9....]UG.
 801ade0:	d96bcd37 e6f3fe26 711c5720 ea4191da     7.k.&... W.q..A.
 801adf0:	af793d3d e100ffa7 9c233c9d 6b6c00ff     ==y......<#...lk
 801ae00:	7ff14d9f c37f14f1 fe4b783a fde73a83     .M......:xK..:..
 801ae10:	00ff17f7 667f5b11 277e3b62 64befe9b     .....[.fb;~'...d
 801ae20:	ffcc00ff 7c16f000 9eb433c0 46ced1a0     .......|.3.....F
 801ae30:	5feb833a c300ff4f fe4b783a fde73a83     :.._O...:xK..:..
 801ae40:	00ff17f7 33fc4711 c98984a7 fbcf75d6     .....G.3.....u..
 801ae50:	00ff17f9 66f64711 1fe2b723 fc4fe6eb     .....G.f#.....O.
 801ae60:	0100ffcf ff1ccc67 931c8d00 bed2e3c9     ....g...........
 801ae70:	8600ff9e fd8ff074 fbcf7506 22fe2fee     ....t....u.../."
 801ae80:	9cfdbba3 9c6d34fc bcba6b5a 1a21ed73     .....4m.Zk..s.!.
 801ae90:	1f942d5f f9131470 71b33f8a ae11bf1d     _-..p....?.q....
 801aea0:	b7dbc93c c000ff3b f227f359 72eaa5f4     <...;...Y.'....r
 801aeb0:	3fadf579 beb76815 ee0df11d 5c147e8b     y..?.h.......~.\
 801aec0:	6663c859 a8c3ba5f 0f82d823 389859e3     Y.cf_...#....Y.8
 801aed0:	1ab8e604 be3eb3b3 82d5489d 57d31d9c     ......>..H.....W
 801aee0:	de9bc94f e3b3fb13 d66e45a6 b231851f     O........En...1.
 801aef0:	956e476e f0b85fb9 a889fc77 dfdb00ff     nGn.._..w.......
 801af00:	e18f54fa 00ff186f ffc6b3e4 fd3fdc00     .T..o.........?.
 801af10:	8aa20035 cccfe92b 1f7cb542 6e2300ff     5...+...B.|...#n
 801af20:	5f00ff8f c5e87ff0 f0d5aaac ba8dfc7f     ..._............
 801af30:	c17ffd3f 16a300ff 39fcafb2 09a3337a     ?..........9z3..
 801af40:	af7a78fc bedafacc ffe9f86d ff262500     .xz.....m....%&.
 801af50:	c3b9fe00 d6a200ff 9baf92be c97f3a7e     ............~:..
 801af60:	00ffbf49 00ff70ae 85afb5e8 c9f76fe1     I....p.......o..
 801af70:	68fe857f 3f8f57fd f10f5de4 0d47caaf     ...h.W.?.]....G.
 801af80:	df571445 1405919f ef1d4051 28f95fc0     E.W.....Q@..._.(
 801af90:	f500ffb6 06fd5fc2 ff023e8a b745c900     ....._...>....E.
 801afa0:	12ae00ff 34e800ff 4ffce757 c2bffafe     .......4W..O....
 801afb0:	bf7e36bf 2df2bfc0 927fe27f 87daaf39     .6~....-....9...
 801afc0:	a6b5f03f c3f9fcc7 6e798dfc f5f91d08     ?.........yn....
 801afd0:	a8fd51af 4eabe47f fee16c3d 1db7bc46     .Q.....N=l..F...
 801afe0:	f26bfd01 a7f157ec 3300ffea 3f8703fb     ..k..W.....3...?
 801aff0:	ff8753e4 237f0400 f8047ed0 1ec1d3de     .S.....#.~......
 801b000:	53e7922d c80b6b46 17dd997c 21c84773     -..SFk..|...sG.!
 801b010:	1ce33ab0 7e41fa8a 2a3cfc2b 3625fc0f     .:....A~+.<*..%6
 801b020:	1ff28c5c e1e22bfc 29e03fbb 3939f058     \....+...?.)X.99
 801b030:	7cb8d6fa e5115a75 ec3c9a8d 59f083eb     ...|uZ....<....Y
 801b040:	15eb23b6 d6ca2825 f5b6b676 fe47fb4c     .#..%(..v...L.G.
 801b050:	cfc3b716 bfac1afa 0a00ff27 7c6be13f     ........'...?.k|
 801b060:	e13fce3c 9ffcb229 dee22bfc 3d5e4f07     <.?.)....+...O^=
 801b070:	4a827a29 00ffadf4 5f76abb5 3f9ef98f     )z.J......v_...?
 801b080:	bf8c43fc ffcf7efe 00ff2500 f81fed23     .C...~...%..#...
 801b090:	7f0fbf5a fcb269e8 3f29fc9f 3c7c6be1     Z....i....)?.k|<
 801b0a0:	aaa100ff f07ff2cb 3c898baf c628aee3     ...........<..(.
 801b0b0:	f69f863e f1cb6eb5 ff3100ff cb38c400     >....n....1...8.
 801b0c0:	ece700ff 5ff200ff ffd23ef2 f0ad8500     ......._.>......
 801b0d0:	9b86fef3 00ffc92f f8bca1c2 daf2f0b9     ..../...........
 801b0e0:	f88f4bd6 d8e62d49 47e2f2b9 31606f67     .K..I-.....Ggo`1
 801b0f0:	c633bed6 6ac7ef79 7e7a9e31 6b7fe91d     ..3.y..j1.z~...k
 801b100:	1fbfec56 c6e105f3 cf6a7d5f 2300fff0     V......._}j....#
 801b110:	bf0ee27b 4f0900ff 7f2db58c ee12f2c8     {......O..-.....
 801b120:	3c19cb6d 50852aaa 7d06f07d 7b8e04eb     m..<.*.P}..}...{
 801b130:	404aed01 add3711d 5e8d3e21 bb93936b     ..J@.q..!>.^k...
 801b140:	1885fa3e 541aa750 9214a3d5 7f235af4     >...P..T.....Z#.
 801b150:	3ed998c2 566e453d ec3e851f 5b5100ff     ...>=EnV..>...Q[
 801b160:	0787fb95 8f9ac87f 00ffbdfd 18fe48a5     .............H..
 801b170:	4bfe8ff1 c3fd6f3c 50d300ff bea2280a     ...K<o.....P.(..
 801b180:	2bc4fc9c 00ffc157 ffe836f2 00fff500     ...+W....6......
 801b190:	5a8cfe07 075fadca dbc800ff d700ffa3     ...Z.._.........
 801b1a0:	31fa1ffc 00ff2a6b 3aa397c3 87c79f30     ...1k*.....:0...
 801b1b0:	adcffcaa 8edfe6ab 6f52f29f 9ceb00ff     ..........Ro....
 801b1c0:	6b2dfa3f b7f92ae9 94fca7e3 fa00ff9b     ?.-k.*..........
 801b1d0:	8bfe0fe7 165ef85a 977c00ff 8fe65ff8     ....Z.^...|.._..
 801b1e0:	fef378d5 00ffd045 70a4fc1a 7d4551d4     .x..E......p.QE}
 801b1f0:	5110f9f9 de011445 00ff05fc ff6f8b92     ...QE.........o.
 801b200:	ff255c00 a368d000 94fc2fe0 e1fa7f5b     .\%...h../..[...
 801b210:	4583fe2f ffc47f7e fcabef00 eb67f32b     /..E~.......+.g.
 801b220:	00ff0bfc 27fed722 fd9823f9 e400ffa8     ...."..'.#......
 801b230:	e93f4eab 6be40fce f6794ecb 3fd5ebfc     .N?....k.Ny....?
 801b240:	8a8f136a c1d9fbd3 cb6be0cf 6a5f1f0f     j.........k..._j
 801b250:	fc15bbfc ccbffa79 cfe1c0fe ff6115f9     ....y.........a.
 801b260:	c81fc100 7d725c00 635c07a9 cef304a5     .....\r}..\c....
 801b270:	70a99d3e 86be3d41 e8b03db0 e41cc579     >..pA=...=..y...
 801b280:	1cd23c67 d2f8739e fbfa809e dbef01d0     g<...s..........
 801b290:	38da68b6 4ec71dc5 781e9c94 3e03a0f6     .h.8...N...x...>
 801b2a0:	a9d27adc d851e0f7 189a63e4 9c9ea71d     .z....Q..c......
 801b2b0:	2400687d 4c4a8f63 297dd493 b10338c3     }h.$c.JL..}).8..
 801b2c0:	e0a439e3 747ee4f5 a0f0de08 56f84dc2     .9....~t.....M.V
 801b2d0:	53f861ed 15f54fee f0b85fb9 a889fc77     .a.S.O..._..w...
 801b2e0:	dfdb00ff e18f54fa 00ff184f ffc6b3e4     .....T..O.......
 801b2f0:	fd3fdc00 8aa20035 cccfe92b 1f7cb542     ..?.5...+...B.|.
 801b300:	6e2300ff 5f00ff8f c5e87ff0 a3b5aaac     ..#n..._........
 801b310:	563f1dde 2408bfb3 dba4d336 acedc609     ..?V...$6.......
 801b320:	8a4a3f0e 928472b1 9a876dec 5bca5885     .?J..r...m...X.[
 801b330:	ec33bf26 e3b7f91a 9b94fca7 e7fa00ff     &.3.............
 801b340:	5a8bfe0f 1a0f3bf7 4ef35a78 dbf5f85b     ...Z.;..xZ.N[...
 801b350:	b82be308 3aaab3ac 2027157b 00ffced7     ..+....:{.' ....
 801b360:	5fbb3513 fbd2f810 f60db253 16912a67     .5._....S...g*..
 801b370:	42152c18 e36cc7ee 333cf135 174fab86     .,.B..l.5.<3..O.
 801b380:	242d4e29 d1bdd79a e31b6ffa 1470f570     )N-$.....o..p.p.
 801b390:	b7694ee3 d277f424 1cc55fcf 5f5114dd     .Ni.$.w.._....Q_
 801b3a0:	14587e72 77004551 e47f01bf 00ffdba2     r~X.QE.w........
 801b3b0:	f47f09d7 0bf8281a 162500ff 4bb8fedf     .....(....%....K
 801b3c0:	d1a000ff 3ff19f5f 00ffeafb fad9fc0a     ...._..?........
 801b3d0:	ff0200ff ffb5c800 48fe8900 106abfe6     ...........H..j.
 801b3e0:	b969c54f 3f24fbc0 7496d7c8 8a832739     O.i...$?...t9'..
 801b3f0:	07da7ff7 f12e7ec0 7559c40f b9421b0d     .....~....Yu..B.
 801b400:	d136b4bc a08c9a27 c9910364 e1c3e715     ..6.'...d.......
 801b410:	7f5cc447 3f78afc8 00ff51e0 8ef955f1     G.\...x?.Q...U..
 801b420:	69dd9426 feec9eb4 d3fce1b1 a12c4f03     &..i.........O,.
 801b430:	6a8ad609 27c9e92a f1c4a9b7 bc34b7c7     ...j*..'......4.
 801b440:	f51ee7b1 c200ffda ff89f8a7 e7bd4200     .............B..
 801b450:	fc9ff4fd 4fe10755 e1f35cc4 bc7fbc7b     ....U..O.\..{...
 801b460:	6355fc9f 2b7f6aec fb638ffb 00ff2f63     ..Uc.j.+..c.c/..
 801b470:	00fff09f 67fea3c0 07ee3e12 38a3b83e     .......g.>..>..8
 801b480:	5dedf51c 7f2afcb7 fcc77888 ff9cd722     ...]..*..x.."...
 801b490:	fc9fb400 47e10755 15fa3fc4 d3d54faf     ....U..G.?...O..
 801b4a0:	a58a00ff 2b7faaec 63fb83fb 9f00ff2f     .......+...c/...
 801b4b0:	c000fff0 1467fea3 37ade039 f7f40c04     ......g.9..7....
 801b4c0:	15fedbae bf3dc43f 7fde2bf2 00ff49df     ....?.=..+...I..
 801b4d0:	133e50c5 fccf43fc 839fb78a 1500ff27     .P>..C......'...
 801b4e0:	fed4d84f f607f757 00ff5fc6 00ffe13f     O...W...._..?...
 801b4f0:	cefc4781 190f7028 e663b41e 63bbe2c9     .G..(p....c....c
 801b500:	26e2a3f0 bc56e47f 9fbc3fc6 f01f55fc     ...&..V..?...U..
 801b510:	77227eaa bfe7b5f0 00ff1fcd a9b24715     .~"w.........G..
 801b520:	b63facfc f900ff32 fc0f00ff 71e63f0a     ..?.2........?.q
 801b530:	1fd3c53f 7d9e4be3 6ad7f9b1 437c143e     ?....K.}...j>.|C
 801b540:	8a00ffc1 fe03f456 54f17fda 7eaaf09f     ....V......T...~
 801b550:	add07f22 9fdcf579 c61e55fc b8bff2a7     "...y....U......
 801b560:	ff32b63f 00fff900 3f0afc0f 54f864e6     ?.2........?.d.T
 801b570:	a6e3b30d 9f566e45 f819be87 274cd8ee     ....EnV.......L'
 801b580:	6ee2ddf0 396419c1 fe5b6bfd 3f8def15     ...n..d9.k[....?
 801b590:	fcba5fe8 f66bfcd7 d1c4127e 855294a5     ._....k.~.....R.
 801b5a0:	edfda449 4cfc491b 67f12bfe c5195b0d     I....I.L.+.g.[..
 801b5b0:	78d8bad8 59f2c139 ee9f36c5 4d6bb4e0     ...x9..Y.6....kM
 801b5c0:	6a39f5f4 00ffa82b 4fe37b85 bfee17fa     ..9j+....{.O....
 801b5d0:	1a00ff35 f85ee13f fb85fed3 c67fcdaf     5...?.^.........
 801b5e0:	d8eb8fbe 1ff9f96f 7f9d1fbd e77fe365     ....o.......e...
 801b5f0:	17f0bfcc 452f47fe aff01f75 00ff697c     .....G/Eu...|i..
 801b600:	e6d7fd42 fc47e3bf 7f1adf2b f975bfd0     B.....G.+.....u.
 801b610:	f5d1f8af fcfc37ec fb83de8f 00ff1b2f     .....7....../...
 801b620:	00ff653e 39f2bf80 ffa82b7a e37b8500     >e.....9z+....{.
 801b630:	ee17fa4f 00ff35bf 5ee13f1a 85fed3f8     O....5...?.^....
 801b640:	7fcdaffb 61af8fc6 7ee4e7bf 78d91ff4     .......a...~...x
 801b650:	2ff3f9df 00ff05fc 5dd1cb91 df2bfc47     .../.......]G.+.
 801b660:	bfd07f1a f8aff975 c200ffd2 fda7f1bd     ....u...........
 801b670:	9a5ff70b 1f8d00ff cf7fc35e 3fe8fdc8     .._.....^......?
 801b680:	f3bff1b2 0bf85fe6 962300ff f89fbaa2     ....._....#.....
 801b690:	ff34be57 eb7ea100 a4f15ff3 7b8500ff     W.4...~.._.....{
 801b6a0:	17fa4fe3 ff35bfee bd3e1a00 9f00ff86     .O....5...>.....
 801b6b0:	7fd0fb91 e77fe365 17f0bfcc c0af46fe     ....e........F..
 801b6c0:	b628f95f c2f500ff 8a06fd5f e13bf8dd     _.(....._.....;.
 801b6d0:	fe68120f 53f78237 b7b667d2 23536458     ..h.7..S.g..XdS#
 801b6e0:	7825c095 85af68e8 abb03ae2 4d83528b     ..%x.h...:...R.M
 801b6f0:	73af6d59 a10b5ef5 e35c8656 992f2e56     Ym.s.^..V.\.V./.
 801b700:	2ebad5e8 eb78a9e7 4ff8d0c4 e2524d46     ......x....OFMR.
 801b710:	9aa87bce 44ac8865 0707b902 b57edc9e     .{..e..D......~.
 801b720:	881fe099 f58b7f1a 6b2b9b0b 20599b1b     ..........+k..Y 
 801b730:	d6fb4b88 1c67b853 189fd460 c3ef8dac     .K..S.g.`.......
 801b740:	655455ad bf4e8ca1 fe0406f0 fc90d780     .UTe..N.........
 801b750:	2ffbbc0a 89684bc4 2cc1dcc2 c380eb47     .../.Kh....,G...
 801b760:	af4100ff dee3fa00 c1ad573c eb02dde1     ..A.....<W......
 801b770:	e58db958 5102dc8e 90c4dc08 d7fa1900     X......Q........
 801b780:	89dfe02f d6273e96 742db37f 421cc8ab     /....>'...-t...B
 801b790:	949197f2 3ef40ba8 d07eaae2 82479eb7     .......>..~...G.
 801b7a0:	9b07b522 7a5cc49b f28f0585 ce7eca15     ".....\z......~.
 801b7b0:	1df53bf6 c42b516b 3e08cb56 fa3f49ec     .;..kQ+.V..>.I?.
 801b7c0:	d30da008 0c48b3f1 a31ef647 4fdfc7c1     ......H.G......O
 801b7d0:	00ffa4f1 7fa4db85 ff500fd0 fcd3be00     ..........P.....
 801b7e0:	edecc56b a1d4bda4 649589b2 85449cb8     k..........d..D.
 801b7f0:	81cd02ba 0bbdce9f 89bf14fe a523e8bf     ..............#.
 801b800:	ff4fdf7f 12d3c400 e2d7263d 81c78d0d     ..O.....=&......
 801b810:	ba5a7c2e dbdbd27d 4b6862ca 0341f22e     .|Z.}....bhK..A.
 801b820:	ae779c23 6e17fe73 4000ff91 fbfe433d     #.w.s..n...@=C..
 801b830:	35a8f14f f85e0e9f ab76e05b 04cddfa5     O..5..^.[.v.....
 801b840:	6efe79b3 862b49e8 3d50c774 177ccc2b     .y.n.I+.t.P=+.|.
 801b850:	15cf9be1 d8a6cfea 2ac15bdc 36dd6542     .........[.*Be.6
 801b860:	18089076 a0791ee0 bf68b367 7d313c18     v.....y.g.h..<1}
 801b870:	c55d9072 2017a779 41019907 2b4e2af5     r.].y.. ...A.*N+
 801b880:	8bcff1a2 a42b7c6d 5a73ea5b f2047b4d     ....m|+.[.sZM{..
 801b890:	9781c188 e420a98c cf579c9e 8ef0369e     ...... ...W..6..
 801b8a0:	c82be1ab 128cd460 295aeaa4 63ab24a1     ..+.`.....Z).$.c
 801b8b0:	0802e4a8 b1ebfcc8 735d9eb0 04a10ee0     ..........]s....
 801b8c0:	a44bd2cc 932c0fdc 914ab193 f86106f9     ..K...,...J...a.
 801b8d0:	8d9e2b50 d81e0fe0 eee6c278 e6cad6de     P+......x.......
 801b8e0:	5c91edd5 c09d4a89 f6c13892 6b188fad     ...\.J...8.....k
 801b8f0:	d01afed6 a12ed627 2ae16892 dcc8b83c     ....'....h.*<...
 801b900:	060098c5 3fe2b57e b70d6f00 70be858f     ....~..?.o.....p
 801b910:	26b256b7 0fc3483d fdb86be4 9f3cafa2     .V.&=H...k....<.
 801b920:	03d95909 09787383 ffa408f7 01293200     .Y...sx......2).
 801b930:	89dfe0a5 d4263e56 d2b5b1e5 ad6820af     ....V>&...... h.
 801b940:	197976de 1cc78571 8835a71e 0469373e     .vy.q.....5.>7i.
 801b950:	a887fd03 7fdafef3 cf7e638d c48f5996     .........c~..Y..
 801b960:	761f913a d44f8105 2be41f33 296bf4cb     :..v..O.3..+..k)
 801b970:	cf462d75 2591854e 466291ba 700bba7f     u-F.N..%..bF...p
 801b980:	67a0f609 c200ffb4 e83fd2ed df7fa807     ...g......?.....
 801b990:	d235fe69 160bc42f b87813f0 675ff769     i.5./.....x.i._g
 801b9a0:	06b37c59 db9ddfe5 e615d773 fca5f0bf     Y|......s.......
 801b9b0:	4100ff4d fafe2b1d b726fe7f fbe153bc     M..A.+....&..S..
 801b9c0:	0dfc0cbf a5afd2b8 e5925986 ed44b45c     .........Y..\.D.
 801b9d0:	ea084ac3 0f3a0205 d2507c07 45af49bc     .J....:..|P..I.E
 801b9e0:	dda747a4 b132cbda a9949547 0f8e332a     .G....2.G...*3..
 801b9f0:	adf2675c aef81ecf 5c3ac2db 9356f737     \g........:\7.V.
 801ba00:	08b3a4dc 2040c482 fa794e90 0e1acd57     ......@ .Ny.W...
 801ba10:	ad9126a3 7d916ad9 5fd659fb f89107a8     .&...j.}.Y._....
 801ba20:	6ff68a8c ee6812da 5ca6137c 96a3c142     ...o..h.|..\B...
 801ba30:	77181ded 4c831805 f19bae66 f0be4e3b     ...w...Lf...;N..
 801ba40:	26afabbe 69917897 653c1aaf 20ef7397     ...&.x.i..<e.s. 
 801ba50:	338e730c f000ff58 fa8f74bb f71fea01     .s.3X....t......
 801ba60:	738d7fda 5b740b3f 037811af 9c451ac5     ...s?.t[..x...E.
 801ba70:	f33c4791 4969eddb c79d36da 8f15f638     .G<...iI.6..8...
 801ba80:	3a870fe3 63f485d7 d8dddfaa 639108cb     ...:...c.......c
 801ba90:	d96d09db 2950c763 c27fdf01 e83fd2ed     ..m.c.P)......?.
 801baa0:	df7fa807 d335fe69 96c703f8 baba305e     ....i.5.....^0..
 801bab0:	e6c2d682 bb22dbd4 6c485919 f6c13892     ......"..YHl.8..
 801bac0:	57f005af 59fcef85 a7614da9 910c6fcf     ...W...Y.Ma..o..
 801bad0:	9831e743 18c80890 6b9e0718 78127ed9     C.1........k.~.x
 801bae0:	8df0551b 8dfafcf5 71cba4cd 0b08221a     .U.........q."..
 801baf0:	f3240812 02683d90 53fc164f e23bfcd2     ..$..=h.O..S..;.
 801bb00:	5d1e8d0b 4be6f236 8da4bb7d 834a2e94     ...]6..K}.....J.
 801bb10:	d76c4f8e 144fe043 47b778da b7b45193     .Ol.C.O..x.G.Q..
 801bb20:	9863dd9a 41cad1c4 3c074060 6ebee676     ..c....A`@.<v..n
 801bb30:	d4e8a5f1 deab5f7c f2969583 90fda74d     ....|_......M...
 801bb40:	15a01fd8 6db39fe9 9ace3aef 3c00ffcd     .......m.:.....<
 801bb50:	a9f951e7 1e9842fe 521445c9 68afae02     .Q...B...E.R...h
 801bb60:	bb9bf42f 0371e926 4ae07fc4 97aff547     /...&.q....JG...
 801bb70:	7474133c 17e919cf 45be1d12 f4992cea     <.tt.......E.,..
 801bb80:	42bfb5dd f9daea6b 8776c74f b1aef14b     ...Bk...O.v.K...
 801bb90:	956f836e d01fef78 d0f9c39d d2fea107     n.o.x...........
 801bba0:	e8dd8057 753f78da a98f9c24 ad913f0a     W....x?u$....?..
 801bbb0:	cbfed9bf ed35f0c8 ab6b18e1 557d3099     ......5...k..0}U
 801bbc0:	73fd2854 93f1755e 8ba71a54 2a3098e3     T(.s^u..T.....0*
 801bbd0:	39be7d9a 3feff2fe 577b15fa a7135bc3     .}.9...?..{W.[..
 801bbe0:	edd238fc d39a61d8 e5ab6fcd 3e30adbf     .8...a...o....0>
 801bbf0:	2ae3f074 774da378 e85b4465 001c338b     t..*x.MweD[..3..
 801bc00:	af498e37 74b73fa9 690cfa4f 9f12f8df     7.I..?.tO..i....
 801bc10:	15255fe3 5255292f 4001b1c4 953e27c9     ._%./)UR...@.'>.
 801bc20:	ff55f63f ef02fd00 ff19f03f 2486c200     ?.U.....?......$
 801bc30:	8af10f7d 86af0be2 d3d69c1a 26443cc5     }............<D&
 801bc40:	a70c371e 79c51de7 fff5ecb7 dfcc2300     .7.....y.....#..
 801bc50:	00ffe2f5 c2d612fa b31f24c5 0b4bd18c     .........$....K.
 801bc60:	2a9be1c2 df8f54e8 8ff31afa 5187780a     ...*.T.......x.Q
 801bc70:	faa4cef0 13619886 e62346b4 90b4e1a6     ......a..F#.....
 801bc80:	40f17a7a 4afba71e d1cffe14 7cfe8d17     zz.@...J.......|
 801bc90:	68e37aa4 bfaaf4cf a10eac04 d9132fe0     .z.h........./..
 801bca0:	2597dcb0 e5ef51a2 79c5f57f 45fc89b7     ...%.Q.....y...E
 801bcb0:	fe9ef8ac 7f569d3b 221b543e abda348e     ....;.V.>T.".4..
 801bcc0:	7754d193 a0aff127 7ef812be 32f80e6f     ..Tw'......~o..2
 801bcd0:	3feed6de 3776ee2e aceaa913 709fc2d8     ...?..v7.......p
 801bce0:	e0011400 ce6e0e9f 16ade39f 2ed08ee1     ......n.........
 801bcf0:	37fa37d6 779d7fca e685b43f b0496bfd     .7.7...w?....kI.
 801bd00:	bb55fd07 b37b46cc 13f43f00 789fd7f9     ..U..F{..?.....x
 801bd10:	fcd1069e 80c2a863 76beb4a9 cb7da04f     ....c......vO.}.
 801bd20:	e36f2bfd 87baa23e 4626ee8e d0761cdd     .+o.>.....&F..v.
 801bd30:	07aa9faa 0015fa3f dbc05f7a 367cb32f     ....?...z_../.|6
 801bd40:	862bb9b9 33699abb 3fda00ea 2f5e13f4     ..+...i3...?..^/
 801bd50:	fc4887e0 23c9a259 44de22aa 01e09859     ..H.Y..#.".DY...
 801bd60:	a527c991 abe01b7d 87efec1f 18a17d3a     ..'.}.......:}..
 801bd70:	df0cb065 f9c75d56 abb0cbd7 2e544438     e...V]......8DT.
 801bd80:	060a00cc 21c5f649 00ff5b9f f49fe86e     ....I..!.[..n...
 801bd90:	f0bfd318 b9c63f25 c3738d3f f2c6f073     ....%?..?.s.s...
 801bda0:	9aa3797b af2d9226 fb53061b f98ad0c1     {y..&.-...S.....
 801bdb0:	ff2afbf7 7781fe00 ff0cf89f b15ee100     ..*....w......^.
 801bdc0:	1f24c5a8 52ac7db3 953af1c4 23953aca     ..$..}.R..:..:.#
 801bdd0:	34f620fd bb7e3c03 3a567bfd 223dc1a7     . .4.<~..{V:..="
 801bde0:	b6741f39 5fd98f3a 62059c27 1fe9f8bf     9.t.:.._'..b....
 801bdf0:	2efa7295 a1a1fd95 094897eb a718c29a     .r........H.....
 801be00:	bfbb3f50 3f87fe6b c94b5085 4f9f4b57     P?..k..?.PK.WK.O
 801be10:	47b30ceb cae81931 34267f18 fd628fd0     ...G1.....&4..b.
 801be20:	e400ff9a 00ffad1d f4bf78d7 1f9f5b13     .........x...[..
 801be30:	c99ee4bf 705f00ff c33a00ff 00ff9afd     ......_p..:.....
 801be40:	ffad1de4 bf78d700 9f5b13f4 9ee4bf1f     ......x...[.....
 801be50:	5f00ffc9 3a00ff70 d96f3843 0d47fecf     ..._p..:C8o...G.
 801be60:	3fbcfe43 b6d7a2f6 4f83d76b 99af2fd1     C..?....k..O./..
 801be70:	797b8bb6 49d1cf24 9cfd12af 70e400ff     ..{y$..I.......p
 801be80:	5cfee3bf b586fe0f 2f1a3fe9 e7f0c57e     ...\.....?./~...
 801be90:	e761c353 ddf30209 66fa0398 349d8f98     S.a........f...4
 801bea0:	197539ab f4ce45e6 8fe196b7 d7588afb     .9u..E........X.
 801beb0:	fb12f067 2310bfec f2167683 a4be48da     g......#.v...H..
 801bec0:	82fec761 0300ff69 b5d4b574 325959dd     a...i...t....YY2
 801bed0:	1749a6ab f91726e3 038fb966 e397b65d     ..I..&..f...]...
 801bee0:	dbe1223d 8978936f ad9dd027 7d00cdfc     ="..o.x.'......}
 801bef0:	5214455b ffce5718 be2c1f00 9ff7e3cd     [E.R.W....,.....
 801bf00:	ace52d00 ca487d72 5704fd1f 7fe315d1     .-..r}H....W....
 801bf10:	3a9795b4 fc07a236 e48f81f4 001af9c3     ...:6...........
 801bf20:	d46742f2 898d626f e1686579 0708a75f     .Bg.ob..yeh._...
 801bf30:	defa8ae5 4cdb1638 b1fb645b 027d1042     ....8..L[d..B.}.
 801bf40:	f864bee2 a1fd6565 df1aede3 02b7e06e     ..d.ee......n...
 801bf50:	0bc81e56 82fa4a7f 9f44fde3 40e59fee     V....J....D....@
 801bf60:	63f8271f 2fbd46fe ffe2bffe be82d100     .'.c.F./........
 801bf70:	2d90afb3 d4b3242e 6f87bc62 54c2049b     ...-.$..b..o...T
 801bf80:	ad3232dc ffee9a91 f870e100 5fbafbc3     .22.......p...._
 801bf90:	ffb703fe 894d1500 aff1a31e a9b649fe     ......M......I..
 801bfa0:	0dfd4ff4 14bec66b f14e7378 d3658947     .O..k...xsN.G.e.
 801bfb0:	423c3fb5 3128cdb6 32b8d33e 35f7b88e     .?<B..(1>..2...5
 801bfc0:	219e6adc f04d3cd4 b5d45533 ed9f0031     .j.!.<M.3U..1...
 801bfd0:	50ee5f1e 633ae0aa 73ad4f82 d7b300ff     ._.P..:c.O.s....
 801bfe0:	ff338ffc ff8bd700 404be800 a78d8d33     ..3.......K@3...
 801bff0:	958bdff0 cbb4899b c3fe73fe fa0afaf3     .........s......
 801c000:	581219c2 e4ce5892 d4a70c75 87f3951e     ...X.X..u.......
 801c010:	ec37edc6 1c6f101f 8dbc232e 91dc172e     ..7...o..#......
 801c020:	3555bfb5 f5091fed 004fed2f 6eb35369     ..U5..../.O.iS.n
 801c030:	89bc2892 ff76a83e 19282000 2c1d5fe3     .(..>.v.. (.._.,
 801c040:	12f1cbbe 6ee1f6ed ee618ea1 fa3fed76     .......n..a.v.?.
 801c050:	2450720d 6fb1b6fa ddf2920b 5c5f1c4d     .rP$...o....M._\
 801c060:	aff4a390 aca4fd51 da68dfb6 1cbf5f88     ....Q.....h.._..
 801c070:	10fa3190 e39af9c3 7d59133e 9126e2bb     .1......>.Y}..&.
 801c080:	4a11011e 00ff3967 78fe4961 97d247a0     ...Jg9..aI.x.G..
 801c090:	645aac51 a4c220b1 0bf64025 13782c5f     Q.Zd. ..%@.._,x.
 801c0a0:	7868188f d89f00ff 5f21f4bf 00ff5f55     ..hx......!_U_..
 801c0b0:	fdc78dc7 6be46f72 f2265de4 d2fa3e6d     ....ro.k.]&.m>..
 801c0c0:	9d67dffe 1ecb226d 39dc95f1 86941e19     ..g.m".....9....
 801c0d0:	3f5c817d 27f94fc7 d2f5df17 570cfd2f     }.\?.O.'..../..W
 801c0e0:	c200ff99 f787f1e1 07fcbf74 ba2afe6f     ........t...o.*.
 801c0f0:	b76b124f 15f823de 226aaa71 2af77011     O.k..#..q.j".p.*
 801c100:	ab52caa7 82032881 3f66024d 156bfdec     ..R..(..M.f?..k.
 801c110:	59afa5ee 9ea2a1ce f7e046c0 f31ac40c     ...Y.....F......
 801c120:	6dc65aad d3bb5533 6b4b0467 efd94433     .Z.m3U..g.Kk3D..
 801c130:	8f3fe3b4 d9bff45a 0d46febf 13bdfe5b     ..?.Z.....F.[...
 801c140:	aa4300ff 73f41f3f f508e361 ea10d738     ..C.?..sa...8...
 801c150:	eb7f8230 4d7f70a2 279d81a6 00ffd7ec     0....p.M...'....
 801c160:	fe6fed20 00ffc5bb f8dc9aa0 2400fffd      .o............$
 801c170:	fbfa4ff6 1fd6f987 00ffd7ec fe6fed20     .O.......... .o.
 801c180:	00ffc5bb f8dc9aa0 2400fffd fbfa4ff6     ...........$.O..
 801c190:	07d0f987 ff39fb0b 7fe1c800 075e00ff     ......9.......^.
 801c1a0:	5a4300ff fb687fe9 d3412fdf 9e79f034     ..CZ..h../A.4.y.
 801c1b0:	b247c8e4 73b5f82f fca7b35f 00ff178e     ..G./..s_.......
 801c1c0:	f47fe2f5 89f6a335 5bbcf3bc 160f6465     ....5......[ed..
 801c1d0:	d02399d6 a2e81fbb 871f8c98 0d3e363e     ..#.........>6>.
 801c1e0:	a54773fb ecddeba5 36c534cb 0e1dcf05     .sG......4.6....
 801c1f0:	2fe69a73 8dfa44ee 7951ecc5 649a4922     s../.D....Qy"I.d
 801c200:	6576368c f89e01b7 5ff046af 1fe291c2     .6ve.....F._....
 801c210:	32eb590d 6e684feb 2d449855 200660c3     .Y.2.OhnU.D-.`. 
 801c220:	19d79173 1fe253ae b584cf85 d43ed3f5     s....S........>.
 801c230:	2cf048d7 b94d29cb 648c20c9 3e8022f4     .H.,.)M.. .d.".>
 801c240:	c56ed199 7c658ffe 04e222a7 06553f93     ..n...e|."...?U.
 801c250:	0dbee68a e1b7fdde 654b96ce bd8146a0     ..........Ke.F..
 801c260:	f40331b6 768614c5 2fe38915 2bde690c     .1.....v.../.i.+
 801c270:	f5d323d3 a348b826 0bad4a94 23406085     .#..&.H..J...`@#
 801c280:	688e07a9 3c3280a2 c3dff027 57d61afe     ...h..2<'......W
 801c290:	fe96b055 4546844b a0acca13 a3805337     U...K.FE....7S..
 801c2a0:	4359ec9a 8cd05329 0fa0281a 3e836f38     ..YC)S...(..8o.>
 801c2b0:	ba492c14 ff39b9d5 ff858f00 ff28e200     .,I...9.......(.
 801c2c0:	e1318500 d5faf93f 21f000ff 288af87f     ..1.?......!...(
 801c2d0:	db6ee0a2 b7450b78 85c76df0 63d36b52     ..n.x.E..m..Rk.c
 801c2e0:	6346863c 9280f922 3b6e070f 831fd50e     <.Fc".....n;....
 801c2f0:	7ee81ebe 525bd516 79bf66d3 1311239a     ...~..[R.f.y.#..
 801c300:	24b8acca 3c47811e 4f004551 68035fe3     ...$..G<QE.O._.h
 801c310:	b6b92dbe eeded4b8 a2d02d39 900b2498     .-......9-...$..
 801c320:	35c8794e 18bec177 9baef0b0 4da79f26     Ny.5w.......&..M
 801c330:	290f2475 62b81397 300e8018 280a1c07     u$.)...b...0...(
 801c340:	d3f806a0 8b67bac2 d4b3212c 1912e1da     ......g.,!......
 801c350:	1c68d47c 6304672b ac391e24 3a7c08cf     |.h.+g.c$.9...|:
 801c360:	ab2f7cd0 964f4f9d a6fc49fa abf27988     .|/..OO..I...y..
 801c370:	918c0428 45f11c85 4cd70114 369e5882     (......E...L.X.6
 801c380:	4ea50ec8 07ceeb3d 80098fc1 7eb5da07     ...N=..........~
 801c390:	7fe1e93f a0288af8 8500ff05 f93fe131     ?.....(.....1.?.
 801c3a0:	00ffd5fa f87f21f0 015fde8a 8dc1a3e8     .....!...._.....
 801c3b0:	ef3541e1 619e0cd8 cc7c316f 6ed7ddee     .A5....ao1|....n
 801c3c0:	286a9f31 57f005a0 096f3481 695d5c5e     1.j(...W.4o.^\]i
 801c3d0:	dcbb5e93 3c712346 e7008081 7eab288c     .^..F#q<.....(.~
 801c3e0:	97a6f034 6d18cbe2 ac3a4335 bc917912     4......m5C:..y..
 801c3f0:	c681152e 8307c908 cf001445 4b3ff804     ........E.....?K
 801c400:	51378cf0 3add9269 f9bbbadc 068218ee     ..7Qi..:........
 801c410:	ad073006 8777f15a a34f7cac 79512b9d     .0..Z.w..|O..+Qy
 801c420:	c82203d2 b2152c4c 34488ea7 5e194051     ..".L,....H4Q@.^
 801c430:	8906f00c 5b464de1 e76b36ed a6bc5896     .....MF[.6k..X..
 801c440:	31acca13 8ec27890 28deaa78 78a069f8     ...1.x..x..(.i.x
 801c450:	569b5a8b 96d4b9bf 88a050e2 28a050a6     .Z.V.....P...P.(
 801c460:	682ac0c0 9d3a80a2 d2b64e17 325d9b34     ..*h..:..N..4.]2
 801c470:	6d9177d3 1c378d18 7a5f0f9c 80a7f1c1     .w.m..7..._z....
 801c480:	5e165ff4 726adedb 112c475e 90c8d798     ._.^..jr^G,.....
 801c490:	f39c2028 80a26890 e11d3c34 690b0fab     ( ...h..4<.....i
 801c4a0:	d2e9a66f 4a03c9dc 86fbfd65 c6019020     o......Je... ...
 801c4b0:	288ae300 ff3f80a2 000000d9 00000000     ...(..?.........

0801c4c0 <data_Verventa_Master_html>:
 801c4c0:	7265562f 746e6576 614d5f61 72657473     /Verventa_Master
 801c4d0:	6d74682e 5448006c 312f5054 3220302e     .html.HTTP/1.0 2
 801c4e0:	4f203030 530a0d4b 65767265 6c203a72     00 OK..Server: l
 801c4f0:	2f504977 2d657270 20362e30 74746828     wIP/pre-0.6 (htt
 801c500:	2f2f3a70 2e777777 73636973 2f65732e     p://www.sics.se/
 801c510:	6164617e 776c2f6d 292f7069 6f430a0d     ~adam/lwip/)..Co
 801c520:	6e65746e 79742d74 203a6570 74786574     ntent-type: text
 801c530:	6d74682f 0d0a0d6c 44213c0a 5954434f     /html....<!DOCTY
 801c540:	68204550 3e6c6d74 74683c0a 3c3e6c6d     PE html>.<html><
 801c550:	6c746974 65563e65 6e657672 432d6174     title>Verventa-C
 801c560:	72746e6f 2f3c6c6f 6c746974 200a3e65     ontrol</title>. 
 801c570:	656d3c20 68206174 2d707474 69757165      <meta http-equi
 801c580:	43223d76 65746e6f 542d746e 22657079     v="Content-Type"
 801c590:	6e6f6320 746e6574 6574223d 682f7478      content="text/h
 801c5a0:	3b6c6d74 61686320 74657372 6674753d     tml; charset=utf
 801c5b0:	3e22382d 3c20200a 6c797473 79742065     -8">.  <style ty
 801c5c0:	223d6570 74786574 7373632f 200a3e22     pe="text/css">. 
 801c5d0:	68202020 2c6c6d74 646f6220 0a7b2079        html, body {.
 801c5e0:	20202020 69772020 3a687464 30303120           width: 100
 801c5f0:	200a3b25 20202020 69656820 3a746867     %;.      height:
 801c600:	30303120 200a3b25 20202020 72616d20      100%;.      mar
 801c610:	3a6e6967 78703020 20200a3b 0a7d2020     gin: 0px;.    }.
 801c620:	20202020 79646f62 200a7b20 20202020         body {.     
 801c630:	65772d20 74696b62 6172742d 6f66736e      -webkit-transfo
 801c640:	203a6d72 73726570 74636570 28657669     rm: perspective(
 801c650:	30303431 20297870 7274616d 64337869     1400px) matrix3d
 801c660:	202c3128 30202c30 2c30202c 202c3020     (1, 0, 0, 0, 0, 
 801c670:	30202c31 2c30202c 202c3020 31202c30     1, 0, 0, 0, 0, 1
 801c680:	2c30202c 202c3020 30202c30 2931202c     , 0, 0, 0, 0, 1)
 801c690:	20200a3b 20202020 6265772d 2d74696b     ;.      -webkit-
 801c6a0:	6e617274 726f6673 74732d6d 3a656c79     transform-style:
 801c6b0:	65727020 76726573 64332d65 20200a3b      preserve-3d;.  
 801c6c0:	20202020 6b636162 756f7267 632d646e         background-c
 801c6d0:	726f6c6f 7274203a 70736e61 6e657261     olor: transparen
 801c6e0:	200a3b74 7d202020 2020200a 77672e20     t;.    }.    .gw
 801c6f0:	69642d64 71672d76 7b207175 2020200a     d-div-gquq {.   
 801c700:	70202020 7469736f 3a6e6f69 73626120        position: abs
 801c710:	74756c6f 200a3b65 20202020 64697720     olute;.      wid
 801c720:	203a6874 70343135 200a3b78 20202020     th: 514px;.     
 801c730:	69656820 3a746867 39363120 0a3b7870      height: 169px;.
 801c740:	20202020 6f662020 662d746e 6c696d61           font-famil
 801c750:	27203a79 656d6954 654e2073 6f522077     y: 'Times New Ro
 801c760:	276e616d 20200a3b 20202020 74786574     man';.      text
 801c770:	696c612d 203a6e67 7466656c 20200a3b     -align: left;.  
 801c780:	20202020 6f6c6f63 72203a72 30286267         color: rgb(0
 801c790:	2c30202c 3b293020 2020200a 6c202020     , 0, 0);.      l
 801c7a0:	3a746665 70303220 200a3b78 20202020     eft: 20px;.     
 801c7b0:	706f7420 3231203a 0a3b7870 20202020      top: 12px;.    
 801c7c0:	61622020 72676b63 646e756f 616d692d       background-ima
 801c7d0:	203a6567 656e6f6e 20200a3b 0a7d2020     ge: none;.    }.
 801c7e0:	20202020 6477672e 6170732d 70342d6e         .gwd-span-4p
 801c7f0:	7b206633 2020200a 66202020 2d746e6f     3f {.      font-
 801c800:	657a6973 3231203a 0a3b7870 20202020     size: 12px;.    
 801c810:	20200a7d 672e2020 732d6477 2d6e6170     }.    .gwd-span-
 801c820:	6d6e7277 200a7b20 20202020 6e6f6620     wrnm {.      fon
 801c830:	69732d74 203a657a 78703231 20200a3b     t-size: 12px;.  
 801c840:	0a7d2020 20202020 6477672e 676d692d       }.    .gwd-img
 801c850:	6732612d 0a7b2071 20202020 6f702020     -a2gq {.      po
 801c860:	69746973 203a6e6f 6f736261 6574756c     sition: absolute
 801c870:	20200a3b 20202020 74646977 32203a68     ;.      width: 2
 801c880:	78703030 20200a3b 20202020 67696568     00px;.      heig
 801c890:	203a7468 70303531 200a3b78 20202020     ht: 150px;.     
 801c8a0:	66656c20 33203a74 78703433 20200a3b      left: 334px;.  
 801c8b0:	20202020 3a706f74 70323120 200a3b78         top: 12px;. 
 801c8c0:	7d202020 2020200a 77672e20 69642d64        }.    .gwd-di
 801c8d0:	33712d76 7b206267 2020200a 70202020     v-q3gb {.      p
 801c8e0:	7469736f 3a6e6f69 73626120 74756c6f     osition: absolut
 801c8f0:	200a3b65 20202020 64697720 203a6874     e;.      width: 
 801c900:	70343135 200a3b78 20202020 69656820     514px;.      hei
 801c910:	3a746867 70313520 200a3b78 20202020     ght: 51px;.     
 801c920:	6e6f6620 61662d74 796c696d 5427203a      font-family: 'T
 801c930:	73656d69 77654e20 6d6f5220 3b276e61     imes New Roman';
 801c940:	2020200a 74202020 2d747865 67696c61     .      text-alig
 801c950:	6c203a6e 3b746665 2020200a 6c202020     n: left;.      l
 801c960:	3a746665 70393120 200a3b78 20202020     eft: 19px;.     
 801c970:	706f7420 3831203a 3b787031 2020200a      top: 181px;.   
 801c980:	200a7d20 672e2020 642d6477 712d7669      }.   .gwd-div-q
 801c990:	20356733 20200a7b 20202020 69736f70     3g5 {.      posi
 801c9a0:	6e6f6974 6261203a 756c6f73 0a3b6574     tion: absolute;.
 801c9b0:	20202020 69772020 3a687464 34313520           width: 514
 801c9c0:	0a3b7870 20202020 65682020 74686769     px;.      height
 801c9d0:	3135203a 0a3b7870 20202020 6f662020     : 51px;.      fo
 801c9e0:	662d746e 6c696d61 27203a79 656d6954     nt-family: 'Time
 801c9f0:	654e2073 6f522077 276e616d 20200a3b     s New Roman';.  
 801ca00:	20202020 74786574 696c612d 203a6e67         text-align: 
 801ca10:	7466656c 20200a3b 20202020 7466656c     left;.      left
 801ca20:	3931203a 0a3b7870 20202020 6f742020     : 19px;.      to
 801ca30:	32203a70 78703031 20200a3b 0a7d2020     p: 210px;.    }.
 801ca40:	20202020 6477672e 6b2d612d 206d6373         .gwd-a-kscm 
 801ca50:	20200a7b 20202020 7466656c 7030203a     {.      left: 0p
 801ca60:	200a3b78 20202020 706f7420 7032203a     x;.      top: 2p
 801ca70:	200a3b78 7d202020 3c20200a 7974732f     x;.    }.  </sty
 801ca80:	0a3e656c 65682f3c 0a3e6461 6f623c0a     le>.</head>..<bo
 801ca90:	0a3e7964 643c2020 63207669 7373616c     dy>.  <div class
 801caa0:	7767223d 69642d64 71672d76 3e227175     ="gwd-div-gquq">
 801cab0:	7274733c 3e676e6f 76726556 61746e65     <strong>Verventa
 801cac0:	73614d2d 20726574 302e3156 2f3c302e     -Master V1.0.0</
 801cad0:	6f727473 0a3e676e 20202020 7669643c     strong>.    <div
 801cae0:	74733c3e 676e6f72 70733c3e 63206e61     ><strong><span c
 801caf0:	7373616c 7767223d 70732d64 342d6e61     lass="gwd-span-4
 801cb00:	22663370 3239313e 3836312e 312e302e     p3f">192.168.0.1
 801cb10:	383a3633 3c303830 6170732f 623c3e6e     36:8080</span><b
 801cb20:	2f3c3e72 6f727473 0a3e676e 20202020     r></strong>.    
 801cb30:	69642f3c 200a3e76 3c202020 3e766964     </div>.    <div>
 801cb40:	7274733c 3e676e6f 6170733c 733c3e6e     <strong><span><s
 801cb50:	206e6170 73616c63 67223d73 732d6477     pan class="gwd-s
 801cb60:	2d6e6170 6d6e7277 756d3e22 6369746c     pan-wrnm">multic
 801cb70:	726f6c61 67726f2e 70732f3c 3c3e6e61     alor.org</span><
 801cb80:	6170732f 2f3c3e6e 6f727473 0a3e676e     /span></strong>.
 801cb90:	20202020 69642f3c 200a3e76 642f3c20         </div>.  </d
 801cba0:	0a3e7669 693c2020 7320676d 223d6372     iv>.  <img src="
 801cbb0:	65737361 732f7374 73616c70 63735f68     assets/splash_sc
 801cbc0:	6e656572 67706a2e 6c632022 3d737361     reen.jpg" class=
 801cbd0:	64776722 676d692d 6732612d 0a3e2271     "gwd-img-a2gq">.
 801cbe0:	643c2020 63207669 7373616c 7767223d       <div class="gw
 801cbf0:	69642d64 33712d76 3e226267 6820613c     d-div-q3gb"><a h
 801cc00:	3d666572 74746822 2f2f3a70 2e323931     ref="http://192.
 801cc10:	2e383631 33312e30 4f4d2f36 53554244     168.0.136/MODBUS
 801cc20:	4b534154 74682e53 20226c6d 67726174     TASKS.html" targ
 801cc30:	223d7465 706f745f 6c632022 3d737361     et="_top" class=
 801cc40:	64776722 6b2d612d 226d6373 646f4d3e     "gwd-a-kscm">Mod
 801cc50:	20535542 69766564 3c736563 0a3e612f     BUS devices</a>.
 801cc60:	2f3c2020 3e766964 3c20200a 20766964       </div>.  <div 
 801cc70:	73616c63 67223d73 642d6477 712d7669     class="gwd-div-q
 801cc80:	22356733 20613c3e 66657268 7468223d     3g5"><a href="ht
 801cc90:	2f3a7074 3239312f 3836312e 312e302e     tp://192.168.0.1
 801cca0:	752f3633 616f6c70 6e6f6364 2e676966     36/uploadconfig.
 801ccb0:	6c6d7468 61742022 74656772 745f223d     html" target="_t
 801ccc0:	2022706f 73616c63 67223d73 612d6477     op" class="gwd-a
 801ccd0:	63736b2d 553e226d 616f6c70 6f632064     -kscm">Upload co
 801cce0:	6769666e 3e612f3c 3c20200a 7669642f     nfig</a>.  </div
 801ccf0:	2f3c0a3e 79646f62 3c0a0a3e 6d74682f     >.</body>..</htm
 801cd00:	00003e6c 00000000 00000000 00000000     l>..............
 801cd10:	62646f6d 725f7375 65757165 00007473     modbus_request..
 801cd20:	6f727265 00000072 65276f6e 726f7272     error...no'error
 801cd30:	00000000 62646f6d 705f7375 006c6c6f     ....modbus_poll.
 801cd40:	61745365 3a737574 0a732520 00000000     eStatus: %s.....
 801cd50:	6e696c62 0072656b 00007325 65726854     blinker.%s..Thre
 801cd60:	62206461 6b6e696c 0a2e7265 00000000     ad blinker......
 801cd70:	3a79656b 20732520 00000000 756c6176     key: %s ....valu
 801cd80:	25203a65 00000a63 20565753 62616e45     e: %c...SWV Enab
 801cd90:	0a64656c 00000000 62696843 20534f69     led.....ChibiOS 
 801cda0:	302e3356 0000000a 00000000 00000000     V3.0............
 801cdb0:	7566202c 6974636e 203a6e6f 00000000     , function: ....
 801cdc0:	65737361 6f697472 2522206e 66202273     assertion "%s" f
 801cdd0:	656c6961 66203a64 20656c69 22732522     ailed: file "%s"
 801cde0:	696c202c 2520656e 25732564 00000a73     , line %d%s%s...

0801cdf0 <zeroes.6753>:
 801cdf0:	30303030 30303030 30303030 30303030     0000000000000000

0801ce00 <blanks.6752>:
 801ce00:	20202020 20202020 20202020 20202020                     
 801ce10:	33323130 37363534 42413938 46454443     0123456789ABCDEF
 801ce20:	00000000 33323130 37363534 62613938     ....0123456789ab
 801ce30:	66656463 00000000                       cdef....
